'use strict';

var require$$0$a = require('@babel/types');
var require$$2$2 = require('@babel/traverse');
var require$$0$b = require('@babel/core');
var require$$0$c = require('assert');
var require$$0$9 = require('path');
require('module');
var require$$2$1 = require('fs');
var require$$0$d = require('os');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var lib$1h = {};

var semver = {exports: {}};

var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver.exports;
	hasRequiredSemver = 1;
	(function (module, exports) {
		exports = module.exports = SemVer;
		var debug;
		if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
		  debug = function() {
		    var args = Array.prototype.slice.call(arguments, 0);
		    args.unshift("SEMVER");
		    console.log.apply(console, args);
		  };
		} else {
		  debug = function() {
		  };
		}
		exports.SEMVER_SPEC_VERSION = "2.0.0";
		var MAX_LENGTH = 256;
		var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
		9007199254740991;
		var MAX_SAFE_COMPONENT_LENGTH = 16;
		var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
		var re = exports.re = [];
		var safeRe = exports.safeRe = [];
		var src = exports.src = [];
		var t = exports.tokens = {};
		var R = 0;
		function tok(n) {
		  t[n] = R++;
		}
		var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
		var safeRegexReplacements = [
		  ["\\s", 1],
		  ["\\d", MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
		];
		function makeSafeRe(value) {
		  for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
		    var token = safeRegexReplacements[i2][0];
		    var max = safeRegexReplacements[i2][1];
		    value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
		  }
		  return value;
		}
		tok("NUMERICIDENTIFIER");
		src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
		tok("NUMERICIDENTIFIERLOOSE");
		src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
		tok("NONNUMERICIDENTIFIER");
		src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
		tok("MAINVERSION");
		src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
		tok("MAINVERSIONLOOSE");
		src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
		tok("PRERELEASEIDENTIFIER");
		src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
		tok("PRERELEASEIDENTIFIERLOOSE");
		src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
		tok("PRERELEASE");
		src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
		tok("PRERELEASELOOSE");
		src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
		tok("BUILDIDENTIFIER");
		src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
		tok("BUILD");
		src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
		tok("FULL");
		tok("FULLPLAIN");
		src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
		src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
		tok("LOOSEPLAIN");
		src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
		tok("LOOSE");
		src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
		tok("GTLT");
		src[t.GTLT] = "((?:<|>)?=?)";
		tok("XRANGEIDENTIFIERLOOSE");
		src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
		tok("XRANGEIDENTIFIER");
		src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
		tok("XRANGEPLAIN");
		src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
		tok("XRANGEPLAINLOOSE");
		src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
		tok("XRANGE");
		src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
		tok("XRANGELOOSE");
		src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
		tok("COERCE");
		src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
		tok("COERCERTL");
		re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
		safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
		tok("LONETILDE");
		src[t.LONETILDE] = "(?:~>?)";
		tok("TILDETRIM");
		src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
		re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
		safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
		var tildeTrimReplace = "$1~";
		tok("TILDE");
		src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
		tok("TILDELOOSE");
		src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
		tok("LONECARET");
		src[t.LONECARET] = "(?:\\^)";
		tok("CARETTRIM");
		src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
		re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
		safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
		var caretTrimReplace = "$1^";
		tok("CARET");
		src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
		tok("CARETLOOSE");
		src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
		tok("COMPARATORLOOSE");
		src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
		tok("COMPARATOR");
		src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
		tok("COMPARATORTRIM");
		src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
		re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
		safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
		var comparatorTrimReplace = "$1$2$3";
		tok("HYPHENRANGE");
		src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
		tok("HYPHENRANGELOOSE");
		src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
		tok("STAR");
		src[t.STAR] = "(<|>)?=?\\s*\\*";
		for (var i = 0; i < R; i++) {
		  debug(i, src[i]);
		  if (!re[i]) {
		    re[i] = new RegExp(src[i]);
		    safeRe[i] = new RegExp(makeSafeRe(src[i]));
		  }
		}
		exports.parse = parse;
		function parse(version, options) {
		  if (!options || typeof options !== "object") {
		    options = {
		      loose: !!options,
		      includePrerelease: false
		    };
		  }
		  if (version instanceof SemVer) {
		    return version;
		  }
		  if (typeof version !== "string") {
		    return null;
		  }
		  if (version.length > MAX_LENGTH) {
		    return null;
		  }
		  var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
		  if (!r.test(version)) {
		    return null;
		  }
		  try {
		    return new SemVer(version, options);
		  } catch (er) {
		    return null;
		  }
		}
		exports.valid = valid;
		function valid(version, options) {
		  var v = parse(version, options);
		  return v ? v.version : null;
		}
		exports.clean = clean;
		function clean(version, options) {
		  var s = parse(version.trim().replace(/^[=v]+/, ""), options);
		  return s ? s.version : null;
		}
		exports.SemVer = SemVer;
		function SemVer(version, options) {
		  if (!options || typeof options !== "object") {
		    options = {
		      loose: !!options,
		      includePrerelease: false
		    };
		  }
		  if (version instanceof SemVer) {
		    if (version.loose === options.loose) {
		      return version;
		    } else {
		      version = version.version;
		    }
		  } else if (typeof version !== "string") {
		    throw new TypeError("Invalid Version: " + version);
		  }
		  if (version.length > MAX_LENGTH) {
		    throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
		  }
		  if (!(this instanceof SemVer)) {
		    return new SemVer(version, options);
		  }
		  debug("SemVer", version, options);
		  this.options = options;
		  this.loose = !!options.loose;
		  var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
		  if (!m) {
		    throw new TypeError("Invalid Version: " + version);
		  }
		  this.raw = version;
		  this.major = +m[1];
		  this.minor = +m[2];
		  this.patch = +m[3];
		  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
		    throw new TypeError("Invalid major version");
		  }
		  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
		    throw new TypeError("Invalid minor version");
		  }
		  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
		    throw new TypeError("Invalid patch version");
		  }
		  if (!m[4]) {
		    this.prerelease = [];
		  } else {
		    this.prerelease = m[4].split(".").map(function(id) {
		      if (/^[0-9]+$/.test(id)) {
		        var num = +id;
		        if (num >= 0 && num < MAX_SAFE_INTEGER) {
		          return num;
		        }
		      }
		      return id;
		    });
		  }
		  this.build = m[5] ? m[5].split(".") : [];
		  this.format();
		}
		SemVer.prototype.format = function() {
		  this.version = this.major + "." + this.minor + "." + this.patch;
		  if (this.prerelease.length) {
		    this.version += "-" + this.prerelease.join(".");
		  }
		  return this.version;
		};
		SemVer.prototype.toString = function() {
		  return this.version;
		};
		SemVer.prototype.compare = function(other) {
		  debug("SemVer.compare", this.version, this.options, other);
		  if (!(other instanceof SemVer)) {
		    other = new SemVer(other, this.options);
		  }
		  return this.compareMain(other) || this.comparePre(other);
		};
		SemVer.prototype.compareMain = function(other) {
		  if (!(other instanceof SemVer)) {
		    other = new SemVer(other, this.options);
		  }
		  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
		};
		SemVer.prototype.comparePre = function(other) {
		  if (!(other instanceof SemVer)) {
		    other = new SemVer(other, this.options);
		  }
		  if (this.prerelease.length && !other.prerelease.length) {
		    return -1;
		  } else if (!this.prerelease.length && other.prerelease.length) {
		    return 1;
		  } else if (!this.prerelease.length && !other.prerelease.length) {
		    return 0;
		  }
		  var i2 = 0;
		  do {
		    var a = this.prerelease[i2];
		    var b = other.prerelease[i2];
		    debug("prerelease compare", i2, a, b);
		    if (a === void 0 && b === void 0) {
		      return 0;
		    } else if (b === void 0) {
		      return 1;
		    } else if (a === void 0) {
		      return -1;
		    } else if (a === b) {
		      continue;
		    } else {
		      return compareIdentifiers(a, b);
		    }
		  } while (++i2);
		};
		SemVer.prototype.compareBuild = function(other) {
		  if (!(other instanceof SemVer)) {
		    other = new SemVer(other, this.options);
		  }
		  var i2 = 0;
		  do {
		    var a = this.build[i2];
		    var b = other.build[i2];
		    debug("prerelease compare", i2, a, b);
		    if (a === void 0 && b === void 0) {
		      return 0;
		    } else if (b === void 0) {
		      return 1;
		    } else if (a === void 0) {
		      return -1;
		    } else if (a === b) {
		      continue;
		    } else {
		      return compareIdentifiers(a, b);
		    }
		  } while (++i2);
		};
		SemVer.prototype.inc = function(release, identifier) {
		  switch (release) {
		    case "premajor":
		      this.prerelease.length = 0;
		      this.patch = 0;
		      this.minor = 0;
		      this.major++;
		      this.inc("pre", identifier);
		      break;
		    case "preminor":
		      this.prerelease.length = 0;
		      this.patch = 0;
		      this.minor++;
		      this.inc("pre", identifier);
		      break;
		    case "prepatch":
		      this.prerelease.length = 0;
		      this.inc("patch", identifier);
		      this.inc("pre", identifier);
		      break;
		    // If the input is a non-prerelease version, this acts the same as
		    // prepatch.
		    case "prerelease":
		      if (this.prerelease.length === 0) {
		        this.inc("patch", identifier);
		      }
		      this.inc("pre", identifier);
		      break;
		    case "major":
		      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
		        this.major++;
		      }
		      this.minor = 0;
		      this.patch = 0;
		      this.prerelease = [];
		      break;
		    case "minor":
		      if (this.patch !== 0 || this.prerelease.length === 0) {
		        this.minor++;
		      }
		      this.patch = 0;
		      this.prerelease = [];
		      break;
		    case "patch":
		      if (this.prerelease.length === 0) {
		        this.patch++;
		      }
		      this.prerelease = [];
		      break;
		    // This probably shouldn't be used publicly.
		    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
		    case "pre":
		      if (this.prerelease.length === 0) {
		        this.prerelease = [0];
		      } else {
		        var i2 = this.prerelease.length;
		        while (--i2 >= 0) {
		          if (typeof this.prerelease[i2] === "number") {
		            this.prerelease[i2]++;
		            i2 = -2;
		          }
		        }
		        if (i2 === -1) {
		          this.prerelease.push(0);
		        }
		      }
		      if (identifier) {
		        if (this.prerelease[0] === identifier) {
		          if (isNaN(this.prerelease[1])) {
		            this.prerelease = [identifier, 0];
		          }
		        } else {
		          this.prerelease = [identifier, 0];
		        }
		      }
		      break;
		    default:
		      throw new Error("invalid increment argument: " + release);
		  }
		  this.format();
		  this.raw = this.version;
		  return this;
		};
		exports.inc = inc;
		function inc(version, release, loose, identifier) {
		  if (typeof loose === "string") {
		    identifier = loose;
		    loose = void 0;
		  }
		  try {
		    return new SemVer(version, loose).inc(release, identifier).version;
		  } catch (er) {
		    return null;
		  }
		}
		exports.diff = diff;
		function diff(version1, version2) {
		  if (eq(version1, version2)) {
		    return null;
		  } else {
		    var v1 = parse(version1);
		    var v2 = parse(version2);
		    var prefix = "";
		    if (v1.prerelease.length || v2.prerelease.length) {
		      prefix = "pre";
		      var defaultResult = "prerelease";
		    }
		    for (var key in v1) {
		      if (key === "major" || key === "minor" || key === "patch") {
		        if (v1[key] !== v2[key]) {
		          return prefix + key;
		        }
		      }
		    }
		    return defaultResult;
		  }
		}
		exports.compareIdentifiers = compareIdentifiers;
		var numeric = /^[0-9]+$/;
		function compareIdentifiers(a, b) {
		  var anum = numeric.test(a);
		  var bnum = numeric.test(b);
		  if (anum && bnum) {
		    a = +a;
		    b = +b;
		  }
		  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
		}
		exports.rcompareIdentifiers = rcompareIdentifiers;
		function rcompareIdentifiers(a, b) {
		  return compareIdentifiers(b, a);
		}
		exports.major = major;
		function major(a, loose) {
		  return new SemVer(a, loose).major;
		}
		exports.minor = minor;
		function minor(a, loose) {
		  return new SemVer(a, loose).minor;
		}
		exports.patch = patch;
		function patch(a, loose) {
		  return new SemVer(a, loose).patch;
		}
		exports.compare = compare;
		function compare(a, b, loose) {
		  return new SemVer(a, loose).compare(new SemVer(b, loose));
		}
		exports.compareLoose = compareLoose;
		function compareLoose(a, b) {
		  return compare(a, b, true);
		}
		exports.compareBuild = compareBuild;
		function compareBuild(a, b, loose) {
		  var versionA = new SemVer(a, loose);
		  var versionB = new SemVer(b, loose);
		  return versionA.compare(versionB) || versionA.compareBuild(versionB);
		}
		exports.rcompare = rcompare;
		function rcompare(a, b, loose) {
		  return compare(b, a, loose);
		}
		exports.sort = sort;
		function sort(list, loose) {
		  return list.sort(function(a, b) {
		    return exports.compareBuild(a, b, loose);
		  });
		}
		exports.rsort = rsort;
		function rsort(list, loose) {
		  return list.sort(function(a, b) {
		    return exports.compareBuild(b, a, loose);
		  });
		}
		exports.gt = gt;
		function gt(a, b, loose) {
		  return compare(a, b, loose) > 0;
		}
		exports.lt = lt;
		function lt(a, b, loose) {
		  return compare(a, b, loose) < 0;
		}
		exports.eq = eq;
		function eq(a, b, loose) {
		  return compare(a, b, loose) === 0;
		}
		exports.neq = neq;
		function neq(a, b, loose) {
		  return compare(a, b, loose) !== 0;
		}
		exports.gte = gte;
		function gte(a, b, loose) {
		  return compare(a, b, loose) >= 0;
		}
		exports.lte = lte;
		function lte(a, b, loose) {
		  return compare(a, b, loose) <= 0;
		}
		exports.cmp = cmp;
		function cmp(a, op, b, loose) {
		  switch (op) {
		    case "===":
		      if (typeof a === "object")
		        a = a.version;
		      if (typeof b === "object")
		        b = b.version;
		      return a === b;
		    case "!==":
		      if (typeof a === "object")
		        a = a.version;
		      if (typeof b === "object")
		        b = b.version;
		      return a !== b;
		    case "":
		    case "=":
		    case "==":
		      return eq(a, b, loose);
		    case "!=":
		      return neq(a, b, loose);
		    case ">":
		      return gt(a, b, loose);
		    case ">=":
		      return gte(a, b, loose);
		    case "<":
		      return lt(a, b, loose);
		    case "<=":
		      return lte(a, b, loose);
		    default:
		      throw new TypeError("Invalid operator: " + op);
		  }
		}
		exports.Comparator = Comparator;
		function Comparator(comp, options) {
		  if (!options || typeof options !== "object") {
		    options = {
		      loose: !!options,
		      includePrerelease: false
		    };
		  }
		  if (comp instanceof Comparator) {
		    if (comp.loose === !!options.loose) {
		      return comp;
		    } else {
		      comp = comp.value;
		    }
		  }
		  if (!(this instanceof Comparator)) {
		    return new Comparator(comp, options);
		  }
		  comp = comp.trim().split(/\s+/).join(" ");
		  debug("comparator", comp, options);
		  this.options = options;
		  this.loose = !!options.loose;
		  this.parse(comp);
		  if (this.semver === ANY) {
		    this.value = "";
		  } else {
		    this.value = this.operator + this.semver.version;
		  }
		  debug("comp", this);
		}
		var ANY = {};
		Comparator.prototype.parse = function(comp) {
		  var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
		  var m = comp.match(r);
		  if (!m) {
		    throw new TypeError("Invalid comparator: " + comp);
		  }
		  this.operator = m[1] !== void 0 ? m[1] : "";
		  if (this.operator === "=") {
		    this.operator = "";
		  }
		  if (!m[2]) {
		    this.semver = ANY;
		  } else {
		    this.semver = new SemVer(m[2], this.options.loose);
		  }
		};
		Comparator.prototype.toString = function() {
		  return this.value;
		};
		Comparator.prototype.test = function(version) {
		  debug("Comparator.test", version, this.options.loose);
		  if (this.semver === ANY || version === ANY) {
		    return true;
		  }
		  if (typeof version === "string") {
		    try {
		      version = new SemVer(version, this.options);
		    } catch (er) {
		      return false;
		    }
		  }
		  return cmp(version, this.operator, this.semver, this.options);
		};
		Comparator.prototype.intersects = function(comp, options) {
		  if (!(comp instanceof Comparator)) {
		    throw new TypeError("a Comparator is required");
		  }
		  if (!options || typeof options !== "object") {
		    options = {
		      loose: !!options,
		      includePrerelease: false
		    };
		  }
		  var rangeTmp;
		  if (this.operator === "") {
		    if (this.value === "") {
		      return true;
		    }
		    rangeTmp = new Range(comp.value, options);
		    return satisfies(this.value, rangeTmp, options);
		  } else if (comp.operator === "") {
		    if (comp.value === "") {
		      return true;
		    }
		    rangeTmp = new Range(this.value, options);
		    return satisfies(comp.semver, rangeTmp, options);
		  }
		  var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
		  var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
		  var sameSemVer = this.semver.version === comp.semver.version;
		  var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
		  var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
		  var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
		  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
		};
		exports.Range = Range;
		function Range(range, options) {
		  if (!options || typeof options !== "object") {
		    options = {
		      loose: !!options,
		      includePrerelease: false
		    };
		  }
		  if (range instanceof Range) {
		    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
		      return range;
		    } else {
		      return new Range(range.raw, options);
		    }
		  }
		  if (range instanceof Comparator) {
		    return new Range(range.value, options);
		  }
		  if (!(this instanceof Range)) {
		    return new Range(range, options);
		  }
		  this.options = options;
		  this.loose = !!options.loose;
		  this.includePrerelease = !!options.includePrerelease;
		  this.raw = range.trim().split(/\s+/).join(" ");
		  this.set = this.raw.split("||").map(function(range2) {
		    return this.parseRange(range2.trim());
		  }, this).filter(function(c) {
		    return c.length;
		  });
		  if (!this.set.length) {
		    throw new TypeError("Invalid SemVer Range: " + this.raw);
		  }
		  this.format();
		}
		Range.prototype.format = function() {
		  this.range = this.set.map(function(comps) {
		    return comps.join(" ").trim();
		  }).join("||").trim();
		  return this.range;
		};
		Range.prototype.toString = function() {
		  return this.range;
		};
		Range.prototype.parseRange = function(range) {
		  var loose = this.options.loose;
		  var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
		  range = range.replace(hr, hyphenReplace);
		  debug("hyphen replace", range);
		  range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
		  debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
		  range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
		  range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
		  range = range.split(/\s+/).join(" ");
		  var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
		  var set = range.split(" ").map(function(comp) {
		    return parseComparator(comp, this.options);
		  }, this).join(" ").split(/\s+/);
		  if (this.options.loose) {
		    set = set.filter(function(comp) {
		      return !!comp.match(compRe);
		    });
		  }
		  set = set.map(function(comp) {
		    return new Comparator(comp, this.options);
		  }, this);
		  return set;
		};
		Range.prototype.intersects = function(range, options) {
		  if (!(range instanceof Range)) {
		    throw new TypeError("a Range is required");
		  }
		  return this.set.some(function(thisComparators) {
		    return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
		      return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
		        return rangeComparators.every(function(rangeComparator) {
		          return thisComparator.intersects(rangeComparator, options);
		        });
		      });
		    });
		  });
		};
		function isSatisfiable(comparators, options) {
		  var result = true;
		  var remainingComparators = comparators.slice();
		  var testComparator = remainingComparators.pop();
		  while (result && remainingComparators.length) {
		    result = remainingComparators.every(function(otherComparator) {
		      return testComparator.intersects(otherComparator, options);
		    });
		    testComparator = remainingComparators.pop();
		  }
		  return result;
		}
		exports.toComparators = toComparators;
		function toComparators(range, options) {
		  return new Range(range, options).set.map(function(comp) {
		    return comp.map(function(c) {
		      return c.value;
		    }).join(" ").trim().split(" ");
		  });
		}
		function parseComparator(comp, options) {
		  debug("comp", comp, options);
		  comp = replaceCarets(comp, options);
		  debug("caret", comp);
		  comp = replaceTildes(comp, options);
		  debug("tildes", comp);
		  comp = replaceXRanges(comp, options);
		  debug("xrange", comp);
		  comp = replaceStars(comp, options);
		  debug("stars", comp);
		  return comp;
		}
		function isX(id) {
		  return !id || id.toLowerCase() === "x" || id === "*";
		}
		function replaceTildes(comp, options) {
		  return comp.trim().split(/\s+/).map(function(comp2) {
		    return replaceTilde(comp2, options);
		  }).join(" ");
		}
		function replaceTilde(comp, options) {
		  var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
		  return comp.replace(r, function(_, M, m, p, pr) {
		    debug("tilde", comp, _, M, m, p, pr);
		    var ret;
		    if (isX(M)) {
		      ret = "";
		    } else if (isX(m)) {
		      ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
		    } else if (isX(p)) {
		      ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
		    } else if (pr) {
		      debug("replaceTilde pr", pr);
		      ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
		    } else {
		      ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
		    }
		    debug("tilde return", ret);
		    return ret;
		  });
		}
		function replaceCarets(comp, options) {
		  return comp.trim().split(/\s+/).map(function(comp2) {
		    return replaceCaret(comp2, options);
		  }).join(" ");
		}
		function replaceCaret(comp, options) {
		  debug("caret", comp, options);
		  var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
		  return comp.replace(r, function(_, M, m, p, pr) {
		    debug("caret", comp, _, M, m, p, pr);
		    var ret;
		    if (isX(M)) {
		      ret = "";
		    } else if (isX(m)) {
		      ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
		    } else if (isX(p)) {
		      if (M === "0") {
		        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
		      } else {
		        ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
		      }
		    } else if (pr) {
		      debug("replaceCaret pr", pr);
		      if (M === "0") {
		        if (m === "0") {
		          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
		        } else {
		          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
		        }
		      } else {
		        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
		      }
		    } else {
		      debug("no pr");
		      if (M === "0") {
		        if (m === "0") {
		          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
		        } else {
		          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
		        }
		      } else {
		        ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
		      }
		    }
		    debug("caret return", ret);
		    return ret;
		  });
		}
		function replaceXRanges(comp, options) {
		  debug("replaceXRanges", comp, options);
		  return comp.split(/\s+/).map(function(comp2) {
		    return replaceXRange(comp2, options);
		  }).join(" ");
		}
		function replaceXRange(comp, options) {
		  comp = comp.trim();
		  var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
		  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
		    debug("xRange", comp, ret, gtlt, M, m, p, pr);
		    var xM = isX(M);
		    var xm = xM || isX(m);
		    var xp = xm || isX(p);
		    var anyX = xp;
		    if (gtlt === "=" && anyX) {
		      gtlt = "";
		    }
		    pr = options.includePrerelease ? "-0" : "";
		    if (xM) {
		      if (gtlt === ">" || gtlt === "<") {
		        ret = "<0.0.0-0";
		      } else {
		        ret = "*";
		      }
		    } else if (gtlt && anyX) {
		      if (xm) {
		        m = 0;
		      }
		      p = 0;
		      if (gtlt === ">") {
		        gtlt = ">=";
		        if (xm) {
		          M = +M + 1;
		          m = 0;
		          p = 0;
		        } else {
		          m = +m + 1;
		          p = 0;
		        }
		      } else if (gtlt === "<=") {
		        gtlt = "<";
		        if (xm) {
		          M = +M + 1;
		        } else {
		          m = +m + 1;
		        }
		      }
		      ret = gtlt + M + "." + m + "." + p + pr;
		    } else if (xm) {
		      ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
		    } else if (xp) {
		      ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
		    }
		    debug("xRange return", ret);
		    return ret;
		  });
		}
		function replaceStars(comp, options) {
		  debug("replaceStars", comp, options);
		  return comp.trim().replace(safeRe[t.STAR], "");
		}
		function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
		  if (isX(fM)) {
		    from = "";
		  } else if (isX(fm)) {
		    from = ">=" + fM + ".0.0";
		  } else if (isX(fp)) {
		    from = ">=" + fM + "." + fm + ".0";
		  } else {
		    from = ">=" + from;
		  }
		  if (isX(tM)) {
		    to = "";
		  } else if (isX(tm)) {
		    to = "<" + (+tM + 1) + ".0.0";
		  } else if (isX(tp)) {
		    to = "<" + tM + "." + (+tm + 1) + ".0";
		  } else if (tpr) {
		    to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
		  } else {
		    to = "<=" + to;
		  }
		  return (from + " " + to).trim();
		}
		Range.prototype.test = function(version) {
		  if (!version) {
		    return false;
		  }
		  if (typeof version === "string") {
		    try {
		      version = new SemVer(version, this.options);
		    } catch (er) {
		      return false;
		    }
		  }
		  for (var i2 = 0; i2 < this.set.length; i2++) {
		    if (testSet(this.set[i2], version, this.options)) {
		      return true;
		    }
		  }
		  return false;
		};
		function testSet(set, version, options) {
		  for (var i2 = 0; i2 < set.length; i2++) {
		    if (!set[i2].test(version)) {
		      return false;
		    }
		  }
		  if (version.prerelease.length && !options.includePrerelease) {
		    for (i2 = 0; i2 < set.length; i2++) {
		      debug(set[i2].semver);
		      if (set[i2].semver === ANY) {
		        continue;
		      }
		      if (set[i2].semver.prerelease.length > 0) {
		        var allowed = set[i2].semver;
		        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
		          return true;
		        }
		      }
		    }
		    return false;
		  }
		  return true;
		}
		exports.satisfies = satisfies;
		function satisfies(version, range, options) {
		  try {
		    range = new Range(range, options);
		  } catch (er) {
		    return false;
		  }
		  return range.test(version);
		}
		exports.maxSatisfying = maxSatisfying;
		function maxSatisfying(versions, range, options) {
		  var max = null;
		  var maxSV = null;
		  try {
		    var rangeObj = new Range(range, options);
		  } catch (er) {
		    return null;
		  }
		  versions.forEach(function(v) {
		    if (rangeObj.test(v)) {
		      if (!max || maxSV.compare(v) === -1) {
		        max = v;
		        maxSV = new SemVer(max, options);
		      }
		    }
		  });
		  return max;
		}
		exports.minSatisfying = minSatisfying;
		function minSatisfying(versions, range, options) {
		  var min = null;
		  var minSV = null;
		  try {
		    var rangeObj = new Range(range, options);
		  } catch (er) {
		    return null;
		  }
		  versions.forEach(function(v) {
		    if (rangeObj.test(v)) {
		      if (!min || minSV.compare(v) === 1) {
		        min = v;
		        minSV = new SemVer(min, options);
		      }
		    }
		  });
		  return min;
		}
		exports.minVersion = minVersion;
		function minVersion(range, loose) {
		  range = new Range(range, loose);
		  var minver = new SemVer("0.0.0");
		  if (range.test(minver)) {
		    return minver;
		  }
		  minver = new SemVer("0.0.0-0");
		  if (range.test(minver)) {
		    return minver;
		  }
		  minver = null;
		  for (var i2 = 0; i2 < range.set.length; ++i2) {
		    var comparators = range.set[i2];
		    comparators.forEach(function(comparator) {
		      var compver = new SemVer(comparator.semver.version);
		      switch (comparator.operator) {
		        case ">":
		          if (compver.prerelease.length === 0) {
		            compver.patch++;
		          } else {
		            compver.prerelease.push(0);
		          }
		          compver.raw = compver.format();
		        /* fallthrough */
		        case "":
		        case ">=":
		          if (!minver || gt(minver, compver)) {
		            minver = compver;
		          }
		          break;
		        case "<":
		        case "<=":
		          break;
		        /* istanbul ignore next */
		        default:
		          throw new Error("Unexpected operation: " + comparator.operator);
		      }
		    });
		  }
		  if (minver && range.test(minver)) {
		    return minver;
		  }
		  return null;
		}
		exports.validRange = validRange;
		function validRange(range, options) {
		  try {
		    return new Range(range, options).range || "*";
		  } catch (er) {
		    return null;
		  }
		}
		exports.ltr = ltr;
		function ltr(version, range, options) {
		  return outside(version, range, "<", options);
		}
		exports.gtr = gtr;
		function gtr(version, range, options) {
		  return outside(version, range, ">", options);
		}
		exports.outside = outside;
		function outside(version, range, hilo, options) {
		  version = new SemVer(version, options);
		  range = new Range(range, options);
		  var gtfn, ltefn, ltfn, comp, ecomp;
		  switch (hilo) {
		    case ">":
		      gtfn = gt;
		      ltefn = lte;
		      ltfn = lt;
		      comp = ">";
		      ecomp = ">=";
		      break;
		    case "<":
		      gtfn = lt;
		      ltefn = gte;
		      ltfn = gt;
		      comp = "<";
		      ecomp = "<=";
		      break;
		    default:
		      throw new TypeError('Must provide a hilo val of "<" or ">"');
		  }
		  if (satisfies(version, range, options)) {
		    return false;
		  }
		  for (var i2 = 0; i2 < range.set.length; ++i2) {
		    var comparators = range.set[i2];
		    var high = null;
		    var low = null;
		    comparators.forEach(function(comparator) {
		      if (comparator.semver === ANY) {
		        comparator = new Comparator(">=0.0.0");
		      }
		      high = high || comparator;
		      low = low || comparator;
		      if (gtfn(comparator.semver, high.semver, options)) {
		        high = comparator;
		      } else if (ltfn(comparator.semver, low.semver, options)) {
		        low = comparator;
		      }
		    });
		    if (high.operator === comp || high.operator === ecomp) {
		      return false;
		    }
		    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
		      return false;
		    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
		      return false;
		    }
		  }
		  return true;
		}
		exports.prerelease = prerelease;
		function prerelease(version, options) {
		  var parsed = parse(version, options);
		  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
		}
		exports.intersects = intersects;
		function intersects(r1, r2, options) {
		  r1 = new Range(r1, options);
		  r2 = new Range(r2, options);
		  return r1.intersects(r2);
		}
		exports.coerce = coerce;
		function coerce(version, options) {
		  if (version instanceof SemVer) {
		    return version;
		  }
		  if (typeof version === "number") {
		    version = String(version);
		  }
		  if (typeof version !== "string") {
		    return null;
		  }
		  options = options || {};
		  var match = null;
		  if (!options.rtl) {
		    match = version.match(safeRe[t.COERCE]);
		  } else {
		    var next;
		    while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
		      if (!match || next.index + next[0].length !== match.index + match[0].length) {
		        match = next;
		      }
		      safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
		    }
		    safeRe[t.COERCERTL].lastIndex = -1;
		  }
		  if (match === null) {
		    return null;
		  }
		  return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
		} 
	} (semver, semver.exports));
	return semver.exports;
}

var debug$1 = {};

var lib$1g = {};

var require$$0$8 = [
	{
		name: "nodejs",
		version: "0.2.0",
		date: "2011-08-26",
		lts: false,
		security: false,
		v8: "2.3.8.0"
	},
	{
		name: "nodejs",
		version: "0.3.0",
		date: "2011-08-26",
		lts: false,
		security: false,
		v8: "2.5.1.0"
	},
	{
		name: "nodejs",
		version: "0.4.0",
		date: "2011-08-26",
		lts: false,
		security: false,
		v8: "3.1.2.0"
	},
	{
		name: "nodejs",
		version: "0.5.0",
		date: "2011-08-26",
		lts: false,
		security: false,
		v8: "3.1.8.25"
	},
	{
		name: "nodejs",
		version: "0.6.0",
		date: "2011-11-04",
		lts: false,
		security: false,
		v8: "3.6.6.6"
	},
	{
		name: "nodejs",
		version: "0.7.0",
		date: "2012-01-17",
		lts: false,
		security: false,
		v8: "3.8.6.0"
	},
	{
		name: "nodejs",
		version: "0.8.0",
		date: "2012-06-22",
		lts: false,
		security: false,
		v8: "3.11.10.10"
	},
	{
		name: "nodejs",
		version: "0.9.0",
		date: "2012-07-20",
		lts: false,
		security: false,
		v8: "3.11.10.15"
	},
	{
		name: "nodejs",
		version: "0.10.0",
		date: "2013-03-11",
		lts: false,
		security: false,
		v8: "3.14.5.8"
	},
	{
		name: "nodejs",
		version: "0.11.0",
		date: "2013-03-28",
		lts: false,
		security: false,
		v8: "3.17.13.0"
	},
	{
		name: "nodejs",
		version: "0.12.0",
		date: "2015-02-06",
		lts: false,
		security: false,
		v8: "3.28.73.0"
	},
	{
		name: "nodejs",
		version: "4.0.0",
		date: "2015-09-08",
		lts: false,
		security: false,
		v8: "4.5.103.30"
	},
	{
		name: "nodejs",
		version: "4.1.0",
		date: "2015-09-17",
		lts: false,
		security: false,
		v8: "4.5.103.33"
	},
	{
		name: "nodejs",
		version: "4.2.0",
		date: "2015-10-12",
		lts: "Argon",
		security: false,
		v8: "4.5.103.35"
	},
	{
		name: "nodejs",
		version: "4.3.0",
		date: "2016-02-09",
		lts: "Argon",
		security: false,
		v8: "4.5.103.35"
	},
	{
		name: "nodejs",
		version: "4.4.0",
		date: "2016-03-08",
		lts: "Argon",
		security: false,
		v8: "4.5.103.35"
	},
	{
		name: "nodejs",
		version: "4.5.0",
		date: "2016-08-16",
		lts: "Argon",
		security: false,
		v8: "4.5.103.37"
	},
	{
		name: "nodejs",
		version: "4.6.0",
		date: "2016-09-27",
		lts: "Argon",
		security: true,
		v8: "4.5.103.37"
	},
	{
		name: "nodejs",
		version: "4.7.0",
		date: "2016-12-06",
		lts: "Argon",
		security: false,
		v8: "4.5.103.43"
	},
	{
		name: "nodejs",
		version: "4.8.0",
		date: "2017-02-21",
		lts: "Argon",
		security: false,
		v8: "4.5.103.45"
	},
	{
		name: "nodejs",
		version: "4.9.0",
		date: "2018-03-28",
		lts: "Argon",
		security: true,
		v8: "4.5.103.53"
	},
	{
		name: "nodejs",
		version: "5.0.0",
		date: "2015-10-29",
		lts: false,
		security: false,
		v8: "4.6.85.28"
	},
	{
		name: "nodejs",
		version: "5.1.0",
		date: "2015-11-17",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.2.0",
		date: "2015-12-09",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.3.0",
		date: "2015-12-15",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.4.0",
		date: "2016-01-06",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.5.0",
		date: "2016-01-21",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.6.0",
		date: "2016-02-09",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.7.0",
		date: "2016-02-23",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.8.0",
		date: "2016-03-09",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.9.0",
		date: "2016-03-16",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.10.0",
		date: "2016-04-01",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.11.0",
		date: "2016-04-21",
		lts: false,
		security: false,
		v8: "4.6.85.31"
	},
	{
		name: "nodejs",
		version: "5.12.0",
		date: "2016-06-23",
		lts: false,
		security: false,
		v8: "4.6.85.32"
	},
	{
		name: "nodejs",
		version: "6.0.0",
		date: "2016-04-26",
		lts: false,
		security: false,
		v8: "5.0.71.35"
	},
	{
		name: "nodejs",
		version: "6.1.0",
		date: "2016-05-05",
		lts: false,
		security: false,
		v8: "5.0.71.35"
	},
	{
		name: "nodejs",
		version: "6.2.0",
		date: "2016-05-17",
		lts: false,
		security: false,
		v8: "5.0.71.47"
	},
	{
		name: "nodejs",
		version: "6.3.0",
		date: "2016-07-06",
		lts: false,
		security: false,
		v8: "5.0.71.52"
	},
	{
		name: "nodejs",
		version: "6.4.0",
		date: "2016-08-12",
		lts: false,
		security: false,
		v8: "5.0.71.60"
	},
	{
		name: "nodejs",
		version: "6.5.0",
		date: "2016-08-26",
		lts: false,
		security: false,
		v8: "5.1.281.81"
	},
	{
		name: "nodejs",
		version: "6.6.0",
		date: "2016-09-14",
		lts: false,
		security: false,
		v8: "5.1.281.83"
	},
	{
		name: "nodejs",
		version: "6.7.0",
		date: "2016-09-27",
		lts: false,
		security: true,
		v8: "5.1.281.83"
	},
	{
		name: "nodejs",
		version: "6.8.0",
		date: "2016-10-12",
		lts: false,
		security: false,
		v8: "5.1.281.84"
	},
	{
		name: "nodejs",
		version: "6.9.0",
		date: "2016-10-18",
		lts: "Boron",
		security: false,
		v8: "5.1.281.84"
	},
	{
		name: "nodejs",
		version: "6.10.0",
		date: "2017-02-21",
		lts: "Boron",
		security: false,
		v8: "5.1.281.93"
	},
	{
		name: "nodejs",
		version: "6.11.0",
		date: "2017-06-06",
		lts: "Boron",
		security: false,
		v8: "5.1.281.102"
	},
	{
		name: "nodejs",
		version: "6.12.0",
		date: "2017-11-06",
		lts: "Boron",
		security: false,
		v8: "5.1.281.108"
	},
	{
		name: "nodejs",
		version: "6.13.0",
		date: "2018-02-10",
		lts: "Boron",
		security: false,
		v8: "5.1.281.111"
	},
	{
		name: "nodejs",
		version: "6.14.0",
		date: "2018-03-28",
		lts: "Boron",
		security: true,
		v8: "5.1.281.111"
	},
	{
		name: "nodejs",
		version: "6.15.0",
		date: "2018-11-27",
		lts: "Boron",
		security: true,
		v8: "5.1.281.111"
	},
	{
		name: "nodejs",
		version: "6.16.0",
		date: "2018-12-26",
		lts: "Boron",
		security: false,
		v8: "5.1.281.111"
	},
	{
		name: "nodejs",
		version: "6.17.0",
		date: "2019-02-28",
		lts: "Boron",
		security: true,
		v8: "5.1.281.111"
	},
	{
		name: "nodejs",
		version: "7.0.0",
		date: "2016-10-25",
		lts: false,
		security: false,
		v8: "5.4.500.36"
	},
	{
		name: "nodejs",
		version: "7.1.0",
		date: "2016-11-08",
		lts: false,
		security: false,
		v8: "5.4.500.36"
	},
	{
		name: "nodejs",
		version: "7.2.0",
		date: "2016-11-22",
		lts: false,
		security: false,
		v8: "5.4.500.43"
	},
	{
		name: "nodejs",
		version: "7.3.0",
		date: "2016-12-20",
		lts: false,
		security: false,
		v8: "5.4.500.45"
	},
	{
		name: "nodejs",
		version: "7.4.0",
		date: "2017-01-04",
		lts: false,
		security: false,
		v8: "5.4.500.45"
	},
	{
		name: "nodejs",
		version: "7.5.0",
		date: "2017-01-31",
		lts: false,
		security: false,
		v8: "5.4.500.48"
	},
	{
		name: "nodejs",
		version: "7.6.0",
		date: "2017-02-21",
		lts: false,
		security: false,
		v8: "5.5.372.40"
	},
	{
		name: "nodejs",
		version: "7.7.0",
		date: "2017-02-28",
		lts: false,
		security: false,
		v8: "5.5.372.41"
	},
	{
		name: "nodejs",
		version: "7.8.0",
		date: "2017-03-29",
		lts: false,
		security: false,
		v8: "5.5.372.43"
	},
	{
		name: "nodejs",
		version: "7.9.0",
		date: "2017-04-11",
		lts: false,
		security: false,
		v8: "5.5.372.43"
	},
	{
		name: "nodejs",
		version: "7.10.0",
		date: "2017-05-02",
		lts: false,
		security: false,
		v8: "5.5.372.43"
	},
	{
		name: "nodejs",
		version: "8.0.0",
		date: "2017-05-30",
		lts: false,
		security: false,
		v8: "5.8.283.41"
	},
	{
		name: "nodejs",
		version: "8.1.0",
		date: "2017-06-08",
		lts: false,
		security: false,
		v8: "5.8.283.41"
	},
	{
		name: "nodejs",
		version: "8.2.0",
		date: "2017-07-19",
		lts: false,
		security: false,
		v8: "5.8.283.41"
	},
	{
		name: "nodejs",
		version: "8.3.0",
		date: "2017-08-08",
		lts: false,
		security: false,
		v8: "6.0.286.52"
	},
	{
		name: "nodejs",
		version: "8.4.0",
		date: "2017-08-15",
		lts: false,
		security: false,
		v8: "6.0.286.52"
	},
	{
		name: "nodejs",
		version: "8.5.0",
		date: "2017-09-12",
		lts: false,
		security: false,
		v8: "6.0.287.53"
	},
	{
		name: "nodejs",
		version: "8.6.0",
		date: "2017-09-26",
		lts: false,
		security: false,
		v8: "6.0.287.53"
	},
	{
		name: "nodejs",
		version: "8.7.0",
		date: "2017-10-11",
		lts: false,
		security: false,
		v8: "6.1.534.42"
	},
	{
		name: "nodejs",
		version: "8.8.0",
		date: "2017-10-24",
		lts: false,
		security: false,
		v8: "6.1.534.42"
	},
	{
		name: "nodejs",
		version: "8.9.0",
		date: "2017-10-31",
		lts: "Carbon",
		security: false,
		v8: "6.1.534.46"
	},
	{
		name: "nodejs",
		version: "8.10.0",
		date: "2018-03-06",
		lts: "Carbon",
		security: false,
		v8: "6.2.414.50"
	},
	{
		name: "nodejs",
		version: "8.11.0",
		date: "2018-03-28",
		lts: "Carbon",
		security: true,
		v8: "6.2.414.50"
	},
	{
		name: "nodejs",
		version: "8.12.0",
		date: "2018-09-10",
		lts: "Carbon",
		security: false,
		v8: "6.2.414.66"
	},
	{
		name: "nodejs",
		version: "8.13.0",
		date: "2018-11-20",
		lts: "Carbon",
		security: false,
		v8: "6.2.414.72"
	},
	{
		name: "nodejs",
		version: "8.14.0",
		date: "2018-11-27",
		lts: "Carbon",
		security: true,
		v8: "6.2.414.72"
	},
	{
		name: "nodejs",
		version: "8.15.0",
		date: "2018-12-26",
		lts: "Carbon",
		security: false,
		v8: "6.2.414.75"
	},
	{
		name: "nodejs",
		version: "8.16.0",
		date: "2019-04-16",
		lts: "Carbon",
		security: false,
		v8: "6.2.414.77"
	},
	{
		name: "nodejs",
		version: "8.17.0",
		date: "2019-12-17",
		lts: "Carbon",
		security: true,
		v8: "6.2.414.78"
	},
	{
		name: "nodejs",
		version: "9.0.0",
		date: "2017-10-31",
		lts: false,
		security: false,
		v8: "6.2.414.32"
	},
	{
		name: "nodejs",
		version: "9.1.0",
		date: "2017-11-07",
		lts: false,
		security: false,
		v8: "6.2.414.32"
	},
	{
		name: "nodejs",
		version: "9.2.0",
		date: "2017-11-14",
		lts: false,
		security: false,
		v8: "6.2.414.44"
	},
	{
		name: "nodejs",
		version: "9.3.0",
		date: "2017-12-12",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.4.0",
		date: "2018-01-10",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.5.0",
		date: "2018-01-31",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.6.0",
		date: "2018-02-21",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.7.0",
		date: "2018-03-01",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.8.0",
		date: "2018-03-07",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.9.0",
		date: "2018-03-21",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.10.0",
		date: "2018-03-28",
		lts: false,
		security: true,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "9.11.0",
		date: "2018-04-04",
		lts: false,
		security: false,
		v8: "6.2.414.46"
	},
	{
		name: "nodejs",
		version: "10.0.0",
		date: "2018-04-24",
		lts: false,
		security: false,
		v8: "6.6.346.24"
	},
	{
		name: "nodejs",
		version: "10.1.0",
		date: "2018-05-08",
		lts: false,
		security: false,
		v8: "6.6.346.27"
	},
	{
		name: "nodejs",
		version: "10.2.0",
		date: "2018-05-23",
		lts: false,
		security: false,
		v8: "6.6.346.32"
	},
	{
		name: "nodejs",
		version: "10.3.0",
		date: "2018-05-29",
		lts: false,
		security: false,
		v8: "6.6.346.32"
	},
	{
		name: "nodejs",
		version: "10.4.0",
		date: "2018-06-06",
		lts: false,
		security: false,
		v8: "6.7.288.43"
	},
	{
		name: "nodejs",
		version: "10.5.0",
		date: "2018-06-20",
		lts: false,
		security: false,
		v8: "6.7.288.46"
	},
	{
		name: "nodejs",
		version: "10.6.0",
		date: "2018-07-04",
		lts: false,
		security: false,
		v8: "6.7.288.46"
	},
	{
		name: "nodejs",
		version: "10.7.0",
		date: "2018-07-18",
		lts: false,
		security: false,
		v8: "6.7.288.49"
	},
	{
		name: "nodejs",
		version: "10.8.0",
		date: "2018-08-01",
		lts: false,
		security: false,
		v8: "6.7.288.49"
	},
	{
		name: "nodejs",
		version: "10.9.0",
		date: "2018-08-15",
		lts: false,
		security: false,
		v8: "6.8.275.24"
	},
	{
		name: "nodejs",
		version: "10.10.0",
		date: "2018-09-06",
		lts: false,
		security: false,
		v8: "6.8.275.30"
	},
	{
		name: "nodejs",
		version: "10.11.0",
		date: "2018-09-19",
		lts: false,
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.12.0",
		date: "2018-10-10",
		lts: false,
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.13.0",
		date: "2018-10-30",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.14.0",
		date: "2018-11-27",
		lts: "Dubnium",
		security: true,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.15.0",
		date: "2018-12-26",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.16.0",
		date: "2019-05-28",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.17.0",
		date: "2019-10-22",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.18.0",
		date: "2019-12-17",
		lts: "Dubnium",
		security: true,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.19.0",
		date: "2020-02-05",
		lts: "Dubnium",
		security: true,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.20.0",
		date: "2020-03-26",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.21.0",
		date: "2020-06-02",
		lts: "Dubnium",
		security: true,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.22.0",
		date: "2020-07-21",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.23.0",
		date: "2020-10-27",
		lts: "Dubnium",
		security: false,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "10.24.0",
		date: "2021-02-23",
		lts: "Dubnium",
		security: true,
		v8: "6.8.275.32"
	},
	{
		name: "nodejs",
		version: "11.0.0",
		date: "2018-10-23",
		lts: false,
		security: false,
		v8: "7.0.276.28"
	},
	{
		name: "nodejs",
		version: "11.1.0",
		date: "2018-10-30",
		lts: false,
		security: false,
		v8: "7.0.276.32"
	},
	{
		name: "nodejs",
		version: "11.2.0",
		date: "2018-11-15",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.3.0",
		date: "2018-11-27",
		lts: false,
		security: true,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.4.0",
		date: "2018-12-07",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.5.0",
		date: "2018-12-18",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.6.0",
		date: "2018-12-26",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.7.0",
		date: "2019-01-17",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.8.0",
		date: "2019-01-24",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.9.0",
		date: "2019-01-30",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.10.0",
		date: "2019-02-14",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.11.0",
		date: "2019-03-05",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.12.0",
		date: "2019-03-14",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.13.0",
		date: "2019-03-28",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.14.0",
		date: "2019-04-10",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "11.15.0",
		date: "2019-04-30",
		lts: false,
		security: false,
		v8: "7.0.276.38"
	},
	{
		name: "nodejs",
		version: "12.0.0",
		date: "2019-04-23",
		lts: false,
		security: false,
		v8: "7.4.288.21"
	},
	{
		name: "nodejs",
		version: "12.1.0",
		date: "2019-04-29",
		lts: false,
		security: false,
		v8: "7.4.288.21"
	},
	{
		name: "nodejs",
		version: "12.2.0",
		date: "2019-05-07",
		lts: false,
		security: false,
		v8: "7.4.288.21"
	},
	{
		name: "nodejs",
		version: "12.3.0",
		date: "2019-05-21",
		lts: false,
		security: false,
		v8: "7.4.288.27"
	},
	{
		name: "nodejs",
		version: "12.4.0",
		date: "2019-06-04",
		lts: false,
		security: false,
		v8: "7.4.288.27"
	},
	{
		name: "nodejs",
		version: "12.5.0",
		date: "2019-06-26",
		lts: false,
		security: false,
		v8: "7.5.288.22"
	},
	{
		name: "nodejs",
		version: "12.6.0",
		date: "2019-07-03",
		lts: false,
		security: false,
		v8: "7.5.288.22"
	},
	{
		name: "nodejs",
		version: "12.7.0",
		date: "2019-07-23",
		lts: false,
		security: false,
		v8: "7.5.288.22"
	},
	{
		name: "nodejs",
		version: "12.8.0",
		date: "2019-08-06",
		lts: false,
		security: false,
		v8: "7.5.288.22"
	},
	{
		name: "nodejs",
		version: "12.9.0",
		date: "2019-08-20",
		lts: false,
		security: false,
		v8: "7.6.303.29"
	},
	{
		name: "nodejs",
		version: "12.10.0",
		date: "2019-09-04",
		lts: false,
		security: false,
		v8: "7.6.303.29"
	},
	{
		name: "nodejs",
		version: "12.11.0",
		date: "2019-09-25",
		lts: false,
		security: false,
		v8: "7.7.299.11"
	},
	{
		name: "nodejs",
		version: "12.12.0",
		date: "2019-10-11",
		lts: false,
		security: false,
		v8: "7.7.299.13"
	},
	{
		name: "nodejs",
		version: "12.13.0",
		date: "2019-10-21",
		lts: "Erbium",
		security: false,
		v8: "7.7.299.13"
	},
	{
		name: "nodejs",
		version: "12.14.0",
		date: "2019-12-17",
		lts: "Erbium",
		security: true,
		v8: "7.7.299.13"
	},
	{
		name: "nodejs",
		version: "12.15.0",
		date: "2020-02-05",
		lts: "Erbium",
		security: true,
		v8: "7.7.299.13"
	},
	{
		name: "nodejs",
		version: "12.16.0",
		date: "2020-02-11",
		lts: "Erbium",
		security: false,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.17.0",
		date: "2020-05-26",
		lts: "Erbium",
		security: false,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.18.0",
		date: "2020-06-02",
		lts: "Erbium",
		security: true,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.19.0",
		date: "2020-10-06",
		lts: "Erbium",
		security: false,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.20.0",
		date: "2020-11-24",
		lts: "Erbium",
		security: false,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.21.0",
		date: "2021-02-23",
		lts: "Erbium",
		security: true,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "12.22.0",
		date: "2021-03-30",
		lts: "Erbium",
		security: false,
		v8: "7.8.279.23"
	},
	{
		name: "nodejs",
		version: "13.0.0",
		date: "2019-10-22",
		lts: false,
		security: false,
		v8: "7.8.279.17"
	},
	{
		name: "nodejs",
		version: "13.1.0",
		date: "2019-11-05",
		lts: false,
		security: false,
		v8: "7.8.279.17"
	},
	{
		name: "nodejs",
		version: "13.2.0",
		date: "2019-11-21",
		lts: false,
		security: false,
		v8: "7.9.317.23"
	},
	{
		name: "nodejs",
		version: "13.3.0",
		date: "2019-12-03",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.4.0",
		date: "2019-12-17",
		lts: false,
		security: true,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.5.0",
		date: "2019-12-18",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.6.0",
		date: "2020-01-07",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.7.0",
		date: "2020-01-21",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.8.0",
		date: "2020-02-05",
		lts: false,
		security: true,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.9.0",
		date: "2020-02-18",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.10.0",
		date: "2020-03-04",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.11.0",
		date: "2020-03-12",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.12.0",
		date: "2020-03-26",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.13.0",
		date: "2020-04-14",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "13.14.0",
		date: "2020-04-29",
		lts: false,
		security: false,
		v8: "7.9.317.25"
	},
	{
		name: "nodejs",
		version: "14.0.0",
		date: "2020-04-21",
		lts: false,
		security: false,
		v8: "8.1.307.30"
	},
	{
		name: "nodejs",
		version: "14.1.0",
		date: "2020-04-29",
		lts: false,
		security: false,
		v8: "8.1.307.31"
	},
	{
		name: "nodejs",
		version: "14.2.0",
		date: "2020-05-05",
		lts: false,
		security: false,
		v8: "8.1.307.31"
	},
	{
		name: "nodejs",
		version: "14.3.0",
		date: "2020-05-19",
		lts: false,
		security: false,
		v8: "8.1.307.31"
	},
	{
		name: "nodejs",
		version: "14.4.0",
		date: "2020-06-02",
		lts: false,
		security: true,
		v8: "8.1.307.31"
	},
	{
		name: "nodejs",
		version: "14.5.0",
		date: "2020-06-30",
		lts: false,
		security: false,
		v8: "8.3.110.9"
	},
	{
		name: "nodejs",
		version: "14.6.0",
		date: "2020-07-20",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.7.0",
		date: "2020-07-29",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.8.0",
		date: "2020-08-11",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.9.0",
		date: "2020-08-27",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.10.0",
		date: "2020-09-08",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.11.0",
		date: "2020-09-15",
		lts: false,
		security: true,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.12.0",
		date: "2020-09-22",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.13.0",
		date: "2020-09-29",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.14.0",
		date: "2020-10-15",
		lts: false,
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.15.0",
		date: "2020-10-27",
		lts: "Fermium",
		security: false,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.16.0",
		date: "2021-02-23",
		lts: "Fermium",
		security: true,
		v8: "8.4.371.19"
	},
	{
		name: "nodejs",
		version: "14.17.0",
		date: "2021-05-11",
		lts: "Fermium",
		security: false,
		v8: "8.4.371.23"
	},
	{
		name: "nodejs",
		version: "14.18.0",
		date: "2021-09-28",
		lts: "Fermium",
		security: false,
		v8: "8.4.371.23"
	},
	{
		name: "nodejs",
		version: "14.19.0",
		date: "2022-02-01",
		lts: "Fermium",
		security: false,
		v8: "8.4.371.23"
	},
	{
		name: "nodejs",
		version: "14.20.0",
		date: "2022-07-07",
		lts: "Fermium",
		security: true,
		v8: "8.4.371.23"
	},
	{
		name: "nodejs",
		version: "14.21.0",
		date: "2022-11-01",
		lts: "Fermium",
		security: false,
		v8: "8.4.371.23"
	},
	{
		name: "nodejs",
		version: "15.0.0",
		date: "2020-10-20",
		lts: false,
		security: false,
		v8: "8.6.395.16"
	},
	{
		name: "nodejs",
		version: "15.1.0",
		date: "2020-11-04",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.2.0",
		date: "2020-11-10",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.3.0",
		date: "2020-11-24",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.4.0",
		date: "2020-12-09",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.5.0",
		date: "2020-12-22",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.6.0",
		date: "2021-01-14",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.7.0",
		date: "2021-01-25",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.8.0",
		date: "2021-02-02",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.9.0",
		date: "2021-02-18",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.10.0",
		date: "2021-02-23",
		lts: false,
		security: true,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.11.0",
		date: "2021-03-03",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.12.0",
		date: "2021-03-17",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.13.0",
		date: "2021-03-31",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "15.14.0",
		date: "2021-04-06",
		lts: false,
		security: false,
		v8: "8.6.395.17"
	},
	{
		name: "nodejs",
		version: "16.0.0",
		date: "2021-04-20",
		lts: false,
		security: false,
		v8: "9.0.257.17"
	},
	{
		name: "nodejs",
		version: "16.1.0",
		date: "2021-05-04",
		lts: false,
		security: false,
		v8: "9.0.257.24"
	},
	{
		name: "nodejs",
		version: "16.2.0",
		date: "2021-05-19",
		lts: false,
		security: false,
		v8: "9.0.257.25"
	},
	{
		name: "nodejs",
		version: "16.3.0",
		date: "2021-06-03",
		lts: false,
		security: false,
		v8: "9.0.257.25"
	},
	{
		name: "nodejs",
		version: "16.4.0",
		date: "2021-06-23",
		lts: false,
		security: false,
		v8: "9.1.269.36"
	},
	{
		name: "nodejs",
		version: "16.5.0",
		date: "2021-07-14",
		lts: false,
		security: false,
		v8: "9.1.269.38"
	},
	{
		name: "nodejs",
		version: "16.6.0",
		date: "2021-07-29",
		lts: false,
		security: true,
		v8: "9.2.230.21"
	},
	{
		name: "nodejs",
		version: "16.7.0",
		date: "2021-08-18",
		lts: false,
		security: false,
		v8: "9.2.230.21"
	},
	{
		name: "nodejs",
		version: "16.8.0",
		date: "2021-08-25",
		lts: false,
		security: false,
		v8: "9.2.230.21"
	},
	{
		name: "nodejs",
		version: "16.9.0",
		date: "2021-09-07",
		lts: false,
		security: false,
		v8: "9.3.345.16"
	},
	{
		name: "nodejs",
		version: "16.10.0",
		date: "2021-09-22",
		lts: false,
		security: false,
		v8: "9.3.345.19"
	},
	{
		name: "nodejs",
		version: "16.11.0",
		date: "2021-10-08",
		lts: false,
		security: false,
		v8: "9.4.146.19"
	},
	{
		name: "nodejs",
		version: "16.12.0",
		date: "2021-10-20",
		lts: false,
		security: false,
		v8: "9.4.146.19"
	},
	{
		name: "nodejs",
		version: "16.13.0",
		date: "2021-10-26",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.19"
	},
	{
		name: "nodejs",
		version: "16.14.0",
		date: "2022-02-08",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.24"
	},
	{
		name: "nodejs",
		version: "16.15.0",
		date: "2022-04-26",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.24"
	},
	{
		name: "nodejs",
		version: "16.16.0",
		date: "2022-07-07",
		lts: "Gallium",
		security: true,
		v8: "9.4.146.24"
	},
	{
		name: "nodejs",
		version: "16.17.0",
		date: "2022-08-16",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.26"
	},
	{
		name: "nodejs",
		version: "16.18.0",
		date: "2022-10-12",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.26"
	},
	{
		name: "nodejs",
		version: "16.19.0",
		date: "2022-12-13",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.26"
	},
	{
		name: "nodejs",
		version: "16.20.0",
		date: "2023-03-28",
		lts: "Gallium",
		security: false,
		v8: "9.4.146.26"
	},
	{
		name: "nodejs",
		version: "17.0.0",
		date: "2021-10-19",
		lts: false,
		security: false,
		v8: "9.5.172.21"
	},
	{
		name: "nodejs",
		version: "17.1.0",
		date: "2021-11-09",
		lts: false,
		security: false,
		v8: "9.5.172.25"
	},
	{
		name: "nodejs",
		version: "17.2.0",
		date: "2021-11-30",
		lts: false,
		security: false,
		v8: "9.6.180.14"
	},
	{
		name: "nodejs",
		version: "17.3.0",
		date: "2021-12-17",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.4.0",
		date: "2022-01-18",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.5.0",
		date: "2022-02-10",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.6.0",
		date: "2022-02-22",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.7.0",
		date: "2022-03-09",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.8.0",
		date: "2022-03-22",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "17.9.0",
		date: "2022-04-07",
		lts: false,
		security: false,
		v8: "9.6.180.15"
	},
	{
		name: "nodejs",
		version: "18.0.0",
		date: "2022-04-18",
		lts: false,
		security: false,
		v8: "10.1.124.8"
	},
	{
		name: "nodejs",
		version: "18.1.0",
		date: "2022-05-03",
		lts: false,
		security: false,
		v8: "10.1.124.8"
	},
	{
		name: "nodejs",
		version: "18.2.0",
		date: "2022-05-17",
		lts: false,
		security: false,
		v8: "10.1.124.8"
	},
	{
		name: "nodejs",
		version: "18.3.0",
		date: "2022-06-02",
		lts: false,
		security: false,
		v8: "10.2.154.4"
	},
	{
		name: "nodejs",
		version: "18.4.0",
		date: "2022-06-16",
		lts: false,
		security: false,
		v8: "10.2.154.4"
	},
	{
		name: "nodejs",
		version: "18.5.0",
		date: "2022-07-06",
		lts: false,
		security: true,
		v8: "10.2.154.4"
	},
	{
		name: "nodejs",
		version: "18.6.0",
		date: "2022-07-13",
		lts: false,
		security: false,
		v8: "10.2.154.13"
	},
	{
		name: "nodejs",
		version: "18.7.0",
		date: "2022-07-26",
		lts: false,
		security: false,
		v8: "10.2.154.13"
	},
	{
		name: "nodejs",
		version: "18.8.0",
		date: "2022-08-24",
		lts: false,
		security: false,
		v8: "10.2.154.13"
	},
	{
		name: "nodejs",
		version: "18.9.0",
		date: "2022-09-07",
		lts: false,
		security: false,
		v8: "10.2.154.15"
	},
	{
		name: "nodejs",
		version: "18.10.0",
		date: "2022-09-28",
		lts: false,
		security: false,
		v8: "10.2.154.15"
	},
	{
		name: "nodejs",
		version: "18.11.0",
		date: "2022-10-13",
		lts: false,
		security: false,
		v8: "10.2.154.15"
	},
	{
		name: "nodejs",
		version: "18.12.0",
		date: "2022-10-25",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.15"
	},
	{
		name: "nodejs",
		version: "18.13.0",
		date: "2023-01-05",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.23"
	},
	{
		name: "nodejs",
		version: "18.14.0",
		date: "2023-02-01",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.23"
	},
	{
		name: "nodejs",
		version: "18.15.0",
		date: "2023-03-05",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "18.16.0",
		date: "2023-04-12",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "18.17.0",
		date: "2023-07-18",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "18.18.0",
		date: "2023-09-18",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "18.19.0",
		date: "2023-11-29",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "18.20.0",
		date: "2024-03-26",
		lts: "Hydrogen",
		security: false,
		v8: "10.2.154.26"
	},
	{
		name: "nodejs",
		version: "19.0.0",
		date: "2022-10-17",
		lts: false,
		security: false,
		v8: "10.7.193.13"
	},
	{
		name: "nodejs",
		version: "19.1.0",
		date: "2022-11-14",
		lts: false,
		security: false,
		v8: "10.7.193.20"
	},
	{
		name: "nodejs",
		version: "19.2.0",
		date: "2022-11-29",
		lts: false,
		security: false,
		v8: "10.8.168.20"
	},
	{
		name: "nodejs",
		version: "19.3.0",
		date: "2022-12-14",
		lts: false,
		security: false,
		v8: "10.8.168.21"
	},
	{
		name: "nodejs",
		version: "19.4.0",
		date: "2023-01-05",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "19.5.0",
		date: "2023-01-24",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "19.6.0",
		date: "2023-02-01",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "19.7.0",
		date: "2023-02-21",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "19.8.0",
		date: "2023-03-14",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "19.9.0",
		date: "2023-04-10",
		lts: false,
		security: false,
		v8: "10.8.168.25"
	},
	{
		name: "nodejs",
		version: "20.0.0",
		date: "2023-04-17",
		lts: false,
		security: false,
		v8: "11.3.244.4"
	},
	{
		name: "nodejs",
		version: "20.1.0",
		date: "2023-05-03",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.2.0",
		date: "2023-05-16",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.3.0",
		date: "2023-06-08",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.4.0",
		date: "2023-07-04",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.5.0",
		date: "2023-07-19",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.6.0",
		date: "2023-08-23",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.7.0",
		date: "2023-09-18",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.8.0",
		date: "2023-09-28",
		lts: false,
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.9.0",
		date: "2023-10-24",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.10.0",
		date: "2023-11-22",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.11.0",
		date: "2024-01-09",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.12.0",
		date: "2024-03-26",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.13.0",
		date: "2024-05-07",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.14.0",
		date: "2024-05-28",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.15.0",
		date: "2024-06-20",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.16.0",
		date: "2024-07-24",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.17.0",
		date: "2024-08-21",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "20.18.0",
		date: "2024-10-03",
		lts: "Iron",
		security: false,
		v8: "11.3.244.8"
	},
	{
		name: "nodejs",
		version: "21.0.0",
		date: "2023-10-17",
		lts: false,
		security: false,
		v8: "11.8.172.13"
	},
	{
		name: "nodejs",
		version: "21.1.0",
		date: "2023-10-24",
		lts: false,
		security: false,
		v8: "11.8.172.15"
	},
	{
		name: "nodejs",
		version: "21.2.0",
		date: "2023-11-14",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "21.3.0",
		date: "2023-11-30",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "21.4.0",
		date: "2023-12-05",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "21.5.0",
		date: "2023-12-19",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "21.6.0",
		date: "2024-01-14",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "21.7.0",
		date: "2024-03-06",
		lts: false,
		security: false,
		v8: "11.8.172.17"
	},
	{
		name: "nodejs",
		version: "22.0.0",
		date: "2024-04-24",
		lts: false,
		security: false,
		v8: "12.4.254.14"
	},
	{
		name: "nodejs",
		version: "22.1.0",
		date: "2024-05-02",
		lts: false,
		security: false,
		v8: "12.4.254.14"
	},
	{
		name: "nodejs",
		version: "22.2.0",
		date: "2024-05-15",
		lts: false,
		security: false,
		v8: "12.4.254.14"
	},
	{
		name: "nodejs",
		version: "22.3.0",
		date: "2024-06-11",
		lts: false,
		security: false,
		v8: "12.4.254.20"
	},
	{
		name: "nodejs",
		version: "22.4.0",
		date: "2024-07-02",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.5.0",
		date: "2024-07-17",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.6.0",
		date: "2024-08-06",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.7.0",
		date: "2024-08-21",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.8.0",
		date: "2024-09-03",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.9.0",
		date: "2024-09-17",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.10.0",
		date: "2024-10-16",
		lts: false,
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.11.0",
		date: "2024-10-29",
		lts: "Jod",
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "22.12.0",
		date: "2024-12-02",
		lts: "Jod",
		security: false,
		v8: "12.4.254.21"
	},
	{
		name: "nodejs",
		version: "23.0.0",
		date: "2024-10-16",
		lts: false,
		security: false,
		v8: "12.9.202.26"
	},
	{
		name: "nodejs",
		version: "23.1.0",
		date: "2024-10-24",
		lts: false,
		security: false,
		v8: "12.9.202.28"
	},
	{
		name: "nodejs",
		version: "23.2.0",
		date: "2024-11-11",
		lts: false,
		security: false,
		v8: "12.9.202.28"
	},
	{
		name: "nodejs",
		version: "23.3.0",
		date: "2024-11-20",
		lts: false,
		security: false,
		v8: "12.9.202.28"
	}
];

var agents$1 = {};

var browsers$1 = {};

var browsers;
var hasRequiredBrowsers$1;

function requireBrowsers$1 () {
	if (hasRequiredBrowsers$1) return browsers;
	hasRequiredBrowsers$1 = 1;
	browsers = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
	return browsers;
}

var hasRequiredBrowsers;

function requireBrowsers () {
	if (hasRequiredBrowsers) return browsers$1;
	hasRequiredBrowsers = 1;
	browsers$1.browsers = requireBrowsers$1();
	return browsers$1;
}

var browserVersions$1 = {};

var browserVersions;
var hasRequiredBrowserVersions$1;

function requireBrowserVersions$1 () {
	if (hasRequiredBrowserVersions$1) return browserVersions;
	hasRequiredBrowserVersions$1 = 1;
	browserVersions = { "0": "117", "1": "20", "2": "21", "3": "22", "4": "23", "5": "24", "6": "25", "7": "26", "8": "27", "9": "118", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "80", I: "136", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "114", y: "115", z: "116", AB: "119", BB: "120", CB: "121", DB: "122", EB: "123", FB: "124", GB: "125", HB: "126", IB: "127", JB: "128", KB: "129", LB: "130", MB: "131", NB: "132", OB: "133", PB: "134", QB: "135", RB: "5", SB: "19", TB: "28", UB: "29", VB: "30", WB: "31", XB: "32", YB: "33", ZB: "34", aB: "35", bB: "36", cB: "37", dB: "38", eB: "39", fB: "40", gB: "41", hB: "42", iB: "43", jB: "44", kB: "45", lB: "46", mB: "47", nB: "48", oB: "49", pB: "50", qB: "51", rB: "52", sB: "53", tB: "54", uB: "55", vB: "56", wB: "57", xB: "58", yB: "60", zB: "62", "0B": "63", "1B": "64", "2B": "65", "3B": "66", "4B": "67", "5B": "68", "6B": "69", "7B": "70", "8B": "71", "9B": "72", AC: "73", BC: "74", CC: "75", DC: "76", EC: "77", FC: "78", GC: "137", HC: "11.1", IC: "12.1", JC: "15.5", KC: "16.0", LC: "17.0", MC: "18.0", NC: "3", OC: "59", PC: "61", QC: "82", RC: "138", SC: "139", TC: "3.2", UC: "10.1", VC: "15.2-15.3", WC: "15.4", XC: "16.1", YC: "16.2", ZC: "16.3", aC: "16.4", bC: "16.5", cC: "17.1", dC: "17.2", eC: "17.3", fC: "17.4", gC: "17.5", hC: "18.1", iC: "18.2", jC: "18.3", kC: "18.4", lC: "18.5", mC: "11.5", nC: "4.2-4.3", oC: "5.5", pC: "2", qC: "140", rC: "141", sC: "3.5", tC: "3.6", uC: "3.1", vC: "5.1", wC: "6.1", xC: "7.1", yC: "9.1", zC: "13.1", "0C": "14.1", "1C": "15.1", "2C": "15.6", "3C": "16.6", "4C": "17.6", "5C": "TP", "6C": "9.5-9.6", "7C": "10.0-10.1", "8C": "10.5", "9C": "10.6", AD: "11.6", BD: "4.0-4.1", CD: "5.0-5.1", DD: "6.0-6.1", ED: "7.0-7.1", FD: "8.1-8.4", GD: "9.0-9.2", HD: "9.3", ID: "10.0-10.2", JD: "10.3", KD: "11.0-11.2", LD: "11.3-11.4", MD: "12.0-12.1", ND: "12.2-12.5", OD: "13.0-13.1", PD: "13.2", QD: "13.3", RD: "13.4-13.7", SD: "14.0-14.4", TD: "14.5-14.8", UD: "15.0-15.1", VD: "15.6-15.8", WD: "16.6-16.7", XD: "17.6-17.7", YD: "all", ZD: "2.1", aD: "2.2", bD: "2.3", cD: "4.1", dD: "4.4", eD: "4.4.3-4.4.4", fD: "5.0-5.4", gD: "6.2-6.4", hD: "7.2-7.4", iD: "8.2", jD: "9.2", kD: "11.1-11.2", lD: "12.0", mD: "13.0", nD: "14.0", oD: "15.0", pD: "19.0", qD: "14.9", rD: "13.52", sD: "2.5", tD: "3.0-3.1" };
	return browserVersions;
}

var hasRequiredBrowserVersions;

function requireBrowserVersions () {
	if (hasRequiredBrowserVersions) return browserVersions$1;
	hasRequiredBrowserVersions = 1;
	browserVersions$1.browserVersions = requireBrowserVersions$1();
	return browserVersions$1;
}

var agents;
var hasRequiredAgents$1;

function requireAgents$1 () {
	if (hasRequiredAgents$1) return agents;
	hasRequiredAgents$1 = 1;
	agents = { A: { A: { K: 0, D: 0, E: 0.030974, F: 0.030974, A: 0, B: 0.433636, oC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "oC", "K", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { oC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { "0": 3644e-6, "9": 3644e-6, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0.10932, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0.014576, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 3644e-6, r: 7288e-6, s: 0.047372, t: 3644e-6, u: 3644e-6, v: 3644e-6, w: 7288e-6, x: 0.010932, y: 3644e-6, z: 3644e-6, AB: 3644e-6, BB: 0.03644, CB: 7288e-6, DB: 0.010932, EB: 3644e-6, FB: 7288e-6, GB: 7288e-6, HB: 0.01822, IB: 0.014576, JB: 0.010932, KB: 0.010932, LB: 0.01822, MB: 0.047372, NB: 0.043728, OB: 0.058304, PB: 0.972948, QB: 3.39621, I: 7288e-6 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "I", "", "", ""], E: "Edge", F: { "0": 1694649600, "9": 1697155200, C: 1438128e3, L: 1447286400, M: 1470096e3, G: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600, t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3, y: 1689897600, z: 1692576e3, AB: 1698969600, BB: 1701993600, CB: 1706227200, DB: 1708732800, EB: 1711152e3, FB: 1713398400, GB: 1715990400, HB: 1718841600, IB: 1721865600, JB: 1724371200, KB: 1726704e3, LB: 1729123200, MB: 1731542400, NB: 1737417600, OB: 1740614400, PB: 1741219200, QB: 1743984e3, I: 1746316800 }, D: { C: "ms", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0.10932, pC: 3644e-6, NC: 0, J: 3644e-6, RB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.029152, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 3644e-6, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0.029152, sB: 7288e-6, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, OC: 7288e-6, yB: 0, PC: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0.040084, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0.010932, Q: 0, H: 0, R: 0, QC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 7288e-6, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 3644e-6, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0.2733, z: 0, AB: 0, BB: 3644e-6, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0.014576, HB: 0, IB: 3644e-6, JB: 0.0911, KB: 0, LB: 0, MB: 3644e-6, NB: 7288e-6, OB: 0.010932, PB: 0.010932, QB: 0.025508, I: 0.207708, GC: 1.19888, RC: 0.021864, SC: 0, qC: 0, rC: 0, sC: 0, tC: 0 }, B: "moz", C: ["pC", "NC", "sC", "tC", "J", "RB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "SB", "1", "2", "3", "4", "5", "6", "7", "8", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "OC", "yB", "PC", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "Q", "H", "R", "QC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "I", "GC", "RC", "SC", "qC", "rC"], E: "Firefox", F: { "0": 1693267200, "1": 1361232e3, "2": 1364860800, "3": 1368489600, "4": 1372118400, "5": 1375747200, "6": 1379376e3, "7": 1386633600, "8": 1391472e3, "9": 1695686400, pC: 1161648e3, NC: 1213660800, sC: 124632e4, tC: 1264032e3, J: 1300752e3, RB: 1308614400, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600, M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, SB: 1357603200, TB: 1395100800, UB: 1398729600, VB: 1402358400, WB: 1405987200, XB: 1409616e3, YB: 1413244800, ZB: 1417392e3, aB: 1421107200, bB: 1424736e3, cB: 1428278400, dB: 1431475200, eB: 1435881600, fB: 1439251200, gB: 144288e4, hB: 1446508800, iB: 1450137600, jB: 1453852800, kB: 1457395200, lB: 1461628800, mB: 1465257600, nB: 1470096e3, oB: 1474329600, pB: 1479168e3, qB: 1485216e3, rB: 1488844800, sB: 149256e4, tB: 1497312e3, uB: 1502150400, vB: 1506556800, wB: 1510617600, xB: 1516665600, OC: 1520985600, yB: 1525824e3, PC: 1529971200, zB: 1536105600, "0B": 1540252800, "1B": 1544486400, "2B": 154872e4, "3B": 1552953600, "4B": 1558396800, "5B": 1562630400, "6B": 1567468800, "7B": 1571788800, "8B": 1575331200, "9B": 1578355200, AC: 1581379200, BC: 1583798400, CC: 1586304e3, DC: 1588636800, EC: 1591056e3, FC: 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800, QC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3, v: 1681171200, w: 1683590400, x: 1686009600, y: 1688428800, z: 1690848e3, AB: 1698105600, BB: 1700524800, CB: 1702944e3, DB: 1705968e3, EB: 1708387200, FB: 1710806400, GB: 1713225600, HB: 1715644800, IB: 1718064e3, JB: 1720483200, KB: 1722902400, LB: 1725321600, MB: 1727740800, NB: 173016e4, OB: 1732579200, PB: 1736208e3, QB: 1738627200, I: 1741046400, GC: 1743465600, RC: 1745884800, SC: null, qC: null, rC: null } }, D: { A: { "0": 0.080168, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0.065592, J: 0, RB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 3644e-6, eB: 0.010932, fB: 0.010932, gB: 0.010932, hB: 0.010932, iB: 0.010932, jB: 0.010932, kB: 0.014576, lB: 0.010932, mB: 0.014576, nB: 0.021864, oB: 0.021864, pB: 0.014576, qB: 0.010932, rB: 0.014576, sB: 0.014576, tB: 0.010932, uB: 0.010932, vB: 0.021864, wB: 0.010932, xB: 0.01822, OC: 0.010932, yB: 0.010932, PC: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0.021864, "4B": 0, "5B": 0, "6B": 0.01822, "7B": 7288e-6, "8B": 0, "9B": 0, AC: 3644e-6, BC: 3644e-6, CC: 3644e-6, DC: 3644e-6, EC: 7288e-6, FC: 0.010932, Q: 0.069236, H: 0.010932, R: 0.021864, S: 0.029152, T: 3644e-6, U: 7288e-6, V: 0.01822, W: 0.051016, X: 0.010932, Y: 7288e-6, Z: 7288e-6, a: 0.03644, b: 0.010932, c: 0.010932, d: 0.01822, e: 7288e-6, f: 7288e-6, g: 0.01822, h: 0.032796, i: 0.01822, j: 0.01822, k: 0.01822, l: 0.010932, m: 0.069236, n: 0.032796, o: 0.010932, p: 0.021864, q: 0.025508, r: 0.043728, s: 0.903712, t: 0.01822, u: 0.03644, v: 0.029152, w: 0.116608, x: 0.051016, y: 0.025508, z: 0.160336, AB: 0.043728, BB: 0.061948, CB: 0.087456, DB: 0.07288, EB: 0.083812, FB: 0.102032, GB: 0.05466, HB: 0.10932, IB: 0.051016, JB: 0.112964, KB: 0.080168, LB: 0.131184, MB: 1.21345, NB: 0.681428, OB: 0.92922, PB: 4.30721, QB: 10.7462, I: 0.065592, GC: 0.014576, RC: 0, SC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "J", "RB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "SB", "1", "2", "3", "4", "5", "6", "7", "8", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "OC", "yB", "PC", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "I", "GC", "RC", "SC"], E: "Chrome", F: { "0": 1694476800, "1": 133704e4, "2": 1340668800, "3": 1343692800, "4": 1348531200, "5": 1352246400, "6": 1357862400, "7": 1361404800, "8": 1364428800, "9": 1696896e3, J: 1264377600, RB: 1274745600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, SB: 1332892800, TB: 1369094400, UB: 1374105600, VB: 1376956800, WB: 1384214400, XB: 1389657600, YB: 1392940800, ZB: 1397001600, aB: 1400544e3, bB: 1405468800, cB: 1409011200, dB: 141264e4, eB: 1416268800, fB: 1421798400, gB: 1425513600, hB: 1429401600, iB: 143208e4, jB: 1437523200, kB: 1441152e3, lB: 1444780800, mB: 1449014400, nB: 1453248e3, oB: 1456963200, pB: 1460592e3, qB: 1464134400, rB: 1469059200, sB: 1472601600, tB: 1476230400, uB: 1480550400, vB: 1485302400, wB: 1489017600, xB: 149256e4, OC: 1496707200, yB: 1500940800, PC: 1504569600, zB: 1508198400, "0B": 1512518400, "1B": 1516752e3, "2B": 1520294400, "3B": 1523923200, "4B": 1527552e3, "5B": 1532390400, "6B": 1536019200, "7B": 1539648e3, "8B": 1543968e3, "9B": 154872e4, AC: 1552348800, BC: 1555977600, CC: 1559606400, DC: 1564444800, EC: 1568073600, FC: 1571702400, Q: 1575936e3, H: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3, r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200, v: 1680566400, w: 1682985600, x: 1685404800, y: 1689724800, z: 1692057600, AB: 1698710400, BB: 1701993600, CB: 1705968e3, DB: 1708387200, EB: 1710806400, FB: 1713225600, GB: 1715644800, HB: 1718064e3, IB: 1721174400, JB: 1724112e3, KB: 1726531200, LB: 1728950400, MB: 1731369600, NB: 1736812800, OB: 1738627200, PB: 1741046400, QB: 1743465600, I: 1745884800, GC: null, RC: null, SC: null } }, E: { A: { J: 0, RB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0.014576, G: 0, uC: 0, TC: 0, vC: 0, wC: 0, xC: 0, yC: 0, UC: 0, HC: 7288e-6, IC: 7288e-6, zC: 0.032796, "0C": 0.040084, "1C": 0.014576, VC: 3644e-6, WC: 0.010932, JC: 0.010932, "2C": 0.134828, KC: 0.029152, XC: 0.021864, YC: 0.01822, ZC: 0.03644, aC: 0.014576, bC: 0.021864, "3C": 0.189488, LC: 0.010932, cC: 0.120252, dC: 0.01822, eC: 0.01822, fC: 0.043728, gC: 0.076524, "4C": 0.233216, MC: 0.032796, hC: 0.080168, iC: 0.040084, jC: 1.1515, kC: 0.335248, lC: 7288e-6, "5C": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "uC", "TC", "J", "RB", "vC", "K", "wC", "D", "xC", "E", "F", "yC", "A", "UC", "B", "HC", "C", "IC", "L", "zC", "M", "0C", "G", "1C", "VC", "WC", "JC", "2C", "KC", "XC", "YC", "ZC", "aC", "bC", "3C", "LC", "cC", "dC", "eC", "fC", "gC", "4C", "MC", "hC", "iC", "jC", "kC", "lC", "5C", "", ""], E: "Safari", F: { uC: 1205798400, TC: 1226534400, J: 1244419200, RB: 1275868800, vC: 131112e4, K: 1343174400, wC: 13824e5, D: 13824e5, xC: 1410998400, E: 1413417600, F: 1443657600, yC: 1458518400, A: 1474329600, UC: 1490572800, B: 1505779200, HC: 1522281600, C: 1537142400, IC: 1553472e3, L: 1568851200, zC: 1585008e3, M: 1600214400, "0C": 1619395200, G: 1632096e3, "1C": 1635292800, VC: 1639353600, WC: 1647216e3, JC: 1652745600, "2C": 1658275200, KC: 1662940800, XC: 1666569600, YC: 1670889600, ZC: 1674432e3, aC: 1679875200, bC: 1684368e3, "3C": 1690156800, LC: 1695686400, cC: 1698192e3, dC: 1702252800, eC: 1705881600, fC: 1709596800, gC: 1715558400, "4C": 1722211200, MC: 1726444800, hC: 1730073600, iC: 1733875200, jC: 1737936e3, kC: 1743379200, lC: 1747008e3, "5C": null } }, F: { A: { "0": 0.750664, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 7288e-6, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0.010932, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, Q: 0, H: 0, R: 0, QC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0.032796, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0.032796, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.076524, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0, z: 3644e-6, "6C": 0, "7C": 0, "8C": 0, "9C": 0, HC: 0, mC: 0, AD: 0, IC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "6C", "7C", "8C", "9C", "B", "HC", "mC", "AD", "C", "IC", "G", "N", "O", "P", "SB", "1", "2", "3", "4", "5", "6", "7", "8", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "Q", "H", "R", "QC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "", "", ""], E: "Opera", F: { "0": 1739404800, "1": 1393891200, "2": 1399334400, "3": 1401753600, "4": 1405987200, "5": 1409616e3, "6": 1413331200, "7": 1417132800, "8": 1422316800, F: 1150761600, "6C": 1223424e3, "7C": 1251763200, "8C": 1267488e3, "9C": 1277942400, B: 1292457600, HC: 1302566400, mC: 1309219200, AD: 1323129600, C: 1323129600, IC: 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3, SB: 1390867200, TB: 1425945600, UB: 1430179200, VB: 1433808e3, WB: 1438646400, XB: 1442448e3, YB: 1445904e3, ZB: 1449100800, aB: 1454371200, bB: 1457308800, cB: 146232e4, dB: 1465344e3, eB: 1470096e3, fB: 1474329600, gB: 1477267200, hB: 1481587200, iB: 1486425600, jB: 1490054400, kB: 1494374400, lB: 1498003200, mB: 1502236800, nB: 1506470400, oB: 1510099200, pB: 1515024e3, qB: 1517961600, rB: 1521676800, sB: 1525910400, tB: 1530144e3, uB: 1534982400, vB: 1537833600, wB: 1543363200, xB: 1548201600, yB: 1554768e3, zB: 1561593600, "0B": 1566259200, "1B": 1570406400, "2B": 1573689600, "3B": 1578441600, "4B": 1583971200, "5B": 1587513600, "6B": 1592956800, "7B": 1595894400, "8B": 1600128e3, "9B": 1603238400, AC: 161352e4, BC: 1612224e3, CC: 1616544e3, DC: 1619568e3, EC: 1623715200, FC: 1627948800, Q: 1631577600, H: 1633392e3, R: 1635984e3, QC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600, t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800, x: 1727222400, y: 1732665600, z: 1736294400 }, D: { F: "o", B: "o", C: "o", "6C": "o", "7C": "o", "8C": "o", "9C": "o", HC: "o", mC: "o", AD: "o", IC: "o" } }, G: { A: { E: 0, TC: 0, BD: 0, nC: 284323e-8, CD: 0, DD: 568645e-8, ED: 568645e-8, FD: 0, GD: 284323e-8, HD: 0.018481, ID: 142161e-8, JD: 0.0298539, KD: 0.243096, LD: 0.0113729, MD: 284323e-8, ND: 0.112307, OD: 142161e-8, PD: 568645e-8, QD: 426484e-8, RD: 0.0199026, SD: 0.130788, TD: 0.0469132, UD: 0.0298539, VC: 0.0298539, WC: 0.036962, JC: 0.0398052, VD: 0.490457, KC: 0.0682374, XC: 0.145005, YC: 0.0753455, ZC: 0.129367, aC: 0.0298539, bC: 0.0540213, WD: 0.604186, LC: 0.0341187, cC: 0.0611294, dC: 0.0483349, eC: 0.0696591, fC: 0.13221, gC: 0.288588, XD: 0.813163, MC: 0.217507, hC: 0.587126, iC: 0.285744, jC: 7.46205, kC: 1.76564, lC: 0.0611294 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "TC", "BD", "nC", "CD", "DD", "ED", "E", "FD", "GD", "HD", "ID", "JD", "KD", "LD", "MD", "ND", "OD", "PD", "QD", "RD", "SD", "TD", "UD", "VC", "WC", "JC", "VD", "KC", "XC", "YC", "ZC", "aC", "bC", "WD", "LC", "cC", "dC", "eC", "fC", "gC", "XD", "MC", "hC", "iC", "jC", "kC", "lC", "", "", ""], E: "Safari on iOS", F: { TC: 1270252800, BD: 1283904e3, nC: 1299628800, CD: 1331078400, DD: 1359331200, ED: 1394409600, E: 1410912e3, FD: 1413763200, GD: 1442361600, HD: 1458518400, ID: 1473724800, JD: 1490572800, KD: 1505779200, LD: 1522281600, MD: 1537142400, ND: 1553472e3, OD: 1568851200, PD: 1572220800, QD: 1580169600, RD: 1585008e3, SD: 1600214400, TD: 1619395200, UD: 1632096e3, VC: 1639353600, WC: 1647216e3, JC: 1652659200, VD: 1658275200, KC: 1662940800, XC: 1666569600, YC: 1670889600, ZC: 1674432e3, aC: 1679875200, bC: 1684368e3, WD: 1690156800, LC: 1694995200, cC: 1698192e3, dC: 1702252800, eC: 1705881600, fC: 1709596800, gC: 1715558400, XD: 1722211200, MC: 1726444800, hC: 1730073600, iC: 1733875200, jC: 1737936e3, kC: 1743379200, lC: 1747008e3 } }, H: { A: { YD: 0.05 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "YD", "", "", ""], E: "Opera Mini", F: { YD: 1426464e3 } }, I: { A: { NC: 0, J: 0, I: 0.818237, ZD: 0, aD: 0, bD: 0, cD: 0, nC: 163959e-9, dD: 0, eD: 819795e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "ZD", "aD", "bD", "NC", "J", "cD", "nC", "dD", "eD", "I", "", "", ""], E: "Android Browser", F: { ZD: 1256515200, aD: 1274313600, bD: 1291593600, NC: 1298332800, J: 1318896e3, cD: 1341792e3, nC: 1374624e3, dD: 1386547200, eD: 1401667200, I: 1745971200 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 0.922315, HC: 0, mC: 0, IC: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "HC", "mC", "C", "IC", "H", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, HC: 1314835200, mC: 1318291200, C: 1330300800, IC: 1349740800, H: 1709769600 }, D: { H: "webkit" } }, L: { A: { I: 44.9483 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "", ""], E: "Chrome for Android", F: { I: 1745971200 } }, M: { A: { GC: 0.336815 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "GC", "", "", ""], E: "Firefox for Android", F: { GC: 1743465600 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { JC: 0.86428 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "JC", "", "", ""], E: "UC Browser for Android", F: { JC: 1710115200 }, D: { JC: "webkit" } }, P: { A: { "1": 0, "2": 0.0220266, "3": 0.0220266, "4": 0.0330398, "5": 0.0440531, "6": 0.0440531, "7": 0.0770929, "8": 1.68503, J: 0.0110133, fD: 0, gD: 0, hD: 0.0110133, iD: 0, jD: 0, UC: 0, kD: 0, lD: 0, mD: 0, nD: 0, oD: 0, KC: 0, LC: 0.0110133, MC: 0, pD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "fD", "gD", "hD", "iD", "jD", "UC", "kD", "lD", "mD", "nD", "oD", "KC", "LC", "MC", "pD", "1", "2", "3", "4", "5", "6", "7", "8", "", "", ""], E: "Samsung Internet", F: { "1": 1677369600, "2": 1684454400, "3": 1689292800, "4": 1697587200, "5": 1711497600, "6": 1715126400, "7": 1717718400, "8": 1725667200, J: 1461024e3, fD: 1481846400, gD: 1509408e3, hD: 1528329600, iD: 1546128e3, jD: 1554163200, UC: 1567900800, kD: 1582588800, lD: 1593475200, mD: 1605657600, nD: 1618531200, oD: 1629072e3, KC: 1640736e3, LC: 1651708800, MC: 1659657600, pD: 1667260800 } }, Q: { A: { qD: 0.222425 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "qD", "", "", ""], E: "QQ Browser", F: { qD: 1710288e3 } }, R: { A: { rD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rD", "", "", ""], E: "Baidu Browser", F: { rD: 1710201600 } }, S: { A: { sD: 0.01271, tD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "sD", "tD", "", "", ""], E: "KaiOS Browser", F: { sD: 1527811200, tD: 1631664e3 } } };
	return agents;
}

var hasRequiredAgents;

function requireAgents () {
	if (hasRequiredAgents) return agents$1;
	hasRequiredAgents = 1;
	const browsers = requireBrowsers().browsers;
	const versions = requireBrowserVersions().browserVersions;
	const agentsData = requireAgents$1();
	function unpackBrowserVersions(versionsData) {
	  return Object.keys(versionsData).reduce((usage, version) => {
	    usage[versions[version]] = versionsData[version];
	    return usage;
	  }, {});
	}
	agents$1.agents = Object.keys(agentsData).reduce((map, key) => {
	  let versionsData = agentsData[key];
	  map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
	    if (entry === "A") {
	      data.usage_global = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === "C") {
	      data.versions = versionsData[entry].reduce((list, version) => {
	        if (version === "") {
	          list.push(null);
	        } else {
	          list.push(versions[version]);
	        }
	        return list;
	      }, []);
	    } else if (entry === "D") {
	      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === "E") {
	      data.browser = versionsData[entry];
	    } else if (entry === "F") {
	      data.release_date = Object.keys(versionsData[entry]).reduce(
	        (map2, key2) => {
	          map2[versions[key2]] = versionsData[entry][key2];
	          return map2;
	        },
	        {}
	      );
	    } else {
	      data.prefix = versionsData[entry];
	    }
	    return data;
	  }, {});
	  return map;
	}, {});
	return agents$1;
}

var versions;
var hasRequiredVersions;

function requireVersions () {
	if (hasRequiredVersions) return versions;
	hasRequiredVersions = 1;
	versions = {
	  "0.20": "39",
	  "0.21": "41",
	  "0.22": "41",
	  "0.23": "41",
	  "0.24": "41",
	  "0.25": "42",
	  "0.26": "42",
	  "0.27": "43",
	  "0.28": "43",
	  "0.29": "43",
	  "0.30": "44",
	  "0.31": "45",
	  "0.32": "45",
	  "0.33": "45",
	  "0.34": "45",
	  "0.35": "45",
	  "0.36": "47",
	  "0.37": "49",
	  "1.0": "49",
	  "1.1": "50",
	  "1.2": "51",
	  "1.3": "52",
	  "1.4": "53",
	  "1.5": "54",
	  "1.6": "56",
	  "1.7": "58",
	  "1.8": "59",
	  "2.0": "61",
	  "2.1": "61",
	  "3.0": "66",
	  "3.1": "66",
	  "4.0": "69",
	  "4.1": "69",
	  "4.2": "69",
	  "5.0": "73",
	  "6.0": "76",
	  "6.1": "76",
	  "7.0": "78",
	  "7.1": "78",
	  "7.2": "78",
	  "7.3": "78",
	  "8.0": "80",
	  "8.1": "80",
	  "8.2": "80",
	  "8.3": "80",
	  "8.4": "80",
	  "8.5": "80",
	  "9.0": "83",
	  "9.1": "83",
	  "9.2": "83",
	  "9.3": "83",
	  "9.4": "83",
	  "10.0": "85",
	  "10.1": "85",
	  "10.2": "85",
	  "10.3": "85",
	  "10.4": "85",
	  "11.0": "87",
	  "11.1": "87",
	  "11.2": "87",
	  "11.3": "87",
	  "11.4": "87",
	  "11.5": "87",
	  "12.0": "89",
	  "12.1": "89",
	  "12.2": "89",
	  "13.0": "91",
	  "13.1": "91",
	  "13.2": "91",
	  "13.3": "91",
	  "13.4": "91",
	  "13.5": "91",
	  "13.6": "91",
	  "14.0": "93",
	  "14.1": "93",
	  "14.2": "93",
	  "15.0": "94",
	  "15.1": "94",
	  "15.2": "94",
	  "15.3": "94",
	  "15.4": "94",
	  "15.5": "94",
	  "16.0": "96",
	  "16.1": "96",
	  "16.2": "96",
	  "17.0": "98",
	  "17.1": "98",
	  "17.2": "98",
	  "17.3": "98",
	  "17.4": "98",
	  "18.0": "100",
	  "18.1": "100",
	  "18.2": "100",
	  "18.3": "100",
	  "19.0": "102",
	  "19.1": "102",
	  "20.0": "104",
	  "20.1": "104",
	  "20.2": "104",
	  "20.3": "104",
	  "21.0": "106",
	  "21.1": "106",
	  "21.2": "106",
	  "21.3": "106",
	  "21.4": "106",
	  "22.0": "108",
	  "22.1": "108",
	  "22.2": "108",
	  "22.3": "108",
	  "23.0": "110",
	  "23.1": "110",
	  "23.2": "110",
	  "23.3": "110",
	  "24.0": "112",
	  "24.1": "112",
	  "24.2": "112",
	  "24.3": "112",
	  "24.4": "112",
	  "24.5": "112",
	  "24.6": "112",
	  "24.7": "112",
	  "24.8": "112",
	  "25.0": "114",
	  "25.1": "114",
	  "25.2": "114",
	  "25.3": "114",
	  "25.4": "114",
	  "25.5": "114",
	  "25.6": "114",
	  "25.7": "114",
	  "25.8": "114",
	  "25.9": "114",
	  "26.0": "116",
	  "26.1": "116",
	  "26.2": "116",
	  "26.3": "116",
	  "26.4": "116",
	  "26.5": "116",
	  "26.6": "116",
	  "27.0": "118",
	  "27.1": "118",
	  "27.2": "118",
	  "27.3": "118",
	  "28.0": "120",
	  "28.1": "120",
	  "28.2": "120",
	  "28.3": "120",
	  "29.0": "122",
	  "29.1": "122",
	  "29.2": "122",
	  "29.3": "122",
	  "29.4": "122",
	  "30.0": "124",
	  "30.1": "124",
	  "30.2": "124",
	  "30.3": "124",
	  "30.4": "124",
	  "30.5": "124",
	  "31.0": "126",
	  "31.1": "126",
	  "31.2": "126",
	  "31.3": "126",
	  "31.4": "126",
	  "31.5": "126",
	  "31.6": "126",
	  "31.7": "126",
	  "32.0": "128",
	  "32.1": "128",
	  "32.2": "128",
	  "32.3": "128",
	  "33.0": "130",
	  "33.1": "130",
	  "33.2": "130",
	  "33.3": "130",
	  "33.4": "130",
	  "34.0": "132",
	  "34.1": "132",
	  "34.2": "132",
	  "34.3": "132",
	  "34.4": "132",
	  "34.5": "132",
	  "35.0": "134",
	  "35.1": "134",
	  "35.2": "134",
	  "35.3": "134",
	  "35.4": "134",
	  "36.0": "136",
	  "36.1": "136",
	  "36.2": "136",
	  "36.3": "136",
	  "37.0": "138"
	};
	return versions;
}

var v4 = {
	start: "2015-09-08",
	lts: "2015-10-12",
	maintenance: "2017-04-01",
	end: "2018-04-30",
	codename: "Argon"
};
var v5 = {
	start: "2015-10-29",
	maintenance: "2016-04-30",
	end: "2016-06-30"
};
var v6 = {
	start: "2016-04-26",
	lts: "2016-10-18",
	maintenance: "2018-04-30",
	end: "2019-04-30",
	codename: "Boron"
};
var v7 = {
	start: "2016-10-25",
	maintenance: "2017-04-30",
	end: "2017-06-30"
};
var v8$2 = {
	start: "2017-05-30",
	lts: "2017-10-31",
	maintenance: "2019-01-01",
	end: "2019-12-31",
	codename: "Carbon"
};
var v9 = {
	start: "2017-10-01",
	maintenance: "2018-04-01",
	end: "2018-06-30"
};
var v10 = {
	start: "2018-04-24",
	lts: "2018-10-30",
	maintenance: "2020-05-19",
	end: "2021-04-30",
	codename: "Dubnium"
};
var v11 = {
	start: "2018-10-23",
	maintenance: "2019-04-22",
	end: "2019-06-01"
};
var v12 = {
	start: "2019-04-23",
	lts: "2019-10-21",
	maintenance: "2020-11-30",
	end: "2022-04-30",
	codename: "Erbium"
};
var v13 = {
	start: "2019-10-22",
	maintenance: "2020-04-01",
	end: "2020-06-01"
};
var v14 = {
	start: "2020-04-21",
	lts: "2020-10-27",
	maintenance: "2021-10-19",
	end: "2023-04-30",
	codename: "Fermium"
};
var v15 = {
	start: "2020-10-20",
	maintenance: "2021-04-01",
	end: "2021-06-01"
};
var v16 = {
	start: "2021-04-20",
	lts: "2021-10-26",
	maintenance: "2022-10-18",
	end: "2023-09-11",
	codename: "Gallium"
};
var v17 = {
	start: "2021-10-19",
	maintenance: "2022-04-01",
	end: "2022-06-01"
};
var v18 = {
	start: "2022-04-19",
	lts: "2022-10-25",
	maintenance: "2023-10-18",
	end: "2025-04-30",
	codename: "Hydrogen"
};
var v19 = {
	start: "2022-10-18",
	maintenance: "2023-04-01",
	end: "2023-06-01"
};
var v20 = {
	start: "2023-04-18",
	lts: "2023-10-24",
	maintenance: "2024-10-22",
	end: "2026-04-30",
	codename: "Iron"
};
var v21 = {
	start: "2023-10-17",
	maintenance: "2024-04-01",
	end: "2024-06-01"
};
var v22 = {
	start: "2024-04-24",
	lts: "2024-10-29",
	maintenance: "2025-10-21",
	end: "2027-04-30",
	codename: "Jod"
};
var v23 = {
	start: "2024-10-16",
	maintenance: "2025-04-01",
	end: "2025-06-01"
};
var v24 = {
	start: "2025-04-22",
	lts: "2025-10-28",
	maintenance: "2026-10-20",
	end: "2028-04-30",
	codename: ""
};
var require$$3 = {
	"v0.8": {
	start: "2012-06-25",
	end: "2014-07-31"
},
	"v0.10": {
	start: "2013-03-11",
	end: "2016-10-31"
},
	"v0.12": {
	start: "2015-02-06",
	end: "2016-12-31"
},
	v4: v4,
	v5: v5,
	v6: v6,
	v7: v7,
	v8: v8$2,
	v9: v9,
	v10: v10,
	v11: v11,
	v12: v12,
	v13: v13,
	v14: v14,
	v15: v15,
	v16: v16,
	v17: v17,
	v18: v18,
	v19: v19,
	v20: v20,
	v21: v21,
	v22: v22,
	v23: v23,
	v24: v24
};

var error;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	function BrowserslistError(message) {
	  this.name = "BrowserslistError";
	  this.message = message;
	  this.browserslist = true;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, BrowserslistError);
	  }
	}
	BrowserslistError.prototype = Error.prototype;
	error = BrowserslistError;
	return error;
}

var node$1 = {exports: {}};

var feature = {exports: {}};

var statuses;
var hasRequiredStatuses;

function requireStatuses () {
	if (hasRequiredStatuses) return statuses;
	hasRequiredStatuses = 1;
	statuses = {
	  1: "ls",
	  // WHATWG Living Standard
	  2: "rec",
	  // W3C Recommendation
	  3: "pr",
	  // W3C Proposed Recommendation
	  4: "cr",
	  // W3C Candidate Recommendation
	  5: "wd",
	  // W3C Working Draft
	  6: "other",
	  // Non-W3C, but reputable
	  7: "unoff"
	  // Unofficial, Editor's Draft or W3C "Note"
	};
	return statuses;
}

var supported;
var hasRequiredSupported;

function requireSupported () {
	if (hasRequiredSupported) return supported;
	hasRequiredSupported = 1;
	supported = {
	  y: 1 << 0,
	  n: 1 << 1,
	  a: 1 << 2,
	  p: 1 << 3,
	  u: 1 << 4,
	  x: 1 << 5,
	  d: 1 << 6
	};
	return supported;
}

var hasRequiredFeature;

function requireFeature () {
	if (hasRequiredFeature) return feature.exports;
	hasRequiredFeature = 1;
	const statuses = requireStatuses();
	const supported = requireSupported();
	const browsers = requireBrowsers().browsers;
	const versions = requireBrowserVersions().browserVersions;
	const MATH2LOG = Math.log(2);
	function unpackSupport(cipher) {
	  let stats = Object.keys(supported).reduce((list, support) => {
	    if (cipher & supported[support]) list.push(support);
	    return list;
	  }, []);
	  let notes = cipher >> 7;
	  let notesArray = [];
	  while (notes) {
	    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
	    notesArray.unshift(`#${note}`);
	    notes -= Math.pow(2, note - 1);
	  }
	  return stats.concat(notesArray).join(" ");
	}
	function unpackFeature(packed) {
	  let unpacked = {
	    status: statuses[packed.B],
	    title: packed.C,
	    shown: packed.D
	  };
	  unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
	    let browser = packed.A[key];
	    browserStats[browsers[key]] = Object.keys(browser).reduce(
	      (stats, support) => {
	        let packedVersions = browser[support].split(" ");
	        let unpacked2 = unpackSupport(support);
	        packedVersions.forEach((v) => stats[versions[v]] = unpacked2);
	        return stats;
	      },
	      {}
	    );
	    return browserStats;
	  }, {});
	  return unpacked;
	}
	feature.exports = unpackFeature;
	feature.exports.default = unpackFeature;
	return feature.exports;
}

var region = {exports: {}};

var hasRequiredRegion;

function requireRegion () {
	if (hasRequiredRegion) return region.exports;
	hasRequiredRegion = 1;
	const browsers = requireBrowsers().browsers;
	function unpackRegion(packed) {
	  return Object.keys(packed).reduce((list, browser) => {
	    let data = packed[browser];
	    list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
	      let stats = data[key];
	      if (key === "_") {
	        stats.split(" ").forEach((version) => memo[version] = null);
	      } else {
	        memo[key] = stats;
	      }
	      return memo;
	    }, {});
	    return list;
	  }, {});
	}
	region.exports = unpackRegion;
	region.exports.default = unpackRegion;
	return region.exports;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node$1.exports;
	hasRequiredNode = 1;
	(function (module) {
		var feature = requireFeature().default;
		var region = requireRegion().default;
		var fs = require$$2$1;
		var path = require$$0$9;
		var BrowserslistError = requireError();
		var IS_SECTION = /^\s*\[(.+)]\s*$/;
		var CONFIG_PATTERN = /^browserslist-config-/;
		var SCOPED_CONFIG__PATTERN = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/;
		var FORMAT = "Browserslist config should be a string or an array of strings with browser queries";
		var dataTimeChecked = false;
		var statCache = {};
		var configPathCache = {};
		var parseConfigCache = {};
		function checkExtend(name) {
		  var use = " Use `dangerousExtend` option to disable.";
		  if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
		    throw new BrowserslistError(
		      "Browserslist config needs `browserslist-config-` prefix. " + use
		    );
		  }
		  if (name.replace(/^@[^/]+\//, "").indexOf(".") !== -1) {
		    throw new BrowserslistError(
		      "`.` not allowed in Browserslist config name. " + use
		    );
		  }
		  if (name.indexOf("node_modules") !== -1) {
		    throw new BrowserslistError(
		      "`node_modules` not allowed in Browserslist config." + use
		    );
		  }
		}
		function isFile(file) {
		  return fs.existsSync(file) && fs.statSync(file).isFile();
		}
		function isDirectory(dir) {
		  return fs.existsSync(dir) && fs.statSync(dir).isDirectory();
		}
		function eachParent(file, callback, cache) {
		  var loc = path.resolve(file);
		  var pathsForCacheResult = [];
		  var result;
		  do {
		    if (!pathInRoot(loc)) {
		      break;
		    }
		    if (cache && loc in cache) {
		      result = cache[loc];
		      break;
		    }
		    pathsForCacheResult.push(loc);
		    if (!isDirectory(loc)) {
		      continue;
		    }
		    var locResult = callback(loc);
		    if (typeof locResult !== "undefined") {
		      result = locResult;
		      break;
		    }
		  } while (loc !== (loc = path.dirname(loc)));
		  if (cache && !process.env.BROWSERSLIST_DISABLE_CACHE) {
		    pathsForCacheResult.forEach(function(cachePath) {
		      cache[cachePath] = result;
		    });
		  }
		  return result;
		}
		function pathInRoot(p) {
		  if (!process.env.BROWSERSLIST_ROOT_PATH) return true;
		  var rootPath = path.resolve(process.env.BROWSERSLIST_ROOT_PATH);
		  if (path.relative(rootPath, p).substring(0, 2) === "..") {
		    return false;
		  }
		  return true;
		}
		function check(section) {
		  if (Array.isArray(section)) {
		    for (var i = 0; i < section.length; i++) {
		      if (typeof section[i] !== "string") {
		        throw new BrowserslistError(FORMAT);
		      }
		    }
		  } else if (typeof section !== "string") {
		    throw new BrowserslistError(FORMAT);
		  }
		}
		function pickEnv(config, opts) {
		  if (typeof config !== "object") return config;
		  var name;
		  if (typeof opts.env === "string") {
		    name = opts.env;
		  } else if (process.env.BROWSERSLIST_ENV) {
		    name = process.env.BROWSERSLIST_ENV;
		  } else if (process.env.NODE_ENV) {
		    name = process.env.NODE_ENV;
		  } else {
		    name = "production";
		  }
		  if (opts.throwOnMissing) {
		    if (name && name !== "defaults" && !config[name]) {
		      throw new BrowserslistError(
		        "Missing config for Browserslist environment `" + name + "`"
		      );
		    }
		  }
		  return config[name] || config.defaults;
		}
		function parsePackage(file) {
		  var text = fs.readFileSync(file).toString().replace(/^\uFEFF/m, "");
		  var list;
		  if (text.indexOf('"browserslist"') >= 0) {
		    list = JSON.parse(text).browserslist;
		  } else if (text.indexOf('"browserlist"') >= 0) {
		    var config = JSON.parse(text);
		    if (config.browserlist && !config.browserslist) {
		      throw new BrowserslistError(
		        "`browserlist` key instead of `browserslist` in " + file
		      );
		    }
		  }
		  if (Array.isArray(list) || typeof list === "string") {
		    list = { defaults: list };
		  }
		  for (var i in list) {
		    check(list[i]);
		  }
		  return list;
		}
		function parsePackageOrReadConfig(file) {
		  if (file in parseConfigCache) {
		    return parseConfigCache[file];
		  }
		  var isPackage = path.basename(file) === "package.json";
		  var result = isPackage ? parsePackage(file) : module.exports.readConfig(file);
		  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
		    parseConfigCache[file] = result;
		  }
		  return result;
		}
		function latestReleaseTime(agents) {
		  var latest = 0;
		  for (var name in agents) {
		    var dates = agents[name].releaseDate || {};
		    for (var key in dates) {
		      if (latest < dates[key]) {
		        latest = dates[key];
		      }
		    }
		  }
		  return latest * 1e3;
		}
		function getMonthsPassed(date) {
		  var now = /* @__PURE__ */ new Date();
		  var past = new Date(date);
		  var years = now.getFullYear() - past.getFullYear();
		  var months = now.getMonth() - past.getMonth();
		  return years * 12 + months;
		}
		function normalizeStats(data, stats) {
		  if (!data) {
		    data = {};
		  }
		  if (stats && "dataByBrowser" in stats) {
		    stats = stats.dataByBrowser;
		  }
		  if (typeof stats !== "object") return void 0;
		  var normalized = {};
		  for (var i in stats) {
		    var versions = Object.keys(stats[i]);
		    if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
		      var normal = data[i].versions[0];
		      normalized[i] = {};
		      normalized[i][normal] = stats[i][versions[0]];
		    } else {
		      normalized[i] = stats[i];
		    }
		  }
		  return normalized;
		}
		function normalizeUsageData(usageData, data) {
		  for (var browser in usageData) {
		    var browserUsage = usageData[browser];
		    if ("0" in browserUsage) {
		      var versions = data[browser].versions;
		      browserUsage[versions[versions.length - 1]] = browserUsage[0];
		      delete browserUsage[0];
		    }
		  }
		}
		module.exports = {
		  loadQueries: function loadQueries(ctx, name) {
		    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
		      checkExtend(name);
		    }
		    var queries = require(require.resolve(name, { paths: [".", ctx.path] }));
		    if (typeof queries === "object" && queries !== null && queries.__esModule) {
		      queries = queries.default;
		    }
		    if (queries) {
		      if (Array.isArray(queries)) {
		        return queries;
		      } else if (typeof queries === "object") {
		        if (!queries.defaults) queries.defaults = [];
		        return pickEnv(queries, ctx);
		      }
		    }
		    throw new BrowserslistError(
		      "`" + name + "` config exports not an array of queries or an object of envs"
		    );
		  },
		  loadStat: function loadStat(ctx, name, data) {
		    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
		      checkExtend(name);
		    }
		    var stats = require(require.resolve(
		      path.join(name, "browserslist-stats.json"),
		      { paths: ["."] }
		    ));
		    return normalizeStats(data, stats);
		  },
		  getStat: function getStat(opts, data) {
		    var stats;
		    if (opts.stats) {
		      stats = opts.stats;
		    } else if (process.env.BROWSERSLIST_STATS) {
		      stats = process.env.BROWSERSLIST_STATS;
		    } else if (opts.path && path.resolve && fs.existsSync) {
		      stats = eachParent(
		        opts.path,
		        function(dir) {
		          var file = path.join(dir, "browserslist-stats.json");
		          return isFile(file) ? file : void 0;
		        },
		        statCache
		      );
		    }
		    if (typeof stats === "string") {
		      try {
		        stats = JSON.parse(fs.readFileSync(stats));
		      } catch (e) {
		        throw new BrowserslistError("Can't read " + stats);
		      }
		    }
		    return normalizeStats(data, stats);
		  },
		  loadConfig: function loadConfig(opts) {
		    if (process.env.BROWSERSLIST) {
		      return process.env.BROWSERSLIST;
		    } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
		      var file = opts.config || process.env.BROWSERSLIST_CONFIG;
		      return pickEnv(parsePackageOrReadConfig(file), opts);
		    } else if (opts.path) {
		      return pickEnv(module.exports.findConfig(opts.path), opts);
		    } else {
		      return void 0;
		    }
		  },
		  loadCountry: function loadCountry(usage, country, data) {
		    var code = country.replace(/[^\w-]/g, "");
		    if (!usage[code]) {
		      var compressed;
		      try {
		        compressed = require("caniuse-lite/data/regions/" + code + ".js");
		      } catch (e) {
		        throw new BrowserslistError("Unknown region name `" + code + "`.");
		      }
		      var usageData = region(compressed);
		      normalizeUsageData(usageData, data);
		      usage[country] = {};
		      for (var i in usageData) {
		        for (var j in usageData[i]) {
		          usage[country][i + " " + j] = usageData[i][j];
		        }
		      }
		    }
		  },
		  loadFeature: function loadFeature(features, name) {
		    name = name.replace(/[^\w-]/g, "");
		    if (features[name]) return;
		    var compressed;
		    try {
		      compressed = require("caniuse-lite/data/features/" + name + ".js");
		    } catch (e) {
		      throw new BrowserslistError("Unknown feature name `" + name + "`.");
		    }
		    var stats = feature(compressed).stats;
		    features[name] = {};
		    for (var i in stats) {
		      features[name][i] = {};
		      for (var j in stats[i]) {
		        features[name][i][j] = stats[i][j];
		      }
		    }
		  },
		  parseConfig: function parseConfig(string) {
		    var result = { defaults: [] };
		    var sections = ["defaults"];
		    string.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(line) {
		      return line.trim();
		    }).filter(function(line) {
		      return line !== "";
		    }).forEach(function(line) {
		      if (IS_SECTION.test(line)) {
		        sections = line.match(IS_SECTION)[1].trim().split(" ");
		        sections.forEach(function(section) {
		          if (result[section]) {
		            throw new BrowserslistError(
		              "Duplicate section " + section + " in Browserslist config"
		            );
		          }
		          result[section] = [];
		        });
		      } else {
		        sections.forEach(function(section) {
		          result[section].push(line);
		        });
		      }
		    });
		    return result;
		  },
		  readConfig: function readConfig(file) {
		    if (!isFile(file)) {
		      throw new BrowserslistError("Can't read " + file + " config");
		    }
		    return module.exports.parseConfig(fs.readFileSync(file));
		  },
		  findConfigFile: function findConfigFile(from) {
		    return eachParent(
		      from,
		      function(dir) {
		        var config = path.join(dir, "browserslist");
		        var pkg = path.join(dir, "package.json");
		        var rc = path.join(dir, ".browserslistrc");
		        var pkgBrowserslist;
		        if (isFile(pkg)) {
		          try {
		            pkgBrowserslist = parsePackage(pkg);
		          } catch (e) {
		            if (e.name === "BrowserslistError") throw e;
		            console.warn(
		              "[Browserslist] Could not parse " + pkg + ". Ignoring it."
		            );
		          }
		        }
		        if (isFile(config) && pkgBrowserslist) {
		          throw new BrowserslistError(
		            dir + " contains both browserslist and package.json with browsers"
		          );
		        } else if (isFile(rc) && pkgBrowserslist) {
		          throw new BrowserslistError(
		            dir + " contains both .browserslistrc and package.json with browsers"
		          );
		        } else if (isFile(config) && isFile(rc)) {
		          throw new BrowserslistError(
		            dir + " contains both .browserslistrc and browserslist"
		          );
		        } else if (isFile(config)) {
		          return config;
		        } else if (isFile(rc)) {
		          return rc;
		        } else if (pkgBrowserslist) {
		          return pkg;
		        }
		      },
		      configPathCache
		    );
		  },
		  findConfig: function findConfig(from) {
		    var configFile = this.findConfigFile(from);
		    return configFile ? parsePackageOrReadConfig(configFile) : void 0;
		  },
		  clearCaches: function clearCaches() {
		    dataTimeChecked = false;
		    statCache = {};
		    configPathCache = {};
		    parseConfigCache = {};
		    this.cache = {};
		  },
		  oldDataWarning: function oldDataWarning(agentsObj) {
		    if (dataTimeChecked) return;
		    dataTimeChecked = true;
		    if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return;
		    var latest = latestReleaseTime(agentsObj);
		    var monthsPassed = getMonthsPassed(latest);
		    if (latest !== 0 && monthsPassed >= 6) {
		      var months = monthsPassed + " " + (monthsPassed > 1 ? "months" : "month");
		      console.warn(
		        "Browserslist: browsers data (caniuse-lite) is " + months + " old. Please run:\n  npx update-browserslist-db@latest\n  Why you should do it regularly: https://github.com/browserslist/update-db#readme"
		      );
		    }
		  },
		  currentNode: function currentNode() {
		    return "node " + process.versions.node;
		  },
		  env: process.env
		}; 
	} (node$1));
	return node$1.exports;
}

var parse$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse$1;
	hasRequiredParse$1 = 1;
	var AND_REGEXP = /^\s+and\s+(.*)/i;
	var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
	function flatten(array) {
	  if (!Array.isArray(array)) return [array];
	  return array.reduce(function(a, b) {
	    return a.concat(flatten(b));
	  }, []);
	}
	function find(string, predicate) {
	  for (var max = string.length, n = 1; n <= max; n++) {
	    var parsed = string.substr(-n, n);
	    if (predicate(parsed, n, max)) {
	      return string.slice(0, -n);
	    }
	  }
	  return "";
	}
	function matchQuery(all, query) {
	  var node = { query };
	  if (query.indexOf("not ") === 0) {
	    node.not = true;
	    query = query.slice(4);
	  }
	  for (var name in all) {
	    var type = all[name];
	    var match = query.match(type.regexp);
	    if (match) {
	      node.type = name;
	      for (var i = 0; i < type.matches.length; i++) {
	        node[type.matches[i]] = match[i + 1];
	      }
	      return node;
	    }
	  }
	  node.type = "unknown";
	  return node;
	}
	function matchBlock(all, string, qs) {
	  var node;
	  return find(string, function(parsed, n, max) {
	    if (AND_REGEXP.test(parsed)) {
	      node = matchQuery(all, parsed.match(AND_REGEXP)[1]);
	      node.compose = "and";
	      qs.unshift(node);
	      return true;
	    } else if (OR_REGEXP.test(parsed)) {
	      node = matchQuery(all, parsed.match(OR_REGEXP)[1]);
	      node.compose = "or";
	      qs.unshift(node);
	      return true;
	    } else if (n === max) {
	      node = matchQuery(all, parsed.trim());
	      node.compose = "or";
	      qs.unshift(node);
	      return true;
	    }
	    return false;
	  });
	}
	parse$1 = function parse(all, queries) {
	  if (!Array.isArray(queries)) queries = [queries];
	  return flatten(
	    queries.map(function(block) {
	      var qs = [];
	      do {
	        block = matchBlock(all, block, qs);
	      } while (block);
	      return qs;
	    })
	  );
	};
	return parse$1;
}

var browserslist_1;
var hasRequiredBrowserslist;

function requireBrowserslist () {
	if (hasRequiredBrowserslist) return browserslist_1;
	hasRequiredBrowserslist = 1;
	var jsReleases = require$$0$8;
	var agents = requireAgents().agents;
	var e2c = requireVersions();
	var jsEOL = require$$3;
	var path = require$$0$9;
	var BrowserslistError = requireError();
	var env = requireNode();
	var parseWithoutCache = requireParse$1();
	var YEAR = 365.259641 * 24 * 60 * 60 * 1e3;
	var ANDROID_EVERGREEN_FIRST = "37";
	var OP_MOB_BLINK_FIRST = 14;
	function isVersionsMatch(versionA, versionB) {
	  return (versionA + ".").indexOf(versionB + ".") === 0;
	}
	function isEolReleased(name) {
	  var version = name.slice(1);
	  return browserslist.nodeVersions.some(function(i) {
	    return isVersionsMatch(i, version);
	  });
	}
	function normalize(versions) {
	  return versions.filter(function(version) {
	    return typeof version === "string";
	  });
	}
	function normalizeElectron(version) {
	  var versionToUse = version;
	  if (version.split(".").length === 3) {
	    versionToUse = version.split(".").slice(0, -1).join(".");
	  }
	  return versionToUse;
	}
	function nameMapper(name) {
	  return function mapName(version) {
	    return name + " " + version;
	  };
	}
	function getMajor(version) {
	  return parseInt(version.split(".")[0]);
	}
	function getMajorVersions(released, number) {
	  if (released.length === 0) return [];
	  var majorVersions = uniq(released.map(getMajor));
	  var minimum = majorVersions[majorVersions.length - number];
	  if (!minimum) {
	    return released;
	  }
	  var selected = [];
	  for (var i = released.length - 1; i >= 0; i--) {
	    if (minimum > getMajor(released[i])) break;
	    selected.unshift(released[i]);
	  }
	  return selected;
	}
	function uniq(array) {
	  var filtered = [];
	  for (var i = 0; i < array.length; i++) {
	    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
	  }
	  return filtered;
	}
	function fillUsage(result, name, data) {
	  for (var i in data) {
	    result[name + " " + i] = data[i];
	  }
	}
	function generateFilter(sign, version) {
	  version = parseFloat(version);
	  if (sign === ">") {
	    return function(v) {
	      return parseLatestFloat(v) > version;
	    };
	  } else if (sign === ">=") {
	    return function(v) {
	      return parseLatestFloat(v) >= version;
	    };
	  } else if (sign === "<") {
	    return function(v) {
	      return parseFloat(v) < version;
	    };
	  } else {
	    return function(v) {
	      return parseFloat(v) <= version;
	    };
	  }
	  function parseLatestFloat(v) {
	    return parseFloat(v.split("-")[1] || v);
	  }
	}
	function generateSemverFilter(sign, version) {
	  version = version.split(".").map(parseSimpleInt);
	  version[1] = version[1] || 0;
	  version[2] = version[2] || 0;
	  if (sign === ">") {
	    return function(v) {
	      v = v.split(".").map(parseSimpleInt);
	      return compareSemver(v, version) > 0;
	    };
	  } else if (sign === ">=") {
	    return function(v) {
	      v = v.split(".").map(parseSimpleInt);
	      return compareSemver(v, version) >= 0;
	    };
	  } else if (sign === "<") {
	    return function(v) {
	      v = v.split(".").map(parseSimpleInt);
	      return compareSemver(version, v) > 0;
	    };
	  } else {
	    return function(v) {
	      v = v.split(".").map(parseSimpleInt);
	      return compareSemver(version, v) >= 0;
	    };
	  }
	}
	function parseSimpleInt(x) {
	  return parseInt(x);
	}
	function compare(a, b) {
	  if (a < b) return -1;
	  if (a > b) return 1;
	  return 0;
	}
	function compareSemver(a, b) {
	  return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || "0"), parseInt(b[1] || "0")) || compare(parseInt(a[2] || "0"), parseInt(b[2] || "0"));
	}
	function semverFilterLoose(operator, range) {
	  range = range.split(".").map(parseSimpleInt);
	  if (typeof range[1] === "undefined") {
	    range[1] = "x";
	  }
	  switch (operator) {
	    case "<=":
	      return function(version) {
	        version = version.split(".").map(parseSimpleInt);
	        return compareSemverLoose(version, range) <= 0;
	      };
	    case ">=":
	    default:
	      return function(version) {
	        version = version.split(".").map(parseSimpleInt);
	        return compareSemverLoose(version, range) >= 0;
	      };
	  }
	}
	function compareSemverLoose(version, range) {
	  if (version[0] !== range[0]) {
	    return version[0] < range[0] ? -1 : 1;
	  }
	  if (range[1] === "x") {
	    return 0;
	  }
	  if (version[1] !== range[1]) {
	    return version[1] < range[1] ? -1 : 1;
	  }
	  return 0;
	}
	function resolveVersion(data, version) {
	  if (data.versions.indexOf(version) !== -1) {
	    return version;
	  } else if (browserslist.versionAliases[data.name][version]) {
	    return browserslist.versionAliases[data.name][version];
	  } else {
	    return false;
	  }
	}
	function normalizeVersion(data, version) {
	  var resolved = resolveVersion(data, version);
	  if (resolved) {
	    return resolved;
	  } else if (data.versions.length === 1) {
	    return data.versions[0];
	  } else {
	    return false;
	  }
	}
	function filterByYear(since, context) {
	  since = since / 1e3;
	  return Object.keys(agents).reduce(function(selected, name) {
	    var data = byName(name, context);
	    if (!data) return selected;
	    var versions = Object.keys(data.releaseDate).filter(function(v) {
	      var date = data.releaseDate[v];
	      return date !== null && date >= since;
	    });
	    return selected.concat(versions.map(nameMapper(data.name)));
	  }, []);
	}
	function cloneData(data) {
	  return {
	    name: data.name,
	    versions: data.versions,
	    released: data.released,
	    releaseDate: data.releaseDate
	  };
	}
	function byName(name, context) {
	  name = name.toLowerCase();
	  name = browserslist.aliases[name] || name;
	  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
	    var desktop = browserslist.data[browserslist.desktopNames[name]];
	    if (name === "android") {
	      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
	    } else {
	      var cloned = cloneData(desktop);
	      cloned.name = name;
	      return cloned;
	    }
	  }
	  return browserslist.data[name];
	}
	function normalizeAndroidVersions(androidVersions, chromeVersions) {
	  var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
	  return androidVersions.filter(function(version) {
	    return /^(?:[2-4]\.|[34]$)/.test(version);
	  }).concat(chromeVersions.slice(iFirstEvergreen));
	}
	function copyObject(obj) {
	  var copy = {};
	  for (var key in obj) {
	    copy[key] = obj[key];
	  }
	  return copy;
	}
	function normalizeAndroidData(android, chrome) {
	  android.released = normalizeAndroidVersions(android.released, chrome.released);
	  android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
	  android.releaseDate = copyObject(android.releaseDate);
	  android.released.forEach(function(v) {
	    if (android.releaseDate[v] === void 0) {
	      android.releaseDate[v] = chrome.releaseDate[v];
	    }
	  });
	  return android;
	}
	function checkName(name, context) {
	  var data = byName(name, context);
	  if (!data) throw new BrowserslistError("Unknown browser " + name);
	  return data;
	}
	function unknownQuery(query) {
	  return new BrowserslistError(
	    "Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query."
	  );
	}
	function filterJumps(list, name, nVersions, context) {
	  var jump = 1;
	  switch (name) {
	    case "android":
	      if (context.mobileToDesktop) return list;
	      var released = browserslist.data.chrome.released;
	      jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
	      break;
	    case "op_mob":
	      var latest = browserslist.data.op_mob.released.slice(-1)[0];
	      jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
	      break;
	    default:
	      return list;
	  }
	  if (nVersions <= jump) {
	    return list.slice(-1);
	  }
	  return list.slice(jump - 1 - nVersions);
	}
	function isSupported(flags, withPartial) {
	  return typeof flags === "string" && (flags.indexOf("y") >= 0 || withPartial && flags.indexOf("a") >= 0);
	}
	function resolve(queries, context) {
	  return parseQueries(queries).reduce(function(result, node, index) {
	    if (node.not && index === 0) {
	      throw new BrowserslistError(
	        "Write any browsers query (for instance, `defaults`) before `" + node.query + "`"
	      );
	    }
	    var type = QUERIES[node.type];
	    var array = type.select.call(browserslist, context, node).map(function(j) {
	      var parts = j.split(" ");
	      if (parts[1] === "0") {
	        return parts[0] + " " + byName(parts[0], context).versions[0];
	      } else {
	        return j;
	      }
	    });
	    if (node.compose === "and") {
	      if (node.not) {
	        return result.filter(function(j) {
	          return array.indexOf(j) === -1;
	        });
	      } else {
	        return result.filter(function(j) {
	          return array.indexOf(j) !== -1;
	        });
	      }
	    } else {
	      if (node.not) {
	        var filter = {};
	        array.forEach(function(j) {
	          filter[j] = true;
	        });
	        return result.filter(function(j) {
	          return !filter[j];
	        });
	      }
	      return result.concat(array);
	    }
	  }, []);
	}
	function prepareOpts(opts) {
	  if (typeof opts === "undefined") opts = {};
	  if (typeof opts.path === "undefined") {
	    opts.path = path.resolve ? path.resolve(".") : ".";
	  }
	  return opts;
	}
	function prepareQueries(queries, opts) {
	  if (typeof queries === "undefined" || queries === null) {
	    var config = browserslist.loadConfig(opts);
	    if (config) {
	      queries = config;
	    } else {
	      queries = browserslist.defaults;
	    }
	  }
	  return queries;
	}
	function checkQueries(queries) {
	  if (!(typeof queries === "string" || Array.isArray(queries))) {
	    throw new BrowserslistError(
	      "Browser queries must be an array or string. Got " + typeof queries + "."
	    );
	  }
	}
	var cache = {};
	var parseCache = {};
	function browserslist(queries, opts) {
	  opts = prepareOpts(opts);
	  queries = prepareQueries(queries, opts);
	  checkQueries(queries);
	  var needsPath = parseQueries(queries).some(function(node) {
	    return QUERIES[node.type].needsPath;
	  });
	  var context = {
	    ignoreUnknownVersions: opts.ignoreUnknownVersions,
	    dangerousExtend: opts.dangerousExtend,
	    mobileToDesktop: opts.mobileToDesktop,
	    env: opts.env
	  };
	  if (needsPath) {
	    context.path = opts.path;
	  }
	  env.oldDataWarning(browserslist.data);
	  var stats = env.getStat(opts, browserslist.data);
	  if (stats) {
	    context.customUsage = {};
	    for (var browser in stats) {
	      fillUsage(context.customUsage, browser, stats[browser]);
	    }
	  }
	  var cacheKey = JSON.stringify([queries, context]);
	  if (cache[cacheKey]) return cache[cacheKey];
	  var result = uniq(resolve(queries, context)).sort(function(name1, name2) {
	    name1 = name1.split(" ");
	    name2 = name2.split(" ");
	    if (name1[0] === name2[0]) {
	      var version1 = name1[1].split("-")[0];
	      var version2 = name2[1].split("-")[0];
	      return compareSemver(version2.split("."), version1.split("."));
	    } else {
	      return compare(name1[0], name2[0]);
	    }
	  });
	  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
	    cache[cacheKey] = result;
	  }
	  return result;
	}
	function parseQueries(queries) {
	  var cacheKey = JSON.stringify(queries);
	  if (cacheKey in parseCache) return parseCache[cacheKey];
	  var result = parseWithoutCache(QUERIES, queries);
	  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
	    parseCache[cacheKey] = result;
	  }
	  return result;
	}
	browserslist.parse = function(queries, opts) {
	  opts = prepareOpts(opts);
	  queries = prepareQueries(queries, opts);
	  checkQueries(queries);
	  return parseQueries(queries);
	};
	browserslist.cache = {};
	browserslist.data = {};
	browserslist.usage = {
	  global: {},
	  custom: null
	};
	browserslist.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
	browserslist.aliases = {
	  fx: "firefox",
	  ff: "firefox",
	  ios: "ios_saf",
	  explorer: "ie",
	  blackberry: "bb",
	  explorermobile: "ie_mob",
	  operamini: "op_mini",
	  operamobile: "op_mob",
	  chromeandroid: "and_chr",
	  firefoxandroid: "and_ff",
	  ucandroid: "and_uc",
	  qqandroid: "and_qq"
	};
	browserslist.desktopNames = {
	  and_chr: "chrome",
	  and_ff: "firefox",
	  ie_mob: "ie",
	  android: "chrome"
	  // has extra processing logic
	};
	browserslist.versionAliases = {};
	browserslist.clearCaches = env.clearCaches;
	browserslist.parseConfig = env.parseConfig;
	browserslist.readConfig = env.readConfig;
	browserslist.findConfigFile = env.findConfigFile;
	browserslist.findConfig = env.findConfig;
	browserslist.loadConfig = env.loadConfig;
	browserslist.coverage = function(browsers, stats) {
	  var data;
	  if (typeof stats === "undefined") {
	    data = browserslist.usage.global;
	  } else if (stats === "my stats") {
	    var opts = {};
	    opts.path = path.resolve ? path.resolve(".") : ".";
	    var customStats = env.getStat(opts);
	    if (!customStats) {
	      throw new BrowserslistError("Custom usage statistics was not provided");
	    }
	    data = {};
	    for (var browser in customStats) {
	      fillUsage(data, browser, customStats[browser]);
	    }
	  } else if (typeof stats === "string") {
	    if (stats.length > 2) {
	      stats = stats.toLowerCase();
	    } else {
	      stats = stats.toUpperCase();
	    }
	    env.loadCountry(browserslist.usage, stats, browserslist.data);
	    data = browserslist.usage[stats];
	  } else {
	    if ("dataByBrowser" in stats) {
	      stats = stats.dataByBrowser;
	    }
	    data = {};
	    for (var name in stats) {
	      for (var version in stats[name]) {
	        data[name + " " + version] = stats[name][version];
	      }
	    }
	  }
	  return browsers.reduce(function(all, i) {
	    var usage = data[i];
	    if (usage === void 0) {
	      usage = data[i.replace(/ \S+$/, " 0")];
	    }
	    return all + (usage || 0);
	  }, 0);
	};
	function nodeQuery(context, node) {
	  var matched = browserslist.nodeVersions.filter(function(i) {
	    return isVersionsMatch(i, node.version);
	  });
	  if (matched.length === 0) {
	    if (context.ignoreUnknownVersions) {
	      return [];
	    } else {
	      throw new BrowserslistError(
	        "Unknown version " + node.version + " of Node.js"
	      );
	    }
	  }
	  return ["node " + matched[matched.length - 1]];
	}
	function sinceQuery(context, node) {
	  var year = parseInt(node.year);
	  var month = parseInt(node.month || "01") - 1;
	  var day = parseInt(node.day || "01");
	  return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
	}
	function coverQuery(context, node) {
	  var coverage = parseFloat(node.coverage);
	  var usage = browserslist.usage.global;
	  if (node.place) {
	    if (node.place.match(/^my\s+stats$/i)) {
	      if (!context.customUsage) {
	        throw new BrowserslistError("Custom usage statistics was not provided");
	      }
	      usage = context.customUsage;
	    } else {
	      var place;
	      if (node.place.length === 2) {
	        place = node.place.toUpperCase();
	      } else {
	        place = node.place.toLowerCase();
	      }
	      env.loadCountry(browserslist.usage, place, browserslist.data);
	      usage = browserslist.usage[place];
	    }
	  }
	  var versions = Object.keys(usage).sort(function(a, b) {
	    return usage[b] - usage[a];
	  });
	  var coveraged = 0;
	  var result = [];
	  var version;
	  for (var i = 0; i < versions.length; i++) {
	    version = versions[i];
	    if (usage[version] === 0) break;
	    coveraged += usage[version];
	    result.push(version);
	    if (coveraged >= coverage) break;
	  }
	  return result;
	}
	var QUERIES = {
	  last_major_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
	    select: function(context, node) {
	      return Object.keys(agents).reduce(function(selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected;
	        var list = getMajorVersions(data.released, node.versions);
	        list = list.map(nameMapper(data.name));
	        list = filterJumps(list, data.name, node.versions, context);
	        return selected.concat(list);
	      }, []);
	    }
	  },
	  last_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+versions?$/i,
	    select: function(context, node) {
	      return Object.keys(agents).reduce(function(selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected;
	        var list = data.released.slice(-node.versions);
	        list = list.map(nameMapper(data.name));
	        list = filterJumps(list, data.name, node.versions, context);
	        return selected.concat(list);
	      }, []);
	    }
	  },
	  last_electron_major_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
	    select: function(context, node) {
	      var validVersions = getMajorVersions(Object.keys(e2c), node.versions);
	      return validVersions.map(function(i) {
	        return "chrome " + e2c[i];
	      });
	    }
	  },
	  last_node_major_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
	    select: function(context, node) {
	      return getMajorVersions(browserslist.nodeVersions, node.versions).map(
	        function(version) {
	          return "node " + version;
	        }
	      );
	    }
	  },
	  last_browser_major_versions: {
	    matches: ["versions", "browser"],
	    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
	    select: function(context, node) {
	      var data = checkName(node.browser, context);
	      var validVersions = getMajorVersions(data.released, node.versions);
	      var list = validVersions.map(nameMapper(data.name));
	      list = filterJumps(list, data.name, node.versions, context);
	      return list;
	    }
	  },
	  last_electron_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
	    select: function(context, node) {
	      return Object.keys(e2c).slice(-node.versions).map(function(i) {
	        return "chrome " + e2c[i];
	      });
	    }
	  },
	  last_node_versions: {
	    matches: ["versions"],
	    regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
	    select: function(context, node) {
	      return browserslist.nodeVersions.slice(-node.versions).map(function(version) {
	        return "node " + version;
	      });
	    }
	  },
	  last_browser_versions: {
	    matches: ["versions", "browser"],
	    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
	    select: function(context, node) {
	      var data = checkName(node.browser, context);
	      var list = data.released.slice(-node.versions).map(nameMapper(data.name));
	      list = filterJumps(list, data.name, node.versions, context);
	      return list;
	    }
	  },
	  unreleased_versions: {
	    matches: [],
	    regexp: /^unreleased\s+versions$/i,
	    select: function(context) {
	      return Object.keys(agents).reduce(function(selected, name) {
	        var data = byName(name, context);
	        if (!data) return selected;
	        var list = data.versions.filter(function(v) {
	          return data.released.indexOf(v) === -1;
	        });
	        list = list.map(nameMapper(data.name));
	        return selected.concat(list);
	      }, []);
	    }
	  },
	  unreleased_electron_versions: {
	    matches: [],
	    regexp: /^unreleased\s+electron\s+versions?$/i,
	    select: function() {
	      return [];
	    }
	  },
	  unreleased_browser_versions: {
	    matches: ["browser"],
	    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
	    select: function(context, node) {
	      var data = checkName(node.browser, context);
	      return data.versions.filter(function(v) {
	        return data.released.indexOf(v) === -1;
	      }).map(nameMapper(data.name));
	    }
	  },
	  last_years: {
	    matches: ["years"],
	    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
	    select: function(context, node) {
	      return filterByYear(Date.now() - YEAR * node.years, context);
	    }
	  },
	  since_y: {
	    matches: ["year"],
	    regexp: /^since (\d+)$/i,
	    select: sinceQuery
	  },
	  since_y_m: {
	    matches: ["year", "month"],
	    regexp: /^since (\d+)-(\d+)$/i,
	    select: sinceQuery
	  },
	  since_y_m_d: {
	    matches: ["year", "month", "day"],
	    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
	    select: sinceQuery
	  },
	  popularity: {
	    matches: ["sign", "popularity"],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
	    select: function(context, node) {
	      var popularity = parseFloat(node.popularity);
	      var usage = browserslist.usage.global;
	      return Object.keys(usage).reduce(function(result, version) {
	        if (node.sign === ">") {
	          if (usage[version] > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<") {
	          if (usage[version] < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<=") {
	          if (usage[version] <= popularity) {
	            result.push(version);
	          }
	        } else if (usage[version] >= popularity) {
	          result.push(version);
	        }
	        return result;
	      }, []);
	    }
	  },
	  popularity_in_my_stats: {
	    matches: ["sign", "popularity"],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
	    select: function(context, node) {
	      var popularity = parseFloat(node.popularity);
	      if (!context.customUsage) {
	        throw new BrowserslistError("Custom usage statistics was not provided");
	      }
	      var usage = context.customUsage;
	      return Object.keys(usage).reduce(function(result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result;
	        }
	        if (node.sign === ">") {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<") {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<=") {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result;
	      }, []);
	    }
	  },
	  popularity_in_config_stats: {
	    matches: ["sign", "popularity", "config"],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
	    select: function(context, node) {
	      var popularity = parseFloat(node.popularity);
	      var stats = env.loadStat(context, node.config, browserslist.data);
	      if (stats) {
	        context.customUsage = {};
	        for (var browser in stats) {
	          fillUsage(context.customUsage, browser, stats[browser]);
	        }
	      }
	      if (!context.customUsage) {
	        throw new BrowserslistError("Custom usage statistics was not provided");
	      }
	      var usage = context.customUsage;
	      return Object.keys(usage).reduce(function(result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result;
	        }
	        if (node.sign === ">") {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<") {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<=") {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result;
	      }, []);
	    }
	  },
	  popularity_in_place: {
	    matches: ["sign", "popularity", "place"],
	    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
	    select: function(context, node) {
	      var popularity = parseFloat(node.popularity);
	      var place = node.place;
	      if (place.length === 2) {
	        place = place.toUpperCase();
	      } else {
	        place = place.toLowerCase();
	      }
	      env.loadCountry(browserslist.usage, place, browserslist.data);
	      var usage = browserslist.usage[place];
	      return Object.keys(usage).reduce(function(result, version) {
	        var percentage = usage[version];
	        if (percentage == null) {
	          return result;
	        }
	        if (node.sign === ">") {
	          if (percentage > popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<") {
	          if (percentage < popularity) {
	            result.push(version);
	          }
	        } else if (node.sign === "<=") {
	          if (percentage <= popularity) {
	            result.push(version);
	          }
	        } else if (percentage >= popularity) {
	          result.push(version);
	        }
	        return result;
	      }, []);
	    }
	  },
	  cover: {
	    matches: ["coverage"],
	    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
	    select: coverQuery
	  },
	  cover_in: {
	    matches: ["coverage", "place"],
	    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
	    select: coverQuery
	  },
	  supports: {
	    matches: ["supportType", "feature"],
	    regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
	    select: function(context, node) {
	      env.loadFeature(browserslist.cache, node.feature);
	      var withPartial = node.supportType !== "fully";
	      var features = browserslist.cache[node.feature];
	      var result = [];
	      for (var name in features) {
	        var data = byName(name, context);
	        var iMax = data.released.length - 1;
	        while (iMax >= 0) {
	          if (data.released[iMax] in features[name]) break;
	          iMax--;
	        }
	        var checkDesktop = context.mobileToDesktop && name in browserslist.desktopNames && isSupported(features[name][data.released[iMax]], withPartial);
	        data.versions.forEach(function(version) {
	          var flags = features[name][version];
	          if (flags === void 0 && checkDesktop) {
	            flags = features[browserslist.desktopNames[name]][version];
	          }
	          if (isSupported(flags, withPartial)) {
	            result.push(name + " " + version);
	          }
	        });
	      }
	      return result;
	    }
	  },
	  electron_range: {
	    matches: ["from", "to"],
	    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function(context, node) {
	      var fromToUse = normalizeElectron(node.from);
	      var toToUse = normalizeElectron(node.to);
	      var from = parseFloat(node.from);
	      var to = parseFloat(node.to);
	      if (!e2c[fromToUse]) {
	        throw new BrowserslistError("Unknown version " + from + " of electron");
	      }
	      if (!e2c[toToUse]) {
	        throw new BrowserslistError("Unknown version " + to + " of electron");
	      }
	      return Object.keys(e2c).filter(function(i) {
	        var parsed = parseFloat(i);
	        return parsed >= from && parsed <= to;
	      }).map(function(i) {
	        return "chrome " + e2c[i];
	      });
	    }
	  },
	  node_range: {
	    matches: ["from", "to"],
	    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function(context, node) {
	      return browserslist.nodeVersions.filter(semverFilterLoose(">=", node.from)).filter(semverFilterLoose("<=", node.to)).map(function(v) {
	        return "node " + v;
	      });
	    }
	  },
	  browser_range: {
	    matches: ["browser", "from", "to"],
	    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	    select: function(context, node) {
	      var data = checkName(node.browser, context);
	      var from = parseFloat(normalizeVersion(data, node.from) || node.from);
	      var to = parseFloat(normalizeVersion(data, node.to) || node.to);
	      function filter(v) {
	        var parsed = parseFloat(v);
	        return parsed >= from && parsed <= to;
	      }
	      return data.released.filter(filter).map(nameMapper(data.name));
	    }
	  },
	  electron_ray: {
	    matches: ["sign", "version"],
	    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
	    select: function(context, node) {
	      var versionToUse = normalizeElectron(node.version);
	      return Object.keys(e2c).filter(generateFilter(node.sign, versionToUse)).map(function(i) {
	        return "chrome " + e2c[i];
	      });
	    }
	  },
	  node_ray: {
	    matches: ["sign", "version"],
	    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
	    select: function(context, node) {
	      return browserslist.nodeVersions.filter(generateSemverFilter(node.sign, node.version)).map(function(v) {
	        return "node " + v;
	      });
	    }
	  },
	  browser_ray: {
	    matches: ["browser", "sign", "version"],
	    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
	    select: function(context, node) {
	      var version = node.version;
	      var data = checkName(node.browser, context);
	      var alias = browserslist.versionAliases[data.name][version];
	      if (alias) version = alias;
	      return data.released.filter(generateFilter(node.sign, version)).map(function(v) {
	        return data.name + " " + v;
	      });
	    }
	  },
	  firefox_esr: {
	    matches: [],
	    regexp: /^(firefox|ff|fx)\s+esr$/i,
	    select: function() {
	      return ["firefox 128"];
	    }
	  },
	  opera_mini_all: {
	    matches: [],
	    regexp: /(operamini|op_mini)\s+all/i,
	    select: function() {
	      return ["op_mini all"];
	    }
	  },
	  electron_version: {
	    matches: ["version"],
	    regexp: /^electron\s+([\d.]+)$/i,
	    select: function(context, node) {
	      var versionToUse = normalizeElectron(node.version);
	      var chrome = e2c[versionToUse];
	      if (!chrome) {
	        throw new BrowserslistError(
	          "Unknown version " + node.version + " of electron"
	        );
	      }
	      return ["chrome " + chrome];
	    }
	  },
	  node_major_version: {
	    matches: ["version"],
	    regexp: /^node\s+(\d+)$/i,
	    select: nodeQuery
	  },
	  node_minor_version: {
	    matches: ["version"],
	    regexp: /^node\s+(\d+\.\d+)$/i,
	    select: nodeQuery
	  },
	  node_patch_version: {
	    matches: ["version"],
	    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
	    select: nodeQuery
	  },
	  current_node: {
	    matches: [],
	    regexp: /^current\s+node$/i,
	    select: function(context) {
	      return [env.currentNode(resolve, context)];
	    }
	  },
	  maintained_node: {
	    matches: [],
	    regexp: /^maintained\s+node\s+versions$/i,
	    select: function(context) {
	      var now = Date.now();
	      var queries = Object.keys(jsEOL).filter(function(key) {
	        return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
	      }).map(function(key) {
	        return "node " + key.slice(1);
	      });
	      return resolve(queries, context);
	    }
	  },
	  phantomjs_1_9: {
	    matches: [],
	    regexp: /^phantomjs\s+1.9$/i,
	    select: function() {
	      return ["safari 5"];
	    }
	  },
	  phantomjs_2_1: {
	    matches: [],
	    regexp: /^phantomjs\s+2.1$/i,
	    select: function() {
	      return ["safari 6"];
	    }
	  },
	  browser_version: {
	    matches: ["browser", "version"],
	    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
	    select: function(context, node) {
	      var version = node.version;
	      if (/^tp$/i.test(version)) version = "TP";
	      var data = checkName(node.browser, context);
	      var alias = normalizeVersion(data, version);
	      if (alias) {
	        version = alias;
	      } else {
	        if (version.indexOf(".") === -1) {
	          alias = version + ".0";
	        } else {
	          alias = version.replace(/\.0$/, "");
	        }
	        alias = normalizeVersion(data, alias);
	        if (alias) {
	          version = alias;
	        } else if (context.ignoreUnknownVersions) {
	          return [];
	        } else {
	          throw new BrowserslistError(
	            "Unknown version " + version + " of " + node.browser
	          );
	        }
	      }
	      return [data.name + " " + version];
	    }
	  },
	  browserslist_config: {
	    matches: [],
	    regexp: /^browserslist config$/i,
	    needsPath: true,
	    select: function(context) {
	      return browserslist(void 0, context);
	    }
	  },
	  extends: {
	    matches: ["config"],
	    regexp: /^extends (.+)$/i,
	    needsPath: true,
	    select: function(context, node) {
	      return resolve(env.loadQueries(context, node.config), context);
	    }
	  },
	  defaults: {
	    matches: [],
	    regexp: /^defaults$/i,
	    select: function(context) {
	      return resolve(browserslist.defaults, context);
	    }
	  },
	  dead: {
	    matches: [],
	    regexp: /^dead$/i,
	    select: function(context) {
	      var dead = [
	        "Baidu >= 0",
	        "ie <= 11",
	        "ie_mob <= 11",
	        "bb <= 10",
	        "op_mob <= 12.1",
	        "samsung 4"
	      ];
	      return resolve(dead, context);
	    }
	  },
	  unknown: {
	    matches: [],
	    regexp: /^(\w+)$/i,
	    select: function(context, node) {
	      if (byName(node.query, context)) {
	        throw new BrowserslistError(
	          "Specify versions in Browserslist query for browser " + node.query
	        );
	      } else {
	        throw unknownQuery(node.query);
	      }
	    }
	  }
	};
	(function() {
	  for (var name in agents) {
	    var browser = agents[name];
	    browserslist.data[name] = {
	      name,
	      versions: normalize(agents[name].versions),
	      released: normalize(agents[name].versions.slice(0, -3)),
	      releaseDate: agents[name].release_date
	    };
	    fillUsage(browserslist.usage.global, name, browser.usage_global);
	    browserslist.versionAliases[name] = {};
	    for (var i = 0; i < browser.versions.length; i++) {
	      var full = browser.versions[i];
	      if (!full) continue;
	      if (full.indexOf("-") !== -1) {
	        var interval = full.split("-");
	        for (var j = 0; j < interval.length; j++) {
	          browserslist.versionAliases[name][interval[j]] = full;
	        }
	      }
	    }
	  }
	  browserslist.nodeVersions = jsReleases.map(function(release) {
	    return release.version;
	  });
	})();
	browserslist_1 = browserslist;
	return browserslist_1;
}

var lib$1f = {};

var validator = {};

var findSuggestion = {};

var hasRequiredFindSuggestion;

function requireFindSuggestion () {
	if (hasRequiredFindSuggestion) return findSuggestion;
	hasRequiredFindSuggestion = 1;
	Object.defineProperty(findSuggestion, "__esModule", {
	  value: true
	});
	findSuggestion.findSuggestion = findSuggestion$1;
	const {
	  min
	} = Math;
	function levenshtein(a, b) {
	  let t = [], u = [], i, j;
	  const m = a.length, n = b.length;
	  if (!m) {
	    return n;
	  }
	  if (!n) {
	    return m;
	  }
	  for (j = 0; j <= n; j++) {
	    t[j] = j;
	  }
	  for (i = 1; i <= m; i++) {
	    for (u = [i], j = 1; j <= n; j++) {
	      u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
	    }
	    t = u;
	  }
	  return u[n];
	}
	function findSuggestion$1(str, arr) {
	  const distances = arr.map((el) => levenshtein(el, str));
	  return arr[distances.indexOf(min(...distances))];
	}
	return findSuggestion;
}

var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;
	Object.defineProperty(validator, "__esModule", {
	  value: true
	});
	validator.OptionValidator = void 0;
	var _findSuggestion = requireFindSuggestion();
	class OptionValidator {
	  constructor(descriptor) {
	    this.descriptor = descriptor;
	  }
	  validateTopLevelOptions(options, TopLevelOptionShape) {
	    const validOptionNames = Object.keys(TopLevelOptionShape);
	    for (const option of Object.keys(options)) {
	      if (!validOptionNames.includes(option)) {
	        throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
	      }
	    }
	  }
	  validateBooleanOption(name, value, defaultValue) {
	    if (value === void 0) {
	      return defaultValue;
	    } else {
	      this.invariant(typeof value === "boolean", `'${name}' option must be a boolean.`);
	    }
	    return value;
	  }
	  validateStringOption(name, value, defaultValue) {
	    if (value === void 0) {
	      return defaultValue;
	    } else {
	      this.invariant(typeof value === "string", `'${name}' option must be a string.`);
	    }
	    return value;
	  }
	  invariant(condition, message) {
	    if (!condition) {
	      throw new Error(this.formatMessage(message));
	    }
	  }
	  formatMessage(message) {
	    return `${this.descriptor}: ${message}`;
	  }
	}
	validator.OptionValidator = OptionValidator;
	return validator;
}

var hasRequiredLib$1h;

function requireLib$1h () {
	if (hasRequiredLib$1h) return lib$1f;
	hasRequiredLib$1h = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "OptionValidator", {
		  enumerable: true,
		  get: function() {
		    return _validator.OptionValidator;
		  }
		});
		Object.defineProperty(exports, "findSuggestion", {
		  enumerable: true,
		  get: function() {
		    return _findSuggestion.findSuggestion;
		  }
		});
		var _validator = requireValidator();
		var _findSuggestion = requireFindSuggestion(); 
	} (lib$1f));
	return lib$1f;
}

var iterator;
var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator;
	hasRequiredIterator = 1;
	iterator = function(Yallist) {
	  Yallist.prototype[Symbol.iterator] = function* () {
	    for (let walker = this.head; walker; walker = walker.next) {
	      yield walker.value;
	    }
	  };
	};
	return iterator;
}

var yallist;
var hasRequiredYallist;

function requireYallist () {
	if (hasRequiredYallist) return yallist;
	hasRequiredYallist = 1;
	yallist = Yallist;
	Yallist.Node = Node;
	Yallist.create = Yallist;
	function Yallist(list) {
	  var self = this;
	  if (!(self instanceof Yallist)) {
	    self = new Yallist();
	  }
	  self.tail = null;
	  self.head = null;
	  self.length = 0;
	  if (list && typeof list.forEach === "function") {
	    list.forEach(function(item) {
	      self.push(item);
	    });
	  } else if (arguments.length > 0) {
	    for (var i = 0, l = arguments.length; i < l; i++) {
	      self.push(arguments[i]);
	    }
	  }
	  return self;
	}
	Yallist.prototype.removeNode = function(node) {
	  if (node.list !== this) {
	    throw new Error("removing node which does not belong to this list");
	  }
	  var next = node.next;
	  var prev = node.prev;
	  if (next) {
	    next.prev = prev;
	  }
	  if (prev) {
	    prev.next = next;
	  }
	  if (node === this.head) {
	    this.head = next;
	  }
	  if (node === this.tail) {
	    this.tail = prev;
	  }
	  node.list.length--;
	  node.next = null;
	  node.prev = null;
	  node.list = null;
	  return next;
	};
	Yallist.prototype.unshiftNode = function(node) {
	  if (node === this.head) {
	    return;
	  }
	  if (node.list) {
	    node.list.removeNode(node);
	  }
	  var head = this.head;
	  node.list = this;
	  node.next = head;
	  if (head) {
	    head.prev = node;
	  }
	  this.head = node;
	  if (!this.tail) {
	    this.tail = node;
	  }
	  this.length++;
	};
	Yallist.prototype.pushNode = function(node) {
	  if (node === this.tail) {
	    return;
	  }
	  if (node.list) {
	    node.list.removeNode(node);
	  }
	  var tail = this.tail;
	  node.list = this;
	  node.prev = tail;
	  if (tail) {
	    tail.next = node;
	  }
	  this.tail = node;
	  if (!this.head) {
	    this.head = node;
	  }
	  this.length++;
	};
	Yallist.prototype.push = function() {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    push(this, arguments[i]);
	  }
	  return this.length;
	};
	Yallist.prototype.unshift = function() {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    unshift(this, arguments[i]);
	  }
	  return this.length;
	};
	Yallist.prototype.pop = function() {
	  if (!this.tail) {
	    return void 0;
	  }
	  var res = this.tail.value;
	  this.tail = this.tail.prev;
	  if (this.tail) {
	    this.tail.next = null;
	  } else {
	    this.head = null;
	  }
	  this.length--;
	  return res;
	};
	Yallist.prototype.shift = function() {
	  if (!this.head) {
	    return void 0;
	  }
	  var res = this.head.value;
	  this.head = this.head.next;
	  if (this.head) {
	    this.head.prev = null;
	  } else {
	    this.tail = null;
	  }
	  this.length--;
	  return res;
	};
	Yallist.prototype.forEach = function(fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.head, i = 0; walker !== null; i++) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.next;
	  }
	};
	Yallist.prototype.forEachReverse = function(fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.prev;
	  }
	};
	Yallist.prototype.get = function(n) {
	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
	    walker = walker.next;
	  }
	  if (i === n && walker !== null) {
	    return walker.value;
	  }
	};
	Yallist.prototype.getReverse = function(n) {
	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
	    walker = walker.prev;
	  }
	  if (i === n && walker !== null) {
	    return walker.value;
	  }
	};
	Yallist.prototype.map = function(fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.head; walker !== null; ) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.next;
	  }
	  return res;
	};
	Yallist.prototype.mapReverse = function(fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.tail; walker !== null; ) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.prev;
	  }
	  return res;
	};
	Yallist.prototype.reduce = function(fn, initial) {
	  var acc;
	  var walker = this.head;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.head) {
	    walker = this.head.next;
	    acc = this.head.value;
	  } else {
	    throw new TypeError("Reduce of empty list with no initial value");
	  }
	  for (var i = 0; walker !== null; i++) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.next;
	  }
	  return acc;
	};
	Yallist.prototype.reduceReverse = function(fn, initial) {
	  var acc;
	  var walker = this.tail;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.tail) {
	    walker = this.tail.prev;
	    acc = this.tail.value;
	  } else {
	    throw new TypeError("Reduce of empty list with no initial value");
	  }
	  for (var i = this.length - 1; walker !== null; i--) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.prev;
	  }
	  return acc;
	};
	Yallist.prototype.toArray = function() {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.head; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.next;
	  }
	  return arr;
	};
	Yallist.prototype.toArrayReverse = function() {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.tail; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.prev;
	  }
	  return arr;
	};
	Yallist.prototype.slice = function(from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret;
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
	    walker = walker.next;
	  }
	  for (; walker !== null && i < to; i++, walker = walker.next) {
	    ret.push(walker.value);
	  }
	  return ret;
	};
	Yallist.prototype.sliceReverse = function(from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret;
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
	    walker = walker.prev;
	  }
	  for (; walker !== null && i > from; i--, walker = walker.prev) {
	    ret.push(walker.value);
	  }
	  return ret;
	};
	Yallist.prototype.splice = function(start, deleteCount) {
	  if (start > this.length) {
	    start = this.length - 1;
	  }
	  if (start < 0) {
	    start = this.length + start;
	  }
	  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
	    walker = walker.next;
	  }
	  var ret = [];
	  for (var i = 0; walker && i < deleteCount; i++) {
	    ret.push(walker.value);
	    walker = this.removeNode(walker);
	  }
	  if (walker === null) {
	    walker = this.tail;
	  }
	  if (walker !== this.head && walker !== this.tail) {
	    walker = walker.prev;
	  }
	  for (var i = 2; i < arguments.length; i++) {
	    walker = insert(this, walker, arguments[i]);
	  }
	  return ret;
	};
	Yallist.prototype.reverse = function() {
	  var head = this.head;
	  var tail = this.tail;
	  for (var walker = head; walker !== null; walker = walker.prev) {
	    var p = walker.prev;
	    walker.prev = walker.next;
	    walker.next = p;
	  }
	  this.head = tail;
	  this.tail = head;
	  return this;
	};
	function insert(self, node, value) {
	  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
	  if (inserted.next === null) {
	    self.tail = inserted;
	  }
	  if (inserted.prev === null) {
	    self.head = inserted;
	  }
	  self.length++;
	  return inserted;
	}
	function push(self, item) {
	  self.tail = new Node(item, self.tail, null, self);
	  if (!self.head) {
	    self.head = self.tail;
	  }
	  self.length++;
	}
	function unshift(self, item) {
	  self.head = new Node(item, null, self.head, self);
	  if (!self.tail) {
	    self.tail = self.head;
	  }
	  self.length++;
	}
	function Node(value, prev, next, list) {
	  if (!(this instanceof Node)) {
	    return new Node(value, prev, next, list);
	  }
	  this.list = list;
	  this.value = value;
	  if (prev) {
	    prev.next = this;
	    this.prev = prev;
	  } else {
	    this.prev = null;
	  }
	  if (next) {
	    next.prev = this;
	    this.next = next;
	  } else {
	    this.next = null;
	  }
	}
	try {
	  requireIterator()(Yallist);
	} catch (er) {
	}
	return yallist;
}

var lruCache;
var hasRequiredLruCache;

function requireLruCache () {
	if (hasRequiredLruCache) return lruCache;
	hasRequiredLruCache = 1;
	const Yallist = requireYallist();
	const MAX = Symbol("max");
	const LENGTH = Symbol("length");
	const LENGTH_CALCULATOR = Symbol("lengthCalculator");
	const ALLOW_STALE = Symbol("allowStale");
	const MAX_AGE = Symbol("maxAge");
	const DISPOSE = Symbol("dispose");
	const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
	const LRU_LIST = Symbol("lruList");
	const CACHE = Symbol("cache");
	const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
	const naiveLength = () => 1;
	class LRUCache {
	  constructor(options) {
	    if (typeof options === "number")
	      options = { max: options };
	    if (!options)
	      options = {};
	    if (options.max && (typeof options.max !== "number" || options.max < 0))
	      throw new TypeError("max must be a non-negative number");
	    this[MAX] = options.max || Infinity;
	    const lc = options.length || naiveLength;
	    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
	    this[ALLOW_STALE] = options.stale || false;
	    if (options.maxAge && typeof options.maxAge !== "number")
	      throw new TypeError("maxAge must be a number");
	    this[MAX_AGE] = options.maxAge || 0;
	    this[DISPOSE] = options.dispose;
	    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
	    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
	    this.reset();
	  }
	  // resize the cache when the max changes.
	  set max(mL) {
	    if (typeof mL !== "number" || mL < 0)
	      throw new TypeError("max must be a non-negative number");
	    this[MAX] = mL || Infinity;
	    trim(this);
	  }
	  get max() {
	    return this[MAX];
	  }
	  set allowStale(allowStale) {
	    this[ALLOW_STALE] = !!allowStale;
	  }
	  get allowStale() {
	    return this[ALLOW_STALE];
	  }
	  set maxAge(mA) {
	    if (typeof mA !== "number")
	      throw new TypeError("maxAge must be a non-negative number");
	    this[MAX_AGE] = mA;
	    trim(this);
	  }
	  get maxAge() {
	    return this[MAX_AGE];
	  }
	  // resize the cache when the lengthCalculator changes.
	  set lengthCalculator(lC) {
	    if (typeof lC !== "function")
	      lC = naiveLength;
	    if (lC !== this[LENGTH_CALCULATOR]) {
	      this[LENGTH_CALCULATOR] = lC;
	      this[LENGTH] = 0;
	      this[LRU_LIST].forEach((hit) => {
	        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
	        this[LENGTH] += hit.length;
	      });
	    }
	    trim(this);
	  }
	  get lengthCalculator() {
	    return this[LENGTH_CALCULATOR];
	  }
	  get length() {
	    return this[LENGTH];
	  }
	  get itemCount() {
	    return this[LRU_LIST].length;
	  }
	  rforEach(fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
	      const prev = walker.prev;
	      forEachStep(this, fn, walker, thisp);
	      walker = prev;
	    }
	  }
	  forEach(fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].head; walker !== null; ) {
	      const next = walker.next;
	      forEachStep(this, fn, walker, thisp);
	      walker = next;
	    }
	  }
	  keys() {
	    return this[LRU_LIST].toArray().map((k) => k.key);
	  }
	  values() {
	    return this[LRU_LIST].toArray().map((k) => k.value);
	  }
	  reset() {
	    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
	      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
	    }
	    this[CACHE] = /* @__PURE__ */ new Map();
	    this[LRU_LIST] = new Yallist();
	    this[LENGTH] = 0;
	  }
	  dump() {
	    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
	      k: hit.key,
	      v: hit.value,
	      e: hit.now + (hit.maxAge || 0)
	    }).toArray().filter((h) => h);
	  }
	  dumpLru() {
	    return this[LRU_LIST];
	  }
	  set(key, value, maxAge) {
	    maxAge = maxAge || this[MAX_AGE];
	    if (maxAge && typeof maxAge !== "number")
	      throw new TypeError("maxAge must be a number");
	    const now = maxAge ? Date.now() : 0;
	    const len = this[LENGTH_CALCULATOR](value, key);
	    if (this[CACHE].has(key)) {
	      if (len > this[MAX]) {
	        del(this, this[CACHE].get(key));
	        return false;
	      }
	      const node = this[CACHE].get(key);
	      const item = node.value;
	      if (this[DISPOSE]) {
	        if (!this[NO_DISPOSE_ON_SET])
	          this[DISPOSE](key, item.value);
	      }
	      item.now = now;
	      item.maxAge = maxAge;
	      item.value = value;
	      this[LENGTH] += len - item.length;
	      item.length = len;
	      this.get(key);
	      trim(this);
	      return true;
	    }
	    const hit = new Entry(key, value, len, now, maxAge);
	    if (hit.length > this[MAX]) {
	      if (this[DISPOSE])
	        this[DISPOSE](key, value);
	      return false;
	    }
	    this[LENGTH] += hit.length;
	    this[LRU_LIST].unshift(hit);
	    this[CACHE].set(key, this[LRU_LIST].head);
	    trim(this);
	    return true;
	  }
	  has(key) {
	    if (!this[CACHE].has(key)) return false;
	    const hit = this[CACHE].get(key).value;
	    return !isStale(this, hit);
	  }
	  get(key) {
	    return get(this, key, true);
	  }
	  peek(key) {
	    return get(this, key, false);
	  }
	  pop() {
	    const node = this[LRU_LIST].tail;
	    if (!node)
	      return null;
	    del(this, node);
	    return node.value;
	  }
	  del(key) {
	    del(this, this[CACHE].get(key));
	  }
	  load(arr) {
	    this.reset();
	    const now = Date.now();
	    for (let l = arr.length - 1; l >= 0; l--) {
	      const hit = arr[l];
	      const expiresAt = hit.e || 0;
	      if (expiresAt === 0)
	        this.set(hit.k, hit.v);
	      else {
	        const maxAge = expiresAt - now;
	        if (maxAge > 0) {
	          this.set(hit.k, hit.v, maxAge);
	        }
	      }
	    }
	  }
	  prune() {
	    this[CACHE].forEach((value, key) => get(this, key, false));
	  }
	}
	const get = (self, key, doUse) => {
	  const node = self[CACHE].get(key);
	  if (node) {
	    const hit = node.value;
	    if (isStale(self, hit)) {
	      del(self, node);
	      if (!self[ALLOW_STALE])
	        return void 0;
	    } else {
	      if (doUse) {
	        if (self[UPDATE_AGE_ON_GET])
	          node.value.now = Date.now();
	        self[LRU_LIST].unshiftNode(node);
	      }
	    }
	    return hit.value;
	  }
	};
	const isStale = (self, hit) => {
	  if (!hit || !hit.maxAge && !self[MAX_AGE])
	    return false;
	  const diff = Date.now() - hit.now;
	  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
	};
	const trim = (self) => {
	  if (self[LENGTH] > self[MAX]) {
	    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
	      const prev = walker.prev;
	      del(self, walker);
	      walker = prev;
	    }
	  }
	};
	const del = (self, node) => {
	  if (node) {
	    const hit = node.value;
	    if (self[DISPOSE])
	      self[DISPOSE](hit.key, hit.value);
	    self[LENGTH] -= hit.length;
	    self[CACHE].delete(hit.key);
	    self[LRU_LIST].removeNode(node);
	  }
	};
	class Entry {
	  constructor(key, value, length, now, maxAge) {
	    this.key = key;
	    this.value = value;
	    this.length = length;
	    this.now = now;
	    this.maxAge = maxAge || 0;
	  }
	}
	const forEachStep = (self, fn, node, thisp) => {
	  let hit = node.value;
	  if (isStale(self, hit)) {
	    del(self, node);
	    if (!self[ALLOW_STALE])
	      hit = void 0;
	  }
	  if (hit)
	    fn.call(thisp, hit.value, hit.key, self);
	};
	lruCache = LRUCache;
	return lruCache;
}

var utils$3 = {};

var targets = {};

var hasRequiredTargets;

function requireTargets () {
	if (hasRequiredTargets) return targets;
	hasRequiredTargets = 1;
	Object.defineProperty(targets, "__esModule", {
	  value: true
	});
	targets.unreleasedLabels = targets.browserNameMap = void 0;
	targets.unreleasedLabels = {
	  safari: "tp"
	};
	targets.browserNameMap = {
	  and_chr: "chrome",
	  and_ff: "firefox",
	  android: "android",
	  chrome: "chrome",
	  edge: "edge",
	  firefox: "firefox",
	  ie: "ie",
	  ie_mob: "ie",
	  ios_saf: "ios",
	  node: "node",
	  deno: "deno",
	  op_mob: "opera_mobile",
	  opera: "opera",
	  safari: "safari",
	  samsung: "samsung"
	};
	return targets;
}

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;
	Object.defineProperty(utils$3, "__esModule", {
	  value: true
	});
	utils$3.getHighestUnreleased = getHighestUnreleased;
	utils$3.getLowestImplementedVersion = getLowestImplementedVersion;
	utils$3.getLowestUnreleased = getLowestUnreleased;
	utils$3.isUnreleasedVersion = isUnreleasedVersion;
	utils$3.semverMin = semverMin;
	utils$3.semverify = semverify;
	var _semver = requireSemver();
	var _helperValidatorOption = requireLib$1h();
	var _targets = requireTargets();
	const versionRegExp = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/;
	const v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
	function semverMin(first, second) {
	  return first && _semver.lt(first, second) ? first : second;
	}
	function semverify(version) {
	  if (typeof version === "string" && _semver.valid(version)) {
	    return version;
	  }
	  v.invariant(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), `'${version}' is not a valid version`);
	  version = version.toString();
	  let pos = 0;
	  let num = 0;
	  while ((pos = version.indexOf(".", pos + 1)) > 0) {
	    num++;
	  }
	  return version + ".0".repeat(2 - num);
	}
	function isUnreleasedVersion(version, env) {
	  const unreleasedLabel = _targets.unreleasedLabels[env];
	  return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
	}
	function getLowestUnreleased(a, b, env) {
	  const unreleasedLabel = _targets.unreleasedLabels[env];
	  if (a === unreleasedLabel) {
	    return b;
	  }
	  if (b === unreleasedLabel) {
	    return a;
	  }
	  return semverMin(a, b);
	}
	function getHighestUnreleased(a, b, env) {
	  return getLowestUnreleased(a, b, env) === a ? b : a;
	}
	function getLowestImplementedVersion(plugin, environment) {
	  const result = plugin[environment];
	  if (!result && environment === "android") {
	    return plugin.chrome;
	  }
	  return result;
	}
	return utils$3;
}

var options$2 = {};

var hasRequiredOptions$2;

function requireOptions$2 () {
	if (hasRequiredOptions$2) return options$2;
	hasRequiredOptions$2 = 1;
	Object.defineProperty(options$2, "__esModule", {
	  value: true
	});
	options$2.TargetNames = void 0;
	options$2.TargetNames = {
	  node: "node",
	  deno: "deno",
	  chrome: "chrome",
	  opera: "opera",
	  edge: "edge",
	  firefox: "firefox",
	  safari: "safari",
	  ie: "ie",
	  ios: "ios",
	  android: "android",
	  electron: "electron",
	  samsung: "samsung",
	  rhino: "rhino",
	  opera_mobile: "opera_mobile"
	};
	return options$2;
}

var pretty = {};

var hasRequiredPretty;

function requirePretty () {
	if (hasRequiredPretty) return pretty;
	hasRequiredPretty = 1;
	Object.defineProperty(pretty, "__esModule", {
	  value: true
	});
	pretty.prettifyTargets = prettifyTargets;
	pretty.prettifyVersion = prettifyVersion;
	var _semver = requireSemver();
	var _targets = requireTargets();
	function prettifyVersion(version) {
	  if (typeof version !== "string") {
	    return version;
	  }
	  const {
	    major,
	    minor,
	    patch
	  } = _semver.parse(version);
	  const parts = [major];
	  if (minor || patch) {
	    parts.push(minor);
	  }
	  if (patch) {
	    parts.push(patch);
	  }
	  return parts.join(".");
	}
	function prettifyTargets(targets) {
	  return Object.keys(targets).reduce((results, target) => {
	    let value = targets[target];
	    const unreleasedLabel = _targets.unreleasedLabels[target];
	    if (typeof value === "string" && unreleasedLabel !== value) {
	      value = prettifyVersion(value);
	    }
	    results[target] = value;
	    return results;
	  }, {});
	}
	return pretty;
}

var debug = {};

var hasRequiredDebug$1;

function requireDebug$1 () {
	if (hasRequiredDebug$1) return debug;
	hasRequiredDebug$1 = 1;
	Object.defineProperty(debug, "__esModule", {
	  value: true
	});
	debug.getInclusionReasons = getInclusionReasons;
	var _semver = requireSemver();
	var _pretty = requirePretty();
	var _utils = requireUtils$3();
	function getInclusionReasons(item, targetVersions, list) {
	  const minVersions = list[item] || {};
	  return Object.keys(targetVersions).reduce((result, env) => {
	    const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env);
	    const targetVersion = targetVersions[env];
	    if (!minVersion) {
	      result[env] = (0, _pretty.prettifyVersion)(targetVersion);
	    } else {
	      const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
	      const targetIsUnreleased = (0, _utils.isUnreleasedVersion)(targetVersion, env);
	      if (!targetIsUnreleased && (minIsUnreleased || _semver.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion)))) {
	        result[env] = (0, _pretty.prettifyVersion)(targetVersion);
	      }
	    }
	    return result;
	  }, {});
	}
	return debug;
}

var filterItems$1 = {};

var require$$0$7 = {
	"transform-duplicate-named-capturing-groups-regex": {
	chrome: "126",
	opera: "112",
	edge: "126",
	firefox: "129",
	safari: "17.4",
	node: "23",
	ios: "17.4",
	electron: "31.0"
},
	"transform-regexp-modifiers": {
	chrome: "125",
	opera: "111",
	edge: "125",
	firefox: "132",
	node: "23",
	samsung: "27",
	electron: "31.0"
},
	"transform-unicode-sets-regex": {
	chrome: "112",
	opera: "98",
	edge: "112",
	firefox: "116",
	safari: "17",
	node: "20",
	deno: "1.32",
	ios: "17",
	samsung: "23",
	opera_mobile: "75",
	electron: "24.0"
},
	"bugfix/transform-v8-static-class-fields-redefine-readonly": {
	chrome: "98",
	opera: "84",
	edge: "98",
	firefox: "75",
	safari: "15",
	node: "12",
	deno: "1.18",
	ios: "15",
	samsung: "11",
	opera_mobile: "52",
	electron: "17.0"
},
	"bugfix/transform-firefox-class-in-computed-class-key": {
	chrome: "74",
	opera: "62",
	edge: "79",
	firefox: "126",
	safari: "16",
	node: "12",
	deno: "1",
	ios: "16",
	samsung: "11",
	opera_mobile: "53",
	electron: "6.0"
},
	"bugfix/transform-safari-class-field-initializer-scope": {
	chrome: "74",
	opera: "62",
	edge: "79",
	firefox: "69",
	safari: "16",
	node: "12",
	deno: "1",
	ios: "16",
	samsung: "11",
	opera_mobile: "53",
	electron: "6.0"
},
	"transform-class-static-block": {
	chrome: "94",
	opera: "80",
	edge: "94",
	firefox: "93",
	safari: "16.4",
	node: "16.11",
	deno: "1.14",
	ios: "16.4",
	samsung: "17",
	opera_mobile: "66",
	electron: "15.0"
},
	"proposal-class-static-block": {
	chrome: "94",
	opera: "80",
	edge: "94",
	firefox: "93",
	safari: "16.4",
	node: "16.11",
	deno: "1.14",
	ios: "16.4",
	samsung: "17",
	opera_mobile: "66",
	electron: "15.0"
},
	"transform-private-property-in-object": {
	chrome: "91",
	opera: "77",
	edge: "91",
	firefox: "90",
	safari: "15",
	node: "16.9",
	deno: "1.9",
	ios: "15",
	samsung: "16",
	opera_mobile: "64",
	electron: "13.0"
},
	"proposal-private-property-in-object": {
	chrome: "91",
	opera: "77",
	edge: "91",
	firefox: "90",
	safari: "15",
	node: "16.9",
	deno: "1.9",
	ios: "15",
	samsung: "16",
	opera_mobile: "64",
	electron: "13.0"
},
	"transform-class-properties": {
	chrome: "74",
	opera: "62",
	edge: "79",
	firefox: "90",
	safari: "14.1",
	node: "12",
	deno: "1",
	ios: "14.5",
	samsung: "11",
	opera_mobile: "53",
	electron: "6.0"
},
	"proposal-class-properties": {
	chrome: "74",
	opera: "62",
	edge: "79",
	firefox: "90",
	safari: "14.1",
	node: "12",
	deno: "1",
	ios: "14.5",
	samsung: "11",
	opera_mobile: "53",
	electron: "6.0"
},
	"transform-private-methods": {
	chrome: "84",
	opera: "70",
	edge: "84",
	firefox: "90",
	safari: "15",
	node: "14.6",
	deno: "1",
	ios: "15",
	samsung: "14",
	opera_mobile: "60",
	electron: "10.0"
},
	"proposal-private-methods": {
	chrome: "84",
	opera: "70",
	edge: "84",
	firefox: "90",
	safari: "15",
	node: "14.6",
	deno: "1",
	ios: "15",
	samsung: "14",
	opera_mobile: "60",
	electron: "10.0"
},
	"transform-numeric-separator": {
	chrome: "75",
	opera: "62",
	edge: "79",
	firefox: "70",
	safari: "13",
	node: "12.5",
	deno: "1",
	ios: "13",
	samsung: "11",
	rhino: "1.7.14",
	opera_mobile: "54",
	electron: "6.0"
},
	"proposal-numeric-separator": {
	chrome: "75",
	opera: "62",
	edge: "79",
	firefox: "70",
	safari: "13",
	node: "12.5",
	deno: "1",
	ios: "13",
	samsung: "11",
	rhino: "1.7.14",
	opera_mobile: "54",
	electron: "6.0"
},
	"transform-logical-assignment-operators": {
	chrome: "85",
	opera: "71",
	edge: "85",
	firefox: "79",
	safari: "14",
	node: "15",
	deno: "1.2",
	ios: "14",
	samsung: "14",
	opera_mobile: "60",
	electron: "10.0"
},
	"proposal-logical-assignment-operators": {
	chrome: "85",
	opera: "71",
	edge: "85",
	firefox: "79",
	safari: "14",
	node: "15",
	deno: "1.2",
	ios: "14",
	samsung: "14",
	opera_mobile: "60",
	electron: "10.0"
},
	"transform-nullish-coalescing-operator": {
	chrome: "80",
	opera: "67",
	edge: "80",
	firefox: "72",
	safari: "13.1",
	node: "14",
	deno: "1",
	ios: "13.4",
	samsung: "13",
	rhino: "1.8",
	opera_mobile: "57",
	electron: "8.0"
},
	"proposal-nullish-coalescing-operator": {
	chrome: "80",
	opera: "67",
	edge: "80",
	firefox: "72",
	safari: "13.1",
	node: "14",
	deno: "1",
	ios: "13.4",
	samsung: "13",
	rhino: "1.8",
	opera_mobile: "57",
	electron: "8.0"
},
	"transform-optional-chaining": {
	chrome: "91",
	opera: "77",
	edge: "91",
	firefox: "74",
	safari: "13.1",
	node: "16.9",
	deno: "1.9",
	ios: "13.4",
	samsung: "16",
	opera_mobile: "64",
	electron: "13.0"
},
	"proposal-optional-chaining": {
	chrome: "91",
	opera: "77",
	edge: "91",
	firefox: "74",
	safari: "13.1",
	node: "16.9",
	deno: "1.9",
	ios: "13.4",
	samsung: "16",
	opera_mobile: "64",
	electron: "13.0"
},
	"transform-json-strings": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "62",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "9",
	rhino: "1.7.14",
	opera_mobile: "47",
	electron: "3.0"
},
	"proposal-json-strings": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "62",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "9",
	rhino: "1.7.14",
	opera_mobile: "47",
	electron: "3.0"
},
	"transform-optional-catch-binding": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "58",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "9",
	opera_mobile: "47",
	electron: "3.0"
},
	"proposal-optional-catch-binding": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "58",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "9",
	opera_mobile: "47",
	electron: "3.0"
},
	"transform-parameters": {
	chrome: "49",
	opera: "36",
	edge: "18",
	firefox: "52",
	safari: "16.3",
	node: "6",
	deno: "1",
	ios: "16.3",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"transform-async-generator-functions": {
	chrome: "63",
	opera: "50",
	edge: "79",
	firefox: "57",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"proposal-async-generator-functions": {
	chrome: "63",
	opera: "50",
	edge: "79",
	firefox: "57",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"transform-object-rest-spread": {
	chrome: "60",
	opera: "47",
	edge: "79",
	firefox: "55",
	safari: "11.1",
	node: "8.3",
	deno: "1",
	ios: "11.3",
	samsung: "8",
	opera_mobile: "44",
	electron: "2.0"
},
	"proposal-object-rest-spread": {
	chrome: "60",
	opera: "47",
	edge: "79",
	firefox: "55",
	safari: "11.1",
	node: "8.3",
	deno: "1",
	ios: "11.3",
	samsung: "8",
	opera_mobile: "44",
	electron: "2.0"
},
	"transform-dotall-regex": {
	chrome: "62",
	opera: "49",
	edge: "79",
	firefox: "78",
	safari: "11.1",
	node: "8.10",
	deno: "1",
	ios: "11.3",
	samsung: "8",
	rhino: "1.7.15",
	opera_mobile: "46",
	electron: "3.0"
},
	"transform-unicode-property-regex": {
	chrome: "64",
	opera: "51",
	edge: "79",
	firefox: "78",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "9",
	opera_mobile: "47",
	electron: "3.0"
},
	"proposal-unicode-property-regex": {
	chrome: "64",
	opera: "51",
	edge: "79",
	firefox: "78",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "9",
	opera_mobile: "47",
	electron: "3.0"
},
	"transform-named-capturing-groups-regex": {
	chrome: "64",
	opera: "51",
	edge: "79",
	firefox: "78",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "9",
	opera_mobile: "47",
	electron: "3.0"
},
	"transform-async-to-generator": {
	chrome: "55",
	opera: "42",
	edge: "15",
	firefox: "52",
	safari: "11",
	node: "7.6",
	deno: "1",
	ios: "11",
	samsung: "6",
	opera_mobile: "42",
	electron: "1.6"
},
	"transform-exponentiation-operator": {
	chrome: "52",
	opera: "39",
	edge: "14",
	firefox: "52",
	safari: "10.1",
	node: "7",
	deno: "1",
	ios: "10.3",
	samsung: "6",
	rhino: "1.7.14",
	opera_mobile: "41",
	electron: "1.3"
},
	"transform-template-literals": {
	chrome: "41",
	opera: "28",
	edge: "13",
	firefox: "34",
	safari: "13",
	node: "4",
	deno: "1",
	ios: "13",
	samsung: "3.4",
	opera_mobile: "28",
	electron: "0.21"
},
	"transform-literals": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "53",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.15",
	opera_mobile: "32",
	electron: "0.30"
},
	"transform-function-name": {
	chrome: "51",
	opera: "38",
	edge: "79",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"transform-arrow-functions": {
	chrome: "47",
	opera: "34",
	edge: "13",
	firefox: "43",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "34",
	electron: "0.36"
},
	"transform-block-scoped-functions": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "46",
	safari: "10",
	node: "4",
	deno: "1",
	ie: "11",
	ios: "10",
	samsung: "3.4",
	opera_mobile: "28",
	electron: "0.21"
},
	"transform-classes": {
	chrome: "46",
	opera: "33",
	edge: "13",
	firefox: "45",
	safari: "10",
	node: "5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "33",
	electron: "0.36"
},
	"transform-object-super": {
	chrome: "46",
	opera: "33",
	edge: "13",
	firefox: "45",
	safari: "10",
	node: "5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "33",
	electron: "0.36"
},
	"transform-shorthand-properties": {
	chrome: "43",
	opera: "30",
	edge: "12",
	firefox: "33",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.14",
	opera_mobile: "30",
	electron: "0.27"
},
	"transform-duplicate-keys": {
	chrome: "42",
	opera: "29",
	edge: "12",
	firefox: "34",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	opera_mobile: "29",
	electron: "0.25"
},
	"transform-computed-properties": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "34",
	safari: "7.1",
	node: "4",
	deno: "1",
	ios: "8",
	samsung: "4",
	rhino: "1.8",
	opera_mobile: "32",
	electron: "0.30"
},
	"transform-for-of": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"transform-sticky-regex": {
	chrome: "49",
	opera: "36",
	edge: "13",
	firefox: "3",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "36",
	electron: "0.37"
},
	"transform-unicode-escapes": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "53",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.15",
	opera_mobile: "32",
	electron: "0.30"
},
	"transform-unicode-regex": {
	chrome: "50",
	opera: "37",
	edge: "13",
	firefox: "46",
	safari: "12",
	node: "6",
	deno: "1",
	ios: "12",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"transform-spread": {
	chrome: "46",
	opera: "33",
	edge: "13",
	firefox: "45",
	safari: "10",
	node: "5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "33",
	electron: "0.36"
},
	"transform-destructuring": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"transform-block-scoping": {
	chrome: "50",
	opera: "37",
	edge: "14",
	firefox: "53",
	safari: "11",
	node: "6",
	deno: "1",
	ios: "11",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"transform-typeof-symbol": {
	chrome: "48",
	opera: "35",
	edge: "12",
	firefox: "36",
	safari: "9",
	node: "6",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "35",
	electron: "0.37"
},
	"transform-new-target": {
	chrome: "46",
	opera: "33",
	edge: "14",
	firefox: "41",
	safari: "10",
	node: "5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "33",
	electron: "0.36"
},
	"transform-regenerator": {
	chrome: "50",
	opera: "37",
	edge: "13",
	firefox: "53",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"transform-member-expression-literals": {
	chrome: "7",
	opera: "12",
	edge: "12",
	firefox: "2",
	safari: "5.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"transform-property-literals": {
	chrome: "7",
	opera: "12",
	edge: "12",
	firefox: "2",
	safari: "5.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"transform-reserved-words": {
	chrome: "13",
	opera: "10.50",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.6",
	deno: "1",
	ie: "9",
	android: "4.4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"transform-export-namespace-from": {
	chrome: "72",
	deno: "1.0",
	edge: "79",
	firefox: "80",
	node: "13.2.0",
	opera: "60",
	opera_mobile: "51",
	safari: "14.1",
	ios: "14.5",
	samsung: "11.0",
	android: "72",
	electron: "5.0"
},
	"proposal-export-namespace-from": {
	chrome: "72",
	deno: "1.0",
	edge: "79",
	firefox: "80",
	node: "13.2.0",
	opera: "60",
	opera_mobile: "51",
	safari: "14.1",
	ios: "14.5",
	samsung: "11.0",
	android: "72",
	electron: "5.0"
}
};

var plugins;
var hasRequiredPlugins;

function requirePlugins () {
	if (hasRequiredPlugins) return plugins;
	hasRequiredPlugins = 1;
	plugins = require$$0$7;
	return plugins;
}

var hasRequiredFilterItems$1;

function requireFilterItems$1 () {
	if (hasRequiredFilterItems$1) return filterItems$1;
	hasRequiredFilterItems$1 = 1;
	Object.defineProperty(filterItems$1, "__esModule", {
	  value: true
	});
	filterItems$1.default = filterItems;
	filterItems$1.isRequired = isRequired;
	filterItems$1.targetsSupported = targetsSupported;
	var _semver = requireSemver();
	var _utils = requireUtils$3();
	const pluginsCompatData = requirePlugins();
	function targetsSupported(target, support) {
	  const targetEnvironments = Object.keys(target);
	  if (targetEnvironments.length === 0) {
	    return false;
	  }
	  const unsupportedEnvironments = targetEnvironments.filter((environment) => {
	    const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
	    if (!lowestImplementedVersion) {
	      return true;
	    }
	    const lowestTargetedVersion = target[environment];
	    if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
	      return false;
	    }
	    if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
	      return true;
	    }
	    if (!_semver.valid(lowestTargetedVersion.toString())) {
	      throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`);
	    }
	    return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
	  });
	  return unsupportedEnvironments.length === 0;
	}
	function isRequired(name, targets, {
	  compatData = pluginsCompatData,
	  includes,
	  excludes
	} = {}) {
	  if (excludes != null && excludes.has(name)) return false;
	  if (includes != null && includes.has(name)) return true;
	  return !targetsSupported(targets, compatData[name]);
	}
	function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
	  const result = /* @__PURE__ */ new Set();
	  const options = {
	    compatData: list,
	    includes,
	    excludes
	  };
	  for (const item in list) {
	    if (isRequired(item, targets, options)) {
	      result.add(item);
	    } else if (pluginSyntaxMap) {
	      const shippedProposalsSyntax = pluginSyntaxMap.get(item);
	      if (shippedProposalsSyntax) {
	        result.add(shippedProposalsSyntax);
	      }
	    }
	  }
	  defaultIncludes == null || defaultIncludes.forEach((item) => !excludes.has(item) && result.add(item));
	  defaultExcludes == null || defaultExcludes.forEach((item) => !includes.has(item) && result.delete(item));
	  return result;
	}
	return filterItems$1;
}

var require$$0$6 = {
	"es6.module": {
	chrome: "61",
	and_chr: "61",
	edge: "16",
	firefox: "60",
	and_ff: "60",
	node: "13.2.0",
	opera: "48",
	op_mob: "45",
	safari: "10.1",
	ios: "10.3",
	samsung: "8.2",
	android: "61",
	electron: "2.0",
	ios_saf: "10.3"
}
};

var nativeModules;
var hasRequiredNativeModules;

function requireNativeModules () {
	if (hasRequiredNativeModules) return nativeModules;
	hasRequiredNativeModules = 1;
	nativeModules = require$$0$6;
	return nativeModules;
}

var hasRequiredLib$1g;

function requireLib$1g () {
	if (hasRequiredLib$1g) return lib$1g;
	hasRequiredLib$1g = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "TargetNames", {
		  enumerable: true,
		  get: function() {
		    return _options.TargetNames;
		  }
		});
		exports.default = getTargets;
		Object.defineProperty(exports, "filterItems", {
		  enumerable: true,
		  get: function() {
		    return _filterItems.default;
		  }
		});
		Object.defineProperty(exports, "getInclusionReasons", {
		  enumerable: true,
		  get: function() {
		    return _debug.getInclusionReasons;
		  }
		});
		exports.isBrowsersQueryValid = isBrowsersQueryValid;
		Object.defineProperty(exports, "isRequired", {
		  enumerable: true,
		  get: function() {
		    return _filterItems.isRequired;
		  }
		});
		Object.defineProperty(exports, "prettifyTargets", {
		  enumerable: true,
		  get: function() {
		    return _pretty.prettifyTargets;
		  }
		});
		Object.defineProperty(exports, "unreleasedLabels", {
		  enumerable: true,
		  get: function() {
		    return _targets.unreleasedLabels;
		  }
		});
		var _browserslist = requireBrowserslist();
		var _helperValidatorOption = requireLib$1h();
		var _lruCache = requireLruCache();
		var _utils = requireUtils$3();
		var _targets = requireTargets();
		var _options = requireOptions$2();
		var _pretty = requirePretty();
		var _debug = requireDebug$1();
		var _filterItems = requireFilterItems$1();
		const browserModulesData = requireNativeModules();
		const ESM_SUPPORT = browserModulesData["es6.module"];
		const v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
		function validateTargetNames(targets) {
		  const validTargets = Object.keys(_options.TargetNames);
		  for (const target of Object.keys(targets)) {
		    if (!(target in _options.TargetNames)) {
		      throw new Error(v.formatMessage(`'${target}' is not a valid target
- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
		    }
		  }
		  return targets;
		}
		function isBrowsersQueryValid(browsers) {
		  return typeof browsers === "string" || Array.isArray(browsers) && browsers.every((b) => typeof b === "string");
		}
		function validateBrowsers(browsers) {
		  v.invariant(browsers === void 0 || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);
		  return browsers;
		}
		function getLowestVersions(browsers) {
		  return browsers.reduce((all, browser) => {
		    const [browserName, browserVersion] = browser.split(" ");
		    const target = _targets.browserNameMap[browserName];
		    if (!target) {
		      return all;
		    }
		    try {
		      const splitVersion = browserVersion.split("-")[0].toLowerCase();
		      const isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);
		      if (!all[target]) {
		        all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);
		        return all;
		      }
		      const version = all[target];
		      const isUnreleased = (0, _utils.isUnreleasedVersion)(version, target);
		      if (isUnreleased && isSplitUnreleased) {
		        all[target] = (0, _utils.getLowestUnreleased)(version, splitVersion, target);
		      } else if (isUnreleased) {
		        all[target] = (0, _utils.semverify)(splitVersion);
		      } else if (!isUnreleased && !isSplitUnreleased) {
		        const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
		        all[target] = (0, _utils.semverMin)(version, parsedBrowserVersion);
		      }
		    } catch (_) {
		    }
		    return all;
		  }, {});
		}
		function outputDecimalWarning(decimalTargets) {
		  if (!decimalTargets.length) {
		    return;
		  }
		  console.warn("Warning, the following targets are using a decimal version:\n");
		  decimalTargets.forEach(({
		    target,
		    value
		  }) => console.warn(`  ${target}: ${value}`));
		  console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`);
		}
		function semverifyTarget(target, value) {
		  try {
		    return (0, _utils.semverify)(value);
		  } catch (_) {
		    throw new Error(v.formatMessage(`'${value}' is not a valid value for 'targets.${target}'.`));
		  }
		}
		function nodeTargetParser(value) {
		  const parsed = value === true || value === "current" ? process.versions.node.split("-")[0] : semverifyTarget("node", value);
		  return ["node", parsed];
		}
		function defaultTargetParser(target, value) {
		  const version = (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
		  return [target, version];
		}
		function generateTargets(inputTargets) {
		  const input = Object.assign({}, inputTargets);
		  delete input.esmodules;
		  delete input.browsers;
		  return input;
		}
		function resolveTargets(queries, env) {
		  const resolved = _browserslist(queries, {
		    mobileToDesktop: true,
		    env
		  });
		  return getLowestVersions(resolved);
		}
		const targetsCache = new _lruCache({
		  max: 64
		});
		function resolveTargetsCached(queries, env) {
		  const cacheKey = typeof queries === "string" ? queries : queries.join() + env;
		  let cached = targetsCache.get(cacheKey);
		  if (!cached) {
		    cached = resolveTargets(queries, env);
		    targetsCache.set(cacheKey, cached);
		  }
		  return Object.assign({}, cached);
		}
		function getTargets(inputTargets = {}, options = {}) {
		  var _browsers, _browsers2;
		  let {
		    browsers,
		    esmodules
		  } = inputTargets;
		  const {
		    configPath = ".",
		    onBrowserslistConfigFound
		  } = options;
		  validateBrowsers(browsers);
		  const input = generateTargets(inputTargets);
		  let targets = validateTargetNames(input);
		  const shouldParseBrowsers = !!browsers;
		  const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
		  const shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
		  if (!browsers && shouldSearchForConfig) {
		    browsers = process.env.BROWSERSLIST;
		    if (!browsers) {
		      const configFile = options.configFile || process.env.BROWSERSLIST_CONFIG || _browserslist.findConfigFile(configPath);
		      if (configFile != null) {
		        onBrowserslistConfigFound == null || onBrowserslistConfigFound(configFile);
		        browsers = _browserslist.loadConfig({
		          config: configFile,
		          env: options.browserslistEnv
		        });
		      }
		    }
		    if (browsers == null) {
		      {
		        browsers = [];
		      }
		    }
		  }
		  if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
		    browsers = Object.keys(ESM_SUPPORT).map((browser) => `${browser} >= ${ESM_SUPPORT[browser]}`).join(", ");
		    esmodules = false;
		  }
		  if ((_browsers2 = browsers) != null && _browsers2.length) {
		    const queryBrowsers = resolveTargetsCached(browsers, options.browserslistEnv);
		    if (esmodules === "intersect") {
		      for (const browser of Object.keys(queryBrowsers)) {
		        if (browser !== "deno" && browser !== "ie") {
		          const esmSupportVersion = ESM_SUPPORT[browser === "opera_mobile" ? "op_mob" : browser];
		          if (esmSupportVersion) {
		            const version = queryBrowsers[browser];
		            queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version, (0, _utils.semverify)(esmSupportVersion), browser);
		          } else {
		            delete queryBrowsers[browser];
		          }
		        } else {
		          delete queryBrowsers[browser];
		        }
		      }
		    }
		    targets = Object.assign(queryBrowsers, targets);
		  }
		  const result = {};
		  const decimalWarnings = [];
		  for (const target of Object.keys(targets).sort()) {
		    const value = targets[target];
		    if (typeof value === "number" && value % 1 !== 0) {
		      decimalWarnings.push({
		        target,
		        value
		      });
		    }
		    const [parsedTarget, parsedValue] = target === "node" ? nodeTargetParser(value) : defaultTargetParser(target, value);
		    if (parsedValue) {
		      result[parsedTarget] = parsedValue;
		    }
		  }
		  outputDecimalWarning(decimalWarnings);
		  return result;
		} 
	} (lib$1g));
	return lib$1g;
}

var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug$1;
	hasRequiredDebug = 1;
	Object.defineProperty(debug$1, "__esModule", {
	  value: true
	});
	debug$1.logPlugin = void 0;
	var _helperCompilationTargets = requireLib$1g();
	const compatData = requirePlugins();
	const logPlugin = (item, targetVersions, list) => {
	  const filteredList = (0, _helperCompilationTargets.getInclusionReasons)(item, targetVersions, list);
	  const support = list[item];
	  {
	    if (item.startsWith("transform-")) {
	      const proposalName = `proposal-${item.slice(10)}`;
	      if (proposalName === "proposal-dynamic-import" || hasOwnProperty.call(compatData, proposalName)) {
	        item = proposalName;
	      }
	    }
	  }
	  if (!support) {
	    console.log(`  ${item}`);
	    return;
	  }
	  let formattedTargets = `{`;
	  let first = true;
	  for (const target of Object.keys(filteredList)) {
	    if (!first) formattedTargets += `,`;
	    first = false;
	    formattedTargets += ` ${target}`;
	    if (support[target]) formattedTargets += ` < ${support[target]}`;
	  }
	  formattedTargets += ` }`;
	  console.log(`  ${item} ${formattedTargets}`);
	};
	debug$1.logPlugin = logPlugin;
	return debug$1;
}

var filterItems = {};

var availablePlugins = {};

var lib$1e = {};

var lib$1d = {};

var hasRequiredLib$1f;

function requireLib$1f () {
	if (hasRequiredLib$1f) return lib$1d;
	hasRequiredLib$1f = 1;
	Object.defineProperty(lib$1d, "__esModule", {
	  value: true
	});
	lib$1d.declare = declare;
	lib$1d.declarePreset = void 0;
	const apiPolyfills = {
	  assertVersion: (api) => (range) => {
	    throwVersionError(range, api.version);
	  }
	};
	{
	  Object.assign(apiPolyfills, {
	    targets: () => () => {
	      return {};
	    },
	    assumption: () => () => {
	      return void 0;
	    },
	    addExternalDependency: () => () => {
	    }
	  });
	}
	function declare(builder) {
	  return (api, options, dirname) => {
	    let clonedApi;
	    for (const name of Object.keys(apiPolyfills)) {
	      if (api[name]) continue;
	      clonedApi != null ? clonedApi : clonedApi = copyApiObject(api);
	      clonedApi[name] = apiPolyfills[name](clonedApi);
	    }
	    return builder(clonedApi != null ? clonedApi : api, options || {}, dirname);
	  };
	}
	lib$1d.declarePreset = declare;
	function copyApiObject(api) {
	  let proto = null;
	  if (typeof api.version === "string" && /^7\./.test(api.version)) {
	    proto = Object.getPrototypeOf(api);
	    if (proto && (!hasOwnProperty.call(proto, "version") || !hasOwnProperty.call(proto, "transform") || !hasOwnProperty.call(proto, "template") || !hasOwnProperty.call(proto, "types"))) {
	      proto = null;
	    }
	  }
	  return Object.assign({}, proto, api);
	}
	function throwVersionError(range, version) {
	  if (typeof range === "number") {
	    if (!Number.isInteger(range)) {
	      throw new Error("Expected string or integer value.");
	    }
	    range = `^${range}.0.0-0`;
	  }
	  if (typeof range !== "string") {
	    throw new Error("Expected string or integer value.");
	  }
	  const limit = Error.stackTraceLimit;
	  if (typeof limit === "number" && limit < 25) {
	    Error.stackTraceLimit = 25;
	  }
	  let err;
	  if (version.slice(0, 2) === "7.") {
	    err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`);
	  } else {
	    err = new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
	  }
	  if (typeof limit === "number") {
	    Error.stackTraceLimit = limit;
	  }
	  throw Object.assign(err, {
	    code: "BABEL_VERSION_UNSUPPORTED",
	    version,
	    range
	  });
	}
	return lib$1d;
}

var hasRequiredLib$1e;

function requireLib$1e () {
	if (hasRequiredLib$1e) return lib$1e;
	hasRequiredLib$1e = 1;
	Object.defineProperty(lib$1e, "__esModule", {
	  value: true
	});
	lib$1e.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$1e.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  const isPlugin = (plugin, name) => name === "plugin" || Array.isArray(plugin) && plugin[0] === "plugin";
	  const options = (plugin) => Array.isArray(plugin) && plugin.length > 1 ? plugin[1] : {};
	  return {
	    name: "syntax-import-assertions",
	    manipulateOptions(opts, {
	      plugins
	    }) {
	      for (let i = 0; i < plugins.length; i++) {
	        const plugin = plugins[i];
	        if (isPlugin(plugin, "deprecatedImportAssert")) return;
	        if (isPlugin(plugin, "importAttributes")) {
	          plugins.splice(i, 1, "deprecatedImportAssert", ["importAttributes", Object.assign({}, options(plugin), {
	            deprecatedAssertSyntax: true
	          })]);
	          return;
	        }
	      }
	      plugins.push("importAssertions");
	    }
	  };
	});
	return lib$1e;
}

var lib$1c = {};

var hasRequiredLib$1d;

function requireLib$1d () {
	if (hasRequiredLib$1d) return lib$1c;
	hasRequiredLib$1d = 1;
	Object.defineProperty(lib$1c, "__esModule", {
	  value: true
	});
	lib$1c.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$1c.default = (0, _helperPluginUtils.declare)((api, {
	  deprecatedAssertSyntax
	}) => {
	  api.assertVersion("^7.22.0 || >8.0.0-alpha <8.0.0-beta");
	  if (deprecatedAssertSyntax != null && typeof deprecatedAssertSyntax !== "boolean") {
	    throw new Error("'deprecatedAssertSyntax' must be a boolean, if specified.");
	  }
	  return {
	    name: "syntax-import-attributes",
	    manipulateOptions({
	      parserOpts,
	      generatorOpts
	    }) {
	      var _generatorOpts$import;
	      (_generatorOpts$import = generatorOpts.importAttributesKeyword) != null ? _generatorOpts$import : generatorOpts.importAttributesKeyword = "with";
	      const importAssertionsPluginIndex = parserOpts.plugins.indexOf("importAssertions");
	      if (importAssertionsPluginIndex !== -1) {
	        parserOpts.plugins.splice(importAssertionsPluginIndex, 1);
	        deprecatedAssertSyntax = true;
	      }
	      if (deprecatedAssertSyntax) {
	        parserOpts.plugins.push("deprecatedImportAssert", ["importAttributes", {
	          deprecatedAssertSyntax: true
	        }]);
	      } else {
	        parserOpts.plugins.push("importAttributes");
	      }
	    }
	  };
	});
	return lib$1c;
}

var lib$1b = {};

var lib$1a = {};

var lib$19 = {};

var lib$18 = {};

var formatters = {};

var hasRequiredFormatters;

function requireFormatters () {
	if (hasRequiredFormatters) return formatters;
	hasRequiredFormatters = 1;
	Object.defineProperty(formatters, "__esModule", {
	  value: true
	});
	formatters.statements = formatters.statement = formatters.smart = formatters.program = formatters.expression = void 0;
	var _t = require$$0$a;
	const {
	  assertExpressionStatement
	} = _t;
	function makeStatementFormatter(fn) {
	  return {
	    code: (str) => `/* @babel/template */;
${str}`,
	    validate: () => {
	    },
	    unwrap: (ast) => {
	      return fn(ast.program.body.slice(1));
	    }
	  };
	}
	formatters.smart = makeStatementFormatter((body) => {
	  if (body.length > 1) {
	    return body;
	  } else {
	    return body[0];
	  }
	});
	formatters.statements = makeStatementFormatter((body) => body);
	formatters.statement = makeStatementFormatter((body) => {
	  if (body.length === 0) {
	    throw new Error("Found nothing to return.");
	  }
	  if (body.length > 1) {
	    throw new Error("Found multiple statements but wanted one");
	  }
	  return body[0];
	});
	const expression = formatters.expression = {
	  code: (str) => `(
${str}
)`,
	  validate: (ast) => {
	    if (ast.program.body.length > 1) {
	      throw new Error("Found multiple statements but wanted one");
	    }
	    if (expression.unwrap(ast).start === 0) {
	      throw new Error("Parse result included parens.");
	    }
	  },
	  unwrap: ({
	    program: program2
	  }) => {
	    const [stmt] = program2.body;
	    assertExpressionStatement(stmt);
	    return stmt.expression;
	  }
	};
	formatters.program = {
	  code: (str) => str,
	  validate: () => {
	  },
	  unwrap: (ast) => ast.program
	};
	return formatters;
}

var builder = {};

var options$1 = {};

var hasRequiredOptions$1;

function requireOptions$1 () {
	if (hasRequiredOptions$1) return options$1;
	hasRequiredOptions$1 = 1;
	Object.defineProperty(options$1, "__esModule", {
	  value: true
	});
	options$1.merge = merge;
	options$1.normalizeReplacements = normalizeReplacements;
	options$1.validate = validate;
	const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
	function _objectWithoutPropertiesLoose(r, e) {
	  if (null == r) return {};
	  var t = {};
	  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
	    if (-1 !== e.indexOf(n)) continue;
	    t[n] = r[n];
	  }
	  return t;
	}
	function merge(a, b) {
	  const {
	    placeholderWhitelist = a.placeholderWhitelist,
	    placeholderPattern = a.placeholderPattern,
	    preserveComments = a.preserveComments,
	    syntacticPlaceholders = a.syntacticPlaceholders
	  } = b;
	  return {
	    parser: Object.assign({}, a.parser, b.parser),
	    placeholderWhitelist,
	    placeholderPattern,
	    preserveComments,
	    syntacticPlaceholders
	  };
	}
	function validate(opts) {
	  if (opts != null && typeof opts !== "object") {
	    throw new Error("Unknown template options.");
	  }
	  const _ref = opts || {}, {
	    placeholderWhitelist,
	    placeholderPattern,
	    preserveComments,
	    syntacticPlaceholders
	  } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
	  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
	    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
	  }
	  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
	    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
	  }
	  if (preserveComments != null && typeof preserveComments !== "boolean") {
	    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
	  }
	  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
	    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
	  }
	  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
	    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
	  }
	  return {
	    parser,
	    placeholderWhitelist: placeholderWhitelist || void 0,
	    placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
	    preserveComments: preserveComments == null ? void 0 : preserveComments,
	    syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
	  };
	}
	function normalizeReplacements(replacements) {
	  if (Array.isArray(replacements)) {
	    return replacements.reduce((acc, replacement, i) => {
	      acc["$" + i] = replacement;
	      return acc;
	    }, {});
	  } else if (typeof replacements === "object" || replacements == null) {
	    return replacements || void 0;
	  }
	  throw new Error("Template replacements must be an array, object, null, or undefined");
	}
	return options$1;
}

var string = {};

var parse = {};

var lib$17 = {};

var hasRequiredLib$1c;

function requireLib$1c () {
	if (hasRequiredLib$1c) return lib$17;
	hasRequiredLib$1c = 1;
	Object.defineProperty(lib$17, "__esModule", {
	  value: true
	});
	function _objectWithoutPropertiesLoose(r, e) {
	  if (null == r) return {};
	  var t = {};
	  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
	    if (-1 !== e.indexOf(n)) continue;
	    t[n] = r[n];
	  }
	  return t;
	}
	class Position {
	  constructor(line, col, index) {
	    this.line = void 0;
	    this.column = void 0;
	    this.index = void 0;
	    this.line = line;
	    this.column = col;
	    this.index = index;
	  }
	}
	class SourceLocation {
	  constructor(start, end) {
	    this.start = void 0;
	    this.end = void 0;
	    this.filename = void 0;
	    this.identifierName = void 0;
	    this.start = start;
	    this.end = end;
	  }
	}
	function createPositionWithColumnOffset(position, columnOffset) {
	  const {
	    line,
	    column,
	    index
	  } = position;
	  return new Position(line, column + columnOffset, index + columnOffset);
	}
	const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
	var ModuleErrors = {
	  ImportMetaOutsideModule: {
	    message: `import.meta may appear only with 'sourceType: "module"'`,
	    code
	  },
	  ImportOutsideModule: {
	    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
	    code
	  }
	};
	const NodeDescriptions = {
	  ArrayPattern: "array destructuring pattern",
	  AssignmentExpression: "assignment expression",
	  AssignmentPattern: "assignment expression",
	  ArrowFunctionExpression: "arrow function expression",
	  ConditionalExpression: "conditional expression",
	  CatchClause: "catch clause",
	  ForOfStatement: "for-of statement",
	  ForInStatement: "for-in statement",
	  ForStatement: "for-loop",
	  FormalParameters: "function parameter list",
	  Identifier: "identifier",
	  ImportSpecifier: "import specifier",
	  ImportDefaultSpecifier: "import default specifier",
	  ImportNamespaceSpecifier: "import namespace specifier",
	  ObjectPattern: "object destructuring pattern",
	  ParenthesizedExpression: "parenthesized expression",
	  RestElement: "rest element",
	  UpdateExpression: {
	    true: "prefix operation",
	    false: "postfix operation"
	  },
	  VariableDeclarator: "variable declaration",
	  YieldExpression: "yield expression"
	};
	const toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
	var StandardErrors = {
	  AccessorIsGenerator: ({
	    kind
	  }) => `A ${kind}ter cannot be a generator.`,
	  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
	  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
	  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
	  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
	  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
	  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
	  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
	  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
	  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
	  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
	  ConstructorClassField: "Classes may not have a field named 'constructor'.",
	  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
	  ConstructorIsAccessor: "Class constructor may not be an accessor.",
	  ConstructorIsAsync: "Constructor can't be an async function.",
	  ConstructorIsGenerator: "Constructor can't be a generator.",
	  DeclarationMissingInitializer: ({
	    kind
	  }) => `Missing initializer in ${kind} declaration.`,
	  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
	  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
	  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
	  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
	  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
	  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
	  DecoratorStaticBlock: "Decorators can't be used with a static block.",
	  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
	  DeletePrivateField: "Deleting a private field is not allowed.",
	  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
	  DuplicateConstructor: "Duplicate constructor in the same class.",
	  DuplicateDefaultExport: "Only one default export allowed per module.",
	  DuplicateExport: ({
	    exportName
	  }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
	  DuplicateProto: "Redefinition of __proto__ property.",
	  DuplicateRegExpFlags: "Duplicate regular expression flag.",
	  ElementAfterRest: "Rest element must be last element.",
	  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
	  ExportBindingIsString: ({
	    localName,
	    exportName
	  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
	  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
	  ForInOfLoopInitializer: ({
	    type
	  }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
	  ForInUsing: "For-in loop may not start with 'using' declaration.",
	  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
	  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
	  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
	  IllegalBreakContinue: ({
	    type
	  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
	  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
	  IllegalReturn: "'return' outside of function.",
	  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
	  ImportBindingIsString: ({
	    importName
	  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
	  ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
	  ImportCallNotNewExpression: "Cannot use new with import(...).",
	  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
	  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
	  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
	  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
	  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
	  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
	  InvalidCodePoint: "Code point out of bounds.",
	  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
	  InvalidDecimal: "Invalid decimal.",
	  InvalidDigit: ({
	    radix
	  }) => `Expected number in radix ${radix}.`,
	  InvalidEscapeSequence: "Bad character escape sequence.",
	  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
	  InvalidEscapedReservedWord: ({
	    reservedWord
	  }) => `Escape sequence in keyword ${reservedWord}.`,
	  InvalidIdentifier: ({
	    identifierName
	  }) => `Invalid identifier ${identifierName}.`,
	  InvalidLhs: ({
	    ancestor
	  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
	  InvalidLhsBinding: ({
	    ancestor
	  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
	  InvalidLhsOptionalChaining: ({
	    ancestor
	  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
	  InvalidNumber: "Invalid number.",
	  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
	  InvalidOrUnexpectedToken: ({
	    unexpected
	  }) => `Unexpected character '${unexpected}'.`,
	  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
	  InvalidPrivateFieldResolution: ({
	    identifierName
	  }) => `Private name #${identifierName} is not defined.`,
	  InvalidPropertyBindingPattern: "Binding member expression.",
	  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
	  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
	  LabelRedeclaration: ({
	    labelName
	  }) => `Label '${labelName}' is already declared.`,
	  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
	  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
	  MalformedRegExpFlags: "Invalid regular expression flag.",
	  MissingClassName: "A class name is required.",
	  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
	  MissingSemicolon: "Missing semicolon.",
	  MissingPlugin: ({
	    missingPlugin
	  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
	  MissingOneOfPlugins: ({
	    missingPlugin
	  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
	  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
	  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
	  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
	  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
	  ModuleAttributesWithDuplicateKeys: ({
	    key
	  }) => `Duplicate key "${key}" is not allowed in module attributes.`,
	  ModuleExportNameHasLoneSurrogate: ({
	    surrogateCharCode
	  }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
	  ModuleExportUndefined: ({
	    localName
	  }) => `Export '${localName}' is not defined.`,
	  MultipleDefaultsInSwitch: "Multiple default clauses.",
	  NewlineAfterThrow: "Illegal newline after throw.",
	  NoCatchOrFinally: "Missing catch or finally clause.",
	  NumberIdentifier: "Identifier directly after number.",
	  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
	  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
	  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
	  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
	  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
	  ParamDupe: "Argument name clash.",
	  PatternHasAccessor: "Object pattern can't contain getter or setter.",
	  PatternHasMethod: "Object pattern can't contain methods.",
	  PrivateInExpectedIn: ({
	    identifierName
	  }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
	  PrivateNameRedeclaration: ({
	    identifierName
	  }) => `Duplicate private name #${identifierName}.`,
	  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
	  RestTrailingComma: "Unexpected trailing comma after rest element.",
	  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
	  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
	  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
	  StaticPrototype: "Classes may not have static property named prototype.",
	  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
	  SuperPrivateField: "Private fields can't be accessed on super.",
	  TrailingDecorator: "Decorators must be attached to a class element.",
	  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
	  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
	  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
	  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
	  UnexpectedKeyword: ({
	    keyword
	  }) => `Unexpected keyword '${keyword}'.`,
	  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
	  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
	  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
	  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
	  UnexpectedPrivateField: "Unexpected private name.",
	  UnexpectedReservedWord: ({
	    reservedWord
	  }) => `Unexpected reserved word '${reservedWord}'.`,
	  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
	  UnexpectedToken: ({
	    expected,
	    unexpected
	  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
	  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
	  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
	  UnsupportedBind: "Binding should be performed on object property.",
	  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
	  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
	  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
	  UnsupportedMetaProperty: ({
	    target,
	    onlyValidPropertyName
	  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
	  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
	  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
	  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
	  UnterminatedComment: "Unterminated comment.",
	  UnterminatedRegExp: "Unterminated regular expression.",
	  UnterminatedString: "Unterminated string constant.",
	  UnterminatedTemplate: "Unterminated template.",
	  UsingDeclarationExport: "Using declaration cannot be exported.",
	  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
	  VarRedeclaration: ({
	    identifierName
	  }) => `Identifier '${identifierName}' has already been declared.`,
	  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
	  YieldInParameter: "Yield expression is not allowed in formal parameters.",
	  YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
	  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
	};
	var StrictModeErrors = {
	  StrictDelete: "Deleting local variable in strict mode.",
	  StrictEvalArguments: ({
	    referenceName
	  }) => `Assigning to '${referenceName}' in strict mode.`,
	  StrictEvalArgumentsBinding: ({
	    bindingName
	  }) => `Binding '${bindingName}' in strict mode.`,
	  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
	  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
	  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
	  StrictWith: "'with' in strict mode."
	};
	const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
	var PipelineOperatorErrors = Object.assign({
	  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
	  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
	  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
	  PipeTopicUnconfiguredToken: ({
	    token
	  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
	  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
	  PipeUnparenthesizedBody: ({
	    type
	  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
	    type
	  })}; please wrap it in parentheses.`
	}, {
	  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
	  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
	  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
	  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
	  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
	  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
	});
	const _excluded = ["message"];
	function defineHidden(obj, key, value) {
	  Object.defineProperty(obj, key, {
	    enumerable: false,
	    configurable: true,
	    value
	  });
	}
	function toParseErrorConstructor({
	  toMessage,
	  code: code2,
	  reasonCode,
	  syntaxPlugin
	}) {
	  const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
	  {
	    const oldReasonCodes = {
	      AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
	      AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
	      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
	      SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
	      SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
	      SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
	    };
	    if (oldReasonCodes[reasonCode]) {
	      reasonCode = oldReasonCodes[reasonCode];
	    }
	  }
	  return function constructor(loc, details) {
	    const error = new SyntaxError();
	    error.code = code2;
	    error.reasonCode = reasonCode;
	    error.loc = loc;
	    error.pos = loc.index;
	    error.syntaxPlugin = syntaxPlugin;
	    if (hasMissingPlugin) {
	      error.missingPlugin = details.missingPlugin;
	    }
	    defineHidden(error, "clone", function clone(overrides = {}) {
	      var _overrides$loc;
	      const {
	        line,
	        column,
	        index
	      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
	      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
	    });
	    defineHidden(error, "details", details);
	    Object.defineProperty(error, "message", {
	      configurable: true,
	      get() {
	        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
	        this.message = message;
	        return message;
	      },
	      set(value) {
	        Object.defineProperty(this, "message", {
	          value,
	          writable: true
	        });
	      }
	    });
	    return error;
	  };
	}
	function ParseErrorEnum(argument, syntaxPlugin) {
	  if (Array.isArray(argument)) {
	    return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
	  }
	  const ParseErrorConstructors = {};
	  for (const reasonCode of Object.keys(argument)) {
	    const template = argument[reasonCode];
	    const _ref = typeof template === "string" ? {
	      message: () => template
	    } : typeof template === "function" ? {
	      message: template
	    } : template, {
	      message
	    } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
	    const toMessage = typeof message === "string" ? () => message : message;
	    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
	      code: "BABEL_PARSER_SYNTAX_ERROR",
	      reasonCode,
	      toMessage
	    }, syntaxPlugin ? {
	      syntaxPlugin
	    } : {}, rest));
	  }
	  return ParseErrorConstructors;
	}
	const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
	function createDefaultOptions() {
	  return {
	    sourceType: "script",
	    sourceFilename: void 0,
	    startIndex: 0,
	    startColumn: 0,
	    startLine: 1,
	    allowAwaitOutsideFunction: false,
	    allowReturnOutsideFunction: false,
	    allowNewTargetOutsideFunction: false,
	    allowImportExportEverywhere: false,
	    allowSuperOutsideMethod: false,
	    allowUndeclaredExports: false,
	    allowYieldOutsideFunction: false,
	    plugins: [],
	    strictMode: null,
	    ranges: false,
	    tokens: false,
	    createImportExpressions: false,
	    createParenthesizedExpressions: false,
	    errorRecovery: false,
	    attachComment: true,
	    annexB: true
	  };
	}
	function getOptions(opts) {
	  const options = createDefaultOptions();
	  if (opts == null) {
	    return options;
	  }
	  if (opts.annexB != null && opts.annexB !== false) {
	    throw new Error("The `annexB` option can only be set to `false`.");
	  }
	  for (const key of Object.keys(options)) {
	    if (opts[key] != null) options[key] = opts[key];
	  }
	  if (options.startLine === 1) {
	    if (opts.startIndex == null && options.startColumn > 0) {
	      options.startIndex = options.startColumn;
	    } else if (opts.startColumn == null && options.startIndex > 0) {
	      options.startColumn = options.startIndex;
	    }
	  } else if (opts.startColumn == null || opts.startIndex == null) {
	    if (opts.startIndex != null) {
	      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
	    }
	  }
	  return options;
	}
	const {
	  defineProperty
	} = Object;
	const toUnenumerable = (object, key) => {
	  if (object) {
	    defineProperty(object, key, {
	      enumerable: false,
	      value: object[key]
	    });
	  }
	};
	function toESTreeLocation(node) {
	  toUnenumerable(node.loc.start, "index");
	  toUnenumerable(node.loc.end, "index");
	  return node;
	}
	var estree = (superClass) => class ESTreeParserMixin extends superClass {
	  parse() {
	    const file = toESTreeLocation(super.parse());
	    if (this.optionFlags & 256) {
	      file.tokens = file.tokens.map(toESTreeLocation);
	    }
	    return file;
	  }
	  parseRegExpLiteral({
	    pattern,
	    flags
	  }) {
	    let regex = null;
	    try {
	      regex = new RegExp(pattern, flags);
	    } catch (_) {
	    }
	    const node = this.estreeParseLiteral(regex);
	    node.regex = {
	      pattern,
	      flags
	    };
	    return node;
	  }
	  parseBigIntLiteral(value) {
	    let bigInt;
	    try {
	      bigInt = BigInt(value);
	    } catch (_unused) {
	      bigInt = null;
	    }
	    const node = this.estreeParseLiteral(bigInt);
	    node.bigint = String(node.value || value);
	    return node;
	  }
	  parseDecimalLiteral(value) {
	    const decimal = null;
	    const node = this.estreeParseLiteral(decimal);
	    node.decimal = String(node.value || value);
	    return node;
	  }
	  estreeParseLiteral(value) {
	    return this.parseLiteral(value, "Literal");
	  }
	  parseStringLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  parseNumericLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  parseNullLiteral() {
	    return this.estreeParseLiteral(null);
	  }
	  parseBooleanLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  estreeParseChainExpression(node, endLoc) {
	    const chain = this.startNodeAtNode(node);
	    chain.expression = node;
	    return this.finishNodeAt(chain, "ChainExpression", endLoc);
	  }
	  directiveToStmt(directive) {
	    const expression = directive.value;
	    delete directive.value;
	    this.castNodeTo(expression, "Literal");
	    expression.raw = expression.extra.raw;
	    expression.value = expression.extra.expressionValue;
	    const stmt = this.castNodeTo(directive, "ExpressionStatement");
	    stmt.expression = expression;
	    stmt.directive = expression.extra.rawValue;
	    delete expression.extra;
	    return stmt;
	  }
	  fillOptionalPropertiesForTSESLint(node) {
	  }
	  cloneEstreeStringLiteral(node) {
	    const {
	      start,
	      end,
	      loc,
	      range,
	      raw,
	      value
	    } = node;
	    const cloned = Object.create(node.constructor.prototype);
	    cloned.type = "Literal";
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.raw = raw;
	    cloned.value = value;
	    return cloned;
	  }
	  initFunction(node, isAsync) {
	    super.initFunction(node, isAsync);
	    node.expression = false;
	  }
	  checkDeclaration(node) {
	    if (node != null && this.isObjectProperty(node)) {
	      this.checkDeclaration(node.value);
	    } else {
	      super.checkDeclaration(node);
	    }
	  }
	  getObjectOrClassMethodParams(method) {
	    return method.value.params;
	  }
	  isValidDirective(stmt) {
	    var _stmt$expression$extr;
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
	  }
	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
	    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
	    const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
	    node.body = directiveStatements.concat(node.body);
	    delete node.directives;
	  }
	  parsePrivateName() {
	    const node = super.parsePrivateName();
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return node;
	      }
	    }
	    return this.convertPrivateNameToPrivateIdentifier(node);
	  }
	  convertPrivateNameToPrivateIdentifier(node) {
	    const name = super.getPrivateNameSV(node);
	    node = node;
	    delete node.id;
	    node.name = name;
	    return this.castNodeTo(node, "PrivateIdentifier");
	  }
	  isPrivateName(node) {
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return super.isPrivateName(node);
	      }
	    }
	    return node.type === "PrivateIdentifier";
	  }
	  getPrivateNameSV(node) {
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return super.getPrivateNameSV(node);
	      }
	    }
	    return node.name;
	  }
	  parseLiteral(value, type) {
	    const node = super.parseLiteral(value, type);
	    node.raw = node.extra.raw;
	    delete node.extra;
	    return node;
	  }
	  parseFunctionBody(node, allowExpression, isMethod = false) {
	    super.parseFunctionBody(node, allowExpression, isMethod);
	    node.expression = node.body.type !== "BlockStatement";
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
	    let funcNode = this.startNode();
	    funcNode.kind = node.kind;
	    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
	    delete funcNode.kind;
	    const {
	      typeParameters
	    } = node;
	    if (typeParameters) {
	      delete node.typeParameters;
	      funcNode.typeParameters = typeParameters;
	      this.resetStartLocationFromNode(funcNode, typeParameters);
	    }
	    const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
	    node.value = valueNode;
	    if (type === "ClassPrivateMethod") {
	      node.computed = false;
	    }
	    if (type === "ObjectMethod") {
	      if (node.kind === "method") {
	        node.kind = "init";
	      }
	      node.shorthand = false;
	      return this.finishNode(node, "Property");
	    } else {
	      return this.finishNode(node, "MethodDefinition");
	    }
	  }
	  nameIsConstructor(key) {
	    if (key.type === "Literal") return key.value === "constructor";
	    return super.nameIsConstructor(key);
	  }
	  parseClassProperty(...args) {
	    const propertyNode = super.parseClassProperty(...args);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return propertyNode;
	      }
	    }
	    {
	      this.castNodeTo(propertyNode, "PropertyDefinition");
	    }
	    return propertyNode;
	  }
	  parseClassPrivateProperty(...args) {
	    const propertyNode = super.parseClassPrivateProperty(...args);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return propertyNode;
	      }
	    }
	    {
	      this.castNodeTo(propertyNode, "PropertyDefinition");
	    }
	    propertyNode.computed = false;
	    return propertyNode;
	  }
	  parseClassAccessorProperty(node) {
	    const accessorPropertyNode = super.parseClassAccessorProperty(node);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return accessorPropertyNode;
	      }
	    }
	    if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
	      delete accessorPropertyNode.abstract;
	      this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
	    } else {
	      this.castNodeTo(accessorPropertyNode, "AccessorProperty");
	    }
	    return accessorPropertyNode;
	  }
	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
	    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
	    if (node) {
	      node.kind = "init";
	      this.castNodeTo(node, "Property");
	    }
	    return node;
	  }
	  finishObjectProperty(node) {
	    node.kind = "init";
	    return this.finishNode(node, "Property");
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
	  }
	  isAssignable(node, isBinding) {
	    if (node != null && this.isObjectProperty(node)) {
	      return this.isAssignable(node.value, isBinding);
	    }
	    return super.isAssignable(node, isBinding);
	  }
	  toAssignable(node, isLHS = false) {
	    if (node != null && this.isObjectProperty(node)) {
	      const {
	        key,
	        value
	      } = node;
	      if (this.isPrivateName(key)) {
	        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
	      }
	      this.toAssignable(value, isLHS);
	    } else {
	      super.toAssignable(node, isLHS);
	    }
	  }
	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
	    if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
	      this.raise(Errors.PatternHasAccessor, prop.key);
	    } else if (prop.type === "Property" && prop.method) {
	      this.raise(Errors.PatternHasMethod, prop.key);
	    } else {
	      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
	    }
	  }
	  finishCallExpression(unfinished, optional) {
	    const node = super.finishCallExpression(unfinished, optional);
	    if (node.callee.type === "Import") {
	      var _ref, _ref2;
	      this.castNodeTo(node, "ImportExpression");
	      node.source = node.arguments[0];
	      node.options = (_ref = node.arguments[1]) != null ? _ref : null;
	      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
	      delete node.arguments;
	      delete node.callee;
	    } else if (node.type === "OptionalCallExpression") {
	      this.castNodeTo(node, "CallExpression");
	    } else {
	      node.optional = false;
	    }
	    return node;
	  }
	  toReferencedArguments(node) {
	    if (node.type === "ImportExpression") {
	      return;
	    }
	    super.toReferencedArguments(node);
	  }
	  parseExport(unfinished, decorators) {
	    const exportStartLoc = this.state.lastTokStartLoc;
	    const node = super.parseExport(unfinished, decorators);
	    switch (node.type) {
	      case "ExportAllDeclaration":
	        node.exported = null;
	        break;
	      case "ExportNamedDeclaration":
	        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
	          this.castNodeTo(node, "ExportAllDeclaration");
	          node.exported = node.specifiers[0].exported;
	          delete node.specifiers;
	        }
	      case "ExportDefaultDeclaration":
	        {
	          var _declaration$decorato;
	          const {
	            declaration
	          } = node;
	          if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
	            this.resetStartLocation(node, exportStartLoc);
	          }
	        }
	        break;
	    }
	    return node;
	  }
	  stopParseSubscript(base, state) {
	    const node = super.stopParseSubscript(base, state);
	    if (state.optionalChainMember) {
	      return this.estreeParseChainExpression(node, base.loc.end);
	    }
	    return node;
	  }
	  parseMember(base, startLoc, state, computed, optional) {
	    const node = super.parseMember(base, startLoc, state, computed, optional);
	    if (node.type === "OptionalMemberExpression") {
	      this.castNodeTo(node, "MemberExpression");
	    } else {
	      node.optional = false;
	    }
	    return node;
	  }
	  isOptionalMemberExpression(node) {
	    if (node.type === "ChainExpression") {
	      return node.expression.type === "MemberExpression";
	    }
	    return super.isOptionalMemberExpression(node);
	  }
	  hasPropertyAsPrivateName(node) {
	    if (node.type === "ChainExpression") {
	      node = node.expression;
	    }
	    return super.hasPropertyAsPrivateName(node);
	  }
	  isObjectProperty(node) {
	    return node.type === "Property" && node.kind === "init" && !node.method;
	  }
	  isObjectMethod(node) {
	    return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
	  }
	  castNodeTo(node, type) {
	    const result = super.castNodeTo(node, type);
	    this.fillOptionalPropertiesForTSESLint(result);
	    return result;
	  }
	  cloneIdentifier(node) {
	    const cloned = super.cloneIdentifier(node);
	    this.fillOptionalPropertiesForTSESLint(cloned);
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    if (node.type === "Literal") {
	      return this.cloneEstreeStringLiteral(node);
	    }
	    return super.cloneStringLiteral(node);
	  }
	  finishNodeAt(node, type, endLoc) {
	    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
	  }
	  finishNode(node, type) {
	    const result = super.finishNode(node, type);
	    this.fillOptionalPropertiesForTSESLint(result);
	    return result;
	  }
	  resetStartLocation(node, startLoc) {
	    super.resetStartLocation(node, startLoc);
	    toESTreeLocation(node);
	  }
	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
	    super.resetEndLocation(node, endLoc);
	    toESTreeLocation(node);
	  }
	};
	class TokContext {
	  constructor(token, preserveSpace) {
	    this.token = void 0;
	    this.preserveSpace = void 0;
	    this.token = token;
	    this.preserveSpace = !!preserveSpace;
	  }
	}
	const types = {
	  brace: new TokContext("{"),
	  j_oTag: new TokContext("<tag"),
	  j_cTag: new TokContext("</tag"),
	  j_expr: new TokContext("<tag>...</tag>", true)
	};
	{
	  types.template = new TokContext("`", true);
	}
	const beforeExpr = true;
	const startsExpr = true;
	const isLoop = true;
	const isAssign = true;
	const prefix = true;
	const postfix = true;
	class ExportedTokenType {
	  constructor(label, conf = {}) {
	    this.label = void 0;
	    this.keyword = void 0;
	    this.beforeExpr = void 0;
	    this.startsExpr = void 0;
	    this.rightAssociative = void 0;
	    this.isLoop = void 0;
	    this.isAssign = void 0;
	    this.prefix = void 0;
	    this.postfix = void 0;
	    this.binop = void 0;
	    this.label = label;
	    this.keyword = conf.keyword;
	    this.beforeExpr = !!conf.beforeExpr;
	    this.startsExpr = !!conf.startsExpr;
	    this.rightAssociative = !!conf.rightAssociative;
	    this.isLoop = !!conf.isLoop;
	    this.isAssign = !!conf.isAssign;
	    this.prefix = !!conf.prefix;
	    this.postfix = !!conf.postfix;
	    this.binop = conf.binop != null ? conf.binop : null;
	    {
	      this.updateContext = null;
	    }
	  }
	}
	const keywords$1 = /* @__PURE__ */ new Map();
	function createKeyword(name, options = {}) {
	  options.keyword = name;
	  const token = createToken(name, options);
	  keywords$1.set(name, token);
	  return token;
	}
	function createBinop(name, binop) {
	  return createToken(name, {
	    beforeExpr,
	    binop
	  });
	}
	let tokenTypeCounter = -1;
	const tokenTypes = [];
	const tokenLabels = [];
	const tokenBinops = [];
	const tokenBeforeExprs = [];
	const tokenStartsExprs = [];
	const tokenPrefixes = [];
	function createToken(name, options = {}) {
	  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
	  ++tokenTypeCounter;
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
	  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
	  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
	  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
	  tokenTypes.push(new ExportedTokenType(name, options));
	  return tokenTypeCounter;
	}
	function createKeywordLike(name, options = {}) {
	  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
	  ++tokenTypeCounter;
	  keywords$1.set(name, tokenTypeCounter);
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
	  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
	  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
	  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
	  tokenTypes.push(new ExportedTokenType("name", options));
	  return tokenTypeCounter;
	}
	const tt = {
	  bracketL: createToken("[", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketHashL: createToken("#[", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketBarL: createToken("[|", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketR: createToken("]"),
	  bracketBarR: createToken("|]"),
	  braceL: createToken("{", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceBarL: createToken("{|", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceHashL: createToken("#{", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceR: createToken("}"),
	  braceBarR: createToken("|}"),
	  parenL: createToken("(", {
	    beforeExpr,
	    startsExpr
	  }),
	  parenR: createToken(")"),
	  comma: createToken(",", {
	    beforeExpr
	  }),
	  semi: createToken(";", {
	    beforeExpr
	  }),
	  colon: createToken(":", {
	    beforeExpr
	  }),
	  doubleColon: createToken("::", {
	    beforeExpr
	  }),
	  dot: createToken("."),
	  question: createToken("?", {
	    beforeExpr
	  }),
	  questionDot: createToken("?."),
	  arrow: createToken("=>", {
	    beforeExpr
	  }),
	  template: createToken("template"),
	  ellipsis: createToken("...", {
	    beforeExpr
	  }),
	  backQuote: createToken("`", {
	    startsExpr
	  }),
	  dollarBraceL: createToken("${", {
	    beforeExpr,
	    startsExpr
	  }),
	  templateTail: createToken("...`", {
	    startsExpr
	  }),
	  templateNonTail: createToken("...${", {
	    beforeExpr,
	    startsExpr
	  }),
	  at: createToken("@"),
	  hash: createToken("#", {
	    startsExpr
	  }),
	  interpreterDirective: createToken("#!..."),
	  eq: createToken("=", {
	    beforeExpr,
	    isAssign
	  }),
	  assign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  slashAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  xorAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  moduloAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  incDec: createToken("++/--", {
	    prefix,
	    postfix,
	    startsExpr
	  }),
	  bang: createToken("!", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  tilde: createToken("~", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  doubleCaret: createToken("^^", {
	    startsExpr
	  }),
	  doubleAt: createToken("@@", {
	    startsExpr
	  }),
	  pipeline: createBinop("|>", 0),
	  nullishCoalescing: createBinop("??", 1),
	  logicalOR: createBinop("||", 1),
	  logicalAND: createBinop("&&", 2),
	  bitwiseOR: createBinop("|", 3),
	  bitwiseXOR: createBinop("^", 4),
	  bitwiseAND: createBinop("&", 5),
	  equality: createBinop("==/!=/===/!==", 6),
	  lt: createBinop("</>/<=/>=", 7),
	  gt: createBinop("</>/<=/>=", 7),
	  relational: createBinop("</>/<=/>=", 7),
	  bitShift: createBinop("<</>>/>>>", 8),
	  bitShiftL: createBinop("<</>>/>>>", 8),
	  bitShiftR: createBinop("<</>>/>>>", 8),
	  plusMin: createToken("+/-", {
	    beforeExpr,
	    binop: 9,
	    prefix,
	    startsExpr
	  }),
	  modulo: createToken("%", {
	    binop: 10,
	    startsExpr
	  }),
	  star: createToken("*", {
	    binop: 10
	  }),
	  slash: createBinop("/", 10),
	  exponent: createToken("**", {
	    beforeExpr,
	    binop: 11,
	    rightAssociative: true
	  }),
	  _in: createKeyword("in", {
	    beforeExpr,
	    binop: 7
	  }),
	  _instanceof: createKeyword("instanceof", {
	    beforeExpr,
	    binop: 7
	  }),
	  _break: createKeyword("break"),
	  _case: createKeyword("case", {
	    beforeExpr
	  }),
	  _catch: createKeyword("catch"),
	  _continue: createKeyword("continue"),
	  _debugger: createKeyword("debugger"),
	  _default: createKeyword("default", {
	    beforeExpr
	  }),
	  _else: createKeyword("else", {
	    beforeExpr
	  }),
	  _finally: createKeyword("finally"),
	  _function: createKeyword("function", {
	    startsExpr
	  }),
	  _if: createKeyword("if"),
	  _return: createKeyword("return", {
	    beforeExpr
	  }),
	  _switch: createKeyword("switch"),
	  _throw: createKeyword("throw", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _try: createKeyword("try"),
	  _var: createKeyword("var"),
	  _const: createKeyword("const"),
	  _with: createKeyword("with"),
	  _new: createKeyword("new", {
	    beforeExpr,
	    startsExpr
	  }),
	  _this: createKeyword("this", {
	    startsExpr
	  }),
	  _super: createKeyword("super", {
	    startsExpr
	  }),
	  _class: createKeyword("class", {
	    startsExpr
	  }),
	  _extends: createKeyword("extends", {
	    beforeExpr
	  }),
	  _export: createKeyword("export"),
	  _import: createKeyword("import", {
	    startsExpr
	  }),
	  _null: createKeyword("null", {
	    startsExpr
	  }),
	  _true: createKeyword("true", {
	    startsExpr
	  }),
	  _false: createKeyword("false", {
	    startsExpr
	  }),
	  _typeof: createKeyword("typeof", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _void: createKeyword("void", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _delete: createKeyword("delete", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _do: createKeyword("do", {
	    isLoop,
	    beforeExpr
	  }),
	  _for: createKeyword("for", {
	    isLoop
	  }),
	  _while: createKeyword("while", {
	    isLoop
	  }),
	  _as: createKeywordLike("as", {
	    startsExpr
	  }),
	  _assert: createKeywordLike("assert", {
	    startsExpr
	  }),
	  _async: createKeywordLike("async", {
	    startsExpr
	  }),
	  _await: createKeywordLike("await", {
	    startsExpr
	  }),
	  _defer: createKeywordLike("defer", {
	    startsExpr
	  }),
	  _from: createKeywordLike("from", {
	    startsExpr
	  }),
	  _get: createKeywordLike("get", {
	    startsExpr
	  }),
	  _let: createKeywordLike("let", {
	    startsExpr
	  }),
	  _meta: createKeywordLike("meta", {
	    startsExpr
	  }),
	  _of: createKeywordLike("of", {
	    startsExpr
	  }),
	  _sent: createKeywordLike("sent", {
	    startsExpr
	  }),
	  _set: createKeywordLike("set", {
	    startsExpr
	  }),
	  _source: createKeywordLike("source", {
	    startsExpr
	  }),
	  _static: createKeywordLike("static", {
	    startsExpr
	  }),
	  _using: createKeywordLike("using", {
	    startsExpr
	  }),
	  _yield: createKeywordLike("yield", {
	    startsExpr
	  }),
	  _asserts: createKeywordLike("asserts", {
	    startsExpr
	  }),
	  _checks: createKeywordLike("checks", {
	    startsExpr
	  }),
	  _exports: createKeywordLike("exports", {
	    startsExpr
	  }),
	  _global: createKeywordLike("global", {
	    startsExpr
	  }),
	  _implements: createKeywordLike("implements", {
	    startsExpr
	  }),
	  _intrinsic: createKeywordLike("intrinsic", {
	    startsExpr
	  }),
	  _infer: createKeywordLike("infer", {
	    startsExpr
	  }),
	  _is: createKeywordLike("is", {
	    startsExpr
	  }),
	  _mixins: createKeywordLike("mixins", {
	    startsExpr
	  }),
	  _proto: createKeywordLike("proto", {
	    startsExpr
	  }),
	  _require: createKeywordLike("require", {
	    startsExpr
	  }),
	  _satisfies: createKeywordLike("satisfies", {
	    startsExpr
	  }),
	  _keyof: createKeywordLike("keyof", {
	    startsExpr
	  }),
	  _readonly: createKeywordLike("readonly", {
	    startsExpr
	  }),
	  _unique: createKeywordLike("unique", {
	    startsExpr
	  }),
	  _abstract: createKeywordLike("abstract", {
	    startsExpr
	  }),
	  _declare: createKeywordLike("declare", {
	    startsExpr
	  }),
	  _enum: createKeywordLike("enum", {
	    startsExpr
	  }),
	  _module: createKeywordLike("module", {
	    startsExpr
	  }),
	  _namespace: createKeywordLike("namespace", {
	    startsExpr
	  }),
	  _interface: createKeywordLike("interface", {
	    startsExpr
	  }),
	  _type: createKeywordLike("type", {
	    startsExpr
	  }),
	  _opaque: createKeywordLike("opaque", {
	    startsExpr
	  }),
	  name: createToken("name", {
	    startsExpr
	  }),
	  placeholder: createToken("%%", {
	    startsExpr: true
	  }),
	  string: createToken("string", {
	    startsExpr
	  }),
	  num: createToken("num", {
	    startsExpr
	  }),
	  bigint: createToken("bigint", {
	    startsExpr
	  }),
	  decimal: createToken("decimal", {
	    startsExpr
	  }),
	  regexp: createToken("regexp", {
	    startsExpr
	  }),
	  privateName: createToken("#name", {
	    startsExpr
	  }),
	  eof: createToken("eof"),
	  jsxName: createToken("jsxName"),
	  jsxText: createToken("jsxText", {
	    beforeExpr: true
	  }),
	  jsxTagStart: createToken("jsxTagStart", {
	    startsExpr: true
	  }),
	  jsxTagEnd: createToken("jsxTagEnd")
	};
	function tokenIsIdentifier(token) {
	  return token >= 93 && token <= 133;
	}
	function tokenKeywordOrIdentifierIsKeyword(token) {
	  return token <= 92;
	}
	function tokenIsKeywordOrIdentifier(token) {
	  return token >= 58 && token <= 133;
	}
	function tokenIsLiteralPropertyName(token) {
	  return token >= 58 && token <= 137;
	}
	function tokenComesBeforeExpression(token) {
	  return tokenBeforeExprs[token];
	}
	function tokenCanStartExpression(token) {
	  return tokenStartsExprs[token];
	}
	function tokenIsAssignment(token) {
	  return token >= 29 && token <= 33;
	}
	function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
	  return token >= 129 && token <= 131;
	}
	function tokenIsLoop(token) {
	  return token >= 90 && token <= 92;
	}
	function tokenIsKeyword(token) {
	  return token >= 58 && token <= 92;
	}
	function tokenIsOperator(token) {
	  return token >= 39 && token <= 59;
	}
	function tokenIsPostfix(token) {
	  return token === 34;
	}
	function tokenIsPrefix(token) {
	  return tokenPrefixes[token];
	}
	function tokenIsTSTypeOperator(token) {
	  return token >= 121 && token <= 123;
	}
	function tokenIsTSDeclarationStart(token) {
	  return token >= 124 && token <= 130;
	}
	function tokenLabelName(token) {
	  return tokenLabels[token];
	}
	function tokenOperatorPrecedence(token) {
	  return tokenBinops[token];
	}
	function tokenIsRightAssociative(token) {
	  return token === 57;
	}
	function tokenIsTemplate(token) {
	  return token >= 24 && token <= 25;
	}
	function getExportedToken(token) {
	  return tokenTypes[token];
	}
	{
	  tokenTypes[8].updateContext = (context) => {
	    context.pop();
	  };
	  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
	    context.push(types.brace);
	  };
	  tokenTypes[22].updateContext = (context) => {
	    if (context[context.length - 1] === types.template) {
	      context.pop();
	    } else {
	      context.push(types.template);
	    }
	  };
	  tokenTypes[143].updateContext = (context) => {
	    context.push(types.j_expr, types.j_oTag);
	  };
	}
	let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
	let nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
	function isInAstralSet(code2, set) {
	  let pos = 65536;
	  for (let i = 0, length = set.length; i < length; i += 2) {
	    pos += set[i];
	    if (pos > code2) return false;
	    pos += set[i + 1];
	    if (pos >= code2) return true;
	  }
	  return false;
	}
	function isIdentifierStart(code2) {
	  if (code2 < 65) return code2 === 36;
	  if (code2 <= 90) return true;
	  if (code2 < 97) return code2 === 95;
	  if (code2 <= 122) return true;
	  if (code2 <= 65535) {
	    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
	  }
	  return isInAstralSet(code2, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code2) {
	  if (code2 < 48) return code2 === 36;
	  if (code2 < 58) return true;
	  if (code2 < 65) return false;
	  if (code2 <= 90) return true;
	  if (code2 < 97) return code2 === 95;
	  if (code2 <= 122) return true;
	  if (code2 <= 65535) {
	    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
	  }
	  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
	}
	const reservedWords = {
	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
	  strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
	  return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
	  return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
	  return keywords.has(word);
	}
	function isIteratorStart(current, next, next2) {
	  return current === 64 && next === 64 && isIdentifierStart(next2);
	}
	const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
	function canBeReservedWord(word) {
	  return reservedWordLikeSet.has(word);
	}
	class Scope {
	  constructor(flags) {
	    this.flags = 0;
	    this.names = /* @__PURE__ */ new Map();
	    this.firstLexicalName = "";
	    this.flags = flags;
	  }
	}
	class ScopeHandler {
	  constructor(parser, inModule) {
	    this.parser = void 0;
	    this.scopeStack = [];
	    this.inModule = void 0;
	    this.undefinedExports = /* @__PURE__ */ new Map();
	    this.parser = parser;
	    this.inModule = inModule;
	  }
	  get inTopLevel() {
	    return (this.currentScope().flags & 1) > 0;
	  }
	  get inFunction() {
	    return (this.currentVarScopeFlags() & 2) > 0;
	  }
	  get allowSuper() {
	    return (this.currentThisScopeFlags() & 16) > 0;
	  }
	  get allowDirectSuper() {
	    return (this.currentThisScopeFlags() & 32) > 0;
	  }
	  get inClass() {
	    return (this.currentThisScopeFlags() & 64) > 0;
	  }
	  get inClassAndNotInNonArrowFunction() {
	    const flags = this.currentThisScopeFlags();
	    return (flags & 64) > 0 && (flags & 2) === 0;
	  }
	  get inStaticBlock() {
	    for (let i = this.scopeStack.length - 1; ; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & 128) {
	        return true;
	      }
	      if (flags & (387 | 64)) {
	        return false;
	      }
	    }
	  }
	  get inNonArrowFunction() {
	    return (this.currentThisScopeFlags() & 2) > 0;
	  }
	  get treatFunctionsAsVar() {
	    return this.treatFunctionsAsVarInScope(this.currentScope());
	  }
	  createScope(flags) {
	    return new Scope(flags);
	  }
	  enter(flags) {
	    this.scopeStack.push(this.createScope(flags));
	  }
	  exit() {
	    const scope = this.scopeStack.pop();
	    return scope.flags;
	  }
	  treatFunctionsAsVarInScope(scope) {
	    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
	  }
	  declareName(name, bindingType, loc) {
	    let scope = this.currentScope();
	    if (bindingType & 8 || bindingType & 16) {
	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
	      let type = scope.names.get(name) || 0;
	      if (bindingType & 16) {
	        type = type | 4;
	      } else {
	        if (!scope.firstLexicalName) {
	          scope.firstLexicalName = name;
	        }
	        type = type | 2;
	      }
	      scope.names.set(name, type);
	      if (bindingType & 8) {
	        this.maybeExportDefined(scope, name);
	      }
	    } else if (bindingType & 4) {
	      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
	        scope = this.scopeStack[i];
	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
	        scope.names.set(name, (scope.names.get(name) || 0) | 1);
	        this.maybeExportDefined(scope, name);
	        if (scope.flags & 387) break;
	      }
	    }
	    if (this.parser.inModule && scope.flags & 1) {
	      this.undefinedExports.delete(name);
	    }
	  }
	  maybeExportDefined(scope, name) {
	    if (this.parser.inModule && scope.flags & 1) {
	      this.undefinedExports.delete(name);
	    }
	  }
	  checkRedeclarationInScope(scope, name, bindingType, loc) {
	    if (this.isRedeclaredInScope(scope, name, bindingType)) {
	      this.parser.raise(Errors.VarRedeclaration, loc, {
	        identifierName: name
	      });
	    }
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    if (!(bindingType & 1)) return false;
	    if (bindingType & 8) {
	      return scope.names.has(name);
	    }
	    const type = scope.names.get(name);
	    if (bindingType & 16) {
	      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
	    }
	    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
	  }
	  checkLocalExport(id) {
	    const {
	      name
	    } = id;
	    const topLevelScope = this.scopeStack[0];
	    if (!topLevelScope.names.has(name)) {
	      this.undefinedExports.set(name, id.loc.start);
	    }
	  }
	  currentScope() {
	    return this.scopeStack[this.scopeStack.length - 1];
	  }
	  currentVarScopeFlags() {
	    for (let i = this.scopeStack.length - 1; ; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & 387) {
	        return flags;
	      }
	    }
	  }
	  currentThisScopeFlags() {
	    for (let i = this.scopeStack.length - 1; ; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & (387 | 64) && !(flags & 4)) {
	        return flags;
	      }
	    }
	  }
	}
	class FlowScope extends Scope {
	  constructor(...args) {
	    super(...args);
	    this.declareFunctions = /* @__PURE__ */ new Set();
	  }
	}
	class FlowScopeHandler extends ScopeHandler {
	  createScope(flags) {
	    return new FlowScope(flags);
	  }
	  declareName(name, bindingType, loc) {
	    const scope = this.currentScope();
	    if (bindingType & 2048) {
	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
	      this.maybeExportDefined(scope, name);
	      scope.declareFunctions.add(name);
	      return;
	    }
	    super.declareName(name, bindingType, loc);
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
	    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
	      const type = scope.names.get(name);
	      return (type & 4) > 0 || (type & 2) > 0;
	    }
	    return false;
	  }
	  checkLocalExport(id) {
	    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
	      super.checkLocalExport(id);
	    }
	  }
	}
	const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
	const FlowErrors = ParseErrorEnum`flow`({
	  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
	  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
	  AssignReservedType: ({
	    reservedType
	  }) => `Cannot overwrite reserved type ${reservedType}.`,
	  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
	  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
	  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
	  EnumBooleanMemberNotInitialized: ({
	    memberName,
	    enumName
	  }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
	  EnumDuplicateMemberName: ({
	    memberName,
	    enumName
	  }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
	  EnumInconsistentMemberValues: ({
	    enumName
	  }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
	  EnumInvalidExplicitType: ({
	    invalidEnumType,
	    enumName
	  }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
	  EnumInvalidExplicitTypeUnknownSupplied: ({
	    enumName
	  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
	  EnumInvalidMemberInitializerPrimaryType: ({
	    enumName,
	    memberName,
	    explicitType
	  }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
	  EnumInvalidMemberInitializerSymbolType: ({
	    enumName,
	    memberName
	  }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
	  EnumInvalidMemberInitializerUnknownType: ({
	    enumName,
	    memberName
	  }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
	  EnumInvalidMemberName: ({
	    enumName,
	    memberName,
	    suggestion
	  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
	  EnumNumberMemberNotInitialized: ({
	    enumName,
	    memberName
	  }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
	  EnumStringMemberInconsistentlyInitialized: ({
	    enumName
	  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
	  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
	  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
	  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
	  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
	  InexactVariance: "Explicit inexact syntax cannot have variance.",
	  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
	  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
	  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
	  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
	  PatternIsOptional: Object.assign({
	    message: "A binding pattern parameter cannot be optional in an implementation signature."
	  }, {
	    reasonCode: "OptionalBindingPattern"
	  }),
	  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
	  SpreadVariance: "Spread properties cannot have variance.",
	  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
	  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
	  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
	  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
	  ThisParamNoDefault: "The `this` parameter may not have a default value.",
	  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
	  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
	  UnexpectedReservedType: ({
	    reservedType
	  }) => `Unexpected reserved type ${reservedType}.`,
	  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
	  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
	  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
	  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
	  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
	  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
	  UnsupportedDeclareExportKind: ({
	    unsupportedExportKind,
	    suggestion
	  }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
	  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
	  UnterminatedFlowComment: "Unterminated flow-comment."
	});
	function isEsModuleType(bodyElement) {
	  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
	}
	function hasTypeImportKind(node) {
	  return node.importKind === "type" || node.importKind === "typeof";
	}
	const exportSuggestions = {
	  const: "declare export var",
	  let: "declare export var",
	  type: "export type",
	  interface: "export interface"
	};
	function partition(list, test) {
	  const list1 = [];
	  const list2 = [];
	  for (let i = 0; i < list.length; i++) {
	    (test(list[i], i, list) ? list1 : list2).push(list[i]);
	  }
	  return [list1, list2];
	}
	const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
	var flow = (superClass) => class FlowParserMixin extends superClass {
	  constructor(...args) {
	    super(...args);
	    this.flowPragma = void 0;
	  }
	  getScopeHandler() {
	    return FlowScopeHandler;
	  }
	  shouldParseTypes() {
	    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
	  }
	  finishToken(type, val) {
	    if (type !== 134 && type !== 13 && type !== 28) {
	      if (this.flowPragma === void 0) {
	        this.flowPragma = null;
	      }
	    }
	    super.finishToken(type, val);
	  }
	  addComment(comment) {
	    if (this.flowPragma === void 0) {
	      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
	      if (!matches) ;
	      else if (matches[1] === "flow") {
	        this.flowPragma = "flow";
	      } else if (matches[1] === "noflow") {
	        this.flowPragma = "noflow";
	      } else {
	        throw new Error("Unexpected flow pragma");
	      }
	    }
	    super.addComment(comment);
	  }
	  flowParseTypeInitialiser(tok) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    this.expect(tok || 14);
	    const type = this.flowParseType();
	    this.state.inType = oldInType;
	    return type;
	  }
	  flowParsePredicate() {
	    const node = this.startNode();
	    const moduloLoc = this.state.startLoc;
	    this.next();
	    this.expectContextual(110);
	    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
	      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
	    }
	    if (this.eat(10)) {
	      node.value = super.parseExpression();
	      this.expect(11);
	      return this.finishNode(node, "DeclaredPredicate");
	    } else {
	      return this.finishNode(node, "InferredPredicate");
	    }
	  }
	  flowParseTypeAndPredicateInitialiser() {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    this.expect(14);
	    let type = null;
	    let predicate = null;
	    if (this.match(54)) {
	      this.state.inType = oldInType;
	      predicate = this.flowParsePredicate();
	    } else {
	      type = this.flowParseType();
	      this.state.inType = oldInType;
	      if (this.match(54)) {
	        predicate = this.flowParsePredicate();
	      }
	    }
	    return [type, predicate];
	  }
	  flowParseDeclareClass(node) {
	    this.next();
	    this.flowParseInterfaceish(node, true);
	    return this.finishNode(node, "DeclareClass");
	  }
	  flowParseDeclareFunction(node) {
	    this.next();
	    const id = node.id = this.parseIdentifier();
	    const typeNode = this.startNode();
	    const typeContainer = this.startNode();
	    if (this.match(47)) {
	      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      typeNode.typeParameters = null;
	    }
	    this.expect(10);
	    const tmp = this.flowParseFunctionTypeParams();
	    typeNode.params = tmp.params;
	    typeNode.rest = tmp.rest;
	    typeNode.this = tmp._this;
	    this.expect(11);
	    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
	    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
	    this.resetEndLocation(id);
	    this.semicolon();
	    this.scope.declareName(node.id.name, 2048, node.id.loc.start);
	    return this.finishNode(node, "DeclareFunction");
	  }
	  flowParseDeclare(node, insideModule) {
	    if (this.match(80)) {
	      return this.flowParseDeclareClass(node);
	    } else if (this.match(68)) {
	      return this.flowParseDeclareFunction(node);
	    } else if (this.match(74)) {
	      return this.flowParseDeclareVariable(node);
	    } else if (this.eatContextual(127)) {
	      if (this.match(16)) {
	        return this.flowParseDeclareModuleExports(node);
	      } else {
	        if (insideModule) {
	          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
	        }
	        return this.flowParseDeclareModule(node);
	      }
	    } else if (this.isContextual(130)) {
	      return this.flowParseDeclareTypeAlias(node);
	    } else if (this.isContextual(131)) {
	      return this.flowParseDeclareOpaqueType(node);
	    } else if (this.isContextual(129)) {
	      return this.flowParseDeclareInterface(node);
	    } else if (this.match(82)) {
	      return this.flowParseDeclareExportDeclaration(node, insideModule);
	    } else {
	      this.unexpected();
	    }
	  }
	  flowParseDeclareVariable(node) {
	    this.next();
	    node.id = this.flowParseTypeAnnotatableIdentifier(true);
	    this.scope.declareName(node.id.name, 5, node.id.loc.start);
	    this.semicolon();
	    return this.finishNode(node, "DeclareVariable");
	  }
	  flowParseDeclareModule(node) {
	    this.scope.enter(0);
	    if (this.match(134)) {
	      node.id = super.parseExprAtom();
	    } else {
	      node.id = this.parseIdentifier();
	    }
	    const bodyNode = node.body = this.startNode();
	    const body = bodyNode.body = [];
	    this.expect(5);
	    while (!this.match(8)) {
	      let bodyNode2 = this.startNode();
	      if (this.match(83)) {
	        this.next();
	        if (!this.isContextual(130) && !this.match(87)) {
	          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
	        }
	        super.parseImport(bodyNode2);
	      } else {
	        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
	        bodyNode2 = this.flowParseDeclare(bodyNode2, true);
	      }
	      body.push(bodyNode2);
	    }
	    this.scope.exit();
	    this.expect(8);
	    this.finishNode(bodyNode, "BlockStatement");
	    let kind = null;
	    let hasModuleExport = false;
	    body.forEach((bodyElement) => {
	      if (isEsModuleType(bodyElement)) {
	        if (kind === "CommonJS") {
	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
	        }
	        kind = "ES";
	      } else if (bodyElement.type === "DeclareModuleExports") {
	        if (hasModuleExport) {
	          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
	        }
	        if (kind === "ES") {
	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
	        }
	        kind = "CommonJS";
	        hasModuleExport = true;
	      }
	    });
	    node.kind = kind || "CommonJS";
	    return this.finishNode(node, "DeclareModule");
	  }
	  flowParseDeclareExportDeclaration(node, insideModule) {
	    this.expect(82);
	    if (this.eat(65)) {
	      if (this.match(68) || this.match(80)) {
	        node.declaration = this.flowParseDeclare(this.startNode());
	      } else {
	        node.declaration = this.flowParseType();
	        this.semicolon();
	      }
	      node.default = true;
	      return this.finishNode(node, "DeclareExportDeclaration");
	    } else {
	      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
	        const label = this.state.value;
	        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
	          unsupportedExportKind: label,
	          suggestion: exportSuggestions[label]
	        });
	      }
	      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
	        node.declaration = this.flowParseDeclare(this.startNode());
	        node.default = false;
	        return this.finishNode(node, "DeclareExportDeclaration");
	      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
	        node = this.parseExport(node, null);
	        if (node.type === "ExportNamedDeclaration") {
	          node.default = false;
	          delete node.exportKind;
	          return this.castNodeTo(node, "DeclareExportDeclaration");
	        } else {
	          return this.castNodeTo(node, "DeclareExportAllDeclaration");
	        }
	      }
	    }
	    this.unexpected();
	  }
	  flowParseDeclareModuleExports(node) {
	    this.next();
	    this.expectContextual(111);
	    node.typeAnnotation = this.flowParseTypeAnnotation();
	    this.semicolon();
	    return this.finishNode(node, "DeclareModuleExports");
	  }
	  flowParseDeclareTypeAlias(node) {
	    this.next();
	    const finished = this.flowParseTypeAlias(node);
	    this.castNodeTo(finished, "DeclareTypeAlias");
	    return finished;
	  }
	  flowParseDeclareOpaqueType(node) {
	    this.next();
	    const finished = this.flowParseOpaqueType(node, true);
	    this.castNodeTo(finished, "DeclareOpaqueType");
	    return finished;
	  }
	  flowParseDeclareInterface(node) {
	    this.next();
	    this.flowParseInterfaceish(node, false);
	    return this.finishNode(node, "DeclareInterface");
	  }
	  flowParseInterfaceish(node, isClass) {
	    node.id = this.flowParseRestrictedIdentifier(!isClass, true);
	    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.extends = [];
	    if (this.eat(81)) {
	      do {
	        node.extends.push(this.flowParseInterfaceExtends());
	      } while (!isClass && this.eat(12));
	    }
	    if (isClass) {
	      node.implements = [];
	      node.mixins = [];
	      if (this.eatContextual(117)) {
	        do {
	          node.mixins.push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }
	      if (this.eatContextual(113)) {
	        do {
	          node.implements.push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }
	    }
	    node.body = this.flowParseObjectType({
	      allowStatic: isClass,
	      allowExact: false,
	      allowSpread: false,
	      allowProto: isClass,
	      allowInexact: false
	    });
	  }
	  flowParseInterfaceExtends() {
	    const node = this.startNode();
	    node.id = this.flowParseQualifiedTypeIdentifier();
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterInstantiation();
	    } else {
	      node.typeParameters = null;
	    }
	    return this.finishNode(node, "InterfaceExtends");
	  }
	  flowParseInterface(node) {
	    this.flowParseInterfaceish(node, false);
	    return this.finishNode(node, "InterfaceDeclaration");
	  }
	  checkNotUnderscore(word) {
	    if (word === "_") {
	      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
	    }
	  }
	  checkReservedType(word, startLoc, declaration) {
	    if (!reservedTypes.has(word)) return;
	    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
	      reservedType: word
	    });
	  }
	  flowParseRestrictedIdentifier(liberal, declaration) {
	    this.checkReservedType(this.state.value, this.state.startLoc, declaration);
	    return this.parseIdentifier(liberal);
	  }
	  flowParseTypeAlias(node) {
	    node.id = this.flowParseRestrictedIdentifier(false, true);
	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.right = this.flowParseTypeInitialiser(29);
	    this.semicolon();
	    return this.finishNode(node, "TypeAlias");
	  }
	  flowParseOpaqueType(node, declare) {
	    this.expectContextual(130);
	    node.id = this.flowParseRestrictedIdentifier(true, true);
	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.supertype = null;
	    if (this.match(14)) {
	      node.supertype = this.flowParseTypeInitialiser(14);
	    }
	    node.impltype = null;
	    if (!declare) {
	      node.impltype = this.flowParseTypeInitialiser(29);
	    }
	    this.semicolon();
	    return this.finishNode(node, "OpaqueType");
	  }
	  flowParseTypeParameter(requireDefault = false) {
	    const nodeStartLoc = this.state.startLoc;
	    const node = this.startNode();
	    const variance = this.flowParseVariance();
	    const ident = this.flowParseTypeAnnotatableIdentifier();
	    node.name = ident.name;
	    node.variance = variance;
	    node.bound = ident.typeAnnotation;
	    if (this.match(29)) {
	      this.eat(29);
	      node.default = this.flowParseType();
	    } else {
	      if (requireDefault) {
	        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
	      }
	    }
	    return this.finishNode(node, "TypeParameter");
	  }
	  flowParseTypeParameterDeclaration() {
	    const oldInType = this.state.inType;
	    const node = this.startNode();
	    node.params = [];
	    this.state.inType = true;
	    if (this.match(47) || this.match(143)) {
	      this.next();
	    } else {
	      this.unexpected();
	    }
	    let defaultRequired = false;
	    do {
	      const typeParameter = this.flowParseTypeParameter(defaultRequired);
	      node.params.push(typeParameter);
	      if (typeParameter.default) {
	        defaultRequired = true;
	      }
	      if (!this.match(48)) {
	        this.expect(12);
	      }
	    } while (!this.match(48));
	    this.expect(48);
	    this.state.inType = oldInType;
	    return this.finishNode(node, "TypeParameterDeclaration");
	  }
	  flowInTopLevelContext(cb) {
	    if (this.curContext() !== types.brace) {
	      const oldContext = this.state.context;
	      this.state.context = [oldContext[0]];
	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    } else {
	      return cb();
	    }
	  }
	  flowParseTypeParameterInstantiationInExpression() {
	    if (this.reScan_lt() !== 47) return;
	    return this.flowParseTypeParameterInstantiation();
	  }
	  flowParseTypeParameterInstantiation() {
	    const node = this.startNode();
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    node.params = [];
	    this.flowInTopLevelContext(() => {
	      this.expect(47);
	      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	      this.state.noAnonFunctionType = false;
	      while (!this.match(48)) {
	        node.params.push(this.flowParseType());
	        if (!this.match(48)) {
	          this.expect(12);
	        }
	      }
	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
	    });
	    this.state.inType = oldInType;
	    if (!this.state.inType && this.curContext() === types.brace) {
	      this.reScan_lt_gt();
	    }
	    this.expect(48);
	    return this.finishNode(node, "TypeParameterInstantiation");
	  }
	  flowParseTypeParameterInstantiationCallOrNew() {
	    if (this.reScan_lt() !== 47) return;
	    const node = this.startNode();
	    const oldInType = this.state.inType;
	    node.params = [];
	    this.state.inType = true;
	    this.expect(47);
	    while (!this.match(48)) {
	      node.params.push(this.flowParseTypeOrImplicitInstantiation());
	      if (!this.match(48)) {
	        this.expect(12);
	      }
	    }
	    this.expect(48);
	    this.state.inType = oldInType;
	    return this.finishNode(node, "TypeParameterInstantiation");
	  }
	  flowParseInterfaceType() {
	    const node = this.startNode();
	    this.expectContextual(129);
	    node.extends = [];
	    if (this.eat(81)) {
	      do {
	        node.extends.push(this.flowParseInterfaceExtends());
	      } while (this.eat(12));
	    }
	    node.body = this.flowParseObjectType({
	      allowStatic: false,
	      allowExact: false,
	      allowSpread: false,
	      allowProto: false,
	      allowInexact: false
	    });
	    return this.finishNode(node, "InterfaceTypeAnnotation");
	  }
	  flowParseObjectPropertyKey() {
	    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
	  }
	  flowParseObjectTypeIndexer(node, isStatic, variance) {
	    node.static = isStatic;
	    if (this.lookahead().type === 14) {
	      node.id = this.flowParseObjectPropertyKey();
	      node.key = this.flowParseTypeInitialiser();
	    } else {
	      node.id = null;
	      node.key = this.flowParseType();
	    }
	    this.expect(3);
	    node.value = this.flowParseTypeInitialiser();
	    node.variance = variance;
	    return this.finishNode(node, "ObjectTypeIndexer");
	  }
	  flowParseObjectTypeInternalSlot(node, isStatic) {
	    node.static = isStatic;
	    node.id = this.flowParseObjectPropertyKey();
	    this.expect(3);
	    this.expect(3);
	    if (this.match(47) || this.match(10)) {
	      node.method = true;
	      node.optional = false;
	      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
	    } else {
	      node.method = false;
	      if (this.eat(17)) {
	        node.optional = true;
	      }
	      node.value = this.flowParseTypeInitialiser();
	    }
	    return this.finishNode(node, "ObjectTypeInternalSlot");
	  }
	  flowParseObjectTypeMethodish(node) {
	    node.params = [];
	    node.rest = null;
	    node.typeParameters = null;
	    node.this = null;
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    this.expect(10);
	    if (this.match(78)) {
	      node.this = this.flowParseFunctionTypeParam(true);
	      node.this.name = null;
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    while (!this.match(11) && !this.match(21)) {
	      node.params.push(this.flowParseFunctionTypeParam(false));
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    if (this.eat(21)) {
	      node.rest = this.flowParseFunctionTypeParam(false);
	    }
	    this.expect(11);
	    node.returnType = this.flowParseTypeInitialiser();
	    return this.finishNode(node, "FunctionTypeAnnotation");
	  }
	  flowParseObjectTypeCallProperty(node, isStatic) {
	    const valueNode = this.startNode();
	    node.static = isStatic;
	    node.value = this.flowParseObjectTypeMethodish(valueNode);
	    return this.finishNode(node, "ObjectTypeCallProperty");
	  }
	  flowParseObjectType({
	    allowStatic,
	    allowExact,
	    allowSpread,
	    allowProto,
	    allowInexact
	  }) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    const nodeStart = this.startNode();
	    nodeStart.callProperties = [];
	    nodeStart.properties = [];
	    nodeStart.indexers = [];
	    nodeStart.internalSlots = [];
	    let endDelim;
	    let exact;
	    let inexact = false;
	    if (allowExact && this.match(6)) {
	      this.expect(6);
	      endDelim = 9;
	      exact = true;
	    } else {
	      this.expect(5);
	      endDelim = 8;
	      exact = false;
	    }
	    nodeStart.exact = exact;
	    while (!this.match(endDelim)) {
	      let isStatic = false;
	      let protoStartLoc = null;
	      let inexactStartLoc = null;
	      const node = this.startNode();
	      if (allowProto && this.isContextual(118)) {
	        const lookahead = this.lookahead();
	        if (lookahead.type !== 14 && lookahead.type !== 17) {
	          this.next();
	          protoStartLoc = this.state.startLoc;
	          allowStatic = false;
	        }
	      }
	      if (allowStatic && this.isContextual(106)) {
	        const lookahead = this.lookahead();
	        if (lookahead.type !== 14 && lookahead.type !== 17) {
	          this.next();
	          isStatic = true;
	        }
	      }
	      const variance = this.flowParseVariance();
	      if (this.eat(0)) {
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (this.eat(0)) {
	          if (variance) {
	            this.unexpected(variance.loc.start);
	          }
	          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
	        } else {
	          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
	        }
	      } else if (this.match(10) || this.match(47)) {
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (variance) {
	          this.unexpected(variance.loc.start);
	        }
	        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
	      } else {
	        let kind = "init";
	        if (this.isContextual(99) || this.isContextual(104)) {
	          const lookahead = this.lookahead();
	          if (tokenIsLiteralPropertyName(lookahead.type)) {
	            kind = this.state.value;
	            this.next();
	          }
	        }
	        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
	        if (propOrInexact === null) {
	          inexact = true;
	          inexactStartLoc = this.state.lastTokStartLoc;
	        } else {
	          nodeStart.properties.push(propOrInexact);
	        }
	      }
	      this.flowObjectTypeSemicolon();
	      if (inexactStartLoc && !this.match(8) && !this.match(9)) {
	        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
	      }
	    }
	    this.expect(endDelim);
	    if (allowSpread) {
	      nodeStart.inexact = inexact;
	    }
	    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
	    this.state.inType = oldInType;
	    return out;
	  }
	  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
	    if (this.eat(21)) {
	      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
	      if (isInexactToken) {
	        if (!allowSpread) {
	          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
	        } else if (!allowInexact) {
	          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
	        }
	        if (variance) {
	          this.raise(FlowErrors.InexactVariance, variance);
	        }
	        return null;
	      }
	      if (!allowSpread) {
	        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
	      }
	      if (protoStartLoc != null) {
	        this.unexpected(protoStartLoc);
	      }
	      if (variance) {
	        this.raise(FlowErrors.SpreadVariance, variance);
	      }
	      node.argument = this.flowParseType();
	      return this.finishNode(node, "ObjectTypeSpreadProperty");
	    } else {
	      node.key = this.flowParseObjectPropertyKey();
	      node.static = isStatic;
	      node.proto = protoStartLoc != null;
	      node.kind = kind;
	      let optional = false;
	      if (this.match(47) || this.match(10)) {
	        node.method = true;
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (variance) {
	          this.unexpected(variance.loc.start);
	        }
	        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
	        if (kind === "get" || kind === "set") {
	          this.flowCheckGetterSetterParams(node);
	        }
	        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
	          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
	        }
	      } else {
	        if (kind !== "init") this.unexpected();
	        node.method = false;
	        if (this.eat(17)) {
	          optional = true;
	        }
	        node.value = this.flowParseTypeInitialiser();
	        node.variance = variance;
	      }
	      node.optional = optional;
	      return this.finishNode(node, "ObjectTypeProperty");
	    }
	  }
	  flowCheckGetterSetterParams(property) {
	    const paramCount = property.kind === "get" ? 0 : 1;
	    const length = property.value.params.length + (property.value.rest ? 1 : 0);
	    if (property.value.this) {
	      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
	    }
	    if (length !== paramCount) {
	      this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
	    }
	    if (property.kind === "set" && property.value.rest) {
	      this.raise(Errors.BadSetterRestParameter, property);
	    }
	  }
	  flowObjectTypeSemicolon() {
	    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
	      this.unexpected();
	    }
	  }
	  flowParseQualifiedTypeIdentifier(startLoc, id) {
	    startLoc != null ? startLoc : startLoc = this.state.startLoc;
	    let node = id || this.flowParseRestrictedIdentifier(true);
	    while (this.eat(16)) {
	      const node2 = this.startNodeAt(startLoc);
	      node2.qualification = node;
	      node2.id = this.flowParseRestrictedIdentifier(true);
	      node = this.finishNode(node2, "QualifiedTypeIdentifier");
	    }
	    return node;
	  }
	  flowParseGenericType(startLoc, id) {
	    const node = this.startNodeAt(startLoc);
	    node.typeParameters = null;
	    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterInstantiation();
	    }
	    return this.finishNode(node, "GenericTypeAnnotation");
	  }
	  flowParseTypeofType() {
	    const node = this.startNode();
	    this.expect(87);
	    node.argument = this.flowParsePrimaryType();
	    return this.finishNode(node, "TypeofTypeAnnotation");
	  }
	  flowParseTupleType() {
	    const node = this.startNode();
	    node.types = [];
	    this.expect(0);
	    while (this.state.pos < this.length && !this.match(3)) {
	      node.types.push(this.flowParseType());
	      if (this.match(3)) break;
	      this.expect(12);
	    }
	    this.expect(3);
	    return this.finishNode(node, "TupleTypeAnnotation");
	  }
	  flowParseFunctionTypeParam(first) {
	    let name = null;
	    let optional = false;
	    let typeAnnotation = null;
	    const node = this.startNode();
	    const lh = this.lookahead();
	    const isThis = this.state.type === 78;
	    if (lh.type === 14 || lh.type === 17) {
	      if (isThis && !first) {
	        this.raise(FlowErrors.ThisParamMustBeFirst, node);
	      }
	      name = this.parseIdentifier(isThis);
	      if (this.eat(17)) {
	        optional = true;
	        if (isThis) {
	          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
	        }
	      }
	      typeAnnotation = this.flowParseTypeInitialiser();
	    } else {
	      typeAnnotation = this.flowParseType();
	    }
	    node.name = name;
	    node.optional = optional;
	    node.typeAnnotation = typeAnnotation;
	    return this.finishNode(node, "FunctionTypeParam");
	  }
	  reinterpretTypeAsFunctionTypeParam(type) {
	    const node = this.startNodeAt(type.loc.start);
	    node.name = null;
	    node.optional = false;
	    node.typeAnnotation = type;
	    return this.finishNode(node, "FunctionTypeParam");
	  }
	  flowParseFunctionTypeParams(params = []) {
	    let rest = null;
	    let _this = null;
	    if (this.match(78)) {
	      _this = this.flowParseFunctionTypeParam(true);
	      _this.name = null;
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    while (!this.match(11) && !this.match(21)) {
	      params.push(this.flowParseFunctionTypeParam(false));
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    if (this.eat(21)) {
	      rest = this.flowParseFunctionTypeParam(false);
	    }
	    return {
	      params,
	      rest,
	      _this
	    };
	  }
	  flowIdentToTypeAnnotation(startLoc, node, id) {
	    switch (id.name) {
	      case "any":
	        return this.finishNode(node, "AnyTypeAnnotation");
	      case "bool":
	      case "boolean":
	        return this.finishNode(node, "BooleanTypeAnnotation");
	      case "mixed":
	        return this.finishNode(node, "MixedTypeAnnotation");
	      case "empty":
	        return this.finishNode(node, "EmptyTypeAnnotation");
	      case "number":
	        return this.finishNode(node, "NumberTypeAnnotation");
	      case "string":
	        return this.finishNode(node, "StringTypeAnnotation");
	      case "symbol":
	        return this.finishNode(node, "SymbolTypeAnnotation");
	      default:
	        this.checkNotUnderscore(id.name);
	        return this.flowParseGenericType(startLoc, id);
	    }
	  }
	  flowParsePrimaryType() {
	    const startLoc = this.state.startLoc;
	    const node = this.startNode();
	    let tmp;
	    let type;
	    let isGroupedType = false;
	    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	    switch (this.state.type) {
	      case 5:
	        return this.flowParseObjectType({
	          allowStatic: false,
	          allowExact: false,
	          allowSpread: true,
	          allowProto: false,
	          allowInexact: true
	        });
	      case 6:
	        return this.flowParseObjectType({
	          allowStatic: false,
	          allowExact: true,
	          allowSpread: true,
	          allowProto: false,
	          allowInexact: false
	        });
	      case 0:
	        this.state.noAnonFunctionType = false;
	        type = this.flowParseTupleType();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	        return type;
	      case 47: {
	        const node2 = this.startNode();
	        node2.typeParameters = this.flowParseTypeParameterDeclaration();
	        this.expect(10);
	        tmp = this.flowParseFunctionTypeParams();
	        node2.params = tmp.params;
	        node2.rest = tmp.rest;
	        node2.this = tmp._this;
	        this.expect(11);
	        this.expect(19);
	        node2.returnType = this.flowParseType();
	        return this.finishNode(node2, "FunctionTypeAnnotation");
	      }
	      case 10: {
	        const node2 = this.startNode();
	        this.next();
	        if (!this.match(11) && !this.match(21)) {
	          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
	            const token = this.lookahead().type;
	            isGroupedType = token !== 17 && token !== 14;
	          } else {
	            isGroupedType = true;
	          }
	        }
	        if (isGroupedType) {
	          this.state.noAnonFunctionType = false;
	          type = this.flowParseType();
	          this.state.noAnonFunctionType = oldNoAnonFunctionType;
	          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
	            this.expect(11);
	            return type;
	          } else {
	            this.eat(12);
	          }
	        }
	        if (type) {
	          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
	        } else {
	          tmp = this.flowParseFunctionTypeParams();
	        }
	        node2.params = tmp.params;
	        node2.rest = tmp.rest;
	        node2.this = tmp._this;
	        this.expect(11);
	        this.expect(19);
	        node2.returnType = this.flowParseType();
	        node2.typeParameters = null;
	        return this.finishNode(node2, "FunctionTypeAnnotation");
	      }
	      case 134:
	        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
	      case 85:
	      case 86:
	        node.value = this.match(85);
	        this.next();
	        return this.finishNode(node, "BooleanLiteralTypeAnnotation");
	      case 53:
	        if (this.state.value === "-") {
	          this.next();
	          if (this.match(135)) {
	            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
	          }
	          if (this.match(136)) {
	            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
	          }
	          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
	        }
	        this.unexpected();
	        return;
	      case 135:
	        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
	      case 136:
	        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
	      case 88:
	        this.next();
	        return this.finishNode(node, "VoidTypeAnnotation");
	      case 84:
	        this.next();
	        return this.finishNode(node, "NullLiteralTypeAnnotation");
	      case 78:
	        this.next();
	        return this.finishNode(node, "ThisTypeAnnotation");
	      case 55:
	        this.next();
	        return this.finishNode(node, "ExistsTypeAnnotation");
	      case 87:
	        return this.flowParseTypeofType();
	      default:
	        if (tokenIsKeyword(this.state.type)) {
	          const label = tokenLabelName(this.state.type);
	          this.next();
	          return super.createIdentifier(node, label);
	        } else if (tokenIsIdentifier(this.state.type)) {
	          if (this.isContextual(129)) {
	            return this.flowParseInterfaceType();
	          }
	          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
	        }
	    }
	    this.unexpected();
	  }
	  flowParsePostfixType() {
	    const startLoc = this.state.startLoc;
	    let type = this.flowParsePrimaryType();
	    let seenOptionalIndexedAccess = false;
	    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
	      const node = this.startNodeAt(startLoc);
	      const optional = this.eat(18);
	      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
	      this.expect(0);
	      if (!optional && this.match(3)) {
	        node.elementType = type;
	        this.next();
	        type = this.finishNode(node, "ArrayTypeAnnotation");
	      } else {
	        node.objectType = type;
	        node.indexType = this.flowParseType();
	        this.expect(3);
	        if (seenOptionalIndexedAccess) {
	          node.optional = optional;
	          type = this.finishNode(node, "OptionalIndexedAccessType");
	        } else {
	          type = this.finishNode(node, "IndexedAccessType");
	        }
	      }
	    }
	    return type;
	  }
	  flowParsePrefixType() {
	    const node = this.startNode();
	    if (this.eat(17)) {
	      node.typeAnnotation = this.flowParsePrefixType();
	      return this.finishNode(node, "NullableTypeAnnotation");
	    } else {
	      return this.flowParsePostfixType();
	    }
	  }
	  flowParseAnonFunctionWithoutParens() {
	    const param = this.flowParsePrefixType();
	    if (!this.state.noAnonFunctionType && this.eat(19)) {
	      const node = this.startNodeAt(param.loc.start);
	      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
	      node.rest = null;
	      node.this = null;
	      node.returnType = this.flowParseType();
	      node.typeParameters = null;
	      return this.finishNode(node, "FunctionTypeAnnotation");
	    }
	    return param;
	  }
	  flowParseIntersectionType() {
	    const node = this.startNode();
	    this.eat(45);
	    const type = this.flowParseAnonFunctionWithoutParens();
	    node.types = [type];
	    while (this.eat(45)) {
	      node.types.push(this.flowParseAnonFunctionWithoutParens());
	    }
	    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
	  }
	  flowParseUnionType() {
	    const node = this.startNode();
	    this.eat(43);
	    const type = this.flowParseIntersectionType();
	    node.types = [type];
	    while (this.eat(43)) {
	      node.types.push(this.flowParseIntersectionType());
	    }
	    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
	  }
	  flowParseType() {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    const type = this.flowParseUnionType();
	    this.state.inType = oldInType;
	    return type;
	  }
	  flowParseTypeOrImplicitInstantiation() {
	    if (this.state.type === 132 && this.state.value === "_") {
	      const startLoc = this.state.startLoc;
	      const node = this.parseIdentifier();
	      return this.flowParseGenericType(startLoc, node);
	    } else {
	      return this.flowParseType();
	    }
	  }
	  flowParseTypeAnnotation() {
	    const node = this.startNode();
	    node.typeAnnotation = this.flowParseTypeInitialiser();
	    return this.finishNode(node, "TypeAnnotation");
	  }
	  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
	    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
	    if (this.match(14)) {
	      ident.typeAnnotation = this.flowParseTypeAnnotation();
	      this.resetEndLocation(ident);
	    }
	    return ident;
	  }
	  typeCastToParameter(node) {
	    node.expression.typeAnnotation = node.typeAnnotation;
	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
	    return node.expression;
	  }
	  flowParseVariance() {
	    let variance = null;
	    if (this.match(53)) {
	      variance = this.startNode();
	      if (this.state.value === "+") {
	        variance.kind = "plus";
	      } else {
	        variance.kind = "minus";
	      }
	      this.next();
	      return this.finishNode(variance, "Variance");
	    }
	    return variance;
	  }
	  parseFunctionBody(node, allowExpressionBody, isMethod = false) {
	    if (allowExpressionBody) {
	      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
	      return;
	    }
	    super.parseFunctionBody(node, false, isMethod);
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    if (this.match(14)) {
	      const typeNode = this.startNode();
	      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
	    }
	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
	  }
	  parseStatementLike(flags) {
	    if (this.state.strict && this.isContextual(129)) {
	      const lookahead = this.lookahead();
	      if (tokenIsKeywordOrIdentifier(lookahead.type)) {
	        const node = this.startNode();
	        this.next();
	        return this.flowParseInterface(node);
	      }
	    } else if (this.isContextual(126)) {
	      const node = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(node);
	    }
	    const stmt = super.parseStatementLike(flags);
	    if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
	      this.flowPragma = null;
	    }
	    return stmt;
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    if (expr.type === "Identifier") {
	      if (expr.name === "declare") {
	        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
	          return this.flowParseDeclare(node);
	        }
	      } else if (tokenIsIdentifier(this.state.type)) {
	        if (expr.name === "interface") {
	          return this.flowParseInterface(node);
	        } else if (expr.name === "type") {
	          return this.flowParseTypeAlias(node);
	        } else if (expr.name === "opaque") {
	          return this.flowParseOpaqueType(node, false);
	        }
	      }
	    }
	    return super.parseExpressionStatement(node, expr, decorators);
	  }
	  shouldParseExportDeclaration() {
	    const {
	      type
	    } = this.state;
	    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
	      return !this.state.containsEsc;
	    }
	    return super.shouldParseExportDeclaration();
	  }
	  isExportDefaultSpecifier() {
	    const {
	      type
	    } = this.state;
	    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
	      return this.state.containsEsc;
	    }
	    return super.isExportDefaultSpecifier();
	  }
	  parseExportDefaultExpression() {
	    if (this.isContextual(126)) {
	      const node = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(node);
	    }
	    return super.parseExportDefaultExpression();
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (!this.match(17)) return expr;
	    if (this.state.maybeInArrowParameters) {
	      const nextCh = this.lookaheadCharCode();
	      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
	        this.setOptionalParametersError(refExpressionErrors);
	        return expr;
	      }
	    }
	    this.expect(17);
	    const state = this.state.clone();
	    const originalNoArrowAt = this.state.noArrowAt;
	    const node = this.startNodeAt(startLoc);
	    let {
	      consequent,
	      failed
	    } = this.tryParseConditionalConsequent();
	    let [valid, invalid] = this.getArrowLikeExpressions(consequent);
	    if (failed || invalid.length > 0) {
	      const noArrowAt = [...originalNoArrowAt];
	      if (invalid.length > 0) {
	        this.state = state;
	        this.state.noArrowAt = noArrowAt;
	        for (let i = 0; i < invalid.length; i++) {
	          noArrowAt.push(invalid[i].start);
	        }
	        ({
	          consequent,
	          failed
	        } = this.tryParseConditionalConsequent());
	        [valid, invalid] = this.getArrowLikeExpressions(consequent);
	      }
	      if (failed && valid.length > 1) {
	        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
	      }
	      if (failed && valid.length === 1) {
	        this.state = state;
	        noArrowAt.push(valid[0].start);
	        this.state.noArrowAt = noArrowAt;
	        ({
	          consequent,
	          failed
	        } = this.tryParseConditionalConsequent());
	      }
	    }
	    this.getArrowLikeExpressions(consequent, true);
	    this.state.noArrowAt = originalNoArrowAt;
	    this.expect(14);
	    node.test = expr;
	    node.consequent = consequent;
	    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  tryParseConditionalConsequent() {
	    this.state.noArrowParamsConversionAt.push(this.state.start);
	    const consequent = this.parseMaybeAssignAllowIn();
	    const failed = !this.match(14);
	    this.state.noArrowParamsConversionAt.pop();
	    return {
	      consequent,
	      failed
	    };
	  }
	  getArrowLikeExpressions(node, disallowInvalid) {
	    const stack = [node];
	    const arrows = [];
	    while (stack.length !== 0) {
	      const node2 = stack.pop();
	      if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
	        if (node2.typeParameters || !node2.returnType) {
	          this.finishArrowValidation(node2);
	        } else {
	          arrows.push(node2);
	        }
	        stack.push(node2.body);
	      } else if (node2.type === "ConditionalExpression") {
	        stack.push(node2.consequent);
	        stack.push(node2.alternate);
	      }
	    }
	    if (disallowInvalid) {
	      arrows.forEach((node2) => this.finishArrowValidation(node2));
	      return [arrows, []];
	    }
	    return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
	  }
	  finishArrowValidation(node) {
	    var _node$extra;
	    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
	    this.scope.enter(2 | 4);
	    super.checkParams(node, false, true);
	    this.scope.exit();
	  }
	  forwardNoArrowParamsConversionAt(node, parse2) {
	    let result;
	    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      this.state.noArrowParamsConversionAt.push(this.state.start);
	      result = parse2();
	      this.state.noArrowParamsConversionAt.pop();
	    } else {
	      result = parse2();
	    }
	    return result;
	  }
	  parseParenItem(node, startLoc) {
	    const newNode = super.parseParenItem(node, startLoc);
	    if (this.eat(17)) {
	      newNode.optional = true;
	      this.resetEndLocation(node);
	    }
	    if (this.match(14)) {
	      const typeCastNode = this.startNodeAt(startLoc);
	      typeCastNode.expression = newNode;
	      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
	      return this.finishNode(typeCastNode, "TypeCastExpression");
	    }
	    return newNode;
	  }
	  assertModuleNodeAllowed(node) {
	    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
	      return;
	    }
	    super.assertModuleNodeAllowed(node);
	  }
	  parseExportDeclaration(node) {
	    if (this.isContextual(130)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      if (this.match(5)) {
	        node.specifiers = this.parseExportSpecifiers(true);
	        super.parseExportFrom(node);
	        return null;
	      } else {
	        return this.flowParseTypeAlias(declarationNode);
	      }
	    } else if (this.isContextual(131)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseOpaqueType(declarationNode, false);
	    } else if (this.isContextual(129)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseInterface(declarationNode);
	    } else if (this.isContextual(126)) {
	      node.exportKind = "value";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(declarationNode);
	    } else {
	      return super.parseExportDeclaration(node);
	    }
	  }
	  eatExportStar(node) {
	    if (super.eatExportStar(node)) return true;
	    if (this.isContextual(130) && this.lookahead().type === 55) {
	      node.exportKind = "type";
	      this.next();
	      this.next();
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamespaceSpecifier(node) {
	    const {
	      startLoc
	    } = this.state;
	    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
	    if (hasNamespace && node.exportKind === "type") {
	      this.unexpected(startLoc);
	    }
	    return hasNamespace;
	  }
	  parseClassId(node, isStatement, optionalId) {
	    super.parseClassId(node, isStatement, optionalId);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	  }
	  parseClassMember(classBody, member, state) {
	    const {
	      startLoc
	    } = this.state;
	    if (this.isContextual(125)) {
	      if (super.parseClassMemberFromModifier(classBody, member)) {
	        return;
	      }
	      member.declare = true;
	    }
	    super.parseClassMember(classBody, member, state);
	    if (member.declare) {
	      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
	        this.raise(FlowErrors.DeclareClassElement, startLoc);
	      } else if (member.value) {
	        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
	      }
	    }
	  }
	  isIterator(word) {
	    return word === "iterator" || word === "asyncIterator";
	  }
	  readIterator() {
	    const word = super.readWord1();
	    const fullWord = "@@" + word;
	    if (!this.isIterator(word) || !this.state.inType) {
	      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
	        identifierName: fullWord
	      });
	    }
	    this.finishToken(132, fullWord);
	  }
	  getTokenFromCode(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code2 === 123 && next === 124) {
	      this.finishOp(6, 2);
	    } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
	      this.finishOp(code2 === 62 ? 48 : 47, 1);
	    } else if (this.state.inType && code2 === 63) {
	      if (next === 46) {
	        this.finishOp(18, 2);
	      } else {
	        this.finishOp(17, 1);
	      }
	    } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
	      this.state.pos += 2;
	      this.readIterator();
	    } else {
	      super.getTokenFromCode(code2);
	    }
	  }
	  isAssignable(node, isBinding) {
	    if (node.type === "TypeCastExpression") {
	      return this.isAssignable(node.expression, isBinding);
	    } else {
	      return super.isAssignable(node, isBinding);
	    }
	  }
	  toAssignable(node, isLHS = false) {
	    if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
	      node.left = this.typeCastToParameter(node.left);
	    }
	    super.toAssignable(node, isLHS);
	  }
	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
	    for (let i = 0; i < exprList.length; i++) {
	      const expr = exprList[i];
	      if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
	        exprList[i] = this.typeCastToParameter(expr);
	      }
	    }
	    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
	  }
	  toReferencedList(exprList, isParenthesizedExpr) {
	    for (let i = 0; i < exprList.length; i++) {
	      var _expr$extra;
	      const expr = exprList[i];
	      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
	        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
	      }
	    }
	    return exprList;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
	    if (canBePattern && !this.state.maybeInArrowParameters) {
	      this.toReferencedList(node.elements);
	    }
	    return node;
	  }
	  isValidLVal(type, isParenthesized, binding) {
	    return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
	  }
	  parseClassProperty(node) {
	    if (this.match(14)) {
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	    }
	    return super.parseClassProperty(node);
	  }
	  parseClassPrivateProperty(node) {
	    if (this.match(14)) {
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	    }
	    return super.parseClassPrivateProperty(node);
	  }
	  isClassMethod() {
	    return this.match(47) || super.isClassMethod();
	  }
	  isClassProperty() {
	    return this.match(14) || super.isClassProperty();
	  }
	  isNonstaticConstructor(method) {
	    return !this.match(14) && super.isNonstaticConstructor(method);
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    if (method.variance) {
	      this.unexpected(method.variance.loc.start);
	    }
	    delete method.variance;
	    if (this.match(47)) {
	      method.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
	    if (method.params && isConstructor) {
	      const params = method.params;
	      if (params.length > 0 && this.isThisParam(params[0])) {
	        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
	      }
	    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
	      const params = method.value.params;
	      if (params.length > 0 && this.isThisParam(params[0])) {
	        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
	      }
	    }
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    if (method.variance) {
	      this.unexpected(method.variance.loc.start);
	    }
	    delete method.variance;
	    if (this.match(47)) {
	      method.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
	  }
	  parseClassSuper(node) {
	    super.parseClassSuper(node);
	    if (node.superClass && (this.match(47) || this.match(51))) {
	      {
	        node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
	      }
	    }
	    if (this.isContextual(113)) {
	      this.next();
	      const implemented = node.implements = [];
	      do {
	        const node2 = this.startNode();
	        node2.id = this.flowParseRestrictedIdentifier(true);
	        if (this.match(47)) {
	          node2.typeParameters = this.flowParseTypeParameterInstantiation();
	        } else {
	          node2.typeParameters = null;
	        }
	        implemented.push(this.finishNode(node2, "ClassImplements"));
	      } while (this.eat(12));
	    }
	  }
	  checkGetterSetterParams(method) {
	    super.checkGetterSetterParams(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    if (params.length > 0) {
	      const param = params[0];
	      if (this.isThisParam(param) && method.kind === "get") {
	        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
	      } else if (this.isThisParam(param)) {
	        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
	      }
	    }
	  }
	  parsePropertyNamePrefixOperator(node) {
	    node.variance = this.flowParseVariance();
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    if (prop.variance) {
	      this.unexpected(prop.variance.loc.start);
	    }
	    delete prop.variance;
	    let typeParameters;
	    if (this.match(47) && !isAccessor) {
	      typeParameters = this.flowParseTypeParameterDeclaration();
	      if (!this.match(10)) this.unexpected();
	    }
	    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
	    if (typeParameters) {
	      (result.value || result).typeParameters = typeParameters;
	    }
	    return result;
	  }
	  parseFunctionParamType(param) {
	    if (this.eat(17)) {
	      if (param.type !== "Identifier") {
	        this.raise(FlowErrors.PatternIsOptional, param);
	      }
	      if (this.isThisParam(param)) {
	        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
	      }
	      param.optional = true;
	    }
	    if (this.match(14)) {
	      param.typeAnnotation = this.flowParseTypeAnnotation();
	    } else if (this.isThisParam(param)) {
	      this.raise(FlowErrors.ThisParamAnnotationRequired, param);
	    }
	    if (this.match(29) && this.isThisParam(param)) {
	      this.raise(FlowErrors.ThisParamNoDefault, param);
	    }
	    this.resetEndLocation(param);
	    return param;
	  }
	  parseMaybeDefault(startLoc, left) {
	    const node = super.parseMaybeDefault(startLoc, left);
	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
	    }
	    return node;
	  }
	  checkImportReflection(node) {
	    super.checkImportReflection(node);
	    if (node.module && node.importKind !== "value") {
	      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
	    }
	  }
	  parseImportSpecifierLocal(node, specifier, type) {
	    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
	  }
	  isPotentialImportPhase(isExport) {
	    if (super.isPotentialImportPhase(isExport)) return true;
	    if (this.isContextual(130)) {
	      if (!isExport) return true;
	      const ch = this.lookaheadCharCode();
	      return ch === 123 || ch === 42;
	    }
	    return !isExport && this.isContextual(87);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    super.applyImportPhase(node, isExport, phase, loc);
	    if (isExport) {
	      if (!phase && this.match(65)) {
	        return;
	      }
	      node.exportKind = phase === "type" ? phase : "value";
	    } else {
	      if (phase === "type" && this.match(55)) this.unexpected();
	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
	    }
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    const firstIdent = specifier.imported;
	    let specifierTypeKind = null;
	    if (firstIdent.type === "Identifier") {
	      if (firstIdent.name === "type") {
	        specifierTypeKind = "type";
	      } else if (firstIdent.name === "typeof") {
	        specifierTypeKind = "typeof";
	      }
	    }
	    let isBinding = false;
	    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
	      const as_ident = this.parseIdentifier(true);
	      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
	        specifier.imported = as_ident;
	        specifier.importKind = specifierTypeKind;
	        specifier.local = this.cloneIdentifier(as_ident);
	      } else {
	        specifier.imported = firstIdent;
	        specifier.importKind = null;
	        specifier.local = this.parseIdentifier();
	      }
	    } else {
	      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
	        specifier.imported = this.parseIdentifier(true);
	        specifier.importKind = specifierTypeKind;
	      } else {
	        if (importedIsString) {
	          throw this.raise(Errors.ImportBindingIsString, specifier, {
	            importName: firstIdent.value
	          });
	        }
	        specifier.imported = firstIdent;
	        specifier.importKind = null;
	      }
	      if (this.eatContextual(93)) {
	        specifier.local = this.parseIdentifier();
	      } else {
	        isBinding = true;
	        specifier.local = this.cloneIdentifier(specifier.imported);
	      }
	    }
	    const specifierIsTypeImport = hasTypeImportKind(specifier);
	    if (isInTypeOnlyImport && specifierIsTypeImport) {
	      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
	    }
	    if (isInTypeOnlyImport || specifierIsTypeImport) {
	      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
	    }
	    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
	      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
	    }
	    return this.finishImportSpecifier(specifier, "ImportSpecifier");
	  }
	  parseBindingAtom() {
	    switch (this.state.type) {
	      case 78:
	        return this.parseIdentifier(true);
	      default:
	        return super.parseBindingAtom();
	    }
	  }
	  parseFunctionParams(node, isConstructor) {
	    const kind = node.kind;
	    if (kind !== "get" && kind !== "set" && this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.parseFunctionParams(node, isConstructor);
	  }
	  parseVarId(decl, kind) {
	    super.parseVarId(decl, kind);
	    if (this.match(14)) {
	      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
	      this.resetEndLocation(decl.id);
	    }
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    if (this.match(14)) {
	      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	      this.state.noAnonFunctionType = true;
	      node.returnType = this.flowParseTypeAnnotation();
	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
	    }
	    return super.parseAsyncArrowFromCallExpression(node, call);
	  }
	  shouldParseAsyncArrow() {
	    return this.match(14) || super.shouldParseAsyncArrow();
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    var _jsx;
	    let state = null;
	    let jsx2;
	    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
	      state = this.state.clone();
	      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!jsx2.error) return jsx2.node;
	      const {
	        context
	      } = this.state;
	      const currentContext = context[context.length - 1];
	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	        context.pop();
	      }
	    }
	    if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
	      var _jsx2, _jsx3;
	      state = state || this.state.clone();
	      let typeParameters;
	      const arrow = this.tryParse((abort) => {
	        var _arrowExpression$extr;
	        typeParameters = this.flowParseTypeParameterDeclaration();
	        const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
	          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	          this.resetStartLocationFromNode(result, typeParameters);
	          return result;
	        });
	        if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
	        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
	        if (expr.type !== "ArrowFunctionExpression") abort();
	        expr.typeParameters = typeParameters;
	        this.resetStartLocationFromNode(expr, typeParameters);
	        return arrowExpression2;
	      }, state);
	      let arrowExpression = null;
	      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
	        if (!arrow.error && !arrow.aborted) {
	          if (arrow.node.async) {
	            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
	          }
	          return arrow.node;
	        }
	        arrowExpression = arrow.node;
	      }
	      if ((_jsx2 = jsx2) != null && _jsx2.node) {
	        this.state = jsx2.failState;
	        return jsx2.node;
	      }
	      if (arrowExpression) {
	        this.state = arrow.failState;
	        return arrowExpression;
	      }
	      if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
	      if (arrow.thrown) throw arrow.error;
	      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
	    }
	    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	  }
	  parseArrow(node) {
	    if (this.match(14)) {
	      const result = this.tryParse(() => {
	        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	        this.state.noAnonFunctionType = true;
	        const typeNode = this.startNode();
	        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	        if (this.canInsertSemicolon()) this.unexpected();
	        if (!this.match(19)) this.unexpected();
	        return typeNode;
	      });
	      if (result.thrown) return null;
	      if (result.error) this.state = result.failState;
	      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
	    }
	    return super.parseArrow(node);
	  }
	  shouldParseArrow(params) {
	    return this.match(14) || super.shouldParseArrow(params);
	  }
	  setArrowFunctionParameters(node, params) {
	    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      node.params = params;
	    } else {
	      super.setArrowFunctionParameters(node, params);
	    }
	  }
	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
	    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      return;
	    }
	    for (let i = 0; i < node.params.length; i++) {
	      if (this.isThisParam(node.params[i]) && i > 0) {
	        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
	      }
	    }
	    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
	  }
	  parseParenAndDistinguishExpression(canBeArrow) {
	    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
	  }
	  parseSubscripts(base, startLoc, noCalls) {
	    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
	      this.next();
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      node.arguments = super.parseCallExpressionArguments(11);
	      base = this.finishNode(node, "CallExpression");
	    } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
	      const state = this.state.clone();
	      const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
	      if (!arrow.error && !arrow.aborted) return arrow.node;
	      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
	      if (result.node && !result.error) return result.node;
	      if (arrow.node) {
	        this.state = arrow.failState;
	        return arrow.node;
	      }
	      if (result.node) {
	        this.state = result.failState;
	        return result.node;
	      }
	      throw arrow.error || result.error;
	    }
	    return super.parseSubscripts(base, startLoc, noCalls);
	  }
	  parseSubscript(base, startLoc, noCalls, subscriptState) {
	    if (this.match(18) && this.isLookaheadToken_lt()) {
	      subscriptState.optionalChainMember = true;
	      if (noCalls) {
	        subscriptState.stop = true;
	        return base;
	      }
	      this.next();
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
	      this.expect(10);
	      node.arguments = this.parseCallExpressionArguments(11);
	      node.optional = true;
	      return this.finishCallExpression(node, true);
	    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      const result = this.tryParse(() => {
	        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
	        this.expect(10);
	        node.arguments = super.parseCallExpressionArguments(11);
	        if (subscriptState.optionalChainMember) {
	          node.optional = false;
	        }
	        return this.finishCallExpression(node, subscriptState.optionalChainMember);
	      });
	      if (result.node) {
	        if (result.error) this.state = result.failState;
	        return result.node;
	      }
	    }
	    return super.parseSubscript(base, startLoc, noCalls, subscriptState);
	  }
	  parseNewCallee(node) {
	    super.parseNewCallee(node);
	    let targs = null;
	    if (this.shouldParseTypes() && this.match(47)) {
	      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
	    }
	    node.typeArguments = targs;
	  }
	  parseAsyncArrowWithTypeParameters(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.parseFunctionParams(node, false);
	    if (!this.parseArrow(node)) return;
	    return super.parseArrowExpression(node, void 0, true);
	  }
	  readToken_mult_modulo(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
	      this.state.hasFlowComment = false;
	      this.state.pos += 2;
	      this.nextToken();
	      return;
	    }
	    super.readToken_mult_modulo(code2);
	  }
	  readToken_pipe_amp(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code2 === 124 && next === 125) {
	      this.finishOp(9, 2);
	      return;
	    }
	    super.readToken_pipe_amp(code2);
	  }
	  parseTopLevel(file, program) {
	    const fileNode = super.parseTopLevel(file, program);
	    if (this.state.hasFlowComment) {
	      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
	    }
	    return fileNode;
	  }
	  skipBlockComment() {
	    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
	      if (this.state.hasFlowComment) {
	        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
	      }
	      this.hasFlowCommentCompletion();
	      const commentSkip = this.skipFlowComment();
	      if (commentSkip) {
	        this.state.pos += commentSkip;
	        this.state.hasFlowComment = true;
	      }
	      return;
	    }
	    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
	  }
	  skipFlowComment() {
	    const {
	      pos
	    } = this.state;
	    let shiftToFirstNonWhiteSpace = 2;
	    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
	      shiftToFirstNonWhiteSpace++;
	    }
	    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
	    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
	    if (ch2 === 58 && ch3 === 58) {
	      return shiftToFirstNonWhiteSpace + 2;
	    }
	    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
	      return shiftToFirstNonWhiteSpace + 12;
	    }
	    if (ch2 === 58 && ch3 !== 58) {
	      return shiftToFirstNonWhiteSpace;
	    }
	    return false;
	  }
	  hasFlowCommentCompletion() {
	    const end = this.input.indexOf("*/", this.state.pos);
	    if (end === -1) {
	      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
	    }
	  }
	  flowEnumErrorBooleanMemberNotInitialized(loc, {
	    enumName,
	    memberName
	  }) {
	    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
	      memberName,
	      enumName
	    });
	  }
	  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
	    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
	  }
	  flowEnumErrorNumberMemberNotInitialized(loc, details) {
	    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
	  }
	  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
	    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
	  }
	  flowEnumMemberInit() {
	    const startLoc = this.state.startLoc;
	    const endOfInit = () => this.match(12) || this.match(8);
	    switch (this.state.type) {
	      case 135: {
	        const literal = this.parseNumericLiteral(this.state.value);
	        if (endOfInit()) {
	          return {
	            type: "number",
	            loc: literal.loc.start,
	            value: literal
	          };
	        }
	        return {
	          type: "invalid",
	          loc: startLoc
	        };
	      }
	      case 134: {
	        const literal = this.parseStringLiteral(this.state.value);
	        if (endOfInit()) {
	          return {
	            type: "string",
	            loc: literal.loc.start,
	            value: literal
	          };
	        }
	        return {
	          type: "invalid",
	          loc: startLoc
	        };
	      }
	      case 85:
	      case 86: {
	        const literal = this.parseBooleanLiteral(this.match(85));
	        if (endOfInit()) {
	          return {
	            type: "boolean",
	            loc: literal.loc.start,
	            value: literal
	          };
	        }
	        return {
	          type: "invalid",
	          loc: startLoc
	        };
	      }
	      default:
	        return {
	          type: "invalid",
	          loc: startLoc
	        };
	    }
	  }
	  flowEnumMemberRaw() {
	    const loc = this.state.startLoc;
	    const id = this.parseIdentifier(true);
	    const init = this.eat(29) ? this.flowEnumMemberInit() : {
	      type: "none",
	      loc
	    };
	    return {
	      id,
	      init
	    };
	  }
	  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
	    const {
	      explicitType
	    } = context;
	    if (explicitType === null) {
	      return;
	    }
	    if (explicitType !== expectedType) {
	      this.flowEnumErrorInvalidMemberInitializer(loc, context);
	    }
	  }
	  flowEnumMembers({
	    enumName,
	    explicitType
	  }) {
	    const seenNames = /* @__PURE__ */ new Set();
	    const members = {
	      booleanMembers: [],
	      numberMembers: [],
	      stringMembers: [],
	      defaultedMembers: []
	    };
	    let hasUnknownMembers = false;
	    while (!this.match(8)) {
	      if (this.eat(21)) {
	        hasUnknownMembers = true;
	        break;
	      }
	      const memberNode = this.startNode();
	      const {
	        id,
	        init
	      } = this.flowEnumMemberRaw();
	      const memberName = id.name;
	      if (memberName === "") {
	        continue;
	      }
	      if (/^[a-z]/.test(memberName)) {
	        this.raise(FlowErrors.EnumInvalidMemberName, id, {
	          memberName,
	          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
	          enumName
	        });
	      }
	      if (seenNames.has(memberName)) {
	        this.raise(FlowErrors.EnumDuplicateMemberName, id, {
	          memberName,
	          enumName
	        });
	      }
	      seenNames.add(memberName);
	      const context = {
	        enumName,
	        explicitType,
	        memberName
	      };
	      memberNode.id = id;
	      switch (init.type) {
	        case "boolean": {
	          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
	          memberNode.init = init.value;
	          members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
	          break;
	        }
	        case "number": {
	          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
	          memberNode.init = init.value;
	          members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
	          break;
	        }
	        case "string": {
	          this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
	          memberNode.init = init.value;
	          members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
	          break;
	        }
	        case "invalid": {
	          throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
	        }
	        case "none": {
	          switch (explicitType) {
	            case "boolean":
	              this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
	              break;
	            case "number":
	              this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
	              break;
	            default:
	              members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
	          }
	        }
	      }
	      if (!this.match(8)) {
	        this.expect(12);
	      }
	    }
	    return {
	      members,
	      hasUnknownMembers
	    };
	  }
	  flowEnumStringMembers(initializedMembers, defaultedMembers, {
	    enumName
	  }) {
	    if (initializedMembers.length === 0) {
	      return defaultedMembers;
	    } else if (defaultedMembers.length === 0) {
	      return initializedMembers;
	    } else if (defaultedMembers.length > initializedMembers.length) {
	      for (const member of initializedMembers) {
	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
	          enumName
	        });
	      }
	      return defaultedMembers;
	    } else {
	      for (const member of defaultedMembers) {
	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
	          enumName
	        });
	      }
	      return initializedMembers;
	    }
	  }
	  flowEnumParseExplicitType({
	    enumName
	  }) {
	    if (!this.eatContextual(102)) return null;
	    if (!tokenIsIdentifier(this.state.type)) {
	      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
	        enumName
	      });
	    }
	    const {
	      value
	    } = this.state;
	    this.next();
	    if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
	      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
	        enumName,
	        invalidEnumType: value
	      });
	    }
	    return value;
	  }
	  flowEnumBody(node, id) {
	    const enumName = id.name;
	    const nameLoc = id.loc.start;
	    const explicitType = this.flowEnumParseExplicitType({
	      enumName
	    });
	    this.expect(5);
	    const {
	      members,
	      hasUnknownMembers
	    } = this.flowEnumMembers({
	      enumName,
	      explicitType
	    });
	    node.hasUnknownMembers = hasUnknownMembers;
	    switch (explicitType) {
	      case "boolean":
	        node.explicitType = true;
	        node.members = members.booleanMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumBooleanBody");
	      case "number":
	        node.explicitType = true;
	        node.members = members.numberMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumNumberBody");
	      case "string":
	        node.explicitType = true;
	        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	          enumName
	        });
	        this.expect(8);
	        return this.finishNode(node, "EnumStringBody");
	      case "symbol":
	        node.members = members.defaultedMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumSymbolBody");
	      default: {
	        const empty = () => {
	          node.members = [];
	          this.expect(8);
	          return this.finishNode(node, "EnumStringBody");
	        };
	        node.explicitType = false;
	        const boolsLen = members.booleanMembers.length;
	        const numsLen = members.numberMembers.length;
	        const strsLen = members.stringMembers.length;
	        const defaultedLen = members.defaultedMembers.length;
	        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
	          return empty();
	        } else if (!boolsLen && !numsLen) {
	          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	            enumName
	          });
	          this.expect(8);
	          return this.finishNode(node, "EnumStringBody");
	        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
	          for (const member of members.defaultedMembers) {
	            this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
	              enumName,
	              memberName: member.id.name
	            });
	          }
	          node.members = members.booleanMembers;
	          this.expect(8);
	          return this.finishNode(node, "EnumBooleanBody");
	        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
	          for (const member of members.defaultedMembers) {
	            this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
	              enumName,
	              memberName: member.id.name
	            });
	          }
	          node.members = members.numberMembers;
	          this.expect(8);
	          return this.finishNode(node, "EnumNumberBody");
	        } else {
	          this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
	            enumName
	          });
	          return empty();
	        }
	      }
	    }
	  }
	  flowParseEnumDeclaration(node) {
	    const id = this.parseIdentifier();
	    node.id = id;
	    node.body = this.flowEnumBody(this.startNode(), id);
	    return this.finishNode(node, "EnumDeclaration");
	  }
	  jsxParseOpeningElementAfterName(node) {
	    if (this.shouldParseTypes()) {
	      if (this.match(47) || this.match(51)) {
	        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
	      }
	    }
	    return super.jsxParseOpeningElementAfterName(node);
	  }
	  isLookaheadToken_lt() {
	    const next = this.nextTokenStart();
	    if (this.input.charCodeAt(next) === 60) {
	      const afterNext = this.input.charCodeAt(next + 1);
	      return afterNext !== 60 && afterNext !== 61;
	    }
	    return false;
	  }
	  reScan_lt_gt() {
	    const {
	      type
	    } = this.state;
	    if (type === 47) {
	      this.state.pos -= 1;
	      this.readToken_lt();
	    } else if (type === 48) {
	      this.state.pos -= 1;
	      this.readToken_gt();
	    }
	  }
	  reScan_lt() {
	    const {
	      type
	    } = this.state;
	    if (type === 51) {
	      this.state.pos -= 2;
	      this.finishOp(47, 1);
	      return 47;
	    }
	    return type;
	  }
	  maybeUnwrapTypeCastExpression(node) {
	    return node.type === "TypeCastExpression" ? node.expression : node;
	  }
	};
	const entities = {
	  __proto__: null,
	  quot: '"',
	  amp: "&",
	  apos: "'",
	  lt: "<",
	  gt: ">",
	  nbsp: "\xA0",
	  iexcl: "\xA1",
	  cent: "\xA2",
	  pound: "\xA3",
	  curren: "\xA4",
	  yen: "\xA5",
	  brvbar: "\xA6",
	  sect: "\xA7",
	  uml: "\xA8",
	  copy: "\xA9",
	  ordf: "\xAA",
	  laquo: "\xAB",
	  not: "\xAC",
	  shy: "\xAD",
	  reg: "\xAE",
	  macr: "\xAF",
	  deg: "\xB0",
	  plusmn: "\xB1",
	  sup2: "\xB2",
	  sup3: "\xB3",
	  acute: "\xB4",
	  micro: "\xB5",
	  para: "\xB6",
	  middot: "\xB7",
	  cedil: "\xB8",
	  sup1: "\xB9",
	  ordm: "\xBA",
	  raquo: "\xBB",
	  frac14: "\xBC",
	  frac12: "\xBD",
	  frac34: "\xBE",
	  iquest: "\xBF",
	  Agrave: "\xC0",
	  Aacute: "\xC1",
	  Acirc: "\xC2",
	  Atilde: "\xC3",
	  Auml: "\xC4",
	  Aring: "\xC5",
	  AElig: "\xC6",
	  Ccedil: "\xC7",
	  Egrave: "\xC8",
	  Eacute: "\xC9",
	  Ecirc: "\xCA",
	  Euml: "\xCB",
	  Igrave: "\xCC",
	  Iacute: "\xCD",
	  Icirc: "\xCE",
	  Iuml: "\xCF",
	  ETH: "\xD0",
	  Ntilde: "\xD1",
	  Ograve: "\xD2",
	  Oacute: "\xD3",
	  Ocirc: "\xD4",
	  Otilde: "\xD5",
	  Ouml: "\xD6",
	  times: "\xD7",
	  Oslash: "\xD8",
	  Ugrave: "\xD9",
	  Uacute: "\xDA",
	  Ucirc: "\xDB",
	  Uuml: "\xDC",
	  Yacute: "\xDD",
	  THORN: "\xDE",
	  szlig: "\xDF",
	  agrave: "\xE0",
	  aacute: "\xE1",
	  acirc: "\xE2",
	  atilde: "\xE3",
	  auml: "\xE4",
	  aring: "\xE5",
	  aelig: "\xE6",
	  ccedil: "\xE7",
	  egrave: "\xE8",
	  eacute: "\xE9",
	  ecirc: "\xEA",
	  euml: "\xEB",
	  igrave: "\xEC",
	  iacute: "\xED",
	  icirc: "\xEE",
	  iuml: "\xEF",
	  eth: "\xF0",
	  ntilde: "\xF1",
	  ograve: "\xF2",
	  oacute: "\xF3",
	  ocirc: "\xF4",
	  otilde: "\xF5",
	  ouml: "\xF6",
	  divide: "\xF7",
	  oslash: "\xF8",
	  ugrave: "\xF9",
	  uacute: "\xFA",
	  ucirc: "\xFB",
	  uuml: "\xFC",
	  yacute: "\xFD",
	  thorn: "\xFE",
	  yuml: "\xFF",
	  OElig: "\u0152",
	  oelig: "\u0153",
	  Scaron: "\u0160",
	  scaron: "\u0161",
	  Yuml: "\u0178",
	  fnof: "\u0192",
	  circ: "\u02C6",
	  tilde: "\u02DC",
	  Alpha: "\u0391",
	  Beta: "\u0392",
	  Gamma: "\u0393",
	  Delta: "\u0394",
	  Epsilon: "\u0395",
	  Zeta: "\u0396",
	  Eta: "\u0397",
	  Theta: "\u0398",
	  Iota: "\u0399",
	  Kappa: "\u039A",
	  Lambda: "\u039B",
	  Mu: "\u039C",
	  Nu: "\u039D",
	  Xi: "\u039E",
	  Omicron: "\u039F",
	  Pi: "\u03A0",
	  Rho: "\u03A1",
	  Sigma: "\u03A3",
	  Tau: "\u03A4",
	  Upsilon: "\u03A5",
	  Phi: "\u03A6",
	  Chi: "\u03A7",
	  Psi: "\u03A8",
	  Omega: "\u03A9",
	  alpha: "\u03B1",
	  beta: "\u03B2",
	  gamma: "\u03B3",
	  delta: "\u03B4",
	  epsilon: "\u03B5",
	  zeta: "\u03B6",
	  eta: "\u03B7",
	  theta: "\u03B8",
	  iota: "\u03B9",
	  kappa: "\u03BA",
	  lambda: "\u03BB",
	  mu: "\u03BC",
	  nu: "\u03BD",
	  xi: "\u03BE",
	  omicron: "\u03BF",
	  pi: "\u03C0",
	  rho: "\u03C1",
	  sigmaf: "\u03C2",
	  sigma: "\u03C3",
	  tau: "\u03C4",
	  upsilon: "\u03C5",
	  phi: "\u03C6",
	  chi: "\u03C7",
	  psi: "\u03C8",
	  omega: "\u03C9",
	  thetasym: "\u03D1",
	  upsih: "\u03D2",
	  piv: "\u03D6",
	  ensp: "\u2002",
	  emsp: "\u2003",
	  thinsp: "\u2009",
	  zwnj: "\u200C",
	  zwj: "\u200D",
	  lrm: "\u200E",
	  rlm: "\u200F",
	  ndash: "\u2013",
	  mdash: "\u2014",
	  lsquo: "\u2018",
	  rsquo: "\u2019",
	  sbquo: "\u201A",
	  ldquo: "\u201C",
	  rdquo: "\u201D",
	  bdquo: "\u201E",
	  dagger: "\u2020",
	  Dagger: "\u2021",
	  bull: "\u2022",
	  hellip: "\u2026",
	  permil: "\u2030",
	  prime: "\u2032",
	  Prime: "\u2033",
	  lsaquo: "\u2039",
	  rsaquo: "\u203A",
	  oline: "\u203E",
	  frasl: "\u2044",
	  euro: "\u20AC",
	  image: "\u2111",
	  weierp: "\u2118",
	  real: "\u211C",
	  trade: "\u2122",
	  alefsym: "\u2135",
	  larr: "\u2190",
	  uarr: "\u2191",
	  rarr: "\u2192",
	  darr: "\u2193",
	  harr: "\u2194",
	  crarr: "\u21B5",
	  lArr: "\u21D0",
	  uArr: "\u21D1",
	  rArr: "\u21D2",
	  dArr: "\u21D3",
	  hArr: "\u21D4",
	  forall: "\u2200",
	  part: "\u2202",
	  exist: "\u2203",
	  empty: "\u2205",
	  nabla: "\u2207",
	  isin: "\u2208",
	  notin: "\u2209",
	  ni: "\u220B",
	  prod: "\u220F",
	  sum: "\u2211",
	  minus: "\u2212",
	  lowast: "\u2217",
	  radic: "\u221A",
	  prop: "\u221D",
	  infin: "\u221E",
	  ang: "\u2220",
	  and: "\u2227",
	  or: "\u2228",
	  cap: "\u2229",
	  cup: "\u222A",
	  int: "\u222B",
	  there4: "\u2234",
	  sim: "\u223C",
	  cong: "\u2245",
	  asymp: "\u2248",
	  ne: "\u2260",
	  equiv: "\u2261",
	  le: "\u2264",
	  ge: "\u2265",
	  sub: "\u2282",
	  sup: "\u2283",
	  nsub: "\u2284",
	  sube: "\u2286",
	  supe: "\u2287",
	  oplus: "\u2295",
	  otimes: "\u2297",
	  perp: "\u22A5",
	  sdot: "\u22C5",
	  lceil: "\u2308",
	  rceil: "\u2309",
	  lfloor: "\u230A",
	  rfloor: "\u230B",
	  lang: "\u2329",
	  rang: "\u232A",
	  loz: "\u25CA",
	  spades: "\u2660",
	  clubs: "\u2663",
	  hearts: "\u2665",
	  diams: "\u2666"
	};
	const lineBreak = /\r\n|[\r\n\u2028\u2029]/;
	const lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code2) {
	  switch (code2) {
	    case 10:
	    case 13:
	    case 8232:
	    case 8233:
	      return true;
	    default:
	      return false;
	  }
	}
	function hasNewLine(input, start, end) {
	  for (let i = start; i < end; i++) {
	    if (isNewLine(input.charCodeAt(i))) {
	      return true;
	    }
	  }
	  return false;
	}
	const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
	function isWhitespace(code2) {
	  switch (code2) {
	    case 9:
	    case 11:
	    case 12:
	    case 32:
	    case 160:
	    case 5760:
	    case 8192:
	    case 8193:
	    case 8194:
	    case 8195:
	    case 8196:
	    case 8197:
	    case 8198:
	    case 8199:
	    case 8200:
	    case 8201:
	    case 8202:
	    case 8239:
	    case 8287:
	    case 12288:
	    case 65279:
	      return true;
	    default:
	      return false;
	  }
	}
	const JsxErrors = ParseErrorEnum`jsx`({
	  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
	  MissingClosingTagElement: ({
	    openingTagName
	  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
	  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
	  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
	  UnexpectedToken: ({
	    unexpected,
	    HTMLEntity
	  }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
	  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
	  UnterminatedJsxContent: "Unterminated JSX contents.",
	  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
	});
	function isFragment(object) {
	  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
	}
	function getQualifiedJSXName(object) {
	  if (object.type === "JSXIdentifier") {
	    return object.name;
	  }
	  if (object.type === "JSXNamespacedName") {
	    return object.namespace.name + ":" + object.name.name;
	  }
	  if (object.type === "JSXMemberExpression") {
	    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
	  }
	  throw new Error("Node had unexpected type: " + object.type);
	}
	var jsx = (superClass) => class JSXParserMixin extends superClass {
	  jsxReadToken() {
	    let out = "";
	    let chunkStart = this.state.pos;
	    for (; ; ) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
	      }
	      const ch = this.input.charCodeAt(this.state.pos);
	      switch (ch) {
	        case 60:
	        case 123:
	          if (this.state.pos === this.state.start) {
	            if (ch === 60 && this.state.canStartJSXElement) {
	              ++this.state.pos;
	              this.finishToken(143);
	            } else {
	              super.getTokenFromCode(ch);
	            }
	            return;
	          }
	          out += this.input.slice(chunkStart, this.state.pos);
	          this.finishToken(142, out);
	          return;
	        case 38:
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadEntity();
	          chunkStart = this.state.pos;
	          break;
	        case 62:
	        case 125:
	        default:
	          if (isNewLine(ch)) {
	            out += this.input.slice(chunkStart, this.state.pos);
	            out += this.jsxReadNewLine(true);
	            chunkStart = this.state.pos;
	          } else {
	            ++this.state.pos;
	          }
	      }
	    }
	  }
	  jsxReadNewLine(normalizeCRLF) {
	    const ch = this.input.charCodeAt(this.state.pos);
	    let out;
	    ++this.state.pos;
	    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
	      ++this.state.pos;
	      out = normalizeCRLF ? "\n" : "\r\n";
	    } else {
	      out = String.fromCharCode(ch);
	    }
	    ++this.state.curLine;
	    this.state.lineStart = this.state.pos;
	    return out;
	  }
	  jsxReadString(quote) {
	    let out = "";
	    let chunkStart = ++this.state.pos;
	    for (; ; ) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(Errors.UnterminatedString, this.state.startLoc);
	      }
	      const ch = this.input.charCodeAt(this.state.pos);
	      if (ch === quote) break;
	      if (ch === 38) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.jsxReadEntity();
	        chunkStart = this.state.pos;
	      } else if (isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.jsxReadNewLine(false);
	        chunkStart = this.state.pos;
	      } else {
	        ++this.state.pos;
	      }
	    }
	    out += this.input.slice(chunkStart, this.state.pos++);
	    this.finishToken(134, out);
	  }
	  jsxReadEntity() {
	    const startPos = ++this.state.pos;
	    if (this.codePointAtPos(this.state.pos) === 35) {
	      ++this.state.pos;
	      let radix = 10;
	      if (this.codePointAtPos(this.state.pos) === 120) {
	        radix = 16;
	        ++this.state.pos;
	      }
	      const codePoint = this.readInt(radix, void 0, false, "bail");
	      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
	        ++this.state.pos;
	        return String.fromCodePoint(codePoint);
	      }
	    } else {
	      let count = 0;
	      let semi = false;
	      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
	        ++this.state.pos;
	      }
	      if (semi) {
	        const desc = this.input.slice(startPos, this.state.pos);
	        const entity = entities[desc];
	        ++this.state.pos;
	        if (entity) {
	          return entity;
	        }
	      }
	    }
	    this.state.pos = startPos;
	    return "&";
	  }
	  jsxReadWord() {
	    let ch;
	    const start = this.state.pos;
	    do {
	      ch = this.input.charCodeAt(++this.state.pos);
	    } while (isIdentifierChar(ch) || ch === 45);
	    this.finishToken(141, this.input.slice(start, this.state.pos));
	  }
	  jsxParseIdentifier() {
	    const node = this.startNode();
	    if (this.match(141)) {
	      node.name = this.state.value;
	    } else if (tokenIsKeyword(this.state.type)) {
	      node.name = tokenLabelName(this.state.type);
	    } else {
	      this.unexpected();
	    }
	    this.next();
	    return this.finishNode(node, "JSXIdentifier");
	  }
	  jsxParseNamespacedName() {
	    const startLoc = this.state.startLoc;
	    const name = this.jsxParseIdentifier();
	    if (!this.eat(14)) return name;
	    const node = this.startNodeAt(startLoc);
	    node.namespace = name;
	    node.name = this.jsxParseIdentifier();
	    return this.finishNode(node, "JSXNamespacedName");
	  }
	  jsxParseElementName() {
	    const startLoc = this.state.startLoc;
	    let node = this.jsxParseNamespacedName();
	    if (node.type === "JSXNamespacedName") {
	      return node;
	    }
	    while (this.eat(16)) {
	      const newNode = this.startNodeAt(startLoc);
	      newNode.object = node;
	      newNode.property = this.jsxParseIdentifier();
	      node = this.finishNode(newNode, "JSXMemberExpression");
	    }
	    return node;
	  }
	  jsxParseAttributeValue() {
	    let node;
	    switch (this.state.type) {
	      case 5:
	        node = this.startNode();
	        this.setContext(types.brace);
	        this.next();
	        node = this.jsxParseExpressionContainer(node, types.j_oTag);
	        if (node.expression.type === "JSXEmptyExpression") {
	          this.raise(JsxErrors.AttributeIsEmpty, node);
	        }
	        return node;
	      case 143:
	      case 134:
	        return this.parseExprAtom();
	      default:
	        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
	    }
	  }
	  jsxParseEmptyExpression() {
	    const node = this.startNodeAt(this.state.lastTokEndLoc);
	    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
	  }
	  jsxParseSpreadChild(node) {
	    this.next();
	    node.expression = this.parseExpression();
	    this.setContext(types.j_expr);
	    this.state.canStartJSXElement = true;
	    this.expect(8);
	    return this.finishNode(node, "JSXSpreadChild");
	  }
	  jsxParseExpressionContainer(node, previousContext) {
	    if (this.match(8)) {
	      node.expression = this.jsxParseEmptyExpression();
	    } else {
	      const expression = this.parseExpression();
	      node.expression = expression;
	    }
	    this.setContext(previousContext);
	    this.state.canStartJSXElement = true;
	    this.expect(8);
	    return this.finishNode(node, "JSXExpressionContainer");
	  }
	  jsxParseAttribute() {
	    const node = this.startNode();
	    if (this.match(5)) {
	      this.setContext(types.brace);
	      this.next();
	      this.expect(21);
	      node.argument = this.parseMaybeAssignAllowIn();
	      this.setContext(types.j_oTag);
	      this.state.canStartJSXElement = true;
	      this.expect(8);
	      return this.finishNode(node, "JSXSpreadAttribute");
	    }
	    node.name = this.jsxParseNamespacedName();
	    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
	    return this.finishNode(node, "JSXAttribute");
	  }
	  jsxParseOpeningElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    if (this.eat(144)) {
	      return this.finishNode(node, "JSXOpeningFragment");
	    }
	    node.name = this.jsxParseElementName();
	    return this.jsxParseOpeningElementAfterName(node);
	  }
	  jsxParseOpeningElementAfterName(node) {
	    const attributes = [];
	    while (!this.match(56) && !this.match(144)) {
	      attributes.push(this.jsxParseAttribute());
	    }
	    node.attributes = attributes;
	    node.selfClosing = this.eat(56);
	    this.expect(144);
	    return this.finishNode(node, "JSXOpeningElement");
	  }
	  jsxParseClosingElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    if (this.eat(144)) {
	      return this.finishNode(node, "JSXClosingFragment");
	    }
	    node.name = this.jsxParseElementName();
	    this.expect(144);
	    return this.finishNode(node, "JSXClosingElement");
	  }
	  jsxParseElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    const children = [];
	    const openingElement = this.jsxParseOpeningElementAt(startLoc);
	    let closingElement = null;
	    if (!openingElement.selfClosing) {
	      contents: for (; ; ) {
	        switch (this.state.type) {
	          case 143:
	            startLoc = this.state.startLoc;
	            this.next();
	            if (this.eat(56)) {
	              closingElement = this.jsxParseClosingElementAt(startLoc);
	              break contents;
	            }
	            children.push(this.jsxParseElementAt(startLoc));
	            break;
	          case 142:
	            children.push(this.parseLiteral(this.state.value, "JSXText"));
	            break;
	          case 5: {
	            const node2 = this.startNode();
	            this.setContext(types.brace);
	            this.next();
	            if (this.match(21)) {
	              children.push(this.jsxParseSpreadChild(node2));
	            } else {
	              children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
	            }
	            break;
	          }
	          default:
	            this.unexpected();
	        }
	      }
	      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
	        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
	      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
	        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
	          openingTagName: getQualifiedJSXName(openingElement.name)
	        });
	      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
	        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
	            openingTagName: getQualifiedJSXName(openingElement.name)
	          });
	        }
	      }
	    }
	    if (isFragment(openingElement)) {
	      node.openingFragment = openingElement;
	      node.closingFragment = closingElement;
	    } else {
	      node.openingElement = openingElement;
	      node.closingElement = closingElement;
	    }
	    node.children = children;
	    if (this.match(47)) {
	      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
	    }
	    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
	  }
	  jsxParseElement() {
	    const startLoc = this.state.startLoc;
	    this.next();
	    return this.jsxParseElementAt(startLoc);
	  }
	  setContext(newContext) {
	    const {
	      context
	    } = this.state;
	    context[context.length - 1] = newContext;
	  }
	  parseExprAtom(refExpressionErrors) {
	    if (this.match(143)) {
	      return this.jsxParseElement();
	    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
	      this.replaceToken(143);
	      return this.jsxParseElement();
	    } else {
	      return super.parseExprAtom(refExpressionErrors);
	    }
	  }
	  skipSpace() {
	    const curContext = this.curContext();
	    if (!curContext.preserveSpace) super.skipSpace();
	  }
	  getTokenFromCode(code2) {
	    const context = this.curContext();
	    if (context === types.j_expr) {
	      this.jsxReadToken();
	      return;
	    }
	    if (context === types.j_oTag || context === types.j_cTag) {
	      if (isIdentifierStart(code2)) {
	        this.jsxReadWord();
	        return;
	      }
	      if (code2 === 62) {
	        ++this.state.pos;
	        this.finishToken(144);
	        return;
	      }
	      if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
	        this.jsxReadString(code2);
	        return;
	      }
	    }
	    if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
	      ++this.state.pos;
	      this.finishToken(143);
	      return;
	    }
	    super.getTokenFromCode(code2);
	  }
	  updateContext(prevType) {
	    const {
	      context,
	      type
	    } = this.state;
	    if (type === 56 && prevType === 143) {
	      context.splice(-2, 2, types.j_cTag);
	      this.state.canStartJSXElement = false;
	    } else if (type === 143) {
	      context.push(types.j_oTag);
	    } else if (type === 144) {
	      const out = context[context.length - 1];
	      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
	        context.pop();
	        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
	      } else {
	        this.setContext(types.j_expr);
	        this.state.canStartJSXElement = true;
	      }
	    } else {
	      this.state.canStartJSXElement = tokenComesBeforeExpression(type);
	    }
	  }
	};
	class TypeScriptScope extends Scope {
	  constructor(...args) {
	    super(...args);
	    this.tsNames = /* @__PURE__ */ new Map();
	  }
	}
	class TypeScriptScopeHandler extends ScopeHandler {
	  constructor(...args) {
	    super(...args);
	    this.importsStack = [];
	  }
	  createScope(flags) {
	    this.importsStack.push(/* @__PURE__ */ new Set());
	    return new TypeScriptScope(flags);
	  }
	  enter(flags) {
	    if (flags === 256) {
	      this.importsStack.push(/* @__PURE__ */ new Set());
	    }
	    super.enter(flags);
	  }
	  exit() {
	    const flags = super.exit();
	    if (flags === 256) {
	      this.importsStack.pop();
	    }
	    return flags;
	  }
	  hasImport(name, allowShadow) {
	    const len = this.importsStack.length;
	    if (this.importsStack[len - 1].has(name)) {
	      return true;
	    }
	    if (!allowShadow && len > 1) {
	      for (let i = 0; i < len - 1; i++) {
	        if (this.importsStack[i].has(name)) return true;
	      }
	    }
	    return false;
	  }
	  declareName(name, bindingType, loc) {
	    if (bindingType & 4096) {
	      if (this.hasImport(name, true)) {
	        this.parser.raise(Errors.VarRedeclaration, loc, {
	          identifierName: name
	        });
	      }
	      this.importsStack[this.importsStack.length - 1].add(name);
	      return;
	    }
	    const scope = this.currentScope();
	    let type = scope.tsNames.get(name) || 0;
	    if (bindingType & 1024) {
	      this.maybeExportDefined(scope, name);
	      scope.tsNames.set(name, type | 16);
	      return;
	    }
	    super.declareName(name, bindingType, loc);
	    if (bindingType & 2) {
	      if (!(bindingType & 1)) {
	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
	        this.maybeExportDefined(scope, name);
	      }
	      type = type | 1;
	    }
	    if (bindingType & 256) {
	      type = type | 2;
	    }
	    if (bindingType & 512) {
	      type = type | 4;
	    }
	    if (bindingType & 128) {
	      type = type | 8;
	    }
	    if (type) scope.tsNames.set(name, type);
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    const type = scope.tsNames.get(name);
	    if ((type & 2) > 0) {
	      if (bindingType & 256) {
	        const isConst = !!(bindingType & 512);
	        const wasConst = (type & 4) > 0;
	        return isConst !== wasConst;
	      }
	      return true;
	    }
	    if (bindingType & 128 && (type & 8) > 0) {
	      if (scope.names.get(name) & 2) {
	        return !!(bindingType & 1);
	      } else {
	        return false;
	      }
	    }
	    if (bindingType & 2 && (type & 1) > 0) {
	      return true;
	    }
	    return super.isRedeclaredInScope(scope, name, bindingType);
	  }
	  checkLocalExport(id) {
	    const {
	      name
	    } = id;
	    if (this.hasImport(name)) return;
	    const len = this.scopeStack.length;
	    for (let i = len - 1; i >= 0; i--) {
	      const scope = this.scopeStack[i];
	      const type = scope.tsNames.get(name);
	      if ((type & 1) > 0 || (type & 16) > 0) {
	        return;
	      }
	    }
	    super.checkLocalExport(id);
	  }
	}
	class ProductionParameterHandler {
	  constructor() {
	    this.stacks = [];
	  }
	  enter(flags) {
	    this.stacks.push(flags);
	  }
	  exit() {
	    this.stacks.pop();
	  }
	  currentFlags() {
	    return this.stacks[this.stacks.length - 1];
	  }
	  get hasAwait() {
	    return (this.currentFlags() & 2) > 0;
	  }
	  get hasYield() {
	    return (this.currentFlags() & 1) > 0;
	  }
	  get hasReturn() {
	    return (this.currentFlags() & 4) > 0;
	  }
	  get hasIn() {
	    return (this.currentFlags() & 8) > 0;
	  }
	}
	function functionFlags(isAsync, isGenerator) {
	  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
	}
	class BaseParser {
	  constructor() {
	    this.sawUnambiguousESM = false;
	    this.ambiguousScriptDifferentAst = false;
	  }
	  sourceToOffsetPos(sourcePos) {
	    return sourcePos + this.startIndex;
	  }
	  offsetToSourcePos(offsetPos) {
	    return offsetPos - this.startIndex;
	  }
	  hasPlugin(pluginConfig) {
	    if (typeof pluginConfig === "string") {
	      return this.plugins.has(pluginConfig);
	    } else {
	      const [pluginName, pluginOptions] = pluginConfig;
	      if (!this.hasPlugin(pluginName)) {
	        return false;
	      }
	      const actualOptions = this.plugins.get(pluginName);
	      for (const key of Object.keys(pluginOptions)) {
	        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
	          return false;
	        }
	      }
	      return true;
	    }
	  }
	  getPluginOption(plugin, name) {
	    var _this$plugins$get;
	    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
	  }
	}
	function setTrailingComments(node, comments) {
	  if (node.trailingComments === void 0) {
	    node.trailingComments = comments;
	  } else {
	    node.trailingComments.unshift(...comments);
	  }
	}
	function setLeadingComments(node, comments) {
	  if (node.leadingComments === void 0) {
	    node.leadingComments = comments;
	  } else {
	    node.leadingComments.unshift(...comments);
	  }
	}
	function setInnerComments(node, comments) {
	  if (node.innerComments === void 0) {
	    node.innerComments = comments;
	  } else {
	    node.innerComments.unshift(...comments);
	  }
	}
	function adjustInnerComments(node, elements, commentWS) {
	  let lastElement = null;
	  let i = elements.length;
	  while (lastElement === null && i > 0) {
	    lastElement = elements[--i];
	  }
	  if (lastElement === null || lastElement.start > commentWS.start) {
	    setInnerComments(node, commentWS.comments);
	  } else {
	    setTrailingComments(lastElement, commentWS.comments);
	  }
	}
	class CommentsParser extends BaseParser {
	  addComment(comment) {
	    if (this.filename) comment.loc.filename = this.filename;
	    const {
	      commentsLen
	    } = this.state;
	    if (this.comments.length !== commentsLen) {
	      this.comments.length = commentsLen;
	    }
	    this.comments.push(comment);
	    this.state.commentsLen++;
	  }
	  processComment(node) {
	    const {
	      commentStack
	    } = this.state;
	    const commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    let i = commentStackLength - 1;
	    const lastCommentWS = commentStack[i];
	    if (lastCommentWS.start === node.end) {
	      lastCommentWS.leadingNode = node;
	      i--;
	    }
	    const {
	      start: nodeStart
	    } = node;
	    for (; i >= 0; i--) {
	      const commentWS = commentStack[i];
	      const commentEnd = commentWS.end;
	      if (commentEnd > nodeStart) {
	        commentWS.containingNode = node;
	        this.finalizeComment(commentWS);
	        commentStack.splice(i, 1);
	      } else {
	        if (commentEnd === nodeStart) {
	          commentWS.trailingNode = node;
	        }
	        break;
	      }
	    }
	  }
	  finalizeComment(commentWS) {
	    var _node$options;
	    const {
	      comments
	    } = commentWS;
	    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
	      if (commentWS.leadingNode !== null) {
	        setTrailingComments(commentWS.leadingNode, comments);
	      }
	      if (commentWS.trailingNode !== null) {
	        setLeadingComments(commentWS.trailingNode, comments);
	      }
	    } else {
	      const {
	        containingNode: node,
	        start: commentStart
	      } = commentWS;
	      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
	        switch (node.type) {
	          case "ObjectExpression":
	          case "ObjectPattern":
	          case "RecordExpression":
	            adjustInnerComments(node, node.properties, commentWS);
	            break;
	          case "CallExpression":
	          case "OptionalCallExpression":
	            adjustInnerComments(node, node.arguments, commentWS);
	            break;
	          case "ImportExpression":
	            adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
	            break;
	          case "FunctionDeclaration":
	          case "FunctionExpression":
	          case "ArrowFunctionExpression":
	          case "ObjectMethod":
	          case "ClassMethod":
	          case "ClassPrivateMethod":
	            adjustInnerComments(node, node.params, commentWS);
	            break;
	          case "ArrayExpression":
	          case "ArrayPattern":
	          case "TupleExpression":
	            adjustInnerComments(node, node.elements, commentWS);
	            break;
	          case "ExportNamedDeclaration":
	          case "ImportDeclaration":
	            adjustInnerComments(node, node.specifiers, commentWS);
	            break;
	          case "TSEnumDeclaration":
	            {
	              adjustInnerComments(node, node.members, commentWS);
	            }
	            break;
	          case "TSEnumBody":
	            adjustInnerComments(node, node.members, commentWS);
	            break;
	          default: {
	            setInnerComments(node, comments);
	          }
	        }
	      } else {
	        setInnerComments(node, comments);
	      }
	    }
	  }
	  finalizeRemainingComments() {
	    const {
	      commentStack
	    } = this.state;
	    for (let i = commentStack.length - 1; i >= 0; i--) {
	      this.finalizeComment(commentStack[i]);
	    }
	    this.state.commentStack = [];
	  }
	  resetPreviousNodeTrailingComments(node) {
	    const {
	      commentStack
	    } = this.state;
	    const {
	      length
	    } = commentStack;
	    if (length === 0) return;
	    const commentWS = commentStack[length - 1];
	    if (commentWS.leadingNode === node) {
	      commentWS.leadingNode = null;
	    }
	  }
	  takeSurroundingComments(node, start, end) {
	    const {
	      commentStack
	    } = this.state;
	    const commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    let i = commentStackLength - 1;
	    for (; i >= 0; i--) {
	      const commentWS = commentStack[i];
	      const commentEnd = commentWS.end;
	      const commentStart = commentWS.start;
	      if (commentStart === end) {
	        commentWS.leadingNode = node;
	      } else if (commentEnd === start) {
	        commentWS.trailingNode = node;
	      } else if (commentEnd < start) {
	        break;
	      }
	    }
	  }
	}
	class State {
	  constructor() {
	    this.flags = 1024;
	    this.startIndex = void 0;
	    this.curLine = void 0;
	    this.lineStart = void 0;
	    this.startLoc = void 0;
	    this.endLoc = void 0;
	    this.errors = [];
	    this.potentialArrowAt = -1;
	    this.noArrowAt = [];
	    this.noArrowParamsConversionAt = [];
	    this.topicContext = {
	      maxNumOfResolvableTopics: 0,
	      maxTopicIndex: null
	    };
	    this.labels = [];
	    this.commentsLen = 0;
	    this.commentStack = [];
	    this.pos = 0;
	    this.type = 140;
	    this.value = null;
	    this.start = 0;
	    this.end = 0;
	    this.lastTokEndLoc = null;
	    this.lastTokStartLoc = null;
	    this.context = [types.brace];
	    this.firstInvalidTemplateEscapePos = null;
	    this.strictErrors = /* @__PURE__ */ new Map();
	    this.tokensLength = 0;
	  }
	  get strict() {
	    return (this.flags & 1) > 0;
	  }
	  set strict(v) {
	    if (v) this.flags |= 1;
	    else this.flags &= -2;
	  }
	  init({
	    strictMode,
	    sourceType,
	    startIndex,
	    startLine,
	    startColumn
	  }) {
	    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
	    this.startIndex = startIndex;
	    this.curLine = startLine;
	    this.lineStart = -startColumn;
	    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
	  }
	  get maybeInArrowParameters() {
	    return (this.flags & 2) > 0;
	  }
	  set maybeInArrowParameters(v) {
	    if (v) this.flags |= 2;
	    else this.flags &= -3;
	  }
	  get inType() {
	    return (this.flags & 4) > 0;
	  }
	  set inType(v) {
	    if (v) this.flags |= 4;
	    else this.flags &= -5;
	  }
	  get noAnonFunctionType() {
	    return (this.flags & 8) > 0;
	  }
	  set noAnonFunctionType(v) {
	    if (v) this.flags |= 8;
	    else this.flags &= -9;
	  }
	  get hasFlowComment() {
	    return (this.flags & 16) > 0;
	  }
	  set hasFlowComment(v) {
	    if (v) this.flags |= 16;
	    else this.flags &= -17;
	  }
	  get isAmbientContext() {
	    return (this.flags & 32) > 0;
	  }
	  set isAmbientContext(v) {
	    if (v) this.flags |= 32;
	    else this.flags &= -33;
	  }
	  get inAbstractClass() {
	    return (this.flags & 64) > 0;
	  }
	  set inAbstractClass(v) {
	    if (v) this.flags |= 64;
	    else this.flags &= -65;
	  }
	  get inDisallowConditionalTypesContext() {
	    return (this.flags & 128) > 0;
	  }
	  set inDisallowConditionalTypesContext(v) {
	    if (v) this.flags |= 128;
	    else this.flags &= -129;
	  }
	  get soloAwait() {
	    return (this.flags & 256) > 0;
	  }
	  set soloAwait(v) {
	    if (v) this.flags |= 256;
	    else this.flags &= -257;
	  }
	  get inFSharpPipelineDirectBody() {
	    return (this.flags & 512) > 0;
	  }
	  set inFSharpPipelineDirectBody(v) {
	    if (v) this.flags |= 512;
	    else this.flags &= -513;
	  }
	  get canStartJSXElement() {
	    return (this.flags & 1024) > 0;
	  }
	  set canStartJSXElement(v) {
	    if (v) this.flags |= 1024;
	    else this.flags &= -1025;
	  }
	  get containsEsc() {
	    return (this.flags & 2048) > 0;
	  }
	  set containsEsc(v) {
	    if (v) this.flags |= 2048;
	    else this.flags &= -2049;
	  }
	  get hasTopLevelAwait() {
	    return (this.flags & 4096) > 0;
	  }
	  set hasTopLevelAwait(v) {
	    if (v) this.flags |= 4096;
	    else this.flags &= -4097;
	  }
	  curPosition() {
	    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
	  }
	  clone() {
	    const state = new State();
	    state.flags = this.flags;
	    state.startIndex = this.startIndex;
	    state.curLine = this.curLine;
	    state.lineStart = this.lineStart;
	    state.startLoc = this.startLoc;
	    state.endLoc = this.endLoc;
	    state.errors = this.errors.slice();
	    state.potentialArrowAt = this.potentialArrowAt;
	    state.noArrowAt = this.noArrowAt.slice();
	    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
	    state.topicContext = this.topicContext;
	    state.labels = this.labels.slice();
	    state.commentsLen = this.commentsLen;
	    state.commentStack = this.commentStack.slice();
	    state.pos = this.pos;
	    state.type = this.type;
	    state.value = this.value;
	    state.start = this.start;
	    state.end = this.end;
	    state.lastTokEndLoc = this.lastTokEndLoc;
	    state.lastTokStartLoc = this.lastTokStartLoc;
	    state.context = this.context.slice();
	    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
	    state.strictErrors = this.strictErrors;
	    state.tokensLength = this.tokensLength;
	    return state;
	  }
	}
	var _isDigit = function isDigit(code2) {
	  return code2 >= 48 && code2 <= 57;
	};
	const forbiddenNumericSeparatorSiblings = {
	  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
	  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
	};
	const isAllowedNumericSeparatorSibling = {
	  bin: (ch) => ch === 48 || ch === 49,
	  oct: (ch) => ch >= 48 && ch <= 55,
	  dec: (ch) => ch >= 48 && ch <= 57,
	  hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
	};
	function readStringContents(type, input, pos, lineStart, curLine, errors) {
	  const initialPos = pos;
	  const initialLineStart = lineStart;
	  const initialCurLine = curLine;
	  let out = "";
	  let firstInvalidLoc = null;
	  let chunkStart = pos;
	  const {
	    length
	  } = input;
	  for (; ; ) {
	    if (pos >= length) {
	      errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    const ch = input.charCodeAt(pos);
	    if (isStringEnd(type, ch, input, pos)) {
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    if (ch === 92) {
	      out += input.slice(chunkStart, pos);
	      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
	      if (res.ch === null && !firstInvalidLoc) {
	        firstInvalidLoc = {
	          pos,
	          lineStart,
	          curLine
	        };
	      } else {
	        out += res.ch;
	      }
	      ({
	        pos,
	        lineStart,
	        curLine
	      } = res);
	      chunkStart = pos;
	    } else if (ch === 8232 || ch === 8233) {
	      ++pos;
	      ++curLine;
	      lineStart = pos;
	    } else if (ch === 10 || ch === 13) {
	      if (type === "template") {
	        out += input.slice(chunkStart, pos) + "\n";
	        ++pos;
	        if (ch === 13 && input.charCodeAt(pos) === 10) {
	          ++pos;
	        }
	        ++curLine;
	        chunkStart = lineStart = pos;
	      } else {
	        errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      }
	    } else {
	      ++pos;
	    }
	  }
	  return {
	    pos,
	    str: out,
	    firstInvalidLoc,
	    lineStart,
	    curLine,
	    containsInvalid: !!firstInvalidLoc
	  };
	}
	function isStringEnd(type, ch, input, pos) {
	  if (type === "template") {
	    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
	  }
	  return ch === (type === "double" ? 34 : 39);
	}
	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
	  const throwOnInvalid = !inTemplate;
	  pos++;
	  const res = (ch2) => ({
	    pos,
	    ch: ch2,
	    lineStart,
	    curLine
	  });
	  const ch = input.charCodeAt(pos++);
	  switch (ch) {
	    case 110:
	      return res("\n");
	    case 114:
	      return res("\r");
	    case 120: {
	      let code2;
	      ({
	        code: code2,
	        pos
	      } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
	      return res(code2 === null ? null : String.fromCharCode(code2));
	    }
	    case 117: {
	      let code2;
	      ({
	        code: code2,
	        pos
	      } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
	      return res(code2 === null ? null : String.fromCodePoint(code2));
	    }
	    case 116:
	      return res("	");
	    case 98:
	      return res("\b");
	    case 118:
	      return res("\v");
	    case 102:
	      return res("\f");
	    case 13:
	      if (input.charCodeAt(pos) === 10) {
	        ++pos;
	      }
	    case 10:
	      lineStart = pos;
	      ++curLine;
	    case 8232:
	    case 8233:
	      return res("");
	    case 56:
	    case 57:
	      if (inTemplate) {
	        return res(null);
	      } else {
	        errors.strictNumericEscape(pos - 1, lineStart, curLine);
	      }
	    default:
	      if (ch >= 48 && ch <= 55) {
	        const startPos = pos - 1;
	        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
	        let octalStr = match[0];
	        let octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        pos += octalStr.length - 1;
	        const next = input.charCodeAt(pos);
	        if (octalStr !== "0" || next === 56 || next === 57) {
	          if (inTemplate) {
	            return res(null);
	          } else {
	            errors.strictNumericEscape(startPos, lineStart, curLine);
	          }
	        }
	        return res(String.fromCharCode(octal));
	      }
	      return res(String.fromCharCode(ch));
	  }
	}
	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
	  const initialPos = pos;
	  let n;
	  ({
	    n,
	    pos
	  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
	  if (n === null) {
	    if (throwOnInvalid) {
	      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
	    } else {
	      pos = initialPos - 1;
	    }
	  }
	  return {
	    code: n,
	    pos
	  };
	}
	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
	  const start = pos;
	  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
	  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
	  let invalid = false;
	  let total = 0;
	  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    const code2 = input.charCodeAt(pos);
	    let val;
	    if (code2 === 95 && allowNumSeparator !== "bail") {
	      const prev = input.charCodeAt(pos - 1);
	      const next = input.charCodeAt(pos + 1);
	      if (!allowNumSeparator) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
	      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
	      }
	      ++pos;
	      continue;
	    }
	    if (code2 >= 97) {
	      val = code2 - 97 + 10;
	    } else if (code2 >= 65) {
	      val = code2 - 65 + 10;
	    } else if (_isDigit(code2)) {
	      val = code2 - 48;
	    } else {
	      val = Infinity;
	    }
	    if (val >= radix) {
	      if (val <= 9 && bailOnError) {
	        return {
	          n: null,
	          pos
	        };
	      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
	        val = 0;
	      } else if (forceLen) {
	        val = 0;
	        invalid = true;
	      } else {
	        break;
	      }
	    }
	    ++pos;
	    total = total * radix + val;
	  }
	  if (pos === start || len != null && pos - start !== len || invalid) {
	    return {
	      n: null,
	      pos
	    };
	  }
	  return {
	    n: total,
	    pos
	  };
	}
	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
	  const ch = input.charCodeAt(pos);
	  let code2;
	  if (ch === 123) {
	    ++pos;
	    ({
	      code: code2,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
	    ++pos;
	    if (code2 !== null && code2 > 1114111) {
	      if (throwOnInvalid) {
	        errors.invalidCodePoint(pos, lineStart, curLine);
	      } else {
	        return {
	          code: null,
	          pos
	        };
	      }
	    }
	  } else {
	    ({
	      code: code2,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
	  }
	  return {
	    code: code2,
	    pos
	  };
	}
	function buildPosition(pos, lineStart, curLine) {
	  return new Position(curLine, pos - lineStart, pos);
	}
	const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
	class Token {
	  constructor(state) {
	    const startIndex = state.startIndex || 0;
	    this.type = state.type;
	    this.value = state.value;
	    this.start = startIndex + state.start;
	    this.end = startIndex + state.end;
	    this.loc = new SourceLocation(state.startLoc, state.endLoc);
	  }
	}
	class Tokenizer extends CommentsParser {
	  constructor(options, input) {
	    super();
	    this.isLookahead = void 0;
	    this.tokens = [];
	    this.errorHandlers_readInt = {
	      invalidDigit: (pos, lineStart, curLine, radix) => {
	        if (!(this.optionFlags & 2048)) return false;
	        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
	          radix
	        });
	        return true;
	      },
	      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
	      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
	    };
	    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
	      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
	      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
	    });
	    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
	      strictNumericEscape: (pos, lineStart, curLine) => {
	        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
	      },
	      unterminated: (pos, lineStart, curLine) => {
	        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
	      }
	    });
	    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
	      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
	      unterminated: (pos, lineStart, curLine) => {
	        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
	      }
	    });
	    this.state = new State();
	    this.state.init(options);
	    this.input = input;
	    this.length = input.length;
	    this.comments = [];
	    this.isLookahead = false;
	  }
	  pushToken(token) {
	    this.tokens.length = this.state.tokensLength;
	    this.tokens.push(token);
	    ++this.state.tokensLength;
	  }
	  next() {
	    this.checkKeywordEscapes();
	    if (this.optionFlags & 256) {
	      this.pushToken(new Token(this.state));
	    }
	    this.state.lastTokEndLoc = this.state.endLoc;
	    this.state.lastTokStartLoc = this.state.startLoc;
	    this.nextToken();
	  }
	  eat(type) {
	    if (this.match(type)) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  }
	  match(type) {
	    return this.state.type === type;
	  }
	  createLookaheadState(state) {
	    return {
	      pos: state.pos,
	      value: null,
	      type: state.type,
	      start: state.start,
	      end: state.end,
	      context: [this.curContext()],
	      inType: state.inType,
	      startLoc: state.startLoc,
	      lastTokEndLoc: state.lastTokEndLoc,
	      curLine: state.curLine,
	      lineStart: state.lineStart,
	      curPosition: state.curPosition
	    };
	  }
	  lookahead() {
	    const old = this.state;
	    this.state = this.createLookaheadState(old);
	    this.isLookahead = true;
	    this.nextToken();
	    this.isLookahead = false;
	    const curr = this.state;
	    this.state = old;
	    return curr;
	  }
	  nextTokenStart() {
	    return this.nextTokenStartSince(this.state.pos);
	  }
	  nextTokenStartSince(pos) {
	    skipWhiteSpace.lastIndex = pos;
	    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
	  }
	  lookaheadCharCode() {
	    return this.lookaheadCharCodeSince(this.state.pos);
	  }
	  lookaheadCharCodeSince(pos) {
	    return this.input.charCodeAt(this.nextTokenStartSince(pos));
	  }
	  nextTokenInLineStart() {
	    return this.nextTokenInLineStartSince(this.state.pos);
	  }
	  nextTokenInLineStartSince(pos) {
	    skipWhiteSpaceInLine.lastIndex = pos;
	    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
	  }
	  lookaheadInLineCharCode() {
	    return this.input.charCodeAt(this.nextTokenInLineStart());
	  }
	  codePointAtPos(pos) {
	    let cp = this.input.charCodeAt(pos);
	    if ((cp & 64512) === 55296 && ++pos < this.input.length) {
	      const trail = this.input.charCodeAt(pos);
	      if ((trail & 64512) === 56320) {
	        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
	      }
	    }
	    return cp;
	  }
	  setStrict(strict) {
	    this.state.strict = strict;
	    if (strict) {
	      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
	      this.state.strictErrors.clear();
	    }
	  }
	  curContext() {
	    return this.state.context[this.state.context.length - 1];
	  }
	  nextToken() {
	    this.skipSpace();
	    this.state.start = this.state.pos;
	    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
	    if (this.state.pos >= this.length) {
	      this.finishToken(140);
	      return;
	    }
	    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
	  }
	  skipBlockComment(commentEnd) {
	    let startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    const start = this.state.pos;
	    const end = this.input.indexOf(commentEnd, start + 2);
	    if (end === -1) {
	      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
	    }
	    this.state.pos = end + commentEnd.length;
	    lineBreakG.lastIndex = start + 2;
	    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
	      ++this.state.curLine;
	      this.state.lineStart = lineBreakG.lastIndex;
	    }
	    if (this.isLookahead) return;
	    const comment = {
	      type: "CommentBlock",
	      value: this.input.slice(start + 2, end),
	      start: this.sourceToOffsetPos(start),
	      end: this.sourceToOffsetPos(end + commentEnd.length),
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.optionFlags & 256) this.pushToken(comment);
	    return comment;
	  }
	  skipLineComment(startSkip) {
	    const start = this.state.pos;
	    let startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    let ch = this.input.charCodeAt(this.state.pos += startSkip);
	    if (this.state.pos < this.length) {
	      while (!isNewLine(ch) && ++this.state.pos < this.length) {
	        ch = this.input.charCodeAt(this.state.pos);
	      }
	    }
	    if (this.isLookahead) return;
	    const end = this.state.pos;
	    const value = this.input.slice(start + startSkip, end);
	    const comment = {
	      type: "CommentLine",
	      value,
	      start: this.sourceToOffsetPos(start),
	      end: this.sourceToOffsetPos(end),
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.optionFlags & 256) this.pushToken(comment);
	    return comment;
	  }
	  skipSpace() {
	    const spaceStart = this.state.pos;
	    const comments = this.optionFlags & 4096 ? [] : null;
	    loop: while (this.state.pos < this.length) {
	      const ch = this.input.charCodeAt(this.state.pos);
	      switch (ch) {
	        case 32:
	        case 160:
	        case 9:
	          ++this.state.pos;
	          break;
	        case 13:
	          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
	            ++this.state.pos;
	          }
	        case 10:
	        case 8232:
	        case 8233:
	          ++this.state.pos;
	          ++this.state.curLine;
	          this.state.lineStart = this.state.pos;
	          break;
	        case 47:
	          switch (this.input.charCodeAt(this.state.pos + 1)) {
	            case 42: {
	              const comment = this.skipBlockComment("*/");
	              if (comment !== void 0) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	              break;
	            }
	            case 47: {
	              const comment = this.skipLineComment(2);
	              if (comment !== void 0) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	              break;
	            }
	            default:
	              break loop;
	          }
	          break;
	        default:
	          if (isWhitespace(ch)) {
	            ++this.state.pos;
	          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
	            const pos = this.state.pos;
	            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
	              const comment = this.skipLineComment(3);
	              if (comment !== void 0) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	            } else {
	              break loop;
	            }
	          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
	            const pos = this.state.pos;
	            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
	              const comment = this.skipLineComment(4);
	              if (comment !== void 0) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	            } else {
	              break loop;
	            }
	          } else {
	            break loop;
	          }
	      }
	    }
	    if ((comments == null ? void 0 : comments.length) > 0) {
	      const end = this.state.pos;
	      const commentWhitespace = {
	        start: this.sourceToOffsetPos(spaceStart),
	        end: this.sourceToOffsetPos(end),
	        comments,
	        leadingNode: null,
	        trailingNode: null,
	        containingNode: null
	      };
	      this.state.commentStack.push(commentWhitespace);
	    }
	  }
	  finishToken(type, val) {
	    this.state.end = this.state.pos;
	    this.state.endLoc = this.state.curPosition();
	    const prevType = this.state.type;
	    this.state.type = type;
	    this.state.value = val;
	    if (!this.isLookahead) {
	      this.updateContext(prevType);
	    }
	  }
	  replaceToken(type) {
	    this.state.type = type;
	    this.updateContext();
	  }
	  readToken_numberSign() {
	    if (this.state.pos === 0 && this.readToken_interpreter()) {
	      return;
	    }
	    const nextPos = this.state.pos + 1;
	    const next = this.codePointAtPos(nextPos);
	    if (next >= 48 && next <= 57) {
	      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
	    }
	    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
	      this.expectPlugin("recordAndTuple");
	      if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
	        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
	      }
	      this.state.pos += 2;
	      if (next === 123) {
	        this.finishToken(7);
	      } else {
	        this.finishToken(1);
	      }
	    } else if (isIdentifierStart(next)) {
	      ++this.state.pos;
	      this.finishToken(139, this.readWord1(next));
	    } else if (next === 92) {
	      ++this.state.pos;
	      this.finishToken(139, this.readWord1());
	    } else {
	      this.finishOp(27, 1);
	    }
	  }
	  readToken_dot() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next >= 48 && next <= 57) {
	      this.readNumber(true);
	      return;
	    }
	    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
	      this.state.pos += 3;
	      this.finishToken(21);
	    } else {
	      ++this.state.pos;
	      this.finishToken(16);
	    }
	  }
	  readToken_slash() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61) {
	      this.finishOp(31, 2);
	    } else {
	      this.finishOp(56, 1);
	    }
	  }
	  readToken_interpreter() {
	    if (this.state.pos !== 0 || this.length < 2) return false;
	    let ch = this.input.charCodeAt(this.state.pos + 1);
	    if (ch !== 33) return false;
	    const start = this.state.pos;
	    this.state.pos += 1;
	    while (!isNewLine(ch) && ++this.state.pos < this.length) {
	      ch = this.input.charCodeAt(this.state.pos);
	    }
	    const value = this.input.slice(start + 2, this.state.pos);
	    this.finishToken(28, value);
	    return true;
	  }
	  readToken_mult_modulo(code2) {
	    let type = code2 === 42 ? 55 : 54;
	    let width = 1;
	    let next = this.input.charCodeAt(this.state.pos + 1);
	    if (code2 === 42 && next === 42) {
	      width++;
	      next = this.input.charCodeAt(this.state.pos + 2);
	      type = 57;
	    }
	    if (next === 61 && !this.state.inType) {
	      width++;
	      type = code2 === 37 ? 33 : 30;
	    }
	    this.finishOp(type, width);
	  }
	  readToken_pipe_amp(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === code2) {
	      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(code2 === 124 ? 41 : 42, 2);
	      }
	      return;
	    }
	    if (code2 === 124) {
	      if (next === 62) {
	        this.finishOp(39, 2);
	        return;
	      }
	      if (this.hasPlugin("recordAndTuple") && next === 125) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
	        }
	        this.state.pos += 2;
	        this.finishToken(9);
	        return;
	      }
	      if (this.hasPlugin("recordAndTuple") && next === 93) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
	        }
	        this.state.pos += 2;
	        this.finishToken(4);
	        return;
	      }
	    }
	    if (next === 61) {
	      this.finishOp(30, 2);
	      return;
	    }
	    this.finishOp(code2 === 124 ? 43 : 45, 1);
	  }
	  readToken_caret() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61 && !this.state.inType) {
	      this.finishOp(32, 2);
	    } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
	      proposal: "hack",
	      topicToken: "^^"
	    }])) {
	      this.finishOp(37, 2);
	      const lookaheadCh = this.input.codePointAt(this.state.pos);
	      if (lookaheadCh === 94) {
	        this.unexpected();
	      }
	    } else {
	      this.finishOp(44, 1);
	    }
	  }
	  readToken_atSign() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 64 && this.hasPlugin(["pipelineOperator", {
	      proposal: "hack",
	      topicToken: "@@"
	    }])) {
	      this.finishOp(38, 2);
	    } else {
	      this.finishOp(26, 1);
	    }
	  }
	  readToken_plus_min(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === code2) {
	      this.finishOp(34, 2);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(30, 2);
	    } else {
	      this.finishOp(53, 1);
	    }
	  }
	  readToken_lt() {
	    const {
	      pos
	    } = this.state;
	    const next = this.input.charCodeAt(pos + 1);
	    if (next === 60) {
	      if (this.input.charCodeAt(pos + 2) === 61) {
	        this.finishOp(30, 3);
	        return;
	      }
	      this.finishOp(51, 2);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(49, 2);
	      return;
	    }
	    this.finishOp(47, 1);
	  }
	  readToken_gt() {
	    const {
	      pos
	    } = this.state;
	    const next = this.input.charCodeAt(pos + 1);
	    if (next === 62) {
	      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
	      if (this.input.charCodeAt(pos + size) === 61) {
	        this.finishOp(30, size + 1);
	        return;
	      }
	      this.finishOp(52, size);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(49, 2);
	      return;
	    }
	    this.finishOp(48, 1);
	  }
	  readToken_eq_excl(code2) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61) {
	      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
	      return;
	    }
	    if (code2 === 61 && next === 62) {
	      this.state.pos += 2;
	      this.finishToken(19);
	      return;
	    }
	    this.finishOp(code2 === 61 ? 29 : 35, 1);
	  }
	  readToken_question() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    const next2 = this.input.charCodeAt(this.state.pos + 2);
	    if (next === 63) {
	      if (next2 === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(40, 2);
	      }
	    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
	      this.state.pos += 2;
	      this.finishToken(18);
	    } else {
	      ++this.state.pos;
	      this.finishToken(17);
	    }
	  }
	  getTokenFromCode(code2) {
	    switch (code2) {
	      case 46:
	        this.readToken_dot();
	        return;
	      case 40:
	        ++this.state.pos;
	        this.finishToken(10);
	        return;
	      case 41:
	        ++this.state.pos;
	        this.finishToken(11);
	        return;
	      case 59:
	        ++this.state.pos;
	        this.finishToken(13);
	        return;
	      case 44:
	        ++this.state.pos;
	        this.finishToken(12);
	        return;
	      case 91:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
	          }
	          this.state.pos += 2;
	          this.finishToken(2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(0);
	        }
	        return;
	      case 93:
	        ++this.state.pos;
	        this.finishToken(3);
	        return;
	      case 123:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
	          }
	          this.state.pos += 2;
	          this.finishToken(6);
	        } else {
	          ++this.state.pos;
	          this.finishToken(5);
	        }
	        return;
	      case 125:
	        ++this.state.pos;
	        this.finishToken(8);
	        return;
	      case 58:
	        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
	          this.finishOp(15, 2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(14);
	        }
	        return;
	      case 63:
	        this.readToken_question();
	        return;
	      case 96:
	        this.readTemplateToken();
	        return;
	      case 48: {
	        const next = this.input.charCodeAt(this.state.pos + 1);
	        if (next === 120 || next === 88) {
	          this.readRadixNumber(16);
	          return;
	        }
	        if (next === 111 || next === 79) {
	          this.readRadixNumber(8);
	          return;
	        }
	        if (next === 98 || next === 66) {
	          this.readRadixNumber(2);
	          return;
	        }
	      }
	      case 49:
	      case 50:
	      case 51:
	      case 52:
	      case 53:
	      case 54:
	      case 55:
	      case 56:
	      case 57:
	        this.readNumber(false);
	        return;
	      case 34:
	      case 39:
	        this.readString(code2);
	        return;
	      case 47:
	        this.readToken_slash();
	        return;
	      case 37:
	      case 42:
	        this.readToken_mult_modulo(code2);
	        return;
	      case 124:
	      case 38:
	        this.readToken_pipe_amp(code2);
	        return;
	      case 94:
	        this.readToken_caret();
	        return;
	      case 43:
	      case 45:
	        this.readToken_plus_min(code2);
	        return;
	      case 60:
	        this.readToken_lt();
	        return;
	      case 62:
	        this.readToken_gt();
	        return;
	      case 61:
	      case 33:
	        this.readToken_eq_excl(code2);
	        return;
	      case 126:
	        this.finishOp(36, 1);
	        return;
	      case 64:
	        this.readToken_atSign();
	        return;
	      case 35:
	        this.readToken_numberSign();
	        return;
	      case 92:
	        this.readWord();
	        return;
	      default:
	        if (isIdentifierStart(code2)) {
	          this.readWord(code2);
	          return;
	        }
	    }
	    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
	      unexpected: String.fromCodePoint(code2)
	    });
	  }
	  finishOp(type, size) {
	    const str = this.input.slice(this.state.pos, this.state.pos + size);
	    this.state.pos += size;
	    this.finishToken(type, str);
	  }
	  readRegexp() {
	    const startLoc = this.state.startLoc;
	    const start = this.state.start + 1;
	    let escaped, inClass;
	    let {
	      pos
	    } = this.state;
	    for (; ; ++pos) {
	      if (pos >= this.length) {
	        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
	      }
	      const ch = this.input.charCodeAt(pos);
	      if (isNewLine(ch)) {
	        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
	      }
	      if (escaped) {
	        escaped = false;
	      } else {
	        if (ch === 91) {
	          inClass = true;
	        } else if (ch === 93 && inClass) {
	          inClass = false;
	        } else if (ch === 47 && !inClass) {
	          break;
	        }
	        escaped = ch === 92;
	      }
	    }
	    const content = this.input.slice(start, pos);
	    ++pos;
	    let mods = "";
	    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
	    while (pos < this.length) {
	      const cp = this.codePointAtPos(pos);
	      const char = String.fromCharCode(cp);
	      if (VALID_REGEX_FLAGS.has(cp)) {
	        if (cp === 118) {
	          if (mods.includes("u")) {
	            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
	          }
	        } else if (cp === 117) {
	          if (mods.includes("v")) {
	            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
	          }
	        }
	        if (mods.includes(char)) {
	          this.raise(Errors.DuplicateRegExpFlags, nextPos());
	        }
	      } else if (isIdentifierChar(cp) || cp === 92) {
	        this.raise(Errors.MalformedRegExpFlags, nextPos());
	      } else {
	        break;
	      }
	      ++pos;
	      mods += char;
	    }
	    this.state.pos = pos;
	    this.finishToken(138, {
	      pattern: content,
	      flags: mods
	    });
	  }
	  readInt(radix, len, forceLen = false, allowNumSeparator = true) {
	    const {
	      n,
	      pos
	    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
	    this.state.pos = pos;
	    return n;
	  }
	  readRadixNumber(radix) {
	    const start = this.state.pos;
	    const startLoc = this.state.curPosition();
	    let isBigInt = false;
	    this.state.pos += 2;
	    const val = this.readInt(radix);
	    if (val == null) {
	      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
	        radix
	      });
	    }
	    const next = this.input.charCodeAt(this.state.pos);
	    if (next === 110) {
	      ++this.state.pos;
	      isBigInt = true;
	    } else if (next === 109) {
	      throw this.raise(Errors.InvalidDecimal, startLoc);
	    }
	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
	    }
	    if (isBigInt) {
	      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
	      this.finishToken(136, str);
	      return;
	    }
	    this.finishToken(135, val);
	  }
	  readNumber(startsWithDot) {
	    const start = this.state.pos;
	    const startLoc = this.state.curPosition();
	    let isFloat = false;
	    let isBigInt = false;
	    let hasExponent = false;
	    let isOctal = false;
	    if (!startsWithDot && this.readInt(10) === null) {
	      this.raise(Errors.InvalidNumber, this.state.curPosition());
	    }
	    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	    if (hasLeadingZero) {
	      const integer = this.input.slice(start, this.state.pos);
	      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
	      if (!this.state.strict) {
	        const underscorePos = integer.indexOf("_");
	        if (underscorePos > 0) {
	          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
	        }
	      }
	      isOctal = hasLeadingZero && !/[89]/.test(integer);
	    }
	    let next = this.input.charCodeAt(this.state.pos);
	    if (next === 46 && !isOctal) {
	      ++this.state.pos;
	      this.readInt(10);
	      isFloat = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }
	    if ((next === 69 || next === 101) && !isOctal) {
	      next = this.input.charCodeAt(++this.state.pos);
	      if (next === 43 || next === 45) {
	        ++this.state.pos;
	      }
	      if (this.readInt(10) === null) {
	        this.raise(Errors.InvalidOrMissingExponent, startLoc);
	      }
	      isFloat = true;
	      hasExponent = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }
	    if (next === 110) {
	      if (isFloat || hasLeadingZero) {
	        this.raise(Errors.InvalidBigIntLiteral, startLoc);
	      }
	      ++this.state.pos;
	      isBigInt = true;
	    }
	    if (next === 109) {
	      this.expectPlugin("decimal", this.state.curPosition());
	      if (hasExponent || hasLeadingZero) {
	        this.raise(Errors.InvalidDecimal, startLoc);
	      }
	      ++this.state.pos;
	      var isDecimal = true;
	    }
	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
	    }
	    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
	    if (isBigInt) {
	      this.finishToken(136, str);
	      return;
	    }
	    if (isDecimal) {
	      this.finishToken(137, str);
	      return;
	    }
	    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
	    this.finishToken(135, val);
	  }
	  readCodePoint(throwOnInvalid) {
	    const {
	      code: code2,
	      pos
	    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
	    this.state.pos = pos;
	    return code2;
	  }
	  readString(quote) {
	    const {
	      str,
	      pos,
	      curLine,
	      lineStart
	    } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
	    this.state.pos = pos + 1;
	    this.state.lineStart = lineStart;
	    this.state.curLine = curLine;
	    this.finishToken(134, str);
	  }
	  readTemplateContinuation() {
	    if (!this.match(8)) {
	      this.unexpected(null, 8);
	    }
	    this.state.pos--;
	    this.readTemplateToken();
	  }
	  readTemplateToken() {
	    const opening = this.input[this.state.pos];
	    const {
	      str,
	      firstInvalidLoc,
	      pos,
	      curLine,
	      lineStart
	    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
	    this.state.pos = pos + 1;
	    this.state.lineStart = lineStart;
	    this.state.curLine = curLine;
	    if (firstInvalidLoc) {
	      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
	    }
	    if (this.input.codePointAt(pos) === 96) {
	      this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
	    } else {
	      this.state.pos++;
	      this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
	    }
	  }
	  recordStrictModeErrors(toParseError, at) {
	    const index = at.index;
	    if (this.state.strict && !this.state.strictErrors.has(index)) {
	      this.raise(toParseError, at);
	    } else {
	      this.state.strictErrors.set(index, [toParseError, at]);
	    }
	  }
	  readWord1(firstCode) {
	    this.state.containsEsc = false;
	    let word = "";
	    const start = this.state.pos;
	    let chunkStart = this.state.pos;
	    if (firstCode !== void 0) {
	      this.state.pos += firstCode <= 65535 ? 1 : 2;
	    }
	    while (this.state.pos < this.length) {
	      const ch = this.codePointAtPos(this.state.pos);
	      if (isIdentifierChar(ch)) {
	        this.state.pos += ch <= 65535 ? 1 : 2;
	      } else if (ch === 92) {
	        this.state.containsEsc = true;
	        word += this.input.slice(chunkStart, this.state.pos);
	        const escStart = this.state.curPosition();
	        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
	        if (this.input.charCodeAt(++this.state.pos) !== 117) {
	          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
	          chunkStart = this.state.pos - 1;
	          continue;
	        }
	        ++this.state.pos;
	        const esc = this.readCodePoint(true);
	        if (esc !== null) {
	          if (!identifierCheck(esc)) {
	            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
	          }
	          word += String.fromCodePoint(esc);
	        }
	        chunkStart = this.state.pos;
	      } else {
	        break;
	      }
	    }
	    return word + this.input.slice(chunkStart, this.state.pos);
	  }
	  readWord(firstCode) {
	    const word = this.readWord1(firstCode);
	    const type = keywords$1.get(word);
	    if (type !== void 0) {
	      this.finishToken(type, tokenLabelName(type));
	    } else {
	      this.finishToken(132, word);
	    }
	  }
	  checkKeywordEscapes() {
	    const {
	      type
	    } = this.state;
	    if (tokenIsKeyword(type) && this.state.containsEsc) {
	      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
	        reservedWord: tokenLabelName(type)
	      });
	    }
	  }
	  raise(toParseError, at, details = {}) {
	    const loc = at instanceof Position ? at : at.loc.start;
	    const error = toParseError(loc, details);
	    if (!(this.optionFlags & 2048)) throw error;
	    if (!this.isLookahead) this.state.errors.push(error);
	    return error;
	  }
	  raiseOverwrite(toParseError, at, details = {}) {
	    const loc = at instanceof Position ? at : at.loc.start;
	    const pos = loc.index;
	    const errors = this.state.errors;
	    for (let i = errors.length - 1; i >= 0; i--) {
	      const error = errors[i];
	      if (error.loc.index === pos) {
	        return errors[i] = toParseError(loc, details);
	      }
	      if (error.loc.index < pos) break;
	    }
	    return this.raise(toParseError, at, details);
	  }
	  updateContext(prevType) {
	  }
	  unexpected(loc, type) {
	    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
	      expected: type ? tokenLabelName(type) : null
	    });
	  }
	  expectPlugin(pluginName, loc) {
	    if (this.hasPlugin(pluginName)) {
	      return true;
	    }
	    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
	      missingPlugin: [pluginName]
	    });
	  }
	  expectOnePlugin(pluginNames) {
	    if (!pluginNames.some((name) => this.hasPlugin(name))) {
	      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
	        missingPlugin: pluginNames
	      });
	    }
	  }
	  errorBuilder(error) {
	    return (pos, lineStart, curLine) => {
	      this.raise(error, buildPosition(pos, lineStart, curLine));
	    };
	  }
	}
	class ClassScope {
	  constructor() {
	    this.privateNames = /* @__PURE__ */ new Set();
	    this.loneAccessors = /* @__PURE__ */ new Map();
	    this.undefinedPrivateNames = /* @__PURE__ */ new Map();
	  }
	}
	class ClassScopeHandler {
	  constructor(parser) {
	    this.parser = void 0;
	    this.stack = [];
	    this.undefinedPrivateNames = /* @__PURE__ */ new Map();
	    this.parser = parser;
	  }
	  current() {
	    return this.stack[this.stack.length - 1];
	  }
	  enter() {
	    this.stack.push(new ClassScope());
	  }
	  exit() {
	    const oldClassScope = this.stack.pop();
	    const current = this.current();
	    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
	      if (current) {
	        if (!current.undefinedPrivateNames.has(name)) {
	          current.undefinedPrivateNames.set(name, loc);
	        }
	      } else {
	        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
	          identifierName: name
	        });
	      }
	    }
	  }
	  declarePrivateName(name, elementType, loc) {
	    const {
	      privateNames,
	      loneAccessors,
	      undefinedPrivateNames
	    } = this.current();
	    let redefined = privateNames.has(name);
	    if (elementType & 3) {
	      const accessor = redefined && loneAccessors.get(name);
	      if (accessor) {
	        const oldStatic = accessor & 4;
	        const newStatic = elementType & 4;
	        const oldKind = accessor & 3;
	        const newKind = elementType & 3;
	        redefined = oldKind === newKind || oldStatic !== newStatic;
	        if (!redefined) loneAccessors.delete(name);
	      } else if (!redefined) {
	        loneAccessors.set(name, elementType);
	      }
	    }
	    if (redefined) {
	      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
	        identifierName: name
	      });
	    }
	    privateNames.add(name);
	    undefinedPrivateNames.delete(name);
	  }
	  usePrivateName(name, loc) {
	    let classScope;
	    for (classScope of this.stack) {
	      if (classScope.privateNames.has(name)) return;
	    }
	    if (classScope) {
	      classScope.undefinedPrivateNames.set(name, loc);
	    } else {
	      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
	        identifierName: name
	      });
	    }
	  }
	}
	class ExpressionScope {
	  constructor(type = 0) {
	    this.type = type;
	  }
	  canBeArrowParameterDeclaration() {
	    return this.type === 2 || this.type === 1;
	  }
	  isCertainlyParameterDeclaration() {
	    return this.type === 3;
	  }
	}
	class ArrowHeadParsingScope extends ExpressionScope {
	  constructor(type) {
	    super(type);
	    this.declarationErrors = /* @__PURE__ */ new Map();
	  }
	  recordDeclarationError(ParsingErrorClass, at) {
	    const index = at.index;
	    this.declarationErrors.set(index, [ParsingErrorClass, at]);
	  }
	  clearDeclarationError(index) {
	    this.declarationErrors.delete(index);
	  }
	  iterateErrors(iterator) {
	    this.declarationErrors.forEach(iterator);
	  }
	}
	class ExpressionScopeHandler {
	  constructor(parser) {
	    this.parser = void 0;
	    this.stack = [new ExpressionScope()];
	    this.parser = parser;
	  }
	  enter(scope) {
	    this.stack.push(scope);
	  }
	  exit() {
	    this.stack.pop();
	  }
	  recordParameterInitializerError(toParseError, node) {
	    const origin = node.loc.start;
	    const {
	      stack
	    } = this;
	    let i = stack.length - 1;
	    let scope = stack[i];
	    while (!scope.isCertainlyParameterDeclaration()) {
	      if (scope.canBeArrowParameterDeclaration()) {
	        scope.recordDeclarationError(toParseError, origin);
	      } else {
	        return;
	      }
	      scope = stack[--i];
	    }
	    this.parser.raise(toParseError, origin);
	  }
	  recordArrowParameterBindingError(error, node) {
	    const {
	      stack
	    } = this;
	    const scope = stack[stack.length - 1];
	    const origin = node.loc.start;
	    if (scope.isCertainlyParameterDeclaration()) {
	      this.parser.raise(error, origin);
	    } else if (scope.canBeArrowParameterDeclaration()) {
	      scope.recordDeclarationError(error, origin);
	    } else {
	      return;
	    }
	  }
	  recordAsyncArrowParametersError(at) {
	    const {
	      stack
	    } = this;
	    let i = stack.length - 1;
	    let scope = stack[i];
	    while (scope.canBeArrowParameterDeclaration()) {
	      if (scope.type === 2) {
	        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
	      }
	      scope = stack[--i];
	    }
	  }
	  validateAsPattern() {
	    const {
	      stack
	    } = this;
	    const currentScope = stack[stack.length - 1];
	    if (!currentScope.canBeArrowParameterDeclaration()) return;
	    currentScope.iterateErrors(([toParseError, loc]) => {
	      this.parser.raise(toParseError, loc);
	      let i = stack.length - 2;
	      let scope = stack[i];
	      while (scope.canBeArrowParameterDeclaration()) {
	        scope.clearDeclarationError(loc.index);
	        scope = stack[--i];
	      }
	    });
	  }
	}
	function newParameterDeclarationScope() {
	  return new ExpressionScope(3);
	}
	function newArrowHeadScope() {
	  return new ArrowHeadParsingScope(1);
	}
	function newAsyncArrowScope() {
	  return new ArrowHeadParsingScope(2);
	}
	function newExpressionScope() {
	  return new ExpressionScope();
	}
	class UtilParser extends Tokenizer {
	  addExtra(node, key, value, enumerable = true) {
	    if (!node) return;
	    let {
	      extra
	    } = node;
	    if (extra == null) {
	      extra = {};
	      node.extra = extra;
	    }
	    if (enumerable) {
	      extra[key] = value;
	    } else {
	      Object.defineProperty(extra, key, {
	        enumerable,
	        value
	      });
	    }
	  }
	  isContextual(token) {
	    return this.state.type === token && !this.state.containsEsc;
	  }
	  isUnparsedContextual(nameStart, name) {
	    const nameEnd = nameStart + name.length;
	    if (this.input.slice(nameStart, nameEnd) === name) {
	      const nextCh = this.input.charCodeAt(nameEnd);
	      return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
	    }
	    return false;
	  }
	  isLookaheadContextual(name) {
	    const next = this.nextTokenStart();
	    return this.isUnparsedContextual(next, name);
	  }
	  eatContextual(token) {
	    if (this.isContextual(token)) {
	      this.next();
	      return true;
	    }
	    return false;
	  }
	  expectContextual(token, toParseError) {
	    if (!this.eatContextual(token)) {
	      if (toParseError != null) {
	        throw this.raise(toParseError, this.state.startLoc);
	      }
	      this.unexpected(null, token);
	    }
	  }
	  canInsertSemicolon() {
	    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
	  }
	  hasPrecedingLineBreak() {
	    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
	  }
	  hasFollowingLineBreak() {
	    return hasNewLine(this.input, this.state.end, this.nextTokenStart());
	  }
	  isLineTerminator() {
	    return this.eat(13) || this.canInsertSemicolon();
	  }
	  semicolon(allowAsi = true) {
	    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
	    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
	  }
	  expect(type, loc) {
	    if (!this.eat(type)) {
	      this.unexpected(loc, type);
	    }
	  }
	  tryParse(fn, oldState = this.state.clone()) {
	    const abortSignal = {
	      node: null
	    };
	    try {
	      const node = fn((node2 = null) => {
	        abortSignal.node = node2;
	        throw abortSignal;
	      });
	      if (this.state.errors.length > oldState.errors.length) {
	        const failState = this.state;
	        this.state = oldState;
	        this.state.tokensLength = failState.tokensLength;
	        return {
	          node,
	          error: failState.errors[oldState.errors.length],
	          thrown: false,
	          aborted: false,
	          failState
	        };
	      }
	      return {
	        node,
	        error: null,
	        thrown: false,
	        aborted: false,
	        failState: null
	      };
	    } catch (error) {
	      const failState = this.state;
	      this.state = oldState;
	      if (error instanceof SyntaxError) {
	        return {
	          node: null,
	          error,
	          thrown: true,
	          aborted: false,
	          failState
	        };
	      }
	      if (error === abortSignal) {
	        return {
	          node: abortSignal.node,
	          error: null,
	          thrown: false,
	          aborted: true,
	          failState
	        };
	      }
	      throw error;
	    }
	  }
	  checkExpressionErrors(refExpressionErrors, andThrow) {
	    if (!refExpressionErrors) return false;
	    const {
	      shorthandAssignLoc,
	      doubleProtoLoc,
	      privateKeyLoc,
	      optionalParametersLoc
	    } = refExpressionErrors;
	    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
	    if (!andThrow) {
	      return hasErrors;
	    }
	    if (shorthandAssignLoc != null) {
	      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
	    }
	    if (doubleProtoLoc != null) {
	      this.raise(Errors.DuplicateProto, doubleProtoLoc);
	    }
	    if (privateKeyLoc != null) {
	      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
	    }
	    if (optionalParametersLoc != null) {
	      this.unexpected(optionalParametersLoc);
	    }
	  }
	  isLiteralPropertyName() {
	    return tokenIsLiteralPropertyName(this.state.type);
	  }
	  isPrivateName(node) {
	    return node.type === "PrivateName";
	  }
	  getPrivateNameSV(node) {
	    return node.id.name;
	  }
	  hasPropertyAsPrivateName(node) {
	    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
	  }
	  isObjectProperty(node) {
	    return node.type === "ObjectProperty";
	  }
	  isObjectMethod(node) {
	    return node.type === "ObjectMethod";
	  }
	  initializeScopes(inModule = this.options.sourceType === "module") {
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    const oldExportedIdentifiers = this.exportedIdentifiers;
	    this.exportedIdentifiers = /* @__PURE__ */ new Set();
	    const oldInModule = this.inModule;
	    this.inModule = inModule;
	    const oldScope = this.scope;
	    const ScopeHandler2 = this.getScopeHandler();
	    this.scope = new ScopeHandler2(this, inModule);
	    const oldProdParam = this.prodParam;
	    this.prodParam = new ProductionParameterHandler();
	    const oldClassScope = this.classScope;
	    this.classScope = new ClassScopeHandler(this);
	    const oldExpressionScope = this.expressionScope;
	    this.expressionScope = new ExpressionScopeHandler(this);
	    return () => {
	      this.state.labels = oldLabels;
	      this.exportedIdentifiers = oldExportedIdentifiers;
	      this.inModule = oldInModule;
	      this.scope = oldScope;
	      this.prodParam = oldProdParam;
	      this.classScope = oldClassScope;
	      this.expressionScope = oldExpressionScope;
	    };
	  }
	  enterInitialScopes() {
	    let paramFlags = 0;
	    if (this.inModule) {
	      paramFlags |= 2;
	    }
	    if (this.optionFlags & 32) {
	      paramFlags |= 1;
	    }
	    this.scope.enter(1);
	    this.prodParam.enter(paramFlags);
	  }
	  checkDestructuringPrivate(refExpressionErrors) {
	    const {
	      privateKeyLoc
	    } = refExpressionErrors;
	    if (privateKeyLoc !== null) {
	      this.expectPlugin("destructuringPrivate", privateKeyLoc);
	    }
	  }
	}
	class ExpressionErrors {
	  constructor() {
	    this.shorthandAssignLoc = null;
	    this.doubleProtoLoc = null;
	    this.privateKeyLoc = null;
	    this.optionalParametersLoc = null;
	  }
	}
	class Node {
	  constructor(parser, pos, loc) {
	    this.type = "";
	    this.start = pos;
	    this.end = 0;
	    this.loc = new SourceLocation(loc);
	    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];
	    if (parser != null && parser.filename) this.loc.filename = parser.filename;
	  }
	}
	const NodePrototype = Node.prototype;
	{
	  NodePrototype.__clone = function() {
	    const newNode = new Node(void 0, this.start, this.loc.start);
	    const keys = Object.keys(this);
	    for (let i = 0, length = keys.length; i < length; i++) {
	      const key = keys[i];
	      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
	        newNode[key] = this[key];
	      }
	    }
	    return newNode;
	  };
	}
	class NodeUtils extends UtilParser {
	  startNode() {
	    const loc = this.state.startLoc;
	    return new Node(this, loc.index, loc);
	  }
	  startNodeAt(loc) {
	    return new Node(this, loc.index, loc);
	  }
	  startNodeAtNode(type) {
	    return this.startNodeAt(type.loc.start);
	  }
	  finishNode(node, type) {
	    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
	  }
	  finishNodeAt(node, type, endLoc) {
	    node.type = type;
	    node.end = endLoc.index;
	    node.loc.end = endLoc;
	    if (this.optionFlags & 128) node.range[1] = endLoc.index;
	    if (this.optionFlags & 4096) {
	      this.processComment(node);
	    }
	    return node;
	  }
	  resetStartLocation(node, startLoc) {
	    node.start = startLoc.index;
	    node.loc.start = startLoc;
	    if (this.optionFlags & 128) node.range[0] = startLoc.index;
	  }
	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
	    node.end = endLoc.index;
	    node.loc.end = endLoc;
	    if (this.optionFlags & 128) node.range[1] = endLoc.index;
	  }
	  resetStartLocationFromNode(node, locationNode) {
	    this.resetStartLocation(node, locationNode.loc.start);
	  }
	  castNodeTo(node, type) {
	    node.type = type;
	    return node;
	  }
	  cloneIdentifier(node) {
	    const {
	      type,
	      start,
	      end,
	      loc,
	      range,
	      name
	    } = node;
	    const cloned = Object.create(NodePrototype);
	    cloned.type = type;
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.name = name;
	    if (node.extra) cloned.extra = node.extra;
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    const {
	      type,
	      start,
	      end,
	      loc,
	      range,
	      extra
	    } = node;
	    const cloned = Object.create(NodePrototype);
	    cloned.type = type;
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.extra = extra;
	    cloned.value = node.value;
	    return cloned;
	  }
	}
	const unwrapParenthesizedExpression = (node) => {
	  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
	};
	class LValParser extends NodeUtils {
	  toAssignable(node, isLHS = false) {
	    var _node$extra, _node$extra3;
	    let parenthesized = void 0;
	    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
	      parenthesized = unwrapParenthesizedExpression(node);
	      if (isLHS) {
	        if (parenthesized.type === "Identifier") {
	          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
	        } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
	          this.raise(Errors.InvalidParenthesizedAssignment, node);
	        }
	      } else {
	        this.raise(Errors.InvalidParenthesizedAssignment, node);
	      }
	    }
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        break;
	      case "ObjectExpression":
	        this.castNodeTo(node, "ObjectPattern");
	        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
	          var _node$extra2;
	          const prop = node.properties[i];
	          const isLast = i === last;
	          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
	          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
	            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
	          }
	        }
	        break;
	      case "ObjectProperty": {
	        const {
	          key,
	          value
	        } = node;
	        if (this.isPrivateName(key)) {
	          this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
	        }
	        this.toAssignable(value, isLHS);
	        break;
	      }
	      case "SpreadElement": {
	        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
	      }
	      case "ArrayExpression":
	        this.castNodeTo(node, "ArrayPattern");
	        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
	        break;
	      case "AssignmentExpression":
	        if (node.operator !== "=") {
	          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
	        }
	        this.castNodeTo(node, "AssignmentPattern");
	        delete node.operator;
	        this.toAssignable(node.left, isLHS);
	        break;
	      case "ParenthesizedExpression":
	        this.toAssignable(parenthesized, isLHS);
	        break;
	    }
	  }
	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
	    if (prop.type === "ObjectMethod") {
	      this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
	    } else if (prop.type === "SpreadElement") {
	      this.castNodeTo(prop, "RestElement");
	      const arg = prop.argument;
	      this.checkToRestConversion(arg, false);
	      this.toAssignable(arg, isLHS);
	      if (!isLast) {
	        this.raise(Errors.RestTrailingComma, prop);
	      }
	    } else {
	      this.toAssignable(prop, isLHS);
	    }
	  }
	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
	    const end = exprList.length - 1;
	    for (let i = 0; i <= end; i++) {
	      const elt = exprList[i];
	      if (!elt) continue;
	      this.toAssignableListItem(exprList, i, isLHS);
	      if (elt.type === "RestElement") {
	        if (i < end) {
	          this.raise(Errors.RestTrailingComma, elt);
	        } else if (trailingCommaLoc) {
	          this.raise(Errors.RestTrailingComma, trailingCommaLoc);
	        }
	      }
	    }
	  }
	  toAssignableListItem(exprList, index, isLHS) {
	    const node = exprList[index];
	    if (node.type === "SpreadElement") {
	      this.castNodeTo(node, "RestElement");
	      const arg = node.argument;
	      this.checkToRestConversion(arg, true);
	      this.toAssignable(arg, isLHS);
	    } else {
	      this.toAssignable(node, isLHS);
	    }
	  }
	  isAssignable(node, isBinding) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        return true;
	      case "ObjectExpression": {
	        const last = node.properties.length - 1;
	        return node.properties.every((prop, i) => {
	          return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
	        });
	      }
	      case "ObjectProperty":
	        return this.isAssignable(node.value);
	      case "SpreadElement":
	        return this.isAssignable(node.argument);
	      case "ArrayExpression":
	        return node.elements.every((element) => element === null || this.isAssignable(element));
	      case "AssignmentExpression":
	        return node.operator === "=";
	      case "ParenthesizedExpression":
	        return this.isAssignable(node.expression);
	      case "MemberExpression":
	      case "OptionalMemberExpression":
	        return !isBinding;
	      default:
	        return false;
	    }
	  }
	  toReferencedList(exprList, isParenthesizedExpr) {
	    return exprList;
	  }
	  toReferencedListDeep(exprList, isParenthesizedExpr) {
	    this.toReferencedList(exprList, isParenthesizedExpr);
	    for (const expr of exprList) {
	      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
	        this.toReferencedListDeep(expr.elements);
	      }
	    }
	  }
	  parseSpread(refExpressionErrors) {
	    const node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
	    return this.finishNode(node, "SpreadElement");
	  }
	  parseRestBinding() {
	    const node = this.startNode();
	    this.next();
	    node.argument = this.parseBindingAtom();
	    return this.finishNode(node, "RestElement");
	  }
	  parseBindingAtom() {
	    switch (this.state.type) {
	      case 0: {
	        const node = this.startNode();
	        this.next();
	        node.elements = this.parseBindingList(3, 93, 1);
	        return this.finishNode(node, "ArrayPattern");
	      }
	      case 5:
	        return this.parseObjectLike(8, true);
	    }
	    return this.parseIdentifier();
	  }
	  parseBindingList(close, closeCharCode, flags) {
	    const allowEmpty = flags & 1;
	    const elts = [];
	    let first = true;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	      }
	      if (allowEmpty && this.match(12)) {
	        elts.push(null);
	      } else if (this.eat(close)) {
	        break;
	      } else if (this.match(21)) {
	        let rest = this.parseRestBinding();
	        if (this.hasPlugin("flow") || flags & 2) {
	          rest = this.parseFunctionParamType(rest);
	        }
	        elts.push(rest);
	        if (!this.checkCommaAfterRest(closeCharCode)) {
	          this.expect(close);
	          break;
	        }
	      } else {
	        const decorators = [];
	        if (flags & 2) {
	          if (this.match(26) && this.hasPlugin("decorators")) {
	            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
	          }
	          while (this.match(26)) {
	            decorators.push(this.parseDecorator());
	          }
	        }
	        elts.push(this.parseBindingElement(flags, decorators));
	      }
	    }
	    return elts;
	  }
	  parseBindingRestProperty(prop) {
	    this.next();
	    prop.argument = this.parseIdentifier();
	    this.checkCommaAfterRest(125);
	    return this.finishNode(prop, "RestElement");
	  }
	  parseBindingProperty() {
	    const {
	      type,
	      startLoc
	    } = this.state;
	    if (type === 21) {
	      return this.parseBindingRestProperty(this.startNode());
	    }
	    const prop = this.startNode();
	    if (type === 139) {
	      this.expectPlugin("destructuringPrivate", startLoc);
	      this.classScope.usePrivateName(this.state.value, startLoc);
	      prop.key = this.parsePrivateName();
	    } else {
	      this.parsePropertyName(prop);
	    }
	    prop.method = false;
	    return this.parseObjPropValue(prop, startLoc, false, false, true, false);
	  }
	  parseBindingElement(flags, decorators) {
	    const left = this.parseMaybeDefault();
	    if (this.hasPlugin("flow") || flags & 2) {
	      this.parseFunctionParamType(left);
	    }
	    if (decorators.length) {
	      left.decorators = decorators;
	      this.resetStartLocationFromNode(left, decorators[0]);
	    }
	    const elt = this.parseMaybeDefault(left.loc.start, left);
	    return elt;
	  }
	  parseFunctionParamType(param) {
	    return param;
	  }
	  parseMaybeDefault(startLoc, left) {
	    startLoc != null ? startLoc : startLoc = this.state.startLoc;
	    left = left != null ? left : this.parseBindingAtom();
	    if (!this.eat(29)) return left;
	    const node = this.startNodeAt(startLoc);
	    node.left = left;
	    node.right = this.parseMaybeAssignAllowIn();
	    return this.finishNode(node, "AssignmentPattern");
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    switch (type) {
	      case "AssignmentPattern":
	        return "left";
	      case "RestElement":
	        return "argument";
	      case "ObjectProperty":
	        return "value";
	      case "ParenthesizedExpression":
	        return "expression";
	      case "ArrayPattern":
	        return "elements";
	      case "ObjectPattern":
	        return "properties";
	    }
	    return false;
	  }
	  isOptionalMemberExpression(expression) {
	    return expression.type === "OptionalMemberExpression";
	  }
	  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
	    var _expression$extra;
	    const type = expression.type;
	    if (this.isObjectMethod(expression)) return;
	    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
	    if (isOptionalMemberExpression || type === "MemberExpression") {
	      if (isOptionalMemberExpression) {
	        this.expectPlugin("optionalChainingAssign", expression.loc.start);
	        if (ancestor.type !== "AssignmentExpression") {
	          this.raise(Errors.InvalidLhsOptionalChaining, expression, {
	            ancestor
	          });
	        }
	      }
	      if (binding !== 64) {
	        this.raise(Errors.InvalidPropertyBindingPattern, expression);
	      }
	      return;
	    }
	    if (type === "Identifier") {
	      this.checkIdentifier(expression, binding, strictModeChanged);
	      const {
	        name
	      } = expression;
	      if (checkClashes) {
	        if (checkClashes.has(name)) {
	          this.raise(Errors.ParamDupe, expression);
	        } else {
	          checkClashes.add(name);
	        }
	      }
	      return;
	    }
	    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
	    if (validity === true) return;
	    if (validity === false) {
	      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
	      this.raise(ParseErrorClass, expression, {
	        ancestor
	      });
	      return;
	    }
	    let key, isParenthesizedExpression;
	    if (typeof validity === "string") {
	      key = validity;
	      isParenthesizedExpression = type === "ParenthesizedExpression";
	    } else {
	      [key, isParenthesizedExpression] = validity;
	    }
	    const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
	      type
	    } : ancestor;
	    const val = expression[key];
	    if (Array.isArray(val)) {
	      for (const child of val) {
	        if (child) {
	          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
	        }
	      }
	    } else if (val) {
	      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
	    }
	  }
	  checkIdentifier(at, bindingType, strictModeChanged = false) {
	    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
	      if (bindingType === 64) {
	        this.raise(Errors.StrictEvalArguments, at, {
	          referenceName: at.name
	        });
	      } else {
	        this.raise(Errors.StrictEvalArgumentsBinding, at, {
	          bindingName: at.name
	        });
	      }
	    }
	    if (bindingType & 8192 && at.name === "let") {
	      this.raise(Errors.LetInLexicalBinding, at);
	    }
	    if (!(bindingType & 64)) {
	      this.declareNameFromIdentifier(at, bindingType);
	    }
	  }
	  declareNameFromIdentifier(identifier, binding) {
	    this.scope.declareName(identifier.name, binding, identifier.loc.start);
	  }
	  checkToRestConversion(node, allowPattern) {
	    switch (node.type) {
	      case "ParenthesizedExpression":
	        this.checkToRestConversion(node.expression, allowPattern);
	        break;
	      case "Identifier":
	      case "MemberExpression":
	        break;
	      case "ArrayExpression":
	      case "ObjectExpression":
	        if (allowPattern) break;
	      default:
	        this.raise(Errors.InvalidRestAssignmentPattern, node);
	    }
	  }
	  checkCommaAfterRest(close) {
	    if (!this.match(12)) {
	      return false;
	    }
	    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
	    return true;
	  }
	}
	function nonNull(x) {
	  if (x == null) {
	    throw new Error(`Unexpected ${x} value.`);
	  }
	  return x;
	}
	function assert(x) {
	  if (!x) {
	    throw new Error("Assert fail");
	  }
	}
	const TSErrors = ParseErrorEnum`typescript`({
	  AbstractMethodHasImplementation: ({
	    methodName
	  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
	  AbstractPropertyHasInitializer: ({
	    propertyName
	  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
	  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
	  AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
	  AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
	  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
	  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
	  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
	  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
	  DeclareAccessor: ({
	    kind
	  }) => `'declare' is not allowed in ${kind}ters.`,
	  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
	  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
	  DuplicateAccessibilityModifier: ({
	    modifier
	  }) => `Accessibility modifier already seen: '${modifier}'.`,
	  DuplicateModifier: ({
	    modifier
	  }) => `Duplicate modifier: '${modifier}'.`,
	  EmptyHeritageClauseType: ({
	    token
	  }) => `'${token}' list cannot be empty.`,
	  EmptyTypeArguments: "Type argument list cannot be empty.",
	  EmptyTypeParameters: "Type parameter list cannot be empty.",
	  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
	  ImportAliasHasImportType: "An import alias can not use 'import type'.",
	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
	  IncompatibleModifiers: ({
	    modifiers
	  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
	  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
	  IndexSignatureHasAccessibility: ({
	    modifier
	  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
	  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
	  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
	  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
	  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
	  InvalidHeritageClauseType: ({
	    token
	  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
	  InvalidModifierOnTypeMember: ({
	    modifier
	  }) => `'${modifier}' modifier cannot appear on a type member.`,
	  InvalidModifierOnTypeParameter: ({
	    modifier
	  }) => `'${modifier}' modifier cannot appear on a type parameter.`,
	  InvalidModifierOnTypeParameterPositions: ({
	    modifier
	  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
	  InvalidModifiersOrder: ({
	    orderedModifiers
	  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
	  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
	  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
	  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
	  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
	  NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
	  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
	  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
	  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
	  PrivateElementHasAccessibility: ({
	    modifier
	  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
	  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
	  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
	  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
	  SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
	  SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
	  SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
	  SingleTypeParameterWithoutTrailingComma: ({
	    typeParameterName
	  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
	  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
	  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
	  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
	  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
	  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
	  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
	  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
	  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
	  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
	  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
	  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
	  UnsupportedSignatureParameterKind: ({
	    type
	  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
	});
	function keywordTypeFromName(value) {
	  switch (value) {
	    case "any":
	      return "TSAnyKeyword";
	    case "boolean":
	      return "TSBooleanKeyword";
	    case "bigint":
	      return "TSBigIntKeyword";
	    case "never":
	      return "TSNeverKeyword";
	    case "number":
	      return "TSNumberKeyword";
	    case "object":
	      return "TSObjectKeyword";
	    case "string":
	      return "TSStringKeyword";
	    case "symbol":
	      return "TSSymbolKeyword";
	    case "undefined":
	      return "TSUndefinedKeyword";
	    case "unknown":
	      return "TSUnknownKeyword";
	    default:
	      return void 0;
	  }
	}
	function tsIsAccessModifier(modifier) {
	  return modifier === "private" || modifier === "public" || modifier === "protected";
	}
	function tsIsVarianceAnnotations(modifier) {
	  return modifier === "in" || modifier === "out";
	}
	var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
	  constructor(...args) {
	    super(...args);
	    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["in", "out"],
	      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
	    });
	    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["const"],
	      disallowedModifiers: ["in", "out"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
	    });
	    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["in", "out", "const"],
	      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
	    });
	  }
	  getScopeHandler() {
	    return TypeScriptScopeHandler;
	  }
	  tsIsIdentifier() {
	    return tokenIsIdentifier(this.state.type);
	  }
	  tsTokenCanFollowModifier() {
	    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
	  }
	  tsNextTokenOnSameLineAndCanFollowModifier() {
	    this.next();
	    if (this.hasPrecedingLineBreak()) {
	      return false;
	    }
	    return this.tsTokenCanFollowModifier();
	  }
	  tsNextTokenCanFollowModifier() {
	    if (this.match(106)) {
	      this.next();
	      return this.tsTokenCanFollowModifier();
	    }
	    return this.tsNextTokenOnSameLineAndCanFollowModifier();
	  }
	  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
	    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
	      return void 0;
	    }
	    const modifier = this.state.value;
	    if (allowedModifiers.includes(modifier)) {
	      if (hasSeenStaticModifier && this.match(106)) {
	        return void 0;
	      }
	      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
	        return void 0;
	      }
	      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
	        return modifier;
	      }
	    }
	    return void 0;
	  }
	  tsParseModifiers({
	    allowedModifiers,
	    disallowedModifiers,
	    stopOnStartOfClassStaticBlock,
	    errorTemplate = TSErrors.InvalidModifierOnTypeMember
	  }, modified) {
	    const enforceOrder = (loc, modifier, before, after) => {
	      if (modifier === before && modified[after]) {
	        this.raise(TSErrors.InvalidModifiersOrder, loc, {
	          orderedModifiers: [before, after]
	        });
	      }
	    };
	    const incompatible = (loc, modifier, mod1, mod2) => {
	      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
	        this.raise(TSErrors.IncompatibleModifiers, loc, {
	          modifiers: [mod1, mod2]
	        });
	      }
	    };
	    for (; ; ) {
	      const {
	        startLoc
	      } = this.state;
	      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
	      if (!modifier) break;
	      if (tsIsAccessModifier(modifier)) {
	        if (modified.accessibility) {
	          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
	            modifier
	          });
	        } else {
	          enforceOrder(startLoc, modifier, modifier, "override");
	          enforceOrder(startLoc, modifier, modifier, "static");
	          enforceOrder(startLoc, modifier, modifier, "readonly");
	          modified.accessibility = modifier;
	        }
	      } else if (tsIsVarianceAnnotations(modifier)) {
	        if (modified[modifier]) {
	          this.raise(TSErrors.DuplicateModifier, startLoc, {
	            modifier
	          });
	        }
	        modified[modifier] = true;
	        enforceOrder(startLoc, modifier, "in", "out");
	      } else {
	        if (hasOwnProperty.call(modified, modifier)) {
	          this.raise(TSErrors.DuplicateModifier, startLoc, {
	            modifier
	          });
	        } else {
	          enforceOrder(startLoc, modifier, "static", "readonly");
	          enforceOrder(startLoc, modifier, "static", "override");
	          enforceOrder(startLoc, modifier, "override", "readonly");
	          enforceOrder(startLoc, modifier, "abstract", "override");
	          incompatible(startLoc, modifier, "declare", "override");
	          incompatible(startLoc, modifier, "static", "abstract");
	        }
	        modified[modifier] = true;
	      }
	      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
	        this.raise(errorTemplate, startLoc, {
	          modifier
	        });
	      }
	    }
	  }
	  tsIsListTerminator(kind) {
	    switch (kind) {
	      case "EnumMembers":
	      case "TypeMembers":
	        return this.match(8);
	      case "HeritageClauseElement":
	        return this.match(5);
	      case "TupleElementTypes":
	        return this.match(3);
	      case "TypeParametersOrArguments":
	        return this.match(48);
	    }
	  }
	  tsParseList(kind, parseElement) {
	    const result = [];
	    while (!this.tsIsListTerminator(kind)) {
	      result.push(parseElement());
	    }
	    return result;
	  }
	  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
	    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
	  }
	  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
	    const result = [];
	    let trailingCommaPos = -1;
	    for (; ; ) {
	      if (this.tsIsListTerminator(kind)) {
	        break;
	      }
	      trailingCommaPos = -1;
	      const element = parseElement();
	      if (element == null) {
	        return void 0;
	      }
	      result.push(element);
	      if (this.eat(12)) {
	        trailingCommaPos = this.state.lastTokStartLoc.index;
	        continue;
	      }
	      if (this.tsIsListTerminator(kind)) {
	        break;
	      }
	      if (expectSuccess) {
	        this.expect(12);
	      }
	      return void 0;
	    }
	    if (refTrailingCommaPos) {
	      refTrailingCommaPos.value = trailingCommaPos;
	    }
	    return result;
	  }
	  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
	    if (!skipFirstToken) {
	      if (bracket) {
	        this.expect(0);
	      } else {
	        this.expect(47);
	      }
	    }
	    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
	    if (bracket) {
	      this.expect(3);
	    } else {
	      this.expect(48);
	    }
	    return result;
	  }
	  tsParseImportType() {
	    const node = this.startNode();
	    this.expect(83);
	    this.expect(10);
	    if (!this.match(134)) {
	      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
	      {
	        node.argument = super.parseExprAtom();
	      }
	    } else {
	      {
	        node.argument = this.parseStringLiteral(this.state.value);
	      }
	    }
	    if (this.eat(12)) {
	      node.options = this.tsParseImportTypeOptions();
	    } else {
	      node.options = null;
	    }
	    this.expect(11);
	    if (this.eat(16)) {
	      node.qualifier = this.tsParseEntityName(1 | 2);
	    }
	    if (this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSImportType");
	  }
	  tsParseImportTypeOptions() {
	    const node = this.startNode();
	    this.expect(5);
	    const withProperty = this.startNode();
	    if (this.isContextual(76)) {
	      withProperty.method = false;
	      withProperty.key = this.parseIdentifier(true);
	      withProperty.computed = false;
	      withProperty.shorthand = false;
	    } else {
	      this.unexpected(null, 76);
	    }
	    this.expect(14);
	    withProperty.value = this.tsParseImportTypeWithPropertyValue();
	    node.properties = [this.finishObjectProperty(withProperty)];
	    this.expect(8);
	    return this.finishNode(node, "ObjectExpression");
	  }
	  tsParseImportTypeWithPropertyValue() {
	    const node = this.startNode();
	    const properties = [];
	    this.expect(5);
	    while (!this.match(8)) {
	      const type = this.state.type;
	      if (tokenIsIdentifier(type) || type === 134) {
	        properties.push(super.parsePropertyDefinition(null));
	      } else {
	        this.unexpected();
	      }
	      this.eat(12);
	    }
	    node.properties = properties;
	    this.next();
	    return this.finishNode(node, "ObjectExpression");
	  }
	  tsParseEntityName(flags) {
	    let entity;
	    if (flags & 1 && this.match(78)) {
	      if (flags & 2) {
	        entity = this.parseIdentifier(true);
	      } else {
	        const node = this.startNode();
	        this.next();
	        entity = this.finishNode(node, "ThisExpression");
	      }
	    } else {
	      entity = this.parseIdentifier(!!(flags & 1));
	    }
	    while (this.eat(16)) {
	      const node = this.startNodeAtNode(entity);
	      node.left = entity;
	      node.right = this.parseIdentifier(!!(flags & 1));
	      entity = this.finishNode(node, "TSQualifiedName");
	    }
	    return entity;
	  }
	  tsParseTypeReference() {
	    const node = this.startNode();
	    node.typeName = this.tsParseEntityName(1);
	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSTypeReference");
	  }
	  tsParseThisTypePredicate(lhs) {
	    this.next();
	    const node = this.startNodeAtNode(lhs);
	    node.parameterName = lhs;
	    node.typeAnnotation = this.tsParseTypeAnnotation(false);
	    node.asserts = false;
	    return this.finishNode(node, "TSTypePredicate");
	  }
	  tsParseThisTypeNode() {
	    const node = this.startNode();
	    this.next();
	    return this.finishNode(node, "TSThisType");
	  }
	  tsParseTypeQuery() {
	    const node = this.startNode();
	    this.expect(87);
	    if (this.match(83)) {
	      node.exprName = this.tsParseImportType();
	    } else {
	      {
	        node.exprName = this.tsParseEntityName(1 | 2);
	      }
	    }
	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSTypeQuery");
	  }
	  tsParseTypeParameter(parseModifiers) {
	    const node = this.startNode();
	    parseModifiers(node);
	    node.name = this.tsParseTypeParameterName();
	    node.constraint = this.tsEatThenParseType(81);
	    node.default = this.tsEatThenParseType(29);
	    return this.finishNode(node, "TSTypeParameter");
	  }
	  tsTryParseTypeParameters(parseModifiers) {
	    if (this.match(47)) {
	      return this.tsParseTypeParameters(parseModifiers);
	    }
	  }
	  tsParseTypeParameters(parseModifiers) {
	    const node = this.startNode();
	    if (this.match(47) || this.match(143)) {
	      this.next();
	    } else {
	      this.unexpected();
	    }
	    const refTrailingCommaPos = {
	      value: -1
	    };
	    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
	    if (node.params.length === 0) {
	      this.raise(TSErrors.EmptyTypeParameters, node);
	    }
	    if (refTrailingCommaPos.value !== -1) {
	      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
	    }
	    return this.finishNode(node, "TSTypeParameterDeclaration");
	  }
	  tsFillSignature(returnToken, signature) {
	    const returnTokenRequired = returnToken === 19;
	    const paramsKey = "parameters";
	    const returnTypeKey = "typeAnnotation";
	    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    this.expect(10);
	    signature[paramsKey] = this.tsParseBindingListForSignature();
	    if (returnTokenRequired) {
	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	    } else if (this.match(returnToken)) {
	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	    }
	  }
	  tsParseBindingListForSignature() {
	    const list = super.parseBindingList(11, 41, 2);
	    for (const pattern of list) {
	      const {
	        type
	      } = pattern;
	      if (type === "AssignmentPattern" || type === "TSParameterProperty") {
	        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
	          type
	        });
	      }
	    }
	    return list;
	  }
	  tsParseTypeMemberSemicolon() {
	    if (!this.eat(12) && !this.isLineTerminator()) {
	      this.expect(13);
	    }
	  }
	  tsParseSignatureMember(kind, node) {
	    this.tsFillSignature(14, node);
	    this.tsParseTypeMemberSemicolon();
	    return this.finishNode(node, kind);
	  }
	  tsIsUnambiguouslyIndexSignature() {
	    this.next();
	    if (tokenIsIdentifier(this.state.type)) {
	      this.next();
	      return this.match(14);
	    }
	    return false;
	  }
	  tsTryParseIndexSignature(node) {
	    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
	      return;
	    }
	    this.expect(0);
	    const id = this.parseIdentifier();
	    id.typeAnnotation = this.tsParseTypeAnnotation();
	    this.resetEndLocation(id);
	    this.expect(3);
	    node.parameters = [id];
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) node.typeAnnotation = type;
	    this.tsParseTypeMemberSemicolon();
	    return this.finishNode(node, "TSIndexSignature");
	  }
	  tsParsePropertyOrMethodSignature(node, readonly) {
	    if (this.eat(17)) node.optional = true;
	    if (this.match(10) || this.match(47)) {
	      if (readonly) {
	        this.raise(TSErrors.ReadonlyForMethodSignature, node);
	      }
	      const method = node;
	      if (method.kind && this.match(47)) {
	        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
	      }
	      this.tsFillSignature(14, method);
	      this.tsParseTypeMemberSemicolon();
	      const paramsKey = "parameters";
	      const returnTypeKey = "typeAnnotation";
	      if (method.kind === "get") {
	        if (method[paramsKey].length > 0) {
	          this.raise(Errors.BadGetterArity, this.state.curPosition());
	          if (this.isThisParam(method[paramsKey][0])) {
	            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
	          }
	        }
	      } else if (method.kind === "set") {
	        if (method[paramsKey].length !== 1) {
	          this.raise(Errors.BadSetterArity, this.state.curPosition());
	        } else {
	          const firstParameter = method[paramsKey][0];
	          if (this.isThisParam(firstParameter)) {
	            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
	          }
	          if (firstParameter.type === "Identifier" && firstParameter.optional) {
	            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
	          }
	          if (firstParameter.type === "RestElement") {
	            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
	          }
	        }
	        if (method[returnTypeKey]) {
	          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
	        }
	      } else {
	        method.kind = "method";
	      }
	      return this.finishNode(method, "TSMethodSignature");
	    } else {
	      const property = node;
	      if (readonly) property.readonly = true;
	      const type = this.tsTryParseTypeAnnotation();
	      if (type) property.typeAnnotation = type;
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(property, "TSPropertySignature");
	    }
	  }
	  tsParseTypeMember() {
	    const node = this.startNode();
	    if (this.match(10) || this.match(47)) {
	      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
	    }
	    if (this.match(77)) {
	      const id = this.startNode();
	      this.next();
	      if (this.match(10) || this.match(47)) {
	        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
	      } else {
	        node.key = this.createIdentifier(id, "new");
	        return this.tsParsePropertyOrMethodSignature(node, false);
	      }
	    }
	    this.tsParseModifiers({
	      allowedModifiers: ["readonly"],
	      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
	    }, node);
	    const idx = this.tsTryParseIndexSignature(node);
	    if (idx) {
	      return idx;
	    }
	    super.parsePropertyName(node);
	    if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
	      node.kind = node.key.name;
	      super.parsePropertyName(node);
	      if (!this.match(10) && !this.match(47)) {
	        this.unexpected(null, 10);
	      }
	    }
	    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
	  }
	  tsParseTypeLiteral() {
	    const node = this.startNode();
	    node.members = this.tsParseObjectTypeMembers();
	    return this.finishNode(node, "TSTypeLiteral");
	  }
	  tsParseObjectTypeMembers() {
	    this.expect(5);
	    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
	    this.expect(8);
	    return members;
	  }
	  tsIsStartOfMappedType() {
	    this.next();
	    if (this.eat(53)) {
	      return this.isContextual(122);
	    }
	    if (this.isContextual(122)) {
	      this.next();
	    }
	    if (!this.match(0)) {
	      return false;
	    }
	    this.next();
	    if (!this.tsIsIdentifier()) {
	      return false;
	    }
	    this.next();
	    return this.match(58);
	  }
	  tsParseMappedType() {
	    const node = this.startNode();
	    this.expect(5);
	    if (this.match(53)) {
	      node.readonly = this.state.value;
	      this.next();
	      this.expectContextual(122);
	    } else if (this.eatContextual(122)) {
	      node.readonly = true;
	    }
	    this.expect(0);
	    {
	      const typeParameter = this.startNode();
	      typeParameter.name = this.tsParseTypeParameterName();
	      typeParameter.constraint = this.tsExpectThenParseType(58);
	      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	    }
	    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
	    this.expect(3);
	    if (this.match(53)) {
	      node.optional = this.state.value;
	      this.next();
	      this.expect(17);
	    } else if (this.eat(17)) {
	      node.optional = true;
	    }
	    node.typeAnnotation = this.tsTryParseType();
	    this.semicolon();
	    this.expect(8);
	    return this.finishNode(node, "TSMappedType");
	  }
	  tsParseTupleType() {
	    const node = this.startNode();
	    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
	    let seenOptionalElement = false;
	    node.elementTypes.forEach((elementNode) => {
	      const {
	        type
	      } = elementNode;
	      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
	        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
	      }
	      seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
	    });
	    return this.finishNode(node, "TSTupleType");
	  }
	  tsParseTupleElementType() {
	    const restStartLoc = this.state.startLoc;
	    const rest = this.eat(21);
	    const {
	      startLoc
	    } = this.state;
	    let labeled;
	    let label;
	    let optional;
	    let type;
	    const isWord = tokenIsKeywordOrIdentifier(this.state.type);
	    const chAfterWord = isWord ? this.lookaheadCharCode() : null;
	    if (chAfterWord === 58) {
	      labeled = true;
	      optional = false;
	      label = this.parseIdentifier(true);
	      this.expect(14);
	      type = this.tsParseType();
	    } else if (chAfterWord === 63) {
	      optional = true;
	      const wordName = this.state.value;
	      const typeOrLabel = this.tsParseNonArrayType();
	      if (this.lookaheadCharCode() === 58) {
	        labeled = true;
	        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
	        this.expect(17);
	        this.expect(14);
	        type = this.tsParseType();
	      } else {
	        labeled = false;
	        type = typeOrLabel;
	        this.expect(17);
	      }
	    } else {
	      type = this.tsParseType();
	      optional = this.eat(17);
	      labeled = this.eat(14);
	    }
	    if (labeled) {
	      let labeledNode;
	      if (label) {
	        labeledNode = this.startNodeAt(startLoc);
	        labeledNode.optional = optional;
	        labeledNode.label = label;
	        labeledNode.elementType = type;
	        if (this.eat(17)) {
	          labeledNode.optional = true;
	          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
	        }
	      } else {
	        labeledNode = this.startNodeAt(startLoc);
	        labeledNode.optional = optional;
	        this.raise(TSErrors.InvalidTupleMemberLabel, type);
	        labeledNode.label = type;
	        labeledNode.elementType = this.tsParseType();
	      }
	      type = this.finishNode(labeledNode, "TSNamedTupleMember");
	    } else if (optional) {
	      const optionalTypeNode = this.startNodeAt(startLoc);
	      optionalTypeNode.typeAnnotation = type;
	      type = this.finishNode(optionalTypeNode, "TSOptionalType");
	    }
	    if (rest) {
	      const restNode = this.startNodeAt(restStartLoc);
	      restNode.typeAnnotation = type;
	      type = this.finishNode(restNode, "TSRestType");
	    }
	    return type;
	  }
	  tsParseParenthesizedType() {
	    const node = this.startNode();
	    this.expect(10);
	    node.typeAnnotation = this.tsParseType();
	    this.expect(11);
	    return this.finishNode(node, "TSParenthesizedType");
	  }
	  tsParseFunctionOrConstructorType(type, abstract) {
	    const node = this.startNode();
	    if (type === "TSConstructorType") {
	      node.abstract = !!abstract;
	      if (abstract) this.next();
	      this.next();
	    }
	    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
	    return this.finishNode(node, type);
	  }
	  tsParseLiteralTypeNode() {
	    const node = this.startNode();
	    switch (this.state.type) {
	      case 135:
	      case 136:
	      case 134:
	      case 85:
	      case 86:
	        node.literal = super.parseExprAtom();
	        break;
	      default:
	        this.unexpected();
	    }
	    return this.finishNode(node, "TSLiteralType");
	  }
	  tsParseTemplateLiteralType() {
	    {
	      const node = this.startNode();
	      node.literal = super.parseTemplate(false);
	      return this.finishNode(node, "TSLiteralType");
	    }
	  }
	  parseTemplateSubstitution() {
	    if (this.state.inType) return this.tsParseType();
	    return super.parseTemplateSubstitution();
	  }
	  tsParseThisTypeOrThisTypePredicate() {
	    const thisKeyword = this.tsParseThisTypeNode();
	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
	      return this.tsParseThisTypePredicate(thisKeyword);
	    } else {
	      return thisKeyword;
	    }
	  }
	  tsParseNonArrayType() {
	    switch (this.state.type) {
	      case 134:
	      case 135:
	      case 136:
	      case 85:
	      case 86:
	        return this.tsParseLiteralTypeNode();
	      case 53:
	        if (this.state.value === "-") {
	          const node = this.startNode();
	          const nextToken = this.lookahead();
	          if (nextToken.type !== 135 && nextToken.type !== 136) {
	            this.unexpected();
	          }
	          node.literal = this.parseMaybeUnary();
	          return this.finishNode(node, "TSLiteralType");
	        }
	        break;
	      case 78:
	        return this.tsParseThisTypeOrThisTypePredicate();
	      case 87:
	        return this.tsParseTypeQuery();
	      case 83:
	        return this.tsParseImportType();
	      case 5:
	        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
	      case 0:
	        return this.tsParseTupleType();
	      case 10:
	        return this.tsParseParenthesizedType();
	      case 25:
	      case 24:
	        return this.tsParseTemplateLiteralType();
	      default: {
	        const {
	          type
	        } = this.state;
	        if (tokenIsIdentifier(type) || type === 88 || type === 84) {
	          const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
	          if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
	            const node = this.startNode();
	            this.next();
	            return this.finishNode(node, nodeType);
	          }
	          return this.tsParseTypeReference();
	        }
	      }
	    }
	    this.unexpected();
	  }
	  tsParseArrayTypeOrHigher() {
	    const {
	      startLoc
	    } = this.state;
	    let type = this.tsParseNonArrayType();
	    while (!this.hasPrecedingLineBreak() && this.eat(0)) {
	      if (this.match(3)) {
	        const node = this.startNodeAt(startLoc);
	        node.elementType = type;
	        this.expect(3);
	        type = this.finishNode(node, "TSArrayType");
	      } else {
	        const node = this.startNodeAt(startLoc);
	        node.objectType = type;
	        node.indexType = this.tsParseType();
	        this.expect(3);
	        type = this.finishNode(node, "TSIndexedAccessType");
	      }
	    }
	    return type;
	  }
	  tsParseTypeOperator() {
	    const node = this.startNode();
	    const operator = this.state.value;
	    this.next();
	    node.operator = operator;
	    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
	    if (operator === "readonly") {
	      this.tsCheckTypeAnnotationForReadOnly(node);
	    }
	    return this.finishNode(node, "TSTypeOperator");
	  }
	  tsCheckTypeAnnotationForReadOnly(node) {
	    switch (node.typeAnnotation.type) {
	      case "TSTupleType":
	      case "TSArrayType":
	        return;
	      default:
	        this.raise(TSErrors.UnexpectedReadonly, node);
	    }
	  }
	  tsParseInferType() {
	    const node = this.startNode();
	    this.expectContextual(115);
	    const typeParameter = this.startNode();
	    typeParameter.name = this.tsParseTypeParameterName();
	    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
	    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	    return this.finishNode(node, "TSInferType");
	  }
	  tsParseConstraintForInferType() {
	    if (this.eat(81)) {
	      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
	      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
	        return constraint;
	      }
	    }
	  }
	  tsParseTypeOperatorOrHigher() {
	    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
	    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
	  }
	  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
	    const node = this.startNode();
	    const hasLeadingOperator = this.eat(operator);
	    const types2 = [];
	    do {
	      types2.push(parseConstituentType());
	    } while (this.eat(operator));
	    if (types2.length === 1 && !hasLeadingOperator) {
	      return types2[0];
	    }
	    node.types = types2;
	    return this.finishNode(node, kind);
	  }
	  tsParseIntersectionTypeOrHigher() {
	    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
	  }
	  tsParseUnionTypeOrHigher() {
	    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
	  }
	  tsIsStartOfFunctionType() {
	    if (this.match(47)) {
	      return true;
	    }
	    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
	  }
	  tsSkipParameterStart() {
	    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
	      this.next();
	      return true;
	    }
	    if (this.match(5)) {
	      const {
	        errors
	      } = this.state;
	      const previousErrorCount = errors.length;
	      try {
	        this.parseObjectLike(8, true);
	        return errors.length === previousErrorCount;
	      } catch (_unused) {
	        return false;
	      }
	    }
	    if (this.match(0)) {
	      this.next();
	      const {
	        errors
	      } = this.state;
	      const previousErrorCount = errors.length;
	      try {
	        super.parseBindingList(3, 93, 1);
	        return errors.length === previousErrorCount;
	      } catch (_unused2) {
	        return false;
	      }
	    }
	    return false;
	  }
	  tsIsUnambiguouslyStartOfFunctionType() {
	    this.next();
	    if (this.match(11) || this.match(21)) {
	      return true;
	    }
	    if (this.tsSkipParameterStart()) {
	      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
	        return true;
	      }
	      if (this.match(11)) {
	        this.next();
	        if (this.match(19)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  tsParseTypeOrTypePredicateAnnotation(returnToken) {
	    return this.tsInType(() => {
	      const t = this.startNode();
	      this.expect(returnToken);
	      const node = this.startNode();
	      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
	      if (asserts && this.match(78)) {
	        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
	        if (thisTypePredicate.type === "TSThisType") {
	          node.parameterName = thisTypePredicate;
	          node.asserts = true;
	          node.typeAnnotation = null;
	          thisTypePredicate = this.finishNode(node, "TSTypePredicate");
	        } else {
	          this.resetStartLocationFromNode(thisTypePredicate, node);
	          thisTypePredicate.asserts = true;
	        }
	        t.typeAnnotation = thisTypePredicate;
	        return this.finishNode(t, "TSTypeAnnotation");
	      }
	      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
	      if (!typePredicateVariable) {
	        if (!asserts) {
	          return this.tsParseTypeAnnotation(false, t);
	        }
	        node.parameterName = this.parseIdentifier();
	        node.asserts = asserts;
	        node.typeAnnotation = null;
	        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
	        return this.finishNode(t, "TSTypeAnnotation");
	      }
	      const type = this.tsParseTypeAnnotation(false);
	      node.parameterName = typePredicateVariable;
	      node.typeAnnotation = type;
	      node.asserts = asserts;
	      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
	      return this.finishNode(t, "TSTypeAnnotation");
	    });
	  }
	  tsTryParseTypeOrTypePredicateAnnotation() {
	    if (this.match(14)) {
	      return this.tsParseTypeOrTypePredicateAnnotation(14);
	    }
	  }
	  tsTryParseTypeAnnotation() {
	    if (this.match(14)) {
	      return this.tsParseTypeAnnotation();
	    }
	  }
	  tsTryParseType() {
	    return this.tsEatThenParseType(14);
	  }
	  tsParseTypePredicatePrefix() {
	    const id = this.parseIdentifier();
	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
	      this.next();
	      return id;
	    }
	  }
	  tsParseTypePredicateAsserts() {
	    if (this.state.type !== 109) {
	      return false;
	    }
	    const containsEsc = this.state.containsEsc;
	    this.next();
	    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
	      return false;
	    }
	    if (containsEsc) {
	      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
	        reservedWord: "asserts"
	      });
	    }
	    return true;
	  }
	  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
	    this.tsInType(() => {
	      if (eatColon) this.expect(14);
	      t.typeAnnotation = this.tsParseType();
	    });
	    return this.finishNode(t, "TSTypeAnnotation");
	  }
	  tsParseType() {
	    assert(this.state.inType);
	    const type = this.tsParseNonConditionalType();
	    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
	      return type;
	    }
	    const node = this.startNodeAtNode(type);
	    node.checkType = type;
	    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
	    this.expect(17);
	    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
	    this.expect(14);
	    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
	    return this.finishNode(node, "TSConditionalType");
	  }
	  isAbstractConstructorSignature() {
	    return this.isContextual(124) && this.lookahead().type === 77;
	  }
	  tsParseNonConditionalType() {
	    if (this.tsIsStartOfFunctionType()) {
	      return this.tsParseFunctionOrConstructorType("TSFunctionType");
	    }
	    if (this.match(77)) {
	      return this.tsParseFunctionOrConstructorType("TSConstructorType");
	    } else if (this.isAbstractConstructorSignature()) {
	      return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
	    }
	    return this.tsParseUnionTypeOrHigher();
	  }
	  tsParseTypeAssertion() {
	    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
	    }
	    const node = this.startNode();
	    node.typeAnnotation = this.tsInType(() => {
	      this.next();
	      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
	    });
	    this.expect(48);
	    node.expression = this.parseMaybeUnary();
	    return this.finishNode(node, "TSTypeAssertion");
	  }
	  tsParseHeritageClause(token) {
	    const originalStartLoc = this.state.startLoc;
	    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
	      {
	        const node = this.startNode();
	        node.expression = this.tsParseEntityName(1 | 2);
	        if (this.match(47)) {
	          node.typeParameters = this.tsParseTypeArguments();
	        }
	        return this.finishNode(node, "TSExpressionWithTypeArguments");
	      }
	    });
	    if (!delimitedList.length) {
	      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
	        token
	      });
	    }
	    return delimitedList;
	  }
	  tsParseInterfaceDeclaration(node, properties = {}) {
	    if (this.hasFollowingLineBreak()) return null;
	    this.expectContextual(129);
	    if (properties.declare) node.declare = true;
	    if (tokenIsIdentifier(this.state.type)) {
	      node.id = this.parseIdentifier();
	      this.checkIdentifier(node.id, 130);
	    } else {
	      node.id = null;
	      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
	    }
	    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
	    if (this.eat(81)) {
	      node.extends = this.tsParseHeritageClause("extends");
	    }
	    const body = this.startNode();
	    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
	    node.body = this.finishNode(body, "TSInterfaceBody");
	    return this.finishNode(node, "TSInterfaceDeclaration");
	  }
	  tsParseTypeAliasDeclaration(node) {
	    node.id = this.parseIdentifier();
	    this.checkIdentifier(node.id, 2);
	    node.typeAnnotation = this.tsInType(() => {
	      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
	      this.expect(29);
	      if (this.isContextual(114) && this.lookahead().type !== 16) {
	        const node2 = this.startNode();
	        this.next();
	        return this.finishNode(node2, "TSIntrinsicKeyword");
	      }
	      return this.tsParseType();
	    });
	    this.semicolon();
	    return this.finishNode(node, "TSTypeAliasDeclaration");
	  }
	  tsInTopLevelContext(cb) {
	    if (this.curContext() !== types.brace) {
	      const oldContext = this.state.context;
	      this.state.context = [oldContext[0]];
	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    } else {
	      return cb();
	    }
	  }
	  tsInType(cb) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    try {
	      return cb();
	    } finally {
	      this.state.inType = oldInType;
	    }
	  }
	  tsInDisallowConditionalTypesContext(cb) {
	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
	    this.state.inDisallowConditionalTypesContext = true;
	    try {
	      return cb();
	    } finally {
	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
	    }
	  }
	  tsInAllowConditionalTypesContext(cb) {
	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
	    this.state.inDisallowConditionalTypesContext = false;
	    try {
	      return cb();
	    } finally {
	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
	    }
	  }
	  tsEatThenParseType(token) {
	    if (this.match(token)) {
	      return this.tsNextThenParseType();
	    }
	  }
	  tsExpectThenParseType(token) {
	    return this.tsInType(() => {
	      this.expect(token);
	      return this.tsParseType();
	    });
	  }
	  tsNextThenParseType() {
	    return this.tsInType(() => {
	      this.next();
	      return this.tsParseType();
	    });
	  }
	  tsParseEnumMember() {
	    const node = this.startNode();
	    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
	    if (this.eat(29)) {
	      node.initializer = super.parseMaybeAssignAllowIn();
	    }
	    return this.finishNode(node, "TSEnumMember");
	  }
	  tsParseEnumDeclaration(node, properties = {}) {
	    if (properties.const) node.const = true;
	    if (properties.declare) node.declare = true;
	    this.expectContextual(126);
	    node.id = this.parseIdentifier();
	    this.checkIdentifier(node.id, node.const ? 8971 : 8459);
	    {
	      this.expect(5);
	      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	      this.expect(8);
	    }
	    return this.finishNode(node, "TSEnumDeclaration");
	  }
	  tsParseEnumBody() {
	    const node = this.startNode();
	    this.expect(5);
	    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	    this.expect(8);
	    return this.finishNode(node, "TSEnumBody");
	  }
	  tsParseModuleBlock() {
	    const node = this.startNode();
	    this.scope.enter(0);
	    this.expect(5);
	    super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
	    this.scope.exit();
	    return this.finishNode(node, "TSModuleBlock");
	  }
	  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
	    node.id = this.parseIdentifier();
	    if (!nested) {
	      this.checkIdentifier(node.id, 1024);
	    }
	    if (this.eat(16)) {
	      const inner = this.startNode();
	      this.tsParseModuleOrNamespaceDeclaration(inner, true);
	      node.body = inner;
	    } else {
	      this.scope.enter(256);
	      this.prodParam.enter(0);
	      node.body = this.tsParseModuleBlock();
	      this.prodParam.exit();
	      this.scope.exit();
	    }
	    return this.finishNode(node, "TSModuleDeclaration");
	  }
	  tsParseAmbientExternalModuleDeclaration(node) {
	    if (this.isContextual(112)) {
	      node.kind = "global";
	      {
	        node.global = true;
	      }
	      node.id = this.parseIdentifier();
	    } else if (this.match(134)) {
	      node.kind = "module";
	      node.id = super.parseStringLiteral(this.state.value);
	    } else {
	      this.unexpected();
	    }
	    if (this.match(5)) {
	      this.scope.enter(256);
	      this.prodParam.enter(0);
	      node.body = this.tsParseModuleBlock();
	      this.prodParam.exit();
	      this.scope.exit();
	    } else {
	      this.semicolon();
	    }
	    return this.finishNode(node, "TSModuleDeclaration");
	  }
	  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
	    {
	      node.isExport = isExport || false;
	    }
	    node.id = maybeDefaultIdentifier || this.parseIdentifier();
	    this.checkIdentifier(node.id, 4096);
	    this.expect(29);
	    const moduleReference = this.tsParseModuleReference();
	    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
	      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
	    }
	    node.moduleReference = moduleReference;
	    this.semicolon();
	    return this.finishNode(node, "TSImportEqualsDeclaration");
	  }
	  tsIsExternalModuleReference() {
	    return this.isContextual(119) && this.lookaheadCharCode() === 40;
	  }
	  tsParseModuleReference() {
	    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
	  }
	  tsParseExternalModuleReference() {
	    const node = this.startNode();
	    this.expectContextual(119);
	    this.expect(10);
	    if (!this.match(134)) {
	      this.unexpected();
	    }
	    node.expression = super.parseExprAtom();
	    this.expect(11);
	    this.sawUnambiguousESM = true;
	    return this.finishNode(node, "TSExternalModuleReference");
	  }
	  tsLookAhead(f) {
	    const state = this.state.clone();
	    const res = f();
	    this.state = state;
	    return res;
	  }
	  tsTryParseAndCatch(f) {
	    const result = this.tryParse((abort) => f() || abort());
	    if (result.aborted || !result.node) return;
	    if (result.error) this.state = result.failState;
	    return result.node;
	  }
	  tsTryParse(f) {
	    const state = this.state.clone();
	    const result = f();
	    if (result !== void 0 && result !== false) {
	      return result;
	    }
	    this.state = state;
	  }
	  tsTryParseDeclare(nany) {
	    if (this.isLineTerminator()) {
	      return;
	    }
	    let startType = this.state.type;
	    let kind;
	    if (this.isContextual(100)) {
	      startType = 74;
	      kind = "let";
	    }
	    return this.tsInAmbientContext(() => {
	      switch (startType) {
	        case 68:
	          nany.declare = true;
	          return super.parseFunctionStatement(nany, false, false);
	        case 80:
	          nany.declare = true;
	          return this.parseClass(nany, true, false);
	        case 126:
	          return this.tsParseEnumDeclaration(nany, {
	            declare: true
	          });
	        case 112:
	          return this.tsParseAmbientExternalModuleDeclaration(nany);
	        case 75:
	        case 74:
	          if (!this.match(75) || !this.isLookaheadContextual("enum")) {
	            nany.declare = true;
	            return this.parseVarStatement(nany, kind || this.state.value, true);
	          }
	          this.expect(75);
	          return this.tsParseEnumDeclaration(nany, {
	            const: true,
	            declare: true
	          });
	        case 129: {
	          const result = this.tsParseInterfaceDeclaration(nany, {
	            declare: true
	          });
	          if (result) return result;
	        }
	        default:
	          if (tokenIsIdentifier(startType)) {
	            return this.tsParseDeclaration(nany, this.state.value, true, null);
	          }
	      }
	    });
	  }
	  tsTryParseExportDeclaration() {
	    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
	  }
	  tsParseExpressionStatement(node, expr, decorators) {
	    switch (expr.name) {
	      case "declare": {
	        const declaration = this.tsTryParseDeclare(node);
	        if (declaration) {
	          declaration.declare = true;
	        }
	        return declaration;
	      }
	      case "global":
	        if (this.match(5)) {
	          this.scope.enter(256);
	          this.prodParam.enter(0);
	          const mod = node;
	          mod.kind = "global";
	          {
	            node.global = true;
	          }
	          mod.id = expr;
	          mod.body = this.tsParseModuleBlock();
	          this.scope.exit();
	          this.prodParam.exit();
	          return this.finishNode(mod, "TSModuleDeclaration");
	        }
	        break;
	      default:
	        return this.tsParseDeclaration(node, expr.name, false, decorators);
	    }
	  }
	  tsParseDeclaration(node, value, next, decorators) {
	    switch (value) {
	      case "abstract":
	        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
	          return this.tsParseAbstractDeclaration(node, decorators);
	        }
	        break;
	      case "module":
	        if (this.tsCheckLineTerminator(next)) {
	          if (this.match(134)) {
	            return this.tsParseAmbientExternalModuleDeclaration(node);
	          } else if (tokenIsIdentifier(this.state.type)) {
	            node.kind = "module";
	            return this.tsParseModuleOrNamespaceDeclaration(node);
	          }
	        }
	        break;
	      case "namespace":
	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	          node.kind = "namespace";
	          return this.tsParseModuleOrNamespaceDeclaration(node);
	        }
	        break;
	      case "type":
	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	          return this.tsParseTypeAliasDeclaration(node);
	        }
	        break;
	    }
	  }
	  tsCheckLineTerminator(next) {
	    if (next) {
	      if (this.hasFollowingLineBreak()) return false;
	      this.next();
	      return true;
	    }
	    return !this.isLineTerminator();
	  }
	  tsTryParseGenericAsyncArrowFunction(startLoc) {
	    if (!this.match(47)) return;
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.maybeInArrowParameters = true;
	    const res = this.tsTryParseAndCatch(() => {
	      const node = this.startNodeAt(startLoc);
	      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
	      super.parseFunctionParams(node);
	      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
	      this.expect(19);
	      return node;
	    });
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    if (!res) return;
	    return super.parseArrowExpression(res, null, true);
	  }
	  tsParseTypeArgumentsInExpression() {
	    if (this.reScan_lt() !== 47) return;
	    return this.tsParseTypeArguments();
	  }
	  tsParseTypeArguments() {
	    const node = this.startNode();
	    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
	      this.expect(47);
	      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
	    }));
	    if (node.params.length === 0) {
	      this.raise(TSErrors.EmptyTypeArguments, node);
	    } else if (!this.state.inType && this.curContext() === types.brace) {
	      this.reScan_lt_gt();
	    }
	    this.expect(48);
	    return this.finishNode(node, "TSTypeParameterInstantiation");
	  }
	  tsIsDeclarationStart() {
	    return tokenIsTSDeclarationStart(this.state.type);
	  }
	  isExportDefaultSpecifier() {
	    if (this.tsIsDeclarationStart()) return false;
	    return super.isExportDefaultSpecifier();
	  }
	  parseBindingElement(flags, decorators) {
	    const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
	    const modified = {};
	    this.tsParseModifiers({
	      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
	    }, modified);
	    const accessibility = modified.accessibility;
	    const override = modified.override;
	    const readonly = modified.readonly;
	    if (!(flags & 4) && (accessibility || readonly || override)) {
	      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
	    }
	    const left = this.parseMaybeDefault();
	    if (flags & 2) {
	      this.parseFunctionParamType(left);
	    }
	    const elt = this.parseMaybeDefault(left.loc.start, left);
	    if (accessibility || readonly || override) {
	      const pp = this.startNodeAt(startLoc);
	      if (decorators.length) {
	        pp.decorators = decorators;
	      }
	      if (accessibility) pp.accessibility = accessibility;
	      if (readonly) pp.readonly = readonly;
	      if (override) pp.override = override;
	      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
	        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
	      }
	      pp.parameter = elt;
	      return this.finishNode(pp, "TSParameterProperty");
	    }
	    if (decorators.length) {
	      left.decorators = decorators;
	    }
	    return elt;
	  }
	  isSimpleParameter(node) {
	    return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
	  }
	  tsDisallowOptionalPattern(node) {
	    for (const param of node.params) {
	      if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
	        this.raise(TSErrors.PatternIsOptional, param);
	      }
	    }
	  }
	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
	    super.setArrowFunctionParameters(node, params, trailingCommaLoc);
	    this.tsDisallowOptionalPattern(node);
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    if (this.match(14)) {
	      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
	    }
	    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
	    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
	      return this.finishNode(node, bodilessType);
	    }
	    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
	      this.raise(TSErrors.DeclareFunctionHasImplementation, node);
	      if (node.declare) {
	        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
	      }
	    }
	    this.tsDisallowOptionalPattern(node);
	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
	  }
	  registerFunctionStatementId(node) {
	    if (!node.body && node.id) {
	      this.checkIdentifier(node.id, 1024);
	    } else {
	      super.registerFunctionStatementId(node);
	    }
	  }
	  tsCheckForInvalidTypeCasts(items) {
	    items.forEach((node) => {
	      if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
	        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
	      }
	    });
	  }
	  toReferencedList(exprList, isInParens) {
	    this.tsCheckForInvalidTypeCasts(exprList);
	    return exprList;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
	    if (node.type === "ArrayExpression") {
	      this.tsCheckForInvalidTypeCasts(node.elements);
	    }
	    return node;
	  }
	  parseSubscript(base, startLoc, noCalls, state) {
	    if (!this.hasPrecedingLineBreak() && this.match(35)) {
	      this.state.canStartJSXElement = false;
	      this.next();
	      const nonNullExpression = this.startNodeAt(startLoc);
	      nonNullExpression.expression = base;
	      return this.finishNode(nonNullExpression, "TSNonNullExpression");
	    }
	    let isOptionalCall = false;
	    if (this.match(18) && this.lookaheadCharCode() === 60) {
	      if (noCalls) {
	        state.stop = true;
	        return base;
	      }
	      state.optionalChainMember = isOptionalCall = true;
	      this.next();
	    }
	    if (this.match(47) || this.match(51)) {
	      let missingParenErrorLoc;
	      const result = this.tsTryParseAndCatch(() => {
	        if (!noCalls && this.atPossibleAsyncArrow(base)) {
	          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
	          if (asyncArrowFn) {
	            return asyncArrowFn;
	          }
	        }
	        const typeArguments = this.tsParseTypeArgumentsInExpression();
	        if (!typeArguments) return;
	        if (isOptionalCall && !this.match(10)) {
	          missingParenErrorLoc = this.state.curPosition();
	          return;
	        }
	        if (tokenIsTemplate(this.state.type)) {
	          const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
	          {
	            result2.typeParameters = typeArguments;
	          }
	          return result2;
	        }
	        if (!noCalls && this.eat(10)) {
	          const node2 = this.startNodeAt(startLoc);
	          node2.callee = base;
	          node2.arguments = this.parseCallExpressionArguments(11);
	          this.tsCheckForInvalidTypeCasts(node2.arguments);
	          {
	            node2.typeParameters = typeArguments;
	          }
	          if (state.optionalChainMember) {
	            node2.optional = isOptionalCall;
	          }
	          return this.finishCallExpression(node2, state.optionalChainMember);
	        }
	        const tokenType = this.state.type;
	        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
	          return;
	        }
	        const node = this.startNodeAt(startLoc);
	        node.expression = base;
	        {
	          node.typeParameters = typeArguments;
	        }
	        return this.finishNode(node, "TSInstantiationExpression");
	      });
	      if (missingParenErrorLoc) {
	        this.unexpected(missingParenErrorLoc, 10);
	      }
	      if (result) {
	        if (result.type === "TSInstantiationExpression") {
	          if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
	            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
	          }
	          if (!this.match(16) && !this.match(18)) {
	            result.expression = super.stopParseSubscript(base, state);
	          }
	        }
	        return result;
	      }
	    }
	    return super.parseSubscript(base, startLoc, noCalls, state);
	  }
	  parseNewCallee(node) {
	    var _callee$extra;
	    super.parseNewCallee(node);
	    const {
	      callee
	    } = node;
	    if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
	      {
	        node.typeParameters = callee.typeParameters;
	      }
	      node.callee = callee.expression;
	    }
	  }
	  parseExprOp(left, leftStartLoc, minPrec) {
	    let isSatisfies;
	    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
	      const node = this.startNodeAt(leftStartLoc);
	      node.expression = left;
	      node.typeAnnotation = this.tsInType(() => {
	        this.next();
	        if (this.match(75)) {
	          if (isSatisfies) {
	            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
	              keyword: "const"
	            });
	          }
	          return this.tsParseTypeReference();
	        }
	        return this.tsParseType();
	      });
	      this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
	      this.reScan_lt_gt();
	      return this.parseExprOp(node, leftStartLoc, minPrec);
	    }
	    return super.parseExprOp(left, leftStartLoc, minPrec);
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (!this.state.isAmbientContext) {
	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
	    }
	  }
	  checkImportReflection(node) {
	    super.checkImportReflection(node);
	    if (node.module && node.importKind !== "value") {
	      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
	    }
	  }
	  checkDuplicateExports() {
	  }
	  isPotentialImportPhase(isExport) {
	    if (super.isPotentialImportPhase(isExport)) return true;
	    if (this.isContextual(130)) {
	      const ch = this.lookaheadCharCode();
	      return isExport ? ch === 123 || ch === 42 : ch !== 61;
	    }
	    return !isExport && this.isContextual(87);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    super.applyImportPhase(node, isExport, phase, loc);
	    if (isExport) {
	      node.exportKind = phase === "type" ? "type" : "value";
	    } else {
	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
	    }
	  }
	  parseImport(node) {
	    if (this.match(134)) {
	      node.importKind = "value";
	      return super.parseImport(node);
	    }
	    let importNode;
	    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
	      node.importKind = "value";
	      return this.tsParseImportEqualsDeclaration(node);
	    } else if (this.isContextual(130)) {
	      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
	      if (this.lookaheadCharCode() === 61) {
	        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
	      } else {
	        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
	      }
	    } else {
	      importNode = super.parseImport(node);
	    }
	    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
	      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
	    }
	    return importNode;
	  }
	  parseExport(node, decorators) {
	    if (this.match(83)) {
	      const nodeImportEquals = node;
	      this.next();
	      let maybeDefaultIdentifier = null;
	      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
	        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
	      } else {
	        nodeImportEquals.importKind = "value";
	      }
	      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
	      {
	        return declaration;
	      }
	    } else if (this.eat(29)) {
	      const assign = node;
	      assign.expression = super.parseExpression();
	      this.semicolon();
	      this.sawUnambiguousESM = true;
	      return this.finishNode(assign, "TSExportAssignment");
	    } else if (this.eatContextual(93)) {
	      const decl = node;
	      this.expectContextual(128);
	      decl.id = this.parseIdentifier();
	      this.semicolon();
	      return this.finishNode(decl, "TSNamespaceExportDeclaration");
	    } else {
	      return super.parseExport(node, decorators);
	    }
	  }
	  isAbstractClass() {
	    return this.isContextual(124) && this.lookahead().type === 80;
	  }
	  parseExportDefaultExpression() {
	    if (this.isAbstractClass()) {
	      const cls = this.startNode();
	      this.next();
	      cls.abstract = true;
	      return this.parseClass(cls, true, true);
	    }
	    if (this.match(129)) {
	      const result = this.tsParseInterfaceDeclaration(this.startNode());
	      if (result) return result;
	    }
	    return super.parseExportDefaultExpression();
	  }
	  parseVarStatement(node, kind, allowMissingInitializer = false) {
	    const {
	      isAmbientContext
	    } = this.state;
	    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
	    if (!isAmbientContext) return declaration;
	    for (const {
	      id,
	      init
	    } of declaration.declarations) {
	      if (!init) continue;
	      if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
	        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
	      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
	        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
	      }
	    }
	    return declaration;
	  }
	  parseStatementContent(flags, decorators) {
	    if (this.match(75) && this.isLookaheadContextual("enum")) {
	      const node = this.startNode();
	      this.expect(75);
	      return this.tsParseEnumDeclaration(node, {
	        const: true
	      });
	    }
	    if (this.isContextual(126)) {
	      return this.tsParseEnumDeclaration(this.startNode());
	    }
	    if (this.isContextual(129)) {
	      const result = this.tsParseInterfaceDeclaration(this.startNode());
	      if (result) return result;
	    }
	    return super.parseStatementContent(flags, decorators);
	  }
	  parseAccessModifier() {
	    return this.tsParseModifier(["public", "protected", "private"]);
	  }
	  tsHasSomeModifiers(member, modifiers) {
	    return modifiers.some((modifier) => {
	      if (tsIsAccessModifier(modifier)) {
	        return member.accessibility === modifier;
	      }
	      return !!member[modifier];
	    });
	  }
	  tsIsStartOfStaticBlocks() {
	    return this.isContextual(106) && this.lookaheadCharCode() === 123;
	  }
	  parseClassMember(classBody, member, state) {
	    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
	    this.tsParseModifiers({
	      allowedModifiers: modifiers,
	      disallowedModifiers: ["in", "out"],
	      stopOnStartOfClassStaticBlock: true,
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
	    }, member);
	    const callParseClassMemberWithIsStatic = () => {
	      if (this.tsIsStartOfStaticBlocks()) {
	        this.next();
	        this.next();
	        if (this.tsHasSomeModifiers(member, modifiers)) {
	          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
	        }
	        super.parseClassStaticBlock(classBody, member);
	      } else {
	        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
	      }
	    };
	    if (member.declare) {
	      this.tsInAmbientContext(callParseClassMemberWithIsStatic);
	    } else {
	      callParseClassMemberWithIsStatic();
	    }
	  }
	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    const idx = this.tsTryParseIndexSignature(member);
	    if (idx) {
	      classBody.body.push(idx);
	      if (member.abstract) {
	        this.raise(TSErrors.IndexSignatureHasAbstract, member);
	      }
	      if (member.accessibility) {
	        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
	          modifier: member.accessibility
	        });
	      }
	      if (member.declare) {
	        this.raise(TSErrors.IndexSignatureHasDeclare, member);
	      }
	      if (member.override) {
	        this.raise(TSErrors.IndexSignatureHasOverride, member);
	      }
	      return;
	    }
	    if (!this.state.inAbstractClass && member.abstract) {
	      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
	    }
	    if (member.override) {
	      if (!state.hadSuperClass) {
	        this.raise(TSErrors.OverrideNotInSubClass, member);
	      }
	    }
	    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  }
	  parsePostMemberNameModifiers(methodOrProp) {
	    const optional = this.eat(17);
	    if (optional) methodOrProp.optional = true;
	    if (methodOrProp.readonly && this.match(10)) {
	      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
	    }
	    if (methodOrProp.declare && this.match(10)) {
	      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
	    }
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
	    return decl || super.parseExpressionStatement(node, expr, decorators);
	  }
	  shouldParseExportDeclaration() {
	    if (this.tsIsDeclarationStart()) return true;
	    return super.shouldParseExportDeclaration();
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (!this.match(17)) return expr;
	    if (this.state.maybeInArrowParameters) {
	      const nextCh = this.lookaheadCharCode();
	      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
	        this.setOptionalParametersError(refExpressionErrors);
	        return expr;
	      }
	    }
	    return super.parseConditional(expr, startLoc, refExpressionErrors);
	  }
	  parseParenItem(node, startLoc) {
	    const newNode = super.parseParenItem(node, startLoc);
	    if (this.eat(17)) {
	      newNode.optional = true;
	      this.resetEndLocation(node);
	    }
	    if (this.match(14)) {
	      const typeCastNode = this.startNodeAt(startLoc);
	      typeCastNode.expression = node;
	      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
	      return this.finishNode(typeCastNode, "TSTypeCastExpression");
	    }
	    return node;
	  }
	  parseExportDeclaration(node) {
	    if (!this.state.isAmbientContext && this.isContextual(125)) {
	      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
	    }
	    const startLoc = this.state.startLoc;
	    const isDeclare = this.eatContextual(125);
	    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
	      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
	    }
	    const isIdentifier = tokenIsIdentifier(this.state.type);
	    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
	    if (!declaration) return null;
	    if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
	      node.exportKind = "type";
	    }
	    if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
	      this.resetStartLocation(declaration, startLoc);
	      declaration.declare = true;
	    }
	    return declaration;
	  }
	  parseClassId(node, isStatement, optionalId, bindingType) {
	    if ((!isStatement || optionalId) && this.isContextual(113)) {
	      return;
	    }
	    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
	    if (typeParameters) node.typeParameters = typeParameters;
	  }
	  parseClassPropertyAnnotation(node) {
	    if (!node.optional) {
	      if (this.eat(35)) {
	        node.definite = true;
	      } else if (this.eat(17)) {
	        node.optional = true;
	      }
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) node.typeAnnotation = type;
	  }
	  parseClassProperty(node) {
	    this.parseClassPropertyAnnotation(node);
	    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
	      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
	    }
	    if (node.abstract && this.match(29)) {
	      const {
	        key
	      } = node;
	      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
	        propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
	      });
	    }
	    return super.parseClassProperty(node);
	  }
	  parseClassPrivateProperty(node) {
	    if (node.abstract) {
	      this.raise(TSErrors.PrivateElementHasAbstract, node);
	    }
	    if (node.accessibility) {
	      this.raise(TSErrors.PrivateElementHasAccessibility, node, {
	        modifier: node.accessibility
	      });
	    }
	    this.parseClassPropertyAnnotation(node);
	    return super.parseClassPrivateProperty(node);
	  }
	  parseClassAccessorProperty(node) {
	    this.parseClassPropertyAnnotation(node);
	    if (node.optional) {
	      this.raise(TSErrors.AccessorCannotBeOptional, node);
	    }
	    return super.parseClassAccessorProperty(node);
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters && isConstructor) {
	      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
	    }
	    const {
	      declare = false,
	      kind
	    } = method;
	    if (declare && (kind === "get" || kind === "set")) {
	      this.raise(TSErrors.DeclareAccessor, method, {
	        kind
	      });
	    }
	    if (typeParameters) method.typeParameters = typeParameters;
	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) method.typeParameters = typeParameters;
	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
	  }
	  declareClassPrivateMethodInScope(node, kind) {
	    if (node.type === "TSDeclareMethod") return;
	    if (node.type === "MethodDefinition" && node.value.body == null) {
	      return;
	    }
	    super.declareClassPrivateMethodInScope(node, kind);
	  }
	  parseClassSuper(node) {
	    super.parseClassSuper(node);
	    if (node.superClass && (this.match(47) || this.match(51))) {
	      {
	        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
	      }
	    }
	    if (this.eatContextual(113)) {
	      node.implements = this.tsParseHeritageClause("implements");
	    }
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) prop.typeParameters = typeParameters;
	    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
	  }
	  parseFunctionParams(node, isConstructor) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) node.typeParameters = typeParameters;
	    super.parseFunctionParams(node, isConstructor);
	  }
	  parseVarId(decl, kind) {
	    super.parseVarId(decl, kind);
	    if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
	      decl.definite = true;
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) {
	      decl.id.typeAnnotation = type;
	      this.resetEndLocation(decl.id);
	    }
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    if (this.match(14)) {
	      node.returnType = this.tsParseTypeAnnotation();
	    }
	    return super.parseAsyncArrowFromCallExpression(node, call);
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
	    let state;
	    let jsx2;
	    let typeCast;
	    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
	      state = this.state.clone();
	      jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!jsx2.error) return jsx2.node;
	      const {
	        context
	      } = this.state;
	      const currentContext = context[context.length - 1];
	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	        context.pop();
	      }
	    }
	    if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
	      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	    }
	    if (!state || state === this.state) state = this.state.clone();
	    let typeParameters;
	    const arrow = this.tryParse((abort) => {
	      var _expr$extra, _typeParameters;
	      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
	      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
	        abort();
	      }
	      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
	        this.resetStartLocationFromNode(expr, typeParameters);
	      }
	      expr.typeParameters = typeParameters;
	      return expr;
	    }, state);
	    if (!arrow.error && !arrow.aborted) {
	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	      return arrow.node;
	    }
	    if (!jsx2) {
	      assert(!this.hasPlugin("jsx"));
	      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!typeCast.error) return typeCast.node;
	    }
	    if ((_jsx2 = jsx2) != null && _jsx2.node) {
	      this.state = jsx2.failState;
	      return jsx2.node;
	    }
	    if (arrow.node) {
	      this.state = arrow.failState;
	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	      return arrow.node;
	    }
	    if ((_typeCast = typeCast) != null && _typeCast.node) {
	      this.state = typeCast.failState;
	      return typeCast.node;
	    }
	    throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
	  }
	  reportReservedArrowTypeParam(node) {
	    var _node$extra2;
	    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	      this.raise(TSErrors.ReservedArrowTypeParam, node);
	    }
	  }
	  parseMaybeUnary(refExpressionErrors, sawUnary) {
	    if (!this.hasPlugin("jsx") && this.match(47)) {
	      return this.tsParseTypeAssertion();
	    }
	    return super.parseMaybeUnary(refExpressionErrors, sawUnary);
	  }
	  parseArrow(node) {
	    if (this.match(14)) {
	      const result = this.tryParse((abort) => {
	        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
	        if (this.canInsertSemicolon() || !this.match(19)) abort();
	        return returnType;
	      });
	      if (result.aborted) return;
	      if (!result.thrown) {
	        if (result.error) this.state = result.failState;
	        node.returnType = result.node;
	      }
	    }
	    return super.parseArrow(node);
	  }
	  parseFunctionParamType(param) {
	    if (this.eat(17)) {
	      param.optional = true;
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) param.typeAnnotation = type;
	    this.resetEndLocation(param);
	    return param;
	  }
	  isAssignable(node, isBinding) {
	    switch (node.type) {
	      case "TSTypeCastExpression":
	        return this.isAssignable(node.expression, isBinding);
	      case "TSParameterProperty":
	        return true;
	      default:
	        return super.isAssignable(node, isBinding);
	    }
	  }
	  toAssignable(node, isLHS = false) {
	    switch (node.type) {
	      case "ParenthesizedExpression":
	        this.toAssignableParenthesizedExpression(node, isLHS);
	        break;
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSNonNullExpression":
	      case "TSTypeAssertion":
	        if (isLHS) {
	          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
	        } else {
	          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
	        }
	        this.toAssignable(node.expression, isLHS);
	        break;
	      case "AssignmentExpression":
	        if (!isLHS && node.left.type === "TSTypeCastExpression") {
	          node.left = this.typeCastToParameter(node.left);
	        }
	      default:
	        super.toAssignable(node, isLHS);
	    }
	  }
	  toAssignableParenthesizedExpression(node, isLHS) {
	    switch (node.expression.type) {
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSNonNullExpression":
	      case "TSTypeAssertion":
	      case "ParenthesizedExpression":
	        this.toAssignable(node.expression, isLHS);
	        break;
	      default:
	        super.toAssignable(node, isLHS);
	    }
	  }
	  checkToRestConversion(node, allowPattern) {
	    switch (node.type) {
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSTypeAssertion":
	      case "TSNonNullExpression":
	        this.checkToRestConversion(node.expression, false);
	        break;
	      default:
	        super.checkToRestConversion(node, allowPattern);
	    }
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    switch (type) {
	      case "TSTypeCastExpression":
	        return true;
	      case "TSParameterProperty":
	        return "parameter";
	      case "TSNonNullExpression":
	        return "expression";
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSTypeAssertion":
	        return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
	      default:
	        return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
	    }
	  }
	  parseBindingAtom() {
	    if (this.state.type === 78) {
	      return this.parseIdentifier(true);
	    }
	    return super.parseBindingAtom();
	  }
	  parseMaybeDecoratorArguments(expr, startLoc) {
	    if (this.match(47) || this.match(51)) {
	      const typeArguments = this.tsParseTypeArgumentsInExpression();
	      if (this.match(10)) {
	        const call = super.parseMaybeDecoratorArguments(expr, startLoc);
	        {
	          call.typeParameters = typeArguments;
	        }
	        return call;
	      }
	      this.unexpected(null, 10);
	    }
	    return super.parseMaybeDecoratorArguments(expr, startLoc);
	  }
	  checkCommaAfterRest(close) {
	    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
	      this.next();
	      return false;
	    }
	    return super.checkCommaAfterRest(close);
	  }
	  isClassMethod() {
	    return this.match(47) || super.isClassMethod();
	  }
	  isClassProperty() {
	    return this.match(35) || this.match(14) || super.isClassProperty();
	  }
	  parseMaybeDefault(startLoc, left) {
	    const node = super.parseMaybeDefault(startLoc, left);
	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
	    }
	    return node;
	  }
	  getTokenFromCode(code2) {
	    if (this.state.inType) {
	      if (code2 === 62) {
	        this.finishOp(48, 1);
	        return;
	      }
	      if (code2 === 60) {
	        this.finishOp(47, 1);
	        return;
	      }
	    }
	    super.getTokenFromCode(code2);
	  }
	  reScan_lt_gt() {
	    const {
	      type
	    } = this.state;
	    if (type === 47) {
	      this.state.pos -= 1;
	      this.readToken_lt();
	    } else if (type === 48) {
	      this.state.pos -= 1;
	      this.readToken_gt();
	    }
	  }
	  reScan_lt() {
	    const {
	      type
	    } = this.state;
	    if (type === 51) {
	      this.state.pos -= 2;
	      this.finishOp(47, 1);
	      return 47;
	    }
	    return type;
	  }
	  toAssignableListItem(exprList, index, isLHS) {
	    const node = exprList[index];
	    if (node.type === "TSTypeCastExpression") {
	      exprList[index] = this.typeCastToParameter(node);
	    }
	    super.toAssignableListItem(exprList, index, isLHS);
	  }
	  typeCastToParameter(node) {
	    node.expression.typeAnnotation = node.typeAnnotation;
	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
	    return node.expression;
	  }
	  shouldParseArrow(params) {
	    if (this.match(14)) {
	      return params.every((expr) => this.isAssignable(expr, true));
	    }
	    return super.shouldParseArrow(params);
	  }
	  shouldParseAsyncArrow() {
	    return this.match(14) || super.shouldParseAsyncArrow();
	  }
	  canHaveLeadingDecorator() {
	    return super.canHaveLeadingDecorator() || this.isAbstractClass();
	  }
	  jsxParseOpeningElementAfterName(node) {
	    if (this.match(47) || this.match(51)) {
	      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
	      if (typeArguments) {
	        {
	          node.typeParameters = typeArguments;
	        }
	      }
	    }
	    return super.jsxParseOpeningElementAfterName(node);
	  }
	  getGetterSetterExpectedParamCount(method) {
	    const baseCount = super.getGetterSetterExpectedParamCount(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    const firstParam = params[0];
	    const hasContextParam = firstParam && this.isThisParam(firstParam);
	    return hasContextParam ? baseCount + 1 : baseCount;
	  }
	  parseCatchClauseParam() {
	    const param = super.parseCatchClauseParam();
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) {
	      param.typeAnnotation = type;
	      this.resetEndLocation(param);
	    }
	    return param;
	  }
	  tsInAmbientContext(cb) {
	    const {
	      isAmbientContext: oldIsAmbientContext,
	      strict: oldStrict
	    } = this.state;
	    this.state.isAmbientContext = true;
	    this.state.strict = false;
	    try {
	      return cb();
	    } finally {
	      this.state.isAmbientContext = oldIsAmbientContext;
	      this.state.strict = oldStrict;
	    }
	  }
	  parseClass(node, isStatement, optionalId) {
	    const oldInAbstractClass = this.state.inAbstractClass;
	    this.state.inAbstractClass = !!node.abstract;
	    try {
	      return super.parseClass(node, isStatement, optionalId);
	    } finally {
	      this.state.inAbstractClass = oldInAbstractClass;
	    }
	  }
	  tsParseAbstractDeclaration(node, decorators) {
	    if (this.match(80)) {
	      node.abstract = true;
	      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
	    } else if (this.isContextual(129)) {
	      if (!this.hasFollowingLineBreak()) {
	        node.abstract = true;
	        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
	        return this.tsParseInterfaceDeclaration(node);
	      }
	    } else {
	      this.unexpected(null, 80);
	    }
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
	    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
	    if (method.abstract || method.type === "TSAbstractMethodDefinition") {
	      const hasEstreePlugin = this.hasPlugin("estree");
	      const methodFn = hasEstreePlugin ? method.value : method;
	      if (methodFn.body) {
	        const {
	          key
	        } = method;
	        this.raise(TSErrors.AbstractMethodHasImplementation, method, {
	          methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
	        });
	      }
	    }
	    return method;
	  }
	  tsParseTypeParameterName() {
	    const typeName = this.parseIdentifier();
	    return typeName.name;
	  }
	  shouldParseAsAmbientContext() {
	    return !!this.getPluginOption("typescript", "dts");
	  }
	  parse() {
	    if (this.shouldParseAsAmbientContext()) {
	      this.state.isAmbientContext = true;
	    }
	    return super.parse();
	  }
	  getExpression() {
	    if (this.shouldParseAsAmbientContext()) {
	      this.state.isAmbientContext = true;
	    }
	    return super.getExpression();
	  }
	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	    if (!isString && isMaybeTypeOnly) {
	      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
	      return this.finishNode(node, "ExportSpecifier");
	    }
	    node.exportKind = "value";
	    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    if (!importedIsString && isMaybeTypeOnly) {
	      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
	      return this.finishNode(specifier, "ImportSpecifier");
	    }
	    specifier.importKind = "value";
	    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
	  }
	  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
	    const leftOfAsKey = isImport ? "imported" : "local";
	    const rightOfAsKey = isImport ? "local" : "exported";
	    let leftOfAs = node[leftOfAsKey];
	    let rightOfAs;
	    let hasTypeSpecifier = false;
	    let canParseAsKeyword = true;
	    const loc = leftOfAs.loc.start;
	    if (this.isContextual(93)) {
	      const firstAs = this.parseIdentifier();
	      if (this.isContextual(93)) {
	        const secondAs = this.parseIdentifier();
	        if (tokenIsKeywordOrIdentifier(this.state.type)) {
	          hasTypeSpecifier = true;
	          leftOfAs = firstAs;
	          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	          canParseAsKeyword = false;
	        } else {
	          rightOfAs = secondAs;
	          canParseAsKeyword = false;
	        }
	      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	        canParseAsKeyword = false;
	        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	      } else {
	        hasTypeSpecifier = true;
	        leftOfAs = firstAs;
	      }
	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	      hasTypeSpecifier = true;
	      if (isImport) {
	        leftOfAs = this.parseIdentifier(true);
	        if (!this.isContextual(93)) {
	          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
	        }
	      } else {
	        leftOfAs = this.parseModuleExportName();
	      }
	    }
	    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
	      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
	    }
	    node[leftOfAsKey] = leftOfAs;
	    node[rightOfAsKey] = rightOfAs;
	    const kindKey = isImport ? "importKind" : "exportKind";
	    node[kindKey] = hasTypeSpecifier ? "type" : "value";
	    if (canParseAsKeyword && this.eatContextual(93)) {
	      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	    }
	    if (!node[rightOfAsKey]) {
	      node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
	    }
	    if (isImport) {
	      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
	    }
	  }
	  fillOptionalPropertiesForTSESLint(node) {
	    var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
	    switch (node.type) {
	      case "ExpressionStatement":
	        (_node$directive = node.directive) != null ? _node$directive : node.directive = void 0;
	        return;
	      case "RestElement":
	        node.value = void 0;
	      case "Identifier":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "ObjectPattern":
	        (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];
	        (_node$optional = node.optional) != null ? _node$optional : node.optional = false;
	        (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = void 0;
	        return;
	      case "TSParameterProperty":
	        (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = void 0;
	        (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];
	        (_node$override = node.override) != null ? _node$override : node.override = false;
	        (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;
	        (_node$static = node.static) != null ? _node$static : node.static = false;
	        return;
	      case "TSEmptyBodyFunctionExpression":
	        node.body = null;
	      case "TSDeclareFunction":
	      case "FunctionDeclaration":
	      case "FunctionExpression":
	      case "ClassMethod":
	      case "ClassPrivateMethod":
	        (_node$declare = node.declare) != null ? _node$declare : node.declare = false;
	        (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = void 0;
	        (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = void 0;
	        return;
	      case "Property":
	        (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;
	        return;
	      case "TSMethodSignature":
	      case "TSPropertySignature":
	        (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;
	      case "TSIndexSignature":
	        (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = void 0;
	        (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;
	        (_node$static2 = node.static) != null ? _node$static2 : node.static = false;
	        return;
	      case "TSAbstractPropertyDefinition":
	      case "PropertyDefinition":
	      case "TSAbstractAccessorProperty":
	      case "AccessorProperty":
	        (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;
	        (_node$definite = node.definite) != null ? _node$definite : node.definite = false;
	        (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;
	        (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = void 0;
	      case "TSAbstractMethodDefinition":
	      case "MethodDefinition":
	        (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = void 0;
	        (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];
	        (_node$override2 = node.override) != null ? _node$override2 : node.override = false;
	        (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;
	        return;
	      case "ClassExpression":
	        (_node$id = node.id) != null ? _node$id : node.id = null;
	      case "ClassDeclaration":
	        (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;
	        (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;
	        (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];
	        (_node$implements = node.implements) != null ? _node$implements : node.implements = [];
	        (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = void 0;
	        (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = void 0;
	        return;
	      case "TSTypeAliasDeclaration":
	      case "VariableDeclaration":
	        (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;
	        return;
	      case "VariableDeclarator":
	        (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;
	        return;
	      case "TSEnumDeclaration":
	        (_node$const = node.const) != null ? _node$const : node.const = false;
	        (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;
	        return;
	      case "TSEnumMember":
	        (_node$computed = node.computed) != null ? _node$computed : node.computed = false;
	        return;
	      case "TSImportType":
	        (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;
	        (_node$options = node.options) != null ? _node$options : node.options = null;
	        return;
	      case "TSInterfaceDeclaration":
	        (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;
	        (_node$extends = node.extends) != null ? _node$extends : node.extends = [];
	        return;
	      case "TSModuleDeclaration":
	        (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;
	        (_node$global = node.global) != null ? _node$global : node.global = node.kind === "global";
	        return;
	      case "TSTypeParameter":
	        (_node$const2 = node.const) != null ? _node$const2 : node.const = false;
	        (_node$in = node.in) != null ? _node$in : node.in = false;
	        (_node$out = node.out) != null ? _node$out : node.out = false;
	        return;
	    }
	  }
	};
	function isPossiblyLiteralEnum(expression) {
	  if (expression.type !== "MemberExpression") return false;
	  const {
	    computed,
	    property
	  } = expression;
	  if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
	    return false;
	  }
	  return isUncomputedMemberExpressionChain(expression.object);
	}
	function isValidAmbientConstInitializer(expression, estree2) {
	  var _expression$extra;
	  const {
	    type
	  } = expression;
	  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
	    return false;
	  }
	  if (estree2) {
	    if (type === "Literal") {
	      const {
	        value
	      } = expression;
	      if (typeof value === "string" || typeof value === "boolean") {
	        return true;
	      }
	    }
	  } else {
	    if (type === "StringLiteral" || type === "BooleanLiteral") {
	      return true;
	    }
	  }
	  if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
	    return true;
	  }
	  if (type === "TemplateLiteral" && expression.expressions.length === 0) {
	    return true;
	  }
	  if (isPossiblyLiteralEnum(expression)) {
	    return true;
	  }
	  return false;
	}
	function isNumber(expression, estree2) {
	  if (estree2) {
	    return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
	  }
	  return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
	}
	function isNegativeNumber(expression, estree2) {
	  if (expression.type === "UnaryExpression") {
	    const {
	      operator,
	      argument
	    } = expression;
	    if (operator === "-" && isNumber(argument, estree2)) {
	      return true;
	    }
	  }
	  return false;
	}
	function isUncomputedMemberExpressionChain(expression) {
	  if (expression.type === "Identifier") return true;
	  if (expression.type !== "MemberExpression" || expression.computed) {
	    return false;
	  }
	  return isUncomputedMemberExpressionChain(expression.object);
	}
	const PlaceholderErrors = ParseErrorEnum`placeholders`({
	  ClassNameIsRequired: "A class name is required.",
	  UnexpectedSpace: "Unexpected space in placeholder."
	});
	var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
	  parsePlaceholder(expectedNode) {
	    if (this.match(133)) {
	      const node = this.startNode();
	      this.next();
	      this.assertNoSpace();
	      node.name = super.parseIdentifier(true);
	      this.assertNoSpace();
	      this.expect(133);
	      return this.finishPlaceholder(node, expectedNode);
	    }
	  }
	  finishPlaceholder(node, expectedNode) {
	    let placeholder = node;
	    if (!placeholder.expectedNode || !placeholder.type) {
	      placeholder = this.finishNode(placeholder, "Placeholder");
	    }
	    placeholder.expectedNode = expectedNode;
	    return placeholder;
	  }
	  getTokenFromCode(code2) {
	    if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
	      this.finishOp(133, 2);
	    } else {
	      super.getTokenFromCode(code2);
	    }
	  }
	  parseExprAtom(refExpressionErrors) {
	    return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
	  }
	  parseIdentifier(liberal) {
	    return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (word !== void 0) {
	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
	    }
	  }
	  cloneIdentifier(node) {
	    const cloned = super.cloneIdentifier(node);
	    if (cloned.type === "Placeholder") {
	      cloned.expectedNode = node.expectedNode;
	    }
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    if (node.type === "Placeholder") {
	      return this.cloneIdentifier(node);
	    }
	    return super.cloneStringLiteral(node);
	  }
	  parseBindingAtom() {
	    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
	  }
	  isValidLVal(type, isParenthesized, binding) {
	    return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
	  }
	  toAssignable(node, isLHS) {
	    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
	      node.expectedNode = "Pattern";
	    } else {
	      super.toAssignable(node, isLHS);
	    }
	  }
	  chStartsBindingIdentifier(ch, pos) {
	    if (super.chStartsBindingIdentifier(ch, pos)) {
	      return true;
	    }
	    const nextToken = this.lookahead();
	    if (nextToken.type === 133) {
	      return true;
	    }
	    return false;
	  }
	  verifyBreakContinue(node, isBreak) {
	    if (node.label && node.label.type === "Placeholder") return;
	    super.verifyBreakContinue(node, isBreak);
	  }
	  parseExpressionStatement(node, expr) {
	    var _expr$extra;
	    if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
	      return super.parseExpressionStatement(node, expr);
	    }
	    if (this.match(14)) {
	      const stmt = node;
	      stmt.label = this.finishPlaceholder(expr, "Identifier");
	      this.next();
	      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
	      return this.finishNode(stmt, "LabeledStatement");
	    }
	    this.semicolon();
	    const stmtPlaceholder = node;
	    stmtPlaceholder.name = expr.name;
	    return this.finishPlaceholder(stmtPlaceholder, "Statement");
	  }
	  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
	    return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
	  }
	  parseFunctionId(requireId) {
	    return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
	  }
	  parseClass(node, isStatement, optionalId) {
	    const type = isStatement ? "ClassDeclaration" : "ClassExpression";
	    this.next();
	    const oldStrict = this.state.strict;
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (placeholder) {
	      if (this.match(81) || this.match(133) || this.match(5)) {
	        node.id = placeholder;
	      } else if (optionalId || !isStatement) {
	        node.id = null;
	        node.body = this.finishPlaceholder(placeholder, "ClassBody");
	        return this.finishNode(node, type);
	      } else {
	        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
	      }
	    } else {
	      this.parseClassId(node, isStatement, optionalId);
	    }
	    super.parseClassSuper(node);
	    node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
	    return this.finishNode(node, type);
	  }
	  parseExport(node, decorators) {
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (!placeholder) return super.parseExport(node, decorators);
	    const node2 = node;
	    if (!this.isContextual(98) && !this.match(12)) {
	      node2.specifiers = [];
	      node2.source = null;
	      node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
	      return this.finishNode(node2, "ExportNamedDeclaration");
	    }
	    this.expectPlugin("exportDefaultFrom");
	    const specifier = this.startNode();
	    specifier.exported = placeholder;
	    node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	    return super.parseExport(node2, decorators);
	  }
	  isExportDefaultSpecifier() {
	    if (this.match(65)) {
	      const next = this.nextTokenStart();
	      if (this.isUnparsedContextual(next, "from")) {
	        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
	          return true;
	        }
	      }
	    }
	    return super.isExportDefaultSpecifier();
	  }
	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
	    var _specifiers;
	    if ((_specifiers = node.specifiers) != null && _specifiers.length) {
	      return true;
	    }
	    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
	  }
	  checkExport(node) {
	    const {
	      specifiers
	    } = node;
	    if (specifiers != null && specifiers.length) {
	      node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
	    }
	    super.checkExport(node);
	    node.specifiers = specifiers;
	  }
	  parseImport(node) {
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (!placeholder) return super.parseImport(node);
	    node.specifiers = [];
	    if (!this.isContextual(98) && !this.match(12)) {
	      node.source = this.finishPlaceholder(placeholder, "StringLiteral");
	      this.semicolon();
	      return this.finishNode(node, "ImportDeclaration");
	    }
	    const specifier = this.startNodeAtNode(placeholder);
	    specifier.local = placeholder;
	    node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
	    if (this.eat(12)) {
	      const hasStarImport = this.maybeParseStarImportSpecifier(node);
	      if (!hasStarImport) this.parseNamedImportSpecifiers(node);
	    }
	    this.expectContextual(98);
	    node.source = this.parseImportSource();
	    this.semicolon();
	    return this.finishNode(node, "ImportDeclaration");
	  }
	  parseImportSource() {
	    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
	  }
	  assertNoSpace() {
	    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
	      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
	    }
	  }
	};
	var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
	  parseV8Intrinsic() {
	    if (this.match(54)) {
	      const v8IntrinsicStartLoc = this.state.startLoc;
	      const node = this.startNode();
	      this.next();
	      if (tokenIsIdentifier(this.state.type)) {
	        const name = this.parseIdentifierName();
	        const identifier = this.createIdentifier(node, name);
	        this.castNodeTo(identifier, "V8IntrinsicIdentifier");
	        if (this.match(10)) {
	          return identifier;
	        }
	      }
	      this.unexpected(v8IntrinsicStartLoc);
	    }
	  }
	  parseExprAtom(refExpressionErrors) {
	    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
	  }
	};
	const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
	const TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
	function validatePlugins(pluginsMap) {
	  if (pluginsMap.has("decorators")) {
	    if (pluginsMap.has("decorators-legacy")) {
	      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
	    }
	    const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
	    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
	      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
	    }
	    const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
	    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
	      throw new Error("'allowCallParenthesized' must be a boolean.");
	    }
	  }
	  if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
	    throw new Error("Cannot combine flow and typescript plugins.");
	  }
	  if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
	    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
	  }
	  if (pluginsMap.has("pipelineOperator")) {
	    var _pluginsMap$get2;
	    const proposal = pluginsMap.get("pipelineOperator").proposal;
	    if (!PIPELINE_PROPOSALS.includes(proposal)) {
	      const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
	      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
	    }
	    if (proposal === "hack") {
	      if (pluginsMap.has("placeholders")) {
	        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
	      }
	      if (pluginsMap.has("v8intrinsic")) {
	        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
	      }
	      const topicToken = pluginsMap.get("pipelineOperator").topicToken;
	      if (!TOPIC_TOKENS.includes(topicToken)) {
	        const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
	        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
	      }
	      {
	        var _pluginsMap$get;
	        if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
	          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
	        }
	      }
	    } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
	      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
	    }
	  }
	  if (pluginsMap.has("moduleAttributes")) {
	    {
	      if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
	        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
	      }
	      const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
	      if (moduleAttributesVersionPluginOption !== "may-2020") {
	        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
	      }
	    }
	  }
	  if (pluginsMap.has("importAssertions")) {
	    if (pluginsMap.has("deprecatedImportAssert")) {
	      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
	    }
	  }
	  if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
	    {
	      pluginsMap.set("deprecatedImportAssert", {});
	    }
	  }
	  if (pluginsMap.has("recordAndTuple")) {
	    {
	      const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
	      if (syntaxType != null) {
	        const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
	        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
	          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
	        }
	      }
	    }
	  }
	  if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
	    const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
	    error.missingPlugins = "doExpressions";
	    throw error;
	  }
	  if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
	    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
	  }
	}
	const mixinPlugins = {
	  estree,
	  jsx,
	  flow,
	  typescript,
	  v8intrinsic,
	  placeholders
	};
	const mixinPluginNames = Object.keys(mixinPlugins);
	class ExpressionParser extends LValParser {
	  checkProto(prop, isRecord, sawProto, refExpressionErrors) {
	    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
	      return sawProto;
	    }
	    const key = prop.key;
	    const name = key.type === "Identifier" ? key.name : key.value;
	    if (name === "__proto__") {
	      if (isRecord) {
	        this.raise(Errors.RecordNoProto, key);
	        return true;
	      }
	      if (sawProto) {
	        if (refExpressionErrors) {
	          if (refExpressionErrors.doubleProtoLoc === null) {
	            refExpressionErrors.doubleProtoLoc = key.loc.start;
	          }
	        } else {
	          this.raise(Errors.DuplicateProto, key);
	        }
	      }
	      return true;
	    }
	    return sawProto;
	  }
	  shouldExitDescending(expr, potentialArrowAt) {
	    return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
	  }
	  getExpression() {
	    this.enterInitialScopes();
	    this.nextToken();
	    const expr = this.parseExpression();
	    if (!this.match(140)) {
	      this.unexpected();
	    }
	    this.finalizeRemainingComments();
	    expr.comments = this.comments;
	    expr.errors = this.state.errors;
	    if (this.optionFlags & 256) {
	      expr.tokens = this.tokens;
	    }
	    return expr;
	  }
	  parseExpression(disallowIn, refExpressionErrors) {
	    if (disallowIn) {
	      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
	    }
	    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
	  }
	  parseExpressionBase(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const expr = this.parseMaybeAssign(refExpressionErrors);
	    if (this.match(12)) {
	      const node = this.startNodeAt(startLoc);
	      node.expressions = [expr];
	      while (this.eat(12)) {
	        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
	      }
	      this.toReferencedList(node.expressions);
	      return this.finishNode(node, "SequenceExpression");
	    }
	    return expr;
	  }
	  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
	    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
	  }
	  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
	    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
	  }
	  setOptionalParametersError(refExpressionErrors) {
	    refExpressionErrors.optionalParametersLoc = this.state.startLoc;
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    const startLoc = this.state.startLoc;
	    const isYield = this.isContextual(108);
	    if (isYield) {
	      if (this.prodParam.hasYield) {
	        this.next();
	        let left2 = this.parseYield(startLoc);
	        if (afterLeftParse) {
	          left2 = afterLeftParse.call(this, left2, startLoc);
	        }
	        return left2;
	      }
	    }
	    let ownExpressionErrors;
	    if (refExpressionErrors) {
	      ownExpressionErrors = false;
	    } else {
	      refExpressionErrors = new ExpressionErrors();
	      ownExpressionErrors = true;
	    }
	    const {
	      type
	    } = this.state;
	    if (type === 10 || tokenIsIdentifier(type)) {
	      this.state.potentialArrowAt = this.state.start;
	    }
	    let left = this.parseMaybeConditional(refExpressionErrors);
	    if (afterLeftParse) {
	      left = afterLeftParse.call(this, left, startLoc);
	    }
	    if (tokenIsAssignment(this.state.type)) {
	      const node = this.startNodeAt(startLoc);
	      const operator = this.state.value;
	      node.operator = operator;
	      if (this.match(29)) {
	        this.toAssignable(left, true);
	        node.left = left;
	        const startIndex = startLoc.index;
	        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
	          refExpressionErrors.doubleProtoLoc = null;
	        }
	        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
	          refExpressionErrors.shorthandAssignLoc = null;
	        }
	        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
	          this.checkDestructuringPrivate(refExpressionErrors);
	          refExpressionErrors.privateKeyLoc = null;
	        }
	      } else {
	        node.left = left;
	      }
	      this.next();
	      node.right = this.parseMaybeAssign();
	      this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
	      return node;
	    } else if (ownExpressionErrors) {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }
	    if (isYield) {
	      const {
	        type: type2
	      } = this.state;
	      const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
	      if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
	        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
	        return this.parseYield(startLoc);
	      }
	    }
	    return left;
	  }
	  parseMaybeConditional(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseExprOps(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseConditional(expr, startLoc, refExpressionErrors);
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (this.eat(17)) {
	      const node = this.startNodeAt(startLoc);
	      node.test = expr;
	      node.consequent = this.parseMaybeAssignAllowIn();
	      this.expect(14);
	      node.alternate = this.parseMaybeAssign();
	      return this.finishNode(node, "ConditionalExpression");
	    }
	    return expr;
	  }
	  parseMaybeUnaryOrPrivate(refExpressionErrors) {
	    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
	  }
	  parseExprOps(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseExprOp(expr, startLoc, -1);
	  }
	  parseExprOp(left, leftStartLoc, minPrec) {
	    if (this.isPrivateName(left)) {
	      const value = this.getPrivateNameSV(left);
	      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
	        this.raise(Errors.PrivateInExpectedIn, left, {
	          identifierName: value
	        });
	      }
	      this.classScope.usePrivateName(value, left.loc.start);
	    }
	    const op = this.state.type;
	    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
	      let prec = tokenOperatorPrecedence(op);
	      if (prec > minPrec) {
	        if (op === 39) {
	          this.expectPlugin("pipelineOperator");
	          if (this.state.inFSharpPipelineDirectBody) {
	            return left;
	          }
	          this.checkPipelineAtInfixOperator(left, leftStartLoc);
	        }
	        const node = this.startNodeAt(leftStartLoc);
	        node.left = left;
	        node.operator = this.state.value;
	        const logical = op === 41 || op === 42;
	        const coalesce = op === 40;
	        if (coalesce) {
	          prec = tokenOperatorPrecedence(42);
	        }
	        this.next();
	        if (op === 39 && this.hasPlugin(["pipelineOperator", {
	          proposal: "minimal"
	        }])) {
	          if (this.state.type === 96 && this.prodParam.hasAwait) {
	            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
	          }
	        }
	        node.right = this.parseExprOpRightExpr(op, prec);
	        const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
	        const nextOp = this.state.type;
	        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
	          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
	        }
	        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
	      }
	    }
	    return left;
	  }
	  parseExprOpRightExpr(op, prec) {
	    const startLoc = this.state.startLoc;
	    switch (op) {
	      case 39:
	        switch (this.getPluginOption("pipelineOperator", "proposal")) {
	          case "hack":
	            return this.withTopicBindingContext(() => {
	              return this.parseHackPipeBody();
	            });
	          case "fsharp":
	            return this.withSoloAwaitPermittingContext(() => {
	              return this.parseFSharpPipelineBody(prec);
	            });
	        }
	        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
	          return this.withTopicBindingContext(() => {
	            if (this.prodParam.hasYield && this.isContextual(108)) {
	              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
	            }
	            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
	          });
	        }
	      default:
	        return this.parseExprOpBaseRightExpr(op, prec);
	    }
	  }
	  parseExprOpBaseRightExpr(op, prec) {
	    const startLoc = this.state.startLoc;
	    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
	  }
	  parseHackPipeBody() {
	    var _body$extra;
	    const {
	      startLoc
	    } = this.state;
	    const body = this.parseMaybeAssign();
	    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
	    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
	      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
	        type: body.type
	      });
	    }
	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(Errors.PipeTopicUnused, startLoc);
	    }
	    return body;
	  }
	  checkExponentialAfterUnary(node) {
	    if (this.match(57)) {
	      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
	    }
	  }
	  parseMaybeUnary(refExpressionErrors, sawUnary) {
	    const startLoc = this.state.startLoc;
	    const isAwait = this.isContextual(96);
	    if (isAwait && this.recordAwaitIfAllowed()) {
	      this.next();
	      const expr2 = this.parseAwait(startLoc);
	      if (!sawUnary) this.checkExponentialAfterUnary(expr2);
	      return expr2;
	    }
	    const update = this.match(34);
	    const node = this.startNode();
	    if (tokenIsPrefix(this.state.type)) {
	      node.operator = this.state.value;
	      node.prefix = true;
	      if (this.match(72)) {
	        this.expectPlugin("throwExpressions");
	      }
	      const isDelete = this.match(89);
	      this.next();
	      node.argument = this.parseMaybeUnary(null, true);
	      this.checkExpressionErrors(refExpressionErrors, true);
	      if (this.state.strict && isDelete) {
	        const arg = node.argument;
	        if (arg.type === "Identifier") {
	          this.raise(Errors.StrictDelete, node);
	        } else if (this.hasPropertyAsPrivateName(arg)) {
	          this.raise(Errors.DeletePrivateField, node);
	        }
	      }
	      if (!update) {
	        if (!sawUnary) {
	          this.checkExponentialAfterUnary(node);
	        }
	        return this.finishNode(node, "UnaryExpression");
	      }
	    }
	    const expr = this.parseUpdate(node, update, refExpressionErrors);
	    if (isAwait) {
	      const {
	        type
	      } = this.state;
	      const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
	      if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
	        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
	        return this.parseAwait(startLoc);
	      }
	    }
	    return expr;
	  }
	  parseUpdate(node, update, refExpressionErrors) {
	    if (update) {
	      const updateExpressionNode = node;
	      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
	      return node;
	    }
	    const startLoc = this.state.startLoc;
	    let expr = this.parseExprSubscripts(refExpressionErrors);
	    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
	    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
	      const node2 = this.startNodeAt(startLoc);
	      node2.operator = this.state.value;
	      node2.prefix = false;
	      node2.argument = expr;
	      this.next();
	      this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
	    }
	    return expr;
	  }
	  parseExprSubscripts(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseExprAtom(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseSubscripts(expr, startLoc);
	  }
	  parseSubscripts(base, startLoc, noCalls) {
	    const state = {
	      optionalChainMember: false,
	      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
	      stop: false
	    };
	    do {
	      base = this.parseSubscript(base, startLoc, noCalls, state);
	      state.maybeAsyncArrow = false;
	    } while (!state.stop);
	    return base;
	  }
	  parseSubscript(base, startLoc, noCalls, state) {
	    const {
	      type
	    } = this.state;
	    if (!noCalls && type === 15) {
	      return this.parseBind(base, startLoc, noCalls, state);
	    } else if (tokenIsTemplate(type)) {
	      return this.parseTaggedTemplateExpression(base, startLoc, state);
	    }
	    let optional = false;
	    if (type === 18) {
	      if (noCalls) {
	        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
	        if (this.lookaheadCharCode() === 40) {
	          return this.stopParseSubscript(base, state);
	        }
	      }
	      state.optionalChainMember = optional = true;
	      this.next();
	    }
	    if (!noCalls && this.match(10)) {
	      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
	    } else {
	      const computed = this.eat(0);
	      if (computed || optional || this.eat(16)) {
	        return this.parseMember(base, startLoc, state, computed, optional);
	      } else {
	        return this.stopParseSubscript(base, state);
	      }
	    }
	  }
	  stopParseSubscript(base, state) {
	    state.stop = true;
	    return base;
	  }
	  parseMember(base, startLoc, state, computed, optional) {
	    const node = this.startNodeAt(startLoc);
	    node.object = base;
	    node.computed = computed;
	    if (computed) {
	      node.property = this.parseExpression();
	      this.expect(3);
	    } else if (this.match(139)) {
	      if (base.type === "Super") {
	        this.raise(Errors.SuperPrivateField, startLoc);
	      }
	      this.classScope.usePrivateName(this.state.value, this.state.startLoc);
	      node.property = this.parsePrivateName();
	    } else {
	      node.property = this.parseIdentifier(true);
	    }
	    if (state.optionalChainMember) {
	      node.optional = optional;
	      return this.finishNode(node, "OptionalMemberExpression");
	    } else {
	      return this.finishNode(node, "MemberExpression");
	    }
	  }
	  parseBind(base, startLoc, noCalls, state) {
	    const node = this.startNodeAt(startLoc);
	    node.object = base;
	    this.next();
	    node.callee = this.parseNoCallExpr();
	    state.stop = true;
	    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
	  }
	  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    let refExpressionErrors = null;
	    this.state.maybeInArrowParameters = true;
	    this.next();
	    const node = this.startNodeAt(startLoc);
	    node.callee = base;
	    const {
	      maybeAsyncArrow,
	      optionalChainMember
	    } = state;
	    if (maybeAsyncArrow) {
	      this.expressionScope.enter(newAsyncArrowScope());
	      refExpressionErrors = new ExpressionErrors();
	    }
	    if (optionalChainMember) {
	      node.optional = optional;
	    }
	    if (optional) {
	      node.arguments = this.parseCallExpressionArguments(11);
	    } else {
	      node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
	    }
	    let finishedNode = this.finishCallExpression(node, optionalChainMember);
	    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
	      state.stop = true;
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
	    } else {
	      if (maybeAsyncArrow) {
	        this.checkExpressionErrors(refExpressionErrors, true);
	        this.expressionScope.exit();
	      }
	      this.toReferencedArguments(finishedNode);
	    }
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return finishedNode;
	  }
	  toReferencedArguments(node, isParenthesizedExpr) {
	    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
	  }
	  parseTaggedTemplateExpression(base, startLoc, state) {
	    const node = this.startNodeAt(startLoc);
	    node.tag = base;
	    node.quasi = this.parseTemplate(true);
	    if (state.optionalChainMember) {
	      this.raise(Errors.OptionalChainingNoTemplate, startLoc);
	    }
	    return this.finishNode(node, "TaggedTemplateExpression");
	  }
	  atPossibleAsyncArrow(base) {
	    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
	  }
	  finishCallExpression(node, optional) {
	    if (node.callee.type === "Import") {
	      if (node.arguments.length === 0 || node.arguments.length > 2) {
	        this.raise(Errors.ImportCallArity, node);
	      } else {
	        for (const arg of node.arguments) {
	          if (arg.type === "SpreadElement") {
	            this.raise(Errors.ImportCallSpreadArgument, arg);
	          }
	        }
	      }
	    }
	    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
	  }
	  parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
	    const elts = [];
	    let first = true;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          if (nodeForExtra) {
	            this.addTrailingCommaExtraToNode(nodeForExtra);
	          }
	          this.next();
	          break;
	        }
	      }
	      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
	    }
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return elts;
	  }
	  shouldParseAsyncArrow() {
	    return this.match(19) && !this.canInsertSemicolon();
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    var _call$extra;
	    this.resetPreviousNodeTrailingComments(call);
	    this.expect(19);
	    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
	    if (call.innerComments) {
	      setInnerComments(node, call.innerComments);
	    }
	    if (call.callee.trailingComments) {
	      setInnerComments(node, call.callee.trailingComments);
	    }
	    return node;
	  }
	  parseNoCallExpr() {
	    const startLoc = this.state.startLoc;
	    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
	  }
	  parseExprAtom(refExpressionErrors) {
	    let node;
	    let decorators = null;
	    const {
	      type
	    } = this.state;
	    switch (type) {
	      case 79:
	        return this.parseSuper();
	      case 83:
	        node = this.startNode();
	        this.next();
	        if (this.match(16)) {
	          return this.parseImportMetaPropertyOrPhaseCall(node);
	        }
	        if (this.match(10)) {
	          if (this.optionFlags & 512) {
	            return this.parseImportCall(node);
	          } else {
	            return this.finishNode(node, "Import");
	          }
	        } else {
	          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
	          return this.finishNode(node, "Import");
	        }
	      case 78:
	        node = this.startNode();
	        this.next();
	        return this.finishNode(node, "ThisExpression");
	      case 90: {
	        return this.parseDo(this.startNode(), false);
	      }
	      case 56:
	      case 31: {
	        this.readRegexp();
	        return this.parseRegExpLiteral(this.state.value);
	      }
	      case 135:
	        return this.parseNumericLiteral(this.state.value);
	      case 136:
	        return this.parseBigIntLiteral(this.state.value);
	      case 134:
	        return this.parseStringLiteral(this.state.value);
	      case 84:
	        return this.parseNullLiteral();
	      case 85:
	        return this.parseBooleanLiteral(true);
	      case 86:
	        return this.parseBooleanLiteral(false);
	      case 10: {
	        const canBeArrow = this.state.potentialArrowAt === this.state.start;
	        return this.parseParenAndDistinguishExpression(canBeArrow);
	      }
	      case 0: {
	        return this.parseArrayLike(3, true, false, refExpressionErrors);
	      }
	      case 5: {
	        return this.parseObjectLike(8, false, false, refExpressionErrors);
	      }
	      case 68:
	        return this.parseFunctionOrFunctionSent();
	      case 26:
	        decorators = this.parseDecorators();
	      case 80:
	        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
	      case 77:
	        return this.parseNewOrNewTarget();
	      case 25:
	      case 24:
	        return this.parseTemplate(false);
	      case 15: {
	        node = this.startNode();
	        this.next();
	        node.object = null;
	        const callee = node.callee = this.parseNoCallExpr();
	        if (callee.type === "MemberExpression") {
	          return this.finishNode(node, "BindExpression");
	        } else {
	          throw this.raise(Errors.UnsupportedBind, callee);
	        }
	      }
	      case 139: {
	        this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
	          identifierName: this.state.value
	        });
	        return this.parsePrivateName();
	      }
	      case 33: {
	        return this.parseTopicReferenceThenEqualsSign(54, "%");
	      }
	      case 32: {
	        return this.parseTopicReferenceThenEqualsSign(44, "^");
	      }
	      case 37:
	      case 38: {
	        return this.parseTopicReference("hack");
	      }
	      case 44:
	      case 54:
	      case 27: {
	        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
	        if (pipeProposal) {
	          return this.parseTopicReference(pipeProposal);
	        }
	        this.unexpected();
	        break;
	      }
	      case 47: {
	        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
	        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
	          this.expectOnePlugin(["jsx", "flow", "typescript"]);
	        } else {
	          this.unexpected();
	        }
	        break;
	      }
	      default:
	        {
	          if (type === 137) {
	            return this.parseDecimalLiteral(this.state.value);
	          } else if (type === 2 || type === 1) {
	            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
	          } else if (type === 6 || type === 7) {
	            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
	          }
	        }
	        if (tokenIsIdentifier(type)) {
	          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
	            return this.parseModuleExpression();
	          }
	          const canBeArrow = this.state.potentialArrowAt === this.state.start;
	          const containsEsc = this.state.containsEsc;
	          const id = this.parseIdentifier();
	          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
	            const {
	              type: type2
	            } = this.state;
	            if (type2 === 68) {
	              this.resetPreviousNodeTrailingComments(id);
	              this.next();
	              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
	            } else if (tokenIsIdentifier(type2)) {
	              if (this.lookaheadCharCode() === 61) {
	                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
	              } else {
	                return id;
	              }
	            } else if (type2 === 90) {
	              this.resetPreviousNodeTrailingComments(id);
	              return this.parseDo(this.startNodeAtNode(id), true);
	            }
	          }
	          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
	            this.next();
	            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
	          }
	          return id;
	        } else {
	          this.unexpected();
	        }
	    }
	  }
	  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
	    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
	    if (pipeProposal) {
	      this.state.type = topicTokenType;
	      this.state.value = topicTokenValue;
	      this.state.pos--;
	      this.state.end--;
	      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
	      return this.parseTopicReference(pipeProposal);
	    } else {
	      this.unexpected();
	    }
	  }
	  parseTopicReference(pipeProposal) {
	    const node = this.startNode();
	    const startLoc = this.state.startLoc;
	    const tokenType = this.state.type;
	    this.next();
	    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
	  }
	  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
	    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
	      if (pipeProposal === "hack") {
	        if (!this.topicReferenceIsAllowedInCurrentContext()) {
	          this.raise(Errors.PipeTopicUnbound, startLoc);
	        }
	        this.registerTopicReference();
	        return this.finishNode(node, "TopicReference");
	      } else {
	        if (!this.topicReferenceIsAllowedInCurrentContext()) {
	          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
	        }
	        this.registerTopicReference();
	        return this.finishNode(node, "PipelinePrimaryTopicReference");
	      }
	    } else {
	      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
	        token: tokenLabelName(tokenType)
	      });
	    }
	  }
	  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
	    switch (pipeProposal) {
	      case "hack": {
	        return this.hasPlugin(["pipelineOperator", {
	          topicToken: tokenLabelName(tokenType)
	        }]);
	      }
	      case "smart":
	        return tokenType === 27;
	      default:
	        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
	    }
	  }
	  parseAsyncArrowUnaryFunction(node) {
	    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
	    const params = [this.parseIdentifier()];
	    this.prodParam.exit();
	    if (this.hasPrecedingLineBreak()) {
	      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
	    }
	    this.expect(19);
	    return this.parseArrowExpression(node, params, true);
	  }
	  parseDo(node, isAsync) {
	    this.expectPlugin("doExpressions");
	    if (isAsync) {
	      this.expectPlugin("asyncDoExpressions");
	    }
	    node.async = isAsync;
	    this.next();
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    if (isAsync) {
	      this.prodParam.enter(2);
	      node.body = this.parseBlock();
	      this.prodParam.exit();
	    } else {
	      node.body = this.parseBlock();
	    }
	    this.state.labels = oldLabels;
	    return this.finishNode(node, "DoExpression");
	  }
	  parseSuper() {
	    const node = this.startNode();
	    this.next();
	    if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
	      this.raise(Errors.SuperNotAllowed, node);
	    } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
	      this.raise(Errors.UnexpectedSuper, node);
	    }
	    if (!this.match(10) && !this.match(0) && !this.match(16)) {
	      this.raise(Errors.UnsupportedSuper, node);
	    }
	    return this.finishNode(node, "Super");
	  }
	  parsePrivateName() {
	    const node = this.startNode();
	    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
	    const name = this.state.value;
	    this.next();
	    node.id = this.createIdentifier(id, name);
	    return this.finishNode(node, "PrivateName");
	  }
	  parseFunctionOrFunctionSent() {
	    const node = this.startNode();
	    this.next();
	    if (this.prodParam.hasYield && this.match(16)) {
	      const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
	      this.next();
	      if (this.match(103)) {
	        this.expectPlugin("functionSent");
	      } else if (!this.hasPlugin("functionSent")) {
	        this.unexpected();
	      }
	      return this.parseMetaProperty(node, meta, "sent");
	    }
	    return this.parseFunction(node);
	  }
	  parseMetaProperty(node, meta, propertyName) {
	    node.meta = meta;
	    const containsEsc = this.state.containsEsc;
	    node.property = this.parseIdentifier(true);
	    if (node.property.name !== propertyName || containsEsc) {
	      this.raise(Errors.UnsupportedMetaProperty, node.property, {
	        target: meta.name,
	        onlyValidPropertyName: propertyName
	      });
	    }
	    return this.finishNode(node, "MetaProperty");
	  }
	  parseImportMetaPropertyOrPhaseCall(node) {
	    this.next();
	    if (this.isContextual(105) || this.isContextual(97)) {
	      const isSource = this.isContextual(105);
	      this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
	      this.next();
	      node.phase = isSource ? "source" : "defer";
	      return this.parseImportCall(node);
	    } else {
	      const id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
	      if (this.isContextual(101)) {
	        if (!this.inModule) {
	          this.raise(Errors.ImportMetaOutsideModule, id);
	        }
	        this.sawUnambiguousESM = true;
	      }
	      return this.parseMetaProperty(node, id, "meta");
	    }
	  }
	  parseLiteralAtNode(value, type, node) {
	    this.addExtra(node, "rawValue", value);
	    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
	    node.value = value;
	    this.next();
	    return this.finishNode(node, type);
	  }
	  parseLiteral(value, type) {
	    const node = this.startNode();
	    return this.parseLiteralAtNode(value, type, node);
	  }
	  parseStringLiteral(value) {
	    return this.parseLiteral(value, "StringLiteral");
	  }
	  parseNumericLiteral(value) {
	    return this.parseLiteral(value, "NumericLiteral");
	  }
	  parseBigIntLiteral(value) {
	    return this.parseLiteral(value, "BigIntLiteral");
	  }
	  parseDecimalLiteral(value) {
	    return this.parseLiteral(value, "DecimalLiteral");
	  }
	  parseRegExpLiteral(value) {
	    const node = this.startNode();
	    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
	    node.pattern = value.pattern;
	    node.flags = value.flags;
	    this.next();
	    return this.finishNode(node, "RegExpLiteral");
	  }
	  parseBooleanLiteral(value) {
	    const node = this.startNode();
	    node.value = value;
	    this.next();
	    return this.finishNode(node, "BooleanLiteral");
	  }
	  parseNullLiteral() {
	    const node = this.startNode();
	    this.next();
	    return this.finishNode(node, "NullLiteral");
	  }
	  parseParenAndDistinguishExpression(canBeArrow) {
	    const startLoc = this.state.startLoc;
	    let val;
	    this.next();
	    this.expressionScope.enter(newArrowHeadScope());
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.maybeInArrowParameters = true;
	    this.state.inFSharpPipelineDirectBody = false;
	    const innerStartLoc = this.state.startLoc;
	    const exprList = [];
	    const refExpressionErrors = new ExpressionErrors();
	    let first = true;
	    let spreadStartLoc;
	    let optionalCommaStartLoc;
	    while (!this.match(11)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
	        if (this.match(11)) {
	          optionalCommaStartLoc = this.state.startLoc;
	          break;
	        }
	      }
	      if (this.match(21)) {
	        const spreadNodeStartLoc = this.state.startLoc;
	        spreadStartLoc = this.state.startLoc;
	        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
	        if (!this.checkCommaAfterRest(41)) {
	          break;
	        }
	      } else {
	        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
	      }
	    }
	    const innerEndLoc = this.state.lastTokEndLoc;
	    this.expect(11);
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    let arrowNode = this.startNodeAt(startLoc);
	    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      this.parseArrowExpression(arrowNode, exprList, false);
	      return arrowNode;
	    }
	    this.expressionScope.exit();
	    if (!exprList.length) {
	      this.unexpected(this.state.lastTokStartLoc);
	    }
	    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
	    if (spreadStartLoc) this.unexpected(spreadStartLoc);
	    this.checkExpressionErrors(refExpressionErrors, true);
	    this.toReferencedListDeep(exprList, true);
	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartLoc);
	      val.expressions = exprList;
	      this.finishNode(val, "SequenceExpression");
	      this.resetEndLocation(val, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	    return this.wrapParenthesis(startLoc, val);
	  }
	  wrapParenthesis(startLoc, expression) {
	    if (!(this.optionFlags & 1024)) {
	      this.addExtra(expression, "parenthesized", true);
	      this.addExtra(expression, "parenStart", startLoc.index);
	      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
	      return expression;
	    }
	    const parenExpression = this.startNodeAt(startLoc);
	    parenExpression.expression = expression;
	    return this.finishNode(parenExpression, "ParenthesizedExpression");
	  }
	  shouldParseArrow(params) {
	    return !this.canInsertSemicolon();
	  }
	  parseArrow(node) {
	    if (this.eat(19)) {
	      return node;
	    }
	  }
	  parseParenItem(node, startLoc) {
	    return node;
	  }
	  parseNewOrNewTarget() {
	    const node = this.startNode();
	    this.next();
	    if (this.match(16)) {
	      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
	      this.next();
	      const metaProp = this.parseMetaProperty(node, meta, "target");
	      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
	        this.raise(Errors.UnexpectedNewTarget, metaProp);
	      }
	      return metaProp;
	    }
	    return this.parseNew(node);
	  }
	  parseNew(node) {
	    this.parseNewCallee(node);
	    if (this.eat(10)) {
	      const args = this.parseExprList(11);
	      this.toReferencedList(args);
	      node.arguments = args;
	    } else {
	      node.arguments = [];
	    }
	    return this.finishNode(node, "NewExpression");
	  }
	  parseNewCallee(node) {
	    const isImport = this.match(83);
	    const callee = this.parseNoCallExpr();
	    node.callee = callee;
	    if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
	      this.raise(Errors.ImportCallNotNewExpression, callee);
	    }
	  }
	  parseTemplateElement(isTagged) {
	    const {
	      start,
	      startLoc,
	      end,
	      value
	    } = this.state;
	    const elemStart = start + 1;
	    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
	    if (value === null) {
	      if (!isTagged) {
	        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
	      }
	    }
	    const isTail = this.match(24);
	    const endOffset = isTail ? -1 : -2;
	    const elemEnd = end + endOffset;
	    elem.value = {
	      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
	      cooked: value === null ? null : value.slice(1, endOffset)
	    };
	    elem.tail = isTail;
	    this.next();
	    const finishedNode = this.finishNode(elem, "TemplateElement");
	    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
	    return finishedNode;
	  }
	  parseTemplate(isTagged) {
	    const node = this.startNode();
	    let curElt = this.parseTemplateElement(isTagged);
	    const quasis = [curElt];
	    const substitutions = [];
	    while (!curElt.tail) {
	      substitutions.push(this.parseTemplateSubstitution());
	      this.readTemplateContinuation();
	      quasis.push(curElt = this.parseTemplateElement(isTagged));
	    }
	    node.expressions = substitutions;
	    node.quasis = quasis;
	    return this.finishNode(node, "TemplateLiteral");
	  }
	  parseTemplateSubstitution() {
	    return this.parseExpression();
	  }
	  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
	    if (isRecord) {
	      this.expectPlugin("recordAndTuple");
	    }
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    let sawProto = false;
	    let first = true;
	    const node = this.startNode();
	    node.properties = [];
	    this.next();
	    while (!this.match(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          this.addTrailingCommaExtraToNode(node);
	          break;
	        }
	      }
	      let prop;
	      if (isPattern) {
	        prop = this.parseBindingProperty();
	      } else {
	        prop = this.parsePropertyDefinition(refExpressionErrors);
	        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
	      }
	      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
	        this.raise(Errors.InvalidRecordProperty, prop);
	      }
	      {
	        if (prop.shorthand) {
	          this.addExtra(prop, "shorthand", true);
	        }
	      }
	      node.properties.push(prop);
	    }
	    this.next();
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    let type = "ObjectExpression";
	    if (isPattern) {
	      type = "ObjectPattern";
	    } else if (isRecord) {
	      type = "RecordExpression";
	    }
	    return this.finishNode(node, type);
	  }
	  addTrailingCommaExtraToNode(node) {
	    this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
	    this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
	  }
	  maybeAsyncOrAccessorProp(prop) {
	    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
	  }
	  parsePropertyDefinition(refExpressionErrors) {
	    let decorators = [];
	    if (this.match(26)) {
	      if (this.hasPlugin("decorators")) {
	        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
	      }
	      while (this.match(26)) {
	        decorators.push(this.parseDecorator());
	      }
	    }
	    const prop = this.startNode();
	    let isAsync = false;
	    let isAccessor = false;
	    let startLoc;
	    if (this.match(21)) {
	      if (decorators.length) this.unexpected();
	      return this.parseSpread();
	    }
	    if (decorators.length) {
	      prop.decorators = decorators;
	      decorators = [];
	    }
	    prop.method = false;
	    if (refExpressionErrors) {
	      startLoc = this.state.startLoc;
	    }
	    let isGenerator = this.eat(55);
	    this.parsePropertyNamePrefixOperator(prop);
	    const containsEsc = this.state.containsEsc;
	    this.parsePropertyName(prop, refExpressionErrors);
	    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
	      const {
	        key
	      } = prop;
	      const keyName = key.name;
	      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
	        isAsync = true;
	        this.resetPreviousNodeTrailingComments(key);
	        isGenerator = this.eat(55);
	        this.parsePropertyName(prop);
	      }
	      if (keyName === "get" || keyName === "set") {
	        isAccessor = true;
	        this.resetPreviousNodeTrailingComments(key);
	        prop.kind = keyName;
	        if (this.match(55)) {
	          isGenerator = true;
	          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
	            kind: keyName
	          });
	          this.next();
	        }
	        this.parsePropertyName(prop);
	      }
	    }
	    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
	  }
	  getGetterSetterExpectedParamCount(method) {
	    return method.kind === "get" ? 0 : 1;
	  }
	  getObjectOrClassMethodParams(method) {
	    return method.params;
	  }
	  checkGetterSetterParams(method) {
	    var _params;
	    const paramCount = this.getGetterSetterExpectedParamCount(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    if (params.length !== paramCount) {
	      this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
	    }
	    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
	      this.raise(Errors.BadSetterRestParameter, method);
	    }
	  }
	  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
	    if (isAccessor) {
	      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
	      this.checkGetterSetterParams(finishedProp);
	      return finishedProp;
	    }
	    if (isAsync || isGenerator || this.match(10)) {
	      if (isPattern) this.unexpected();
	      prop.kind = "method";
	      prop.method = true;
	      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
	    }
	  }
	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
	    prop.shorthand = false;
	    if (this.eat(14)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
	      return this.finishObjectProperty(prop);
	    }
	    if (!prop.computed && prop.key.type === "Identifier") {
	      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
	      } else if (this.match(29)) {
	        const shorthandAssignLoc = this.state.startLoc;
	        if (refExpressionErrors != null) {
	          if (refExpressionErrors.shorthandAssignLoc === null) {
	            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
	          }
	        } else {
	          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
	        }
	        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
	      } else {
	        prop.value = this.cloneIdentifier(prop.key);
	      }
	      prop.shorthand = true;
	      return this.finishObjectProperty(prop);
	    }
	  }
	  finishObjectProperty(node) {
	    return this.finishNode(node, "ObjectProperty");
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
	    if (!node) this.unexpected();
	    return node;
	  }
	  parsePropertyName(prop, refExpressionErrors) {
	    if (this.eat(0)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssignAllowIn();
	      this.expect(3);
	    } else {
	      const {
	        type,
	        value
	      } = this.state;
	      let key;
	      if (tokenIsKeywordOrIdentifier(type)) {
	        key = this.parseIdentifier(true);
	      } else {
	        switch (type) {
	          case 135:
	            key = this.parseNumericLiteral(value);
	            break;
	          case 134:
	            key = this.parseStringLiteral(value);
	            break;
	          case 136:
	            key = this.parseBigIntLiteral(value);
	            break;
	          case 139: {
	            const privateKeyLoc = this.state.startLoc;
	            if (refExpressionErrors != null) {
	              if (refExpressionErrors.privateKeyLoc === null) {
	                refExpressionErrors.privateKeyLoc = privateKeyLoc;
	              }
	            } else {
	              this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
	            }
	            key = this.parsePrivateName();
	            break;
	          }
	          default:
	            if (type === 137) {
	              key = this.parseDecimalLiteral(value);
	              break;
	            }
	            this.unexpected();
	        }
	      }
	      prop.key = key;
	      if (type !== 139) {
	        prop.computed = false;
	      }
	    }
	  }
	  initFunction(node, isAsync) {
	    node.id = null;
	    node.generator = false;
	    node.async = isAsync;
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
	    this.initFunction(node, isAsync);
	    node.generator = isGenerator;
	    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
	    this.prodParam.enter(functionFlags(isAsync, node.generator));
	    this.parseFunctionParams(node, isConstructor);
	    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    return finishedNode;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    if (isTuple) {
	      this.expectPlugin("recordAndTuple");
	    }
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    const node = this.startNode();
	    this.next();
	    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
	  }
	  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
	    this.scope.enter(2 | 4);
	    let flags = functionFlags(isAsync, false);
	    if (!this.match(5) && this.prodParam.hasIn) {
	      flags |= 8;
	    }
	    this.prodParam.enter(flags);
	    this.initFunction(node, isAsync);
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    if (params) {
	      this.state.maybeInArrowParameters = true;
	      this.setArrowFunctionParameters(node, params, trailingCommaLoc);
	    }
	    this.state.maybeInArrowParameters = false;
	    this.parseFunctionBody(node, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return this.finishNode(node, "ArrowFunctionExpression");
	  }
	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
	    this.toAssignableList(params, trailingCommaLoc, false);
	    node.params = params;
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    this.parseFunctionBody(node, false, isMethod);
	    return this.finishNode(node, type);
	  }
	  parseFunctionBody(node, allowExpression, isMethod = false) {
	    const isExpression = allowExpression && !this.match(5);
	    this.expressionScope.enter(newExpressionScope());
	    if (isExpression) {
	      node.body = this.parseMaybeAssign();
	      this.checkParams(node, false, allowExpression, false);
	    } else {
	      const oldStrict = this.state.strict;
	      const oldLabels = this.state.labels;
	      this.state.labels = [];
	      this.prodParam.enter(this.prodParam.currentFlags() | 4);
	      node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
	        const nonSimple = !this.isSimpleParamList(node.params);
	        if (hasStrictModeDirective && nonSimple) {
	          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
	        }
	        const strictModeChanged = !oldStrict && this.state.strict;
	        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
	        if (this.state.strict && node.id) {
	          this.checkIdentifier(node.id, 65, strictModeChanged);
	        }
	      });
	      this.prodParam.exit();
	      this.state.labels = oldLabels;
	    }
	    this.expressionScope.exit();
	  }
	  isSimpleParameter(node) {
	    return node.type === "Identifier";
	  }
	  isSimpleParamList(params) {
	    for (let i = 0, len = params.length; i < len; i++) {
	      if (!this.isSimpleParameter(params[i])) return false;
	    }
	    return true;
	  }
	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
	    const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
	    const formalParameters = {
	      type: "FormalParameters"
	    };
	    for (const param of node.params) {
	      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
	    }
	  }
	  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
	    const elts = [];
	    let first = true;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          if (nodeForExtra) {
	            this.addTrailingCommaExtraToNode(nodeForExtra);
	          }
	          this.next();
	          break;
	        }
	      }
	      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
	    }
	    return elts;
	  }
	  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
	    let elt;
	    if (this.match(12)) {
	      if (!allowEmpty) {
	        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
	          unexpected: ","
	        });
	      }
	      elt = null;
	    } else if (this.match(21)) {
	      const spreadNodeStartLoc = this.state.startLoc;
	      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
	    } else if (this.match(17)) {
	      this.expectPlugin("partialApplication");
	      if (!allowPlaceholder) {
	        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
	      }
	      const node = this.startNode();
	      this.next();
	      elt = this.finishNode(node, "ArgumentPlaceholder");
	    } else {
	      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
	    }
	    return elt;
	  }
	  parseIdentifier(liberal) {
	    const node = this.startNode();
	    const name = this.parseIdentifierName(liberal);
	    return this.createIdentifier(node, name);
	  }
	  createIdentifier(node, name) {
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNode(node, "Identifier");
	  }
	  createIdentifierAt(node, name, endLoc) {
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNodeAt(node, "Identifier", endLoc);
	  }
	  parseIdentifierName(liberal) {
	    let name;
	    const {
	      startLoc,
	      type
	    } = this.state;
	    if (tokenIsKeywordOrIdentifier(type)) {
	      name = this.state.value;
	    } else {
	      this.unexpected();
	    }
	    const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
	    if (liberal) {
	      if (tokenIsKeyword2) {
	        this.replaceToken(132);
	      }
	    } else {
	      this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
	    }
	    this.next();
	    return name;
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (word.length > 10) {
	      return;
	    }
	    if (!canBeReservedWord(word)) {
	      return;
	    }
	    if (checkKeywords && isKeyword(word)) {
	      this.raise(Errors.UnexpectedKeyword, startLoc, {
	        keyword: word
	      });
	      return;
	    }
	    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
	    if (reservedTest(word, this.inModule)) {
	      this.raise(Errors.UnexpectedReservedWord, startLoc, {
	        reservedWord: word
	      });
	      return;
	    } else if (word === "yield") {
	      if (this.prodParam.hasYield) {
	        this.raise(Errors.YieldBindingIdentifier, startLoc);
	        return;
	      }
	    } else if (word === "await") {
	      if (this.prodParam.hasAwait) {
	        this.raise(Errors.AwaitBindingIdentifier, startLoc);
	        return;
	      }
	      if (this.scope.inStaticBlock) {
	        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
	        return;
	      }
	      this.expressionScope.recordAsyncArrowParametersError(startLoc);
	    } else if (word === "arguments") {
	      if (this.scope.inClassAndNotInNonArrowFunction) {
	        this.raise(Errors.ArgumentsInClass, startLoc);
	        return;
	      }
	    }
	  }
	  recordAwaitIfAllowed() {
	    const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
	    if (isAwaitAllowed && !this.scope.inFunction) {
	      this.state.hasTopLevelAwait = true;
	    }
	    return isAwaitAllowed;
	  }
	  parseAwait(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
	    if (this.eat(55)) {
	      this.raise(Errors.ObsoleteAwaitStar, node);
	    }
	    if (!this.scope.inFunction && !(this.optionFlags & 1)) {
	      if (this.isAmbiguousPrefixOrIdentifier()) {
	        this.ambiguousScriptDifferentAst = true;
	      } else {
	        this.sawUnambiguousESM = true;
	      }
	    }
	    if (!this.state.soloAwait) {
	      node.argument = this.parseMaybeUnary(null, true);
	    }
	    return this.finishNode(node, "AwaitExpression");
	  }
	  isAmbiguousPrefixOrIdentifier() {
	    if (this.hasPrecedingLineBreak()) return true;
	    const {
	      type
	    } = this.state;
	    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
	  }
	  parseYield(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
	    let delegating = false;
	    let argument = null;
	    if (!this.hasPrecedingLineBreak()) {
	      delegating = this.eat(55);
	      switch (this.state.type) {
	        case 13:
	        case 140:
	        case 8:
	        case 11:
	        case 3:
	        case 9:
	        case 14:
	        case 12:
	          if (!delegating) break;
	        default:
	          argument = this.parseMaybeAssign();
	      }
	    }
	    node.delegate = delegating;
	    node.argument = argument;
	    return this.finishNode(node, "YieldExpression");
	  }
	  parseImportCall(node) {
	    this.next();
	    node.source = this.parseMaybeAssignAllowIn();
	    node.options = null;
	    if (this.eat(12)) {
	      if (!this.match(11)) {
	        node.options = this.parseMaybeAssignAllowIn();
	        if (this.eat(12)) {
	          this.addTrailingCommaExtraToNode(node.options);
	          if (!this.match(11)) {
	            do {
	              this.parseMaybeAssignAllowIn();
	            } while (this.eat(12) && !this.match(11));
	            this.raise(Errors.ImportCallArity, node);
	          }
	        }
	      } else {
	        this.addTrailingCommaExtraToNode(node.source);
	      }
	    }
	    this.expect(11);
	    return this.finishNode(node, "ImportExpression");
	  }
	  checkPipelineAtInfixOperator(left, leftStartLoc) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      if (left.type === "SequenceExpression") {
	        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
	      }
	    }
	  }
	  parseSmartPipelineBodyInStyle(childExpr, startLoc) {
	    if (this.isSimpleReference(childExpr)) {
	      const bodyNode = this.startNodeAt(startLoc);
	      bodyNode.callee = childExpr;
	      return this.finishNode(bodyNode, "PipelineBareFunction");
	    } else {
	      const bodyNode = this.startNodeAt(startLoc);
	      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
	      bodyNode.expression = childExpr;
	      return this.finishNode(bodyNode, "PipelineTopicExpression");
	    }
	  }
	  isSimpleReference(expression) {
	    switch (expression.type) {
	      case "MemberExpression":
	        return !expression.computed && this.isSimpleReference(expression.object);
	      case "Identifier":
	        return true;
	      default:
	        return false;
	    }
	  }
	  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
	    if (this.match(19)) {
	      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
	    }
	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(Errors.PipelineTopicUnused, startLoc);
	    }
	  }
	  withTopicBindingContext(callback) {
	    const outerContextTopicState = this.state.topicContext;
	    this.state.topicContext = {
	      maxNumOfResolvableTopics: 1,
	      maxTopicIndex: null
	    };
	    try {
	      return callback();
	    } finally {
	      this.state.topicContext = outerContextTopicState;
	    }
	  }
	  withSmartMixTopicForbiddingContext(callback) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      const outerContextTopicState = this.state.topicContext;
	      this.state.topicContext = {
	        maxNumOfResolvableTopics: 0,
	        maxTopicIndex: null
	      };
	      try {
	        return callback();
	      } finally {
	        this.state.topicContext = outerContextTopicState;
	      }
	    } else {
	      return callback();
	    }
	  }
	  withSoloAwaitPermittingContext(callback) {
	    const outerContextSoloAwaitState = this.state.soloAwait;
	    this.state.soloAwait = true;
	    try {
	      return callback();
	    } finally {
	      this.state.soloAwait = outerContextSoloAwaitState;
	    }
	  }
	  allowInAnd(callback) {
	    const flags = this.prodParam.currentFlags();
	    const prodParamToSet = 8 & ~flags;
	    if (prodParamToSet) {
	      this.prodParam.enter(flags | 8);
	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }
	    return callback();
	  }
	  disallowInAnd(callback) {
	    const flags = this.prodParam.currentFlags();
	    const prodParamToClear = 8 & flags;
	    if (prodParamToClear) {
	      this.prodParam.enter(flags & -9);
	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }
	    return callback();
	  }
	  registerTopicReference() {
	    this.state.topicContext.maxTopicIndex = 0;
	  }
	  topicReferenceIsAllowedInCurrentContext() {
	    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
	  }
	  topicReferenceWasUsedInCurrentContext() {
	    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
	  }
	  parseFSharpPipelineBody(prec) {
	    const startLoc = this.state.startLoc;
	    this.state.potentialArrowAt = this.state.start;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = true;
	    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return ret;
	  }
	  parseModuleExpression() {
	    this.expectPlugin("moduleBlocks");
	    const node = this.startNode();
	    this.next();
	    if (!this.match(5)) {
	      this.unexpected(null, 5);
	    }
	    const program = this.startNodeAt(this.state.endLoc);
	    this.next();
	    const revertScopes = this.initializeScopes(true);
	    this.enterInitialScopes();
	    try {
	      node.body = this.parseProgram(program, 8, "module");
	    } finally {
	      revertScopes();
	    }
	    return this.finishNode(node, "ModuleExpression");
	  }
	  parsePropertyNamePrefixOperator(prop) {
	  }
	}
	const loopLabel = {
	  kind: 1
	}, switchLabel = {
	  kind: 2
	};
	const loneSurrogate = /[\uD800-\uDFFF]/u;
	const keywordRelationalOperator = /in(?:stanceof)?/y;
	function babel7CompatTokens(tokens, input, startIndex) {
	  for (let i = 0; i < tokens.length; i++) {
	    const token = tokens[i];
	    const {
	      type
	    } = token;
	    if (typeof type === "number") {
	      {
	        if (type === 139) {
	          const {
	            loc,
	            start,
	            value,
	            end
	          } = token;
	          const hashEndPos = start + 1;
	          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
	          tokens.splice(i, 1, new Token({
	            type: getExportedToken(27),
	            value: "#",
	            start,
	            end: hashEndPos,
	            startLoc: loc.start,
	            endLoc: hashEndLoc
	          }), new Token({
	            type: getExportedToken(132),
	            value,
	            start: hashEndPos,
	            end,
	            startLoc: hashEndLoc,
	            endLoc: loc.end
	          }));
	          i++;
	          continue;
	        }
	        if (tokenIsTemplate(type)) {
	          const {
	            loc,
	            start,
	            value,
	            end
	          } = token;
	          const backquoteEnd = start + 1;
	          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
	          let startToken;
	          if (input.charCodeAt(start - startIndex) === 96) {
	            startToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start,
	              end: backquoteEnd,
	              startLoc: loc.start,
	              endLoc: backquoteEndLoc
	            });
	          } else {
	            startToken = new Token({
	              type: getExportedToken(8),
	              value: "}",
	              start,
	              end: backquoteEnd,
	              startLoc: loc.start,
	              endLoc: backquoteEndLoc
	            });
	          }
	          let templateValue, templateElementEnd, templateElementEndLoc, endToken;
	          if (type === 24) {
	            templateElementEnd = end - 1;
	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
	            templateValue = value === null ? null : value.slice(1, -1);
	            endToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start: templateElementEnd,
	              end,
	              startLoc: templateElementEndLoc,
	              endLoc: loc.end
	            });
	          } else {
	            templateElementEnd = end - 2;
	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
	            templateValue = value === null ? null : value.slice(1, -2);
	            endToken = new Token({
	              type: getExportedToken(23),
	              value: "${",
	              start: templateElementEnd,
	              end,
	              startLoc: templateElementEndLoc,
	              endLoc: loc.end
	            });
	          }
	          tokens.splice(i, 1, startToken, new Token({
	            type: getExportedToken(20),
	            value: templateValue,
	            start: backquoteEnd,
	            end: templateElementEnd,
	            startLoc: backquoteEndLoc,
	            endLoc: templateElementEndLoc
	          }), endToken);
	          i += 2;
	          continue;
	        }
	      }
	      token.type = getExportedToken(type);
	    }
	  }
	  return tokens;
	}
	class StatementParser extends ExpressionParser {
	  parseTopLevel(file, program) {
	    file.program = this.parseProgram(program);
	    file.comments = this.comments;
	    if (this.optionFlags & 256) {
	      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
	    }
	    return this.finishNode(file, "File");
	  }
	  parseProgram(program, end = 140, sourceType = this.options.sourceType) {
	    program.sourceType = sourceType;
	    program.interpreter = this.parseInterpreterDirective();
	    this.parseBlockBody(program, true, true, end);
	    if (this.inModule) {
	      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
	        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
	          this.raise(Errors.ModuleExportUndefined, at, {
	            localName
	          });
	        }
	      }
	      this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
	    }
	    let finishedProgram;
	    if (end === 140) {
	      finishedProgram = this.finishNode(program, "Program");
	    } else {
	      finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
	    }
	    return finishedProgram;
	  }
	  stmtToDirective(stmt) {
	    const directive = this.castNodeTo(stmt, "Directive");
	    const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
	    const expressionValue = directiveLiteral.value;
	    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
	    const val = directiveLiteral.value = raw.slice(1, -1);
	    this.addExtra(directiveLiteral, "raw", raw);
	    this.addExtra(directiveLiteral, "rawValue", val);
	    this.addExtra(directiveLiteral, "expressionValue", expressionValue);
	    directive.value = directiveLiteral;
	    delete stmt.expression;
	    return directive;
	  }
	  parseInterpreterDirective() {
	    if (!this.match(28)) {
	      return null;
	    }
	    const node = this.startNode();
	    node.value = this.state.value;
	    this.next();
	    return this.finishNode(node, "InterpreterDirective");
	  }
	  isLet() {
	    if (!this.isContextual(100)) {
	      return false;
	    }
	    return this.hasFollowingBindingAtom();
	  }
	  chStartsBindingIdentifier(ch, pos) {
	    if (isIdentifierStart(ch)) {
	      keywordRelationalOperator.lastIndex = pos;
	      if (keywordRelationalOperator.test(this.input)) {
	        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
	        if (!isIdentifierChar(endCh) && endCh !== 92) {
	          return false;
	        }
	      }
	      return true;
	    } else if (ch === 92) {
	      return true;
	    } else {
	      return false;
	    }
	  }
	  chStartsBindingPattern(ch) {
	    return ch === 91 || ch === 123;
	  }
	  hasFollowingBindingAtom() {
	    const next = this.nextTokenStart();
	    const nextCh = this.codePointAtPos(next);
	    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
	  }
	  hasInLineFollowingBindingIdentifierOrBrace() {
	    const next = this.nextTokenInLineStart();
	    const nextCh = this.codePointAtPos(next);
	    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
	  }
	  allowsForUsing() {
	    const {
	      type,
	      containsEsc,
	      end
	    } = this.lookahead();
	    if (type === 102 && !containsEsc) {
	      const nextCharAfterOf = this.lookaheadCharCodeSince(end);
	      if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
	        return false;
	      }
	    }
	    if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
	      this.expectPlugin("explicitResourceManagement");
	      return true;
	    }
	    return false;
	  }
	  startsAwaitUsing() {
	    let next = this.nextTokenInLineStart();
	    if (this.isUnparsedContextual(next, "using")) {
	      next = this.nextTokenInLineStartSince(next + 5);
	      const nextCh = this.codePointAtPos(next);
	      if (this.chStartsBindingIdentifier(nextCh, next)) {
	        this.expectPlugin("explicitResourceManagement");
	        return true;
	      }
	    }
	    return false;
	  }
	  parseModuleItem() {
	    return this.parseStatementLike(1 | 2 | 4 | 8);
	  }
	  parseStatementListItem() {
	    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
	  }
	  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
	    let flags = 0;
	    if (this.options.annexB && !this.state.strict) {
	      flags |= 4;
	      if (allowLabeledFunction) {
	        flags |= 8;
	      }
	    }
	    return this.parseStatementLike(flags);
	  }
	  parseStatement() {
	    return this.parseStatementLike(0);
	  }
	  parseStatementLike(flags) {
	    let decorators = null;
	    if (this.match(26)) {
	      decorators = this.parseDecorators(true);
	    }
	    return this.parseStatementContent(flags, decorators);
	  }
	  parseStatementContent(flags, decorators) {
	    const startType = this.state.type;
	    const node = this.startNode();
	    const allowDeclaration = !!(flags & 2);
	    const allowFunctionDeclaration = !!(flags & 4);
	    const topLevel = flags & 1;
	    switch (startType) {
	      case 60:
	        return this.parseBreakContinueStatement(node, true);
	      case 63:
	        return this.parseBreakContinueStatement(node, false);
	      case 64:
	        return this.parseDebuggerStatement(node);
	      case 90:
	        return this.parseDoWhileStatement(node);
	      case 91:
	        return this.parseForStatement(node);
	      case 68:
	        if (this.lookaheadCharCode() === 46) break;
	        if (!allowFunctionDeclaration) {
	          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
	        }
	        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
	      case 80:
	        if (!allowDeclaration) this.unexpected();
	        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
	      case 69:
	        return this.parseIfStatement(node);
	      case 70:
	        return this.parseReturnStatement(node);
	      case 71:
	        return this.parseSwitchStatement(node);
	      case 72:
	        return this.parseThrowStatement(node);
	      case 73:
	        return this.parseTryStatement(node);
	      case 96:
	        if (!this.state.containsEsc && this.startsAwaitUsing()) {
	          if (!this.recordAwaitIfAllowed()) {
	            this.raise(Errors.AwaitUsingNotInAsyncContext, node);
	          } else if (!allowDeclaration) {
	            this.raise(Errors.UnexpectedLexicalDeclaration, node);
	          }
	          this.next();
	          return this.parseVarStatement(node, "await using");
	        }
	        break;
	      case 107:
	        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
	          break;
	        }
	        this.expectPlugin("explicitResourceManagement");
	        if (!this.scope.inModule && this.scope.inTopLevel) {
	          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
	        } else if (!allowDeclaration) {
	          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
	        }
	        return this.parseVarStatement(node, "using");
	      case 100: {
	        if (this.state.containsEsc) {
	          break;
	        }
	        const next = this.nextTokenStart();
	        const nextCh = this.codePointAtPos(next);
	        if (nextCh !== 91) {
	          if (!allowDeclaration && this.hasFollowingLineBreak()) break;
	          if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
	            break;
	          }
	        }
	      }
	      case 75: {
	        if (!allowDeclaration) {
	          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
	        }
	      }
	      case 74: {
	        const kind = this.state.value;
	        return this.parseVarStatement(node, kind);
	      }
	      case 92:
	        return this.parseWhileStatement(node);
	      case 76:
	        return this.parseWithStatement(node);
	      case 5:
	        return this.parseBlock();
	      case 13:
	        return this.parseEmptyStatement(node);
	      case 83: {
	        const nextTokenCharCode = this.lookaheadCharCode();
	        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
	          break;
	        }
	      }
	      case 82: {
	        if (!(this.optionFlags & 8) && !topLevel) {
	          this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
	        }
	        this.next();
	        let result;
	        if (startType === 83) {
	          result = this.parseImport(node);
	        } else {
	          result = this.parseExport(node, decorators);
	        }
	        this.assertModuleNodeAllowed(result);
	        return result;
	      }
	      default: {
	        if (this.isAsyncFunction()) {
	          if (!allowDeclaration) {
	            this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
	          }
	          this.next();
	          return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
	        }
	      }
	    }
	    const maybeName = this.state.value;
	    const expr = this.parseExpression();
	    if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
	      return this.parseLabeledStatement(node, maybeName, expr, flags);
	    } else {
	      return this.parseExpressionStatement(node, expr, decorators);
	    }
	  }
	  assertModuleNodeAllowed(node) {
	    if (!(this.optionFlags & 8) && !this.inModule) {
	      this.raise(Errors.ImportOutsideModule, node);
	    }
	  }
	  decoratorsEnabledBeforeExport() {
	    if (this.hasPlugin("decorators-legacy")) return true;
	    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
	  }
	  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
	    if (maybeDecorators) {
	      var _classNode$decorators;
	      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
	        if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
	          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
	        }
	        classNode.decorators.unshift(...maybeDecorators);
	      } else {
	        classNode.decorators = maybeDecorators;
	      }
	      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
	      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
	    }
	    return classNode;
	  }
	  canHaveLeadingDecorator() {
	    return this.match(80);
	  }
	  parseDecorators(allowExport) {
	    const decorators = [];
	    do {
	      decorators.push(this.parseDecorator());
	    } while (this.match(26));
	    if (this.match(82)) {
	      if (!allowExport) {
	        this.unexpected();
	      }
	      if (!this.decoratorsEnabledBeforeExport()) {
	        this.raise(Errors.DecoratorExportClass, this.state.startLoc);
	      }
	    } else if (!this.canHaveLeadingDecorator()) {
	      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
	    }
	    return decorators;
	  }
	  parseDecorator() {
	    this.expectOnePlugin(["decorators", "decorators-legacy"]);
	    const node = this.startNode();
	    this.next();
	    if (this.hasPlugin("decorators")) {
	      const startLoc = this.state.startLoc;
	      let expr;
	      if (this.match(10)) {
	        const startLoc2 = this.state.startLoc;
	        this.next();
	        expr = this.parseExpression();
	        this.expect(11);
	        expr = this.wrapParenthesis(startLoc2, expr);
	        const paramsStartLoc = this.state.startLoc;
	        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
	        if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
	          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
	        }
	      } else {
	        expr = this.parseIdentifier(false);
	        while (this.eat(16)) {
	          const node2 = this.startNodeAt(startLoc);
	          node2.object = expr;
	          if (this.match(139)) {
	            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
	            node2.property = this.parsePrivateName();
	          } else {
	            node2.property = this.parseIdentifier(true);
	          }
	          node2.computed = false;
	          expr = this.finishNode(node2, "MemberExpression");
	        }
	        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
	      }
	    } else {
	      node.expression = this.parseExprSubscripts();
	    }
	    return this.finishNode(node, "Decorator");
	  }
	  parseMaybeDecoratorArguments(expr, startLoc) {
	    if (this.eat(10)) {
	      const node = this.startNodeAt(startLoc);
	      node.callee = expr;
	      node.arguments = this.parseCallExpressionArguments(11);
	      this.toReferencedList(node.arguments);
	      return this.finishNode(node, "CallExpression");
	    }
	    return expr;
	  }
	  parseBreakContinueStatement(node, isBreak) {
	    this.next();
	    if (this.isLineTerminator()) {
	      node.label = null;
	    } else {
	      node.label = this.parseIdentifier();
	      this.semicolon();
	    }
	    this.verifyBreakContinue(node, isBreak);
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	  }
	  verifyBreakContinue(node, isBreak) {
	    let i;
	    for (i = 0; i < this.state.labels.length; ++i) {
	      const lab = this.state.labels[i];
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === 1)) {
	          break;
	        }
	        if (node.label && isBreak) break;
	      }
	    }
	    if (i === this.state.labels.length) {
	      const type = isBreak ? "BreakStatement" : "ContinueStatement";
	      this.raise(Errors.IllegalBreakContinue, node, {
	        type
	      });
	    }
	  }
	  parseDebuggerStatement(node) {
	    this.next();
	    this.semicolon();
	    return this.finishNode(node, "DebuggerStatement");
	  }
	  parseHeaderExpression() {
	    this.expect(10);
	    const val = this.parseExpression();
	    this.expect(11);
	    return val;
	  }
	  parseDoWhileStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.state.labels.pop();
	    this.expect(92);
	    node.test = this.parseHeaderExpression();
	    this.eat(13);
	    return this.finishNode(node, "DoWhileStatement");
	  }
	  parseForStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    let awaitAt = null;
	    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
	      awaitAt = this.state.startLoc;
	      this.next();
	    }
	    this.scope.enter(0);
	    this.expect(10);
	    if (this.match(13)) {
	      if (awaitAt !== null) {
	        this.unexpected(awaitAt);
	      }
	      return this.parseFor(node, null);
	    }
	    const startsWithLet = this.isContextual(100);
	    {
	      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
	      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.allowsForUsing();
	      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
	      if (this.match(74) || this.match(75) || isLetOrUsing) {
	        const initNode = this.startNode();
	        let kind;
	        if (startsWithAwaitUsing) {
	          kind = "await using";
	          if (!this.recordAwaitIfAllowed()) {
	            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
	          }
	          this.next();
	        } else {
	          kind = this.state.value;
	        }
	        this.next();
	        this.parseVar(initNode, true, kind);
	        const init2 = this.finishNode(initNode, "VariableDeclaration");
	        const isForIn = this.match(58);
	        if (isForIn && starsWithUsingDeclaration) {
	          this.raise(Errors.ForInUsing, init2);
	        }
	        if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
	          return this.parseForIn(node, init2, awaitAt);
	        }
	        if (awaitAt !== null) {
	          this.unexpected(awaitAt);
	        }
	        return this.parseFor(node, init2);
	      }
	    }
	    const startsWithAsync = this.isContextual(95);
	    const refExpressionErrors = new ExpressionErrors();
	    const init = this.parseExpression(true, refExpressionErrors);
	    const isForOf = this.isContextual(102);
	    if (isForOf) {
	      if (startsWithLet) {
	        this.raise(Errors.ForOfLet, init);
	      }
	      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
	        this.raise(Errors.ForOfAsync, init);
	      }
	    }
	    if (isForOf || this.match(58)) {
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.toAssignable(init, true);
	      const type = isForOf ? "ForOfStatement" : "ForInStatement";
	      this.checkLVal(init, {
	        type
	      });
	      return this.parseForIn(node, init, awaitAt);
	    } else {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }
	    if (awaitAt !== null) {
	      this.unexpected(awaitAt);
	    }
	    return this.parseFor(node, init);
	  }
	  parseFunctionStatement(node, isAsync, isHangingDeclaration) {
	    this.next();
	    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
	  }
	  parseIfStatement(node) {
	    this.next();
	    node.test = this.parseHeaderExpression();
	    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
	    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
	    return this.finishNode(node, "IfStatement");
	  }
	  parseReturnStatement(node) {
	    if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
	      this.raise(Errors.IllegalReturn, this.state.startLoc);
	    }
	    this.next();
	    if (this.isLineTerminator()) {
	      node.argument = null;
	    } else {
	      node.argument = this.parseExpression();
	      this.semicolon();
	    }
	    return this.finishNode(node, "ReturnStatement");
	  }
	  parseSwitchStatement(node) {
	    this.next();
	    node.discriminant = this.parseHeaderExpression();
	    const cases = node.cases = [];
	    this.expect(5);
	    this.state.labels.push(switchLabel);
	    this.scope.enter(0);
	    let cur;
	    for (let sawDefault; !this.match(8); ) {
	      if (this.match(61) || this.match(65)) {
	        const isCase = this.match(61);
	        if (cur) this.finishNode(cur, "SwitchCase");
	        cases.push(cur = this.startNode());
	        cur.consequent = [];
	        this.next();
	        if (isCase) {
	          cur.test = this.parseExpression();
	        } else {
	          if (sawDefault) {
	            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
	          }
	          sawDefault = true;
	          cur.test = null;
	        }
	        this.expect(14);
	      } else {
	        if (cur) {
	          cur.consequent.push(this.parseStatementListItem());
	        } else {
	          this.unexpected();
	        }
	      }
	    }
	    this.scope.exit();
	    if (cur) this.finishNode(cur, "SwitchCase");
	    this.next();
	    this.state.labels.pop();
	    return this.finishNode(node, "SwitchStatement");
	  }
	  parseThrowStatement(node) {
	    this.next();
	    if (this.hasPrecedingLineBreak()) {
	      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
	    }
	    node.argument = this.parseExpression();
	    this.semicolon();
	    return this.finishNode(node, "ThrowStatement");
	  }
	  parseCatchClauseParam() {
	    const param = this.parseBindingAtom();
	    this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
	    this.checkLVal(param, {
	      type: "CatchClause"
	    }, 9);
	    return param;
	  }
	  parseTryStatement(node) {
	    this.next();
	    node.block = this.parseBlock();
	    node.handler = null;
	    if (this.match(62)) {
	      const clause = this.startNode();
	      this.next();
	      if (this.match(10)) {
	        this.expect(10);
	        clause.param = this.parseCatchClauseParam();
	        this.expect(11);
	      } else {
	        clause.param = null;
	        this.scope.enter(0);
	      }
	      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
	      this.scope.exit();
	      node.handler = this.finishNode(clause, "CatchClause");
	    }
	    node.finalizer = this.eat(67) ? this.parseBlock() : null;
	    if (!node.handler && !node.finalizer) {
	      this.raise(Errors.NoCatchOrFinally, node);
	    }
	    return this.finishNode(node, "TryStatement");
	  }
	  parseVarStatement(node, kind, allowMissingInitializer = false) {
	    this.next();
	    this.parseVar(node, false, kind, allowMissingInitializer);
	    this.semicolon();
	    return this.finishNode(node, "VariableDeclaration");
	  }
	  parseWhileStatement(node) {
	    this.next();
	    node.test = this.parseHeaderExpression();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.state.labels.pop();
	    return this.finishNode(node, "WhileStatement");
	  }
	  parseWithStatement(node) {
	    if (this.state.strict) {
	      this.raise(Errors.StrictWith, this.state.startLoc);
	    }
	    this.next();
	    node.object = this.parseHeaderExpression();
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    return this.finishNode(node, "WithStatement");
	  }
	  parseEmptyStatement(node) {
	    this.next();
	    return this.finishNode(node, "EmptyStatement");
	  }
	  parseLabeledStatement(node, maybeName, expr, flags) {
	    for (const label of this.state.labels) {
	      if (label.name === maybeName) {
	        this.raise(Errors.LabelRedeclaration, expr, {
	          labelName: maybeName
	        });
	      }
	    }
	    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
	    for (let i = this.state.labels.length - 1; i >= 0; i--) {
	      const label = this.state.labels[i];
	      if (label.statementStart === node.start) {
	        label.statementStart = this.sourceToOffsetPos(this.state.start);
	        label.kind = kind;
	      } else {
	        break;
	      }
	    }
	    this.state.labels.push({
	      name: maybeName,
	      kind,
	      statementStart: this.sourceToOffsetPos(this.state.start)
	    });
	    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
	    this.state.labels.pop();
	    node.label = expr;
	    return this.finishNode(node, "LabeledStatement");
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    node.expression = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExpressionStatement");
	  }
	  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
	    const node = this.startNode();
	    if (allowDirectives) {
	      this.state.strictErrors.clear();
	    }
	    this.expect(5);
	    if (createNewLexicalScope) {
	      this.scope.enter(0);
	    }
	    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
	    if (createNewLexicalScope) {
	      this.scope.exit();
	    }
	    return this.finishNode(node, "BlockStatement");
	  }
	  isValidDirective(stmt) {
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
	  }
	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
	    const body = node.body = [];
	    const directives = node.directives = [];
	    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
	  }
	  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
	    const oldStrict = this.state.strict;
	    let hasStrictModeDirective = false;
	    let parsedNonDirective = false;
	    while (!this.match(end)) {
	      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
	      if (directives && !parsedNonDirective) {
	        if (this.isValidDirective(stmt)) {
	          const directive = this.stmtToDirective(stmt);
	          directives.push(directive);
	          if (!hasStrictModeDirective && directive.value.value === "use strict") {
	            hasStrictModeDirective = true;
	            this.setStrict(true);
	          }
	          continue;
	        }
	        parsedNonDirective = true;
	        this.state.strictErrors.clear();
	      }
	      body.push(stmt);
	    }
	    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
	    if (!oldStrict) {
	      this.setStrict(false);
	    }
	    this.next();
	  }
	  parseFor(node, init) {
	    node.init = init;
	    this.semicolon(false);
	    node.test = this.match(13) ? null : this.parseExpression();
	    this.semicolon(false);
	    node.update = this.match(11) ? null : this.parseExpression();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, "ForStatement");
	  }
	  parseForIn(node, init, awaitAt) {
	    const isForIn = this.match(58);
	    this.next();
	    if (isForIn) {
	      if (awaitAt !== null) this.unexpected(awaitAt);
	    } else {
	      node.await = awaitAt !== null;
	    }
	    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
	      this.raise(Errors.ForInOfLoopInitializer, init, {
	        type: isForIn ? "ForInStatement" : "ForOfStatement"
	      });
	    }
	    if (init.type === "AssignmentPattern") {
	      this.raise(Errors.InvalidLhs, init, {
	        ancestor: {
	          type: "ForStatement"
	        }
	      });
	    }
	    node.left = init;
	    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
	  }
	  parseVar(node, isFor, kind, allowMissingInitializer = false) {
	    const declarations = node.declarations = [];
	    node.kind = kind;
	    for (; ; ) {
	      const decl = this.startNode();
	      this.parseVarId(decl, kind);
	      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
	      if (decl.init === null && !allowMissingInitializer) {
	        if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
	          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
	            kind: "destructuring"
	          });
	        } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
	          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
	            kind
	          });
	        }
	      }
	      declarations.push(this.finishNode(decl, "VariableDeclarator"));
	      if (!this.eat(12)) break;
	    }
	    return node;
	  }
	  parseVarId(decl, kind) {
	    const id = this.parseBindingAtom();
	    if (kind === "using" || kind === "await using") {
	      if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
	        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
	      }
	    }
	    this.checkLVal(id, {
	      type: "VariableDeclarator"
	    }, kind === "var" ? 5 : 8201);
	    decl.id = id;
	  }
	  parseAsyncFunctionExpression(node) {
	    return this.parseFunction(node, 8);
	  }
	  parseFunction(node, flags = 0) {
	    const hangingDeclaration = flags & 2;
	    const isDeclaration = !!(flags & 1);
	    const requireId = isDeclaration && !(flags & 4);
	    const isAsync = !!(flags & 8);
	    this.initFunction(node, isAsync);
	    if (this.match(55)) {
	      if (hangingDeclaration) {
	        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
	      }
	      this.next();
	      node.generator = true;
	    }
	    if (isDeclaration) {
	      node.id = this.parseFunctionId(requireId);
	    }
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.maybeInArrowParameters = false;
	    this.scope.enter(2);
	    this.prodParam.enter(functionFlags(isAsync, node.generator));
	    if (!isDeclaration) {
	      node.id = this.parseFunctionId();
	    }
	    this.parseFunctionParams(node, false);
	    this.withSmartMixTopicForbiddingContext(() => {
	      this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
	    });
	    this.prodParam.exit();
	    this.scope.exit();
	    if (isDeclaration && !hangingDeclaration) {
	      this.registerFunctionStatementId(node);
	    }
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return node;
	  }
	  parseFunctionId(requireId) {
	    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
	  }
	  parseFunctionParams(node, isConstructor) {
	    this.expect(10);
	    this.expressionScope.enter(newParameterDeclarationScope());
	    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
	    this.expressionScope.exit();
	  }
	  registerFunctionStatementId(node) {
	    if (!node.id) return;
	    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
	  }
	  parseClass(node, isStatement, optionalId) {
	    this.next();
	    const oldStrict = this.state.strict;
	    this.state.strict = true;
	    this.parseClassId(node, isStatement, optionalId);
	    this.parseClassSuper(node);
	    node.body = this.parseClassBody(!!node.superClass, oldStrict);
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	  }
	  isClassProperty() {
	    return this.match(29) || this.match(13) || this.match(8);
	  }
	  isClassMethod() {
	    return this.match(10);
	  }
	  nameIsConstructor(key) {
	    return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
	  }
	  isNonstaticConstructor(method) {
	    return !method.computed && !method.static && this.nameIsConstructor(method.key);
	  }
	  parseClassBody(hadSuperClass, oldStrict) {
	    this.classScope.enter();
	    const state = {
	      hadConstructor: false,
	      hadSuperClass
	    };
	    let decorators = [];
	    const classBody = this.startNode();
	    classBody.body = [];
	    this.expect(5);
	    this.withSmartMixTopicForbiddingContext(() => {
	      while (!this.match(8)) {
	        if (this.eat(13)) {
	          if (decorators.length > 0) {
	            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
	          }
	          continue;
	        }
	        if (this.match(26)) {
	          decorators.push(this.parseDecorator());
	          continue;
	        }
	        const member = this.startNode();
	        if (decorators.length) {
	          member.decorators = decorators;
	          this.resetStartLocationFromNode(member, decorators[0]);
	          decorators = [];
	        }
	        this.parseClassMember(classBody, member, state);
	        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
	          this.raise(Errors.DecoratorConstructor, member);
	        }
	      }
	    });
	    this.state.strict = oldStrict;
	    this.next();
	    if (decorators.length) {
	      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
	    }
	    this.classScope.exit();
	    return this.finishNode(classBody, "ClassBody");
	  }
	  parseClassMemberFromModifier(classBody, member) {
	    const key = this.parseIdentifier(true);
	    if (this.isClassMethod()) {
	      const method = member;
	      method.kind = "method";
	      method.computed = false;
	      method.key = key;
	      method.static = false;
	      this.pushClassMethod(classBody, method, false, false, false, false);
	      return true;
	    } else if (this.isClassProperty()) {
	      const prop = member;
	      prop.computed = false;
	      prop.key = key;
	      prop.static = false;
	      classBody.body.push(this.parseClassProperty(prop));
	      return true;
	    }
	    this.resetPreviousNodeTrailingComments(key);
	    return false;
	  }
	  parseClassMember(classBody, member, state) {
	    const isStatic = this.isContextual(106);
	    if (isStatic) {
	      if (this.parseClassMemberFromModifier(classBody, member)) {
	        return;
	      }
	      if (this.eat(5)) {
	        this.parseClassStaticBlock(classBody, member);
	        return;
	      }
	    }
	    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  }
	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    const publicMethod = member;
	    const privateMethod = member;
	    const publicProp = member;
	    const privateProp = member;
	    const accessorProp = member;
	    const method = publicMethod;
	    const publicMember = publicMethod;
	    member.static = isStatic;
	    this.parsePropertyNamePrefixOperator(member);
	    if (this.eat(55)) {
	      method.kind = "method";
	      const isPrivateName = this.match(139);
	      this.parseClassElementName(method);
	      this.parsePostMemberNameModifiers(method);
	      if (isPrivateName) {
	        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
	        return;
	      }
	      if (this.isNonstaticConstructor(publicMethod)) {
	        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
	      }
	      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
	      return;
	    }
	    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
	    const key = this.parseClassElementName(member);
	    const maybeContextualKw = isContextual ? key.name : null;
	    const isPrivate = this.isPrivateName(key);
	    const maybeQuestionTokenStartLoc = this.state.startLoc;
	    this.parsePostMemberNameModifiers(publicMember);
	    if (this.isClassMethod()) {
	      method.kind = "method";
	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	        return;
	      }
	      const isConstructor = this.isNonstaticConstructor(publicMethod);
	      let allowsDirectSuper = false;
	      if (isConstructor) {
	        publicMethod.kind = "constructor";
	        if (state.hadConstructor && !this.hasPlugin("typescript")) {
	          this.raise(Errors.DuplicateConstructor, key);
	        }
	        if (isConstructor && this.hasPlugin("typescript") && member.override) {
	          this.raise(Errors.OverrideOnConstructor, key);
	        }
	        state.hadConstructor = true;
	        allowsDirectSuper = state.hadSuperClass;
	      }
	      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
	    } else if (this.isClassProperty()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
	      this.resetPreviousNodeTrailingComments(key);
	      const isGenerator = this.eat(55);
	      if (publicMember.optional) {
	        this.unexpected(maybeQuestionTokenStartLoc);
	      }
	      method.kind = "method";
	      const isPrivate2 = this.match(139);
	      this.parseClassElementName(method);
	      this.parsePostMemberNameModifiers(publicMember);
	      if (isPrivate2) {
	        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(Errors.ConstructorIsAsync, publicMethod.key);
	        }
	        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
	      }
	    } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
	      this.resetPreviousNodeTrailingComments(key);
	      method.kind = maybeContextualKw;
	      const isPrivate2 = this.match(139);
	      this.parseClassElementName(publicMethod);
	      if (isPrivate2) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
	        }
	        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
	      }
	      this.checkGetterSetterParams(publicMethod);
	    } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
	      this.expectPlugin("decoratorAutoAccessors");
	      this.resetPreviousNodeTrailingComments(key);
	      const isPrivate2 = this.match(139);
	      this.parseClassElementName(publicProp);
	      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
	    } else if (this.isLineTerminator()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else {
	      this.unexpected();
	    }
	  }
	  parseClassElementName(member) {
	    const {
	      type,
	      value
	    } = this.state;
	    if ((type === 132 || type === 134) && member.static && value === "prototype") {
	      this.raise(Errors.StaticPrototype, this.state.startLoc);
	    }
	    if (type === 139) {
	      if (value === "constructor") {
	        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
	      }
	      const key = this.parsePrivateName();
	      member.key = key;
	      return key;
	    }
	    this.parsePropertyName(member);
	    return member.key;
	  }
	  parseClassStaticBlock(classBody, member) {
	    var _member$decorators;
	    this.scope.enter(64 | 128 | 16);
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    this.prodParam.enter(0);
	    const body = member.body = [];
	    this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.labels = oldLabels;
	    classBody.body.push(this.finishNode(member, "StaticBlock"));
	    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
	      this.raise(Errors.DecoratorStaticBlock, member);
	    }
	  }
	  pushClassProperty(classBody, prop) {
	    if (!prop.computed && this.nameIsConstructor(prop.key)) {
	      this.raise(Errors.ConstructorClassField, prop.key);
	    }
	    classBody.body.push(this.parseClassProperty(prop));
	  }
	  pushClassPrivateProperty(classBody, prop) {
	    const node = this.parseClassPrivateProperty(prop);
	    classBody.body.push(node);
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
	  }
	  pushClassAccessorProperty(classBody, prop, isPrivate) {
	    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
	      this.raise(Errors.ConstructorClassField, prop.key);
	    }
	    const node = this.parseClassAccessorProperty(prop);
	    classBody.body.push(node);
	    if (isPrivate) {
	      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
	    }
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
	    classBody.body.push(node);
	    const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
	    this.declareClassPrivateMethodInScope(node, kind);
	  }
	  declareClassPrivateMethodInScope(node, kind) {
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
	  }
	  parsePostMemberNameModifiers(methodOrProp) {
	  }
	  parseClassPrivateProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassPrivateProperty");
	  }
	  parseClassProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassProperty");
	  }
	  parseClassAccessorProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassAccessorProperty");
	  }
	  parseInitializer(node) {
	    this.scope.enter(64 | 16);
	    this.expressionScope.enter(newExpressionScope());
	    this.prodParam.enter(0);
	    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
	    this.expressionScope.exit();
	    this.prodParam.exit();
	    this.scope.exit();
	  }
	  parseClassId(node, isStatement, optionalId, bindingType = 8331) {
	    if (tokenIsIdentifier(this.state.type)) {
	      node.id = this.parseIdentifier();
	      if (isStatement) {
	        this.declareNameFromIdentifier(node.id, bindingType);
	      }
	    } else {
	      if (optionalId || !isStatement) {
	        node.id = null;
	      } else {
	        throw this.raise(Errors.MissingClassName, this.state.startLoc);
	      }
	    }
	  }
	  parseClassSuper(node) {
	    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
	  }
	  parseExport(node, decorators) {
	    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
	    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
	    const parseAfterDefault = !hasDefault || this.eat(12);
	    const hasStar = parseAfterDefault && this.eatExportStar(node);
	    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
	    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
	    const isFromRequired = hasDefault || hasStar;
	    if (hasStar && !hasNamespace) {
	      if (hasDefault) this.unexpected();
	      if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.parseExportFrom(node, true);
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node, "ExportAllDeclaration");
	    }
	    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
	    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
	      this.unexpected(null, 5);
	    }
	    if (hasNamespace && parseAfterNamespace) {
	      this.unexpected(null, 98);
	    }
	    let hasDeclaration;
	    if (isFromRequired || hasSpecifiers) {
	      hasDeclaration = false;
	      if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.parseExportFrom(node, isFromRequired);
	    } else {
	      hasDeclaration = this.maybeParseExportDeclaration(node);
	    }
	    if (isFromRequired || hasSpecifiers || hasDeclaration) {
	      var _node2$declaration;
	      const node2 = node;
	      this.checkExport(node2, true, false, !!node2.source);
	      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
	        this.maybeTakeDecorators(decorators, node2.declaration, node2);
	      } else if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node2, "ExportNamedDeclaration");
	    }
	    if (this.eat(65)) {
	      const node2 = node;
	      const decl = this.parseExportDefaultExpression();
	      node2.declaration = decl;
	      if (decl.type === "ClassDeclaration") {
	        this.maybeTakeDecorators(decorators, decl, node2);
	      } else if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.checkExport(node2, true, true);
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node2, "ExportDefaultDeclaration");
	    }
	    this.unexpected(null, 5);
	  }
	  eatExportStar(node) {
	    return this.eat(55);
	  }
	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
	    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
	      this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
	      const id = maybeDefaultIdentifier || this.parseIdentifier(true);
	      const specifier = this.startNodeAtNode(id);
	      specifier.exported = id;
	      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamespaceSpecifier(node) {
	    if (this.isContextual(93)) {
	      var _ref, _ref$specifiers;
	      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
	      const specifier = this.startNodeAt(this.state.lastTokStartLoc);
	      this.next();
	      specifier.exported = this.parseModuleExportName();
	      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamedSpecifiers(node) {
	    if (this.match(5)) {
	      const node2 = node;
	      if (!node2.specifiers) node2.specifiers = [];
	      const isTypeExport = node2.exportKind === "type";
	      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
	      node2.source = null;
	      if (this.hasPlugin("importAssertions")) {
	        node2.assertions = [];
	      } else {
	        node2.attributes = [];
	      }
	      node2.declaration = null;
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportDeclaration(node) {
	    if (this.shouldParseExportDeclaration()) {
	      node.specifiers = [];
	      node.source = null;
	      if (this.hasPlugin("importAssertions")) {
	        node.assertions = [];
	      } else {
	        node.attributes = [];
	      }
	      node.declaration = this.parseExportDeclaration(node);
	      return true;
	    }
	    return false;
	  }
	  isAsyncFunction() {
	    if (!this.isContextual(95)) return false;
	    const next = this.nextTokenInLineStart();
	    return this.isUnparsedContextual(next, "function");
	  }
	  parseExportDefaultExpression() {
	    const expr = this.startNode();
	    if (this.match(68)) {
	      this.next();
	      return this.parseFunction(expr, 1 | 4);
	    } else if (this.isAsyncFunction()) {
	      this.next();
	      this.next();
	      return this.parseFunction(expr, 1 | 4 | 8);
	    }
	    if (this.match(80)) {
	      return this.parseClass(expr, true, true);
	    }
	    if (this.match(26)) {
	      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
	        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
	      }
	      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
	    }
	    if (this.match(75) || this.match(74) || this.isLet()) {
	      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
	    }
	    const res = this.parseMaybeAssignAllowIn();
	    this.semicolon();
	    return res;
	  }
	  parseExportDeclaration(node) {
	    if (this.match(80)) {
	      const node2 = this.parseClass(this.startNode(), true, false);
	      return node2;
	    }
	    return this.parseStatementListItem();
	  }
	  isExportDefaultSpecifier() {
	    const {
	      type
	    } = this.state;
	    if (tokenIsIdentifier(type)) {
	      if (type === 95 && !this.state.containsEsc || type === 100) {
	        return false;
	      }
	      if ((type === 130 || type === 129) && !this.state.containsEsc) {
	        const {
	          type: nextType
	        } = this.lookahead();
	        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
	          this.expectOnePlugin(["flow", "typescript"]);
	          return false;
	        }
	      }
	    } else if (!this.match(65)) {
	      return false;
	    }
	    const next = this.nextTokenStart();
	    const hasFrom = this.isUnparsedContextual(next, "from");
	    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
	      return true;
	    }
	    if (this.match(65) && hasFrom) {
	      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
	      return nextAfterFrom === 34 || nextAfterFrom === 39;
	    }
	    return false;
	  }
	  parseExportFrom(node, expect) {
	    if (this.eatContextual(98)) {
	      node.source = this.parseImportSource();
	      this.checkExport(node);
	      this.maybeParseImportAttributes(node);
	      this.checkJSONModuleImport(node);
	    } else if (expect) {
	      this.unexpected();
	    }
	    this.semicolon();
	  }
	  shouldParseExportDeclaration() {
	    const {
	      type
	    } = this.state;
	    if (type === 26) {
	      this.expectOnePlugin(["decorators", "decorators-legacy"]);
	      if (this.hasPlugin("decorators")) {
	        if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
	          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
	        }
	        return true;
	      }
	    }
	    if (this.isContextual(107)) {
	      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
	      return true;
	    }
	    if (this.isContextual(96) && this.startsAwaitUsing()) {
	      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
	      return true;
	    }
	    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
	  }
	  checkExport(node, checkNames, isDefault, isFrom) {
	    if (checkNames) {
	      var _node$specifiers;
	      if (isDefault) {
	        this.checkDuplicateExports(node, "default");
	        if (this.hasPlugin("exportDefaultFrom")) {
	          var _declaration$extra;
	          const declaration = node.declaration;
	          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
	            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
	          }
	        }
	      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
	        for (const specifier of node.specifiers) {
	          const {
	            exported
	          } = specifier;
	          const exportName = exported.type === "Identifier" ? exported.name : exported.value;
	          this.checkDuplicateExports(specifier, exportName);
	          if (!isFrom && specifier.local) {
	            const {
	              local
	            } = specifier;
	            if (local.type !== "Identifier") {
	              this.raise(Errors.ExportBindingIsString, specifier, {
	                localName: local.value,
	                exportName
	              });
	            } else {
	              this.checkReservedWord(local.name, local.loc.start, true, false);
	              this.scope.checkLocalExport(local);
	            }
	          }
	        }
	      } else if (node.declaration) {
	        const decl = node.declaration;
	        if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
	          const {
	            id
	          } = decl;
	          if (!id) throw new Error("Assertion failure");
	          this.checkDuplicateExports(node, id.name);
	        } else if (decl.type === "VariableDeclaration") {
	          for (const declaration of decl.declarations) {
	            this.checkDeclaration(declaration.id);
	          }
	        }
	      }
	    }
	  }
	  checkDeclaration(node) {
	    if (node.type === "Identifier") {
	      this.checkDuplicateExports(node, node.name);
	    } else if (node.type === "ObjectPattern") {
	      for (const prop of node.properties) {
	        this.checkDeclaration(prop);
	      }
	    } else if (node.type === "ArrayPattern") {
	      for (const elem of node.elements) {
	        if (elem) {
	          this.checkDeclaration(elem);
	        }
	      }
	    } else if (node.type === "ObjectProperty") {
	      this.checkDeclaration(node.value);
	    } else if (node.type === "RestElement") {
	      this.checkDeclaration(node.argument);
	    } else if (node.type === "AssignmentPattern") {
	      this.checkDeclaration(node.left);
	    }
	  }
	  checkDuplicateExports(node, exportName) {
	    if (this.exportedIdentifiers.has(exportName)) {
	      if (exportName === "default") {
	        this.raise(Errors.DuplicateDefaultExport, node);
	      } else {
	        this.raise(Errors.DuplicateExport, node, {
	          exportName
	        });
	      }
	    }
	    this.exportedIdentifiers.add(exportName);
	  }
	  parseExportSpecifiers(isInTypeExport) {
	    const nodes = [];
	    let first = true;
	    this.expect(5);
	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.eat(8)) break;
	      }
	      const isMaybeTypeOnly = this.isContextual(130);
	      const isString = this.match(134);
	      const node = this.startNode();
	      node.local = this.parseModuleExportName();
	      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
	    }
	    return nodes;
	  }
	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	    if (this.eatContextual(93)) {
	      node.exported = this.parseModuleExportName();
	    } else if (isString) {
	      node.exported = this.cloneStringLiteral(node.local);
	    } else if (!node.exported) {
	      node.exported = this.cloneIdentifier(node.local);
	    }
	    return this.finishNode(node, "ExportSpecifier");
	  }
	  parseModuleExportName() {
	    if (this.match(134)) {
	      const result = this.parseStringLiteral(this.state.value);
	      const surrogate = loneSurrogate.exec(result.value);
	      if (surrogate) {
	        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
	          surrogateCharCode: surrogate[0].charCodeAt(0)
	        });
	      }
	      return result;
	    }
	    return this.parseIdentifier(true);
	  }
	  isJSONModuleImport(node) {
	    if (node.assertions != null) {
	      return node.assertions.some(({
	        key,
	        value
	      }) => {
	        return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
	      });
	    }
	    return false;
	  }
	  checkImportReflection(node) {
	    const {
	      specifiers
	    } = node;
	    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
	    if (node.phase === "source") {
	      if (singleBindingType !== "ImportDefaultSpecifier") {
	        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
	      }
	    } else if (node.phase === "defer") {
	      if (singleBindingType !== "ImportNamespaceSpecifier") {
	        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
	      }
	    } else if (node.module) {
	      var _node$assertions;
	      if (singleBindingType !== "ImportDefaultSpecifier") {
	        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
	      }
	      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
	        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
	      }
	    }
	  }
	  checkJSONModuleImport(node) {
	    if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
	      const {
	        specifiers
	      } = node;
	      if (specifiers != null) {
	        const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
	          let imported;
	          if (specifier.type === "ExportSpecifier") {
	            imported = specifier.local;
	          } else if (specifier.type === "ImportSpecifier") {
	            imported = specifier.imported;
	          }
	          if (imported !== void 0) {
	            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
	          }
	        });
	        if (nonDefaultNamedSpecifier !== void 0) {
	          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
	        }
	      }
	    }
	  }
	  isPotentialImportPhase(isExport) {
	    if (isExport) return false;
	    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    if (isExport) {
	      return;
	    }
	    if (phase === "module") {
	      this.expectPlugin("importReflection", loc);
	      node.module = true;
	    } else if (this.hasPlugin("importReflection")) {
	      node.module = false;
	    }
	    if (phase === "source") {
	      this.expectPlugin("sourcePhaseImports", loc);
	      node.phase = "source";
	    } else if (phase === "defer") {
	      this.expectPlugin("deferredImportEvaluation", loc);
	      node.phase = "defer";
	    } else if (this.hasPlugin("sourcePhaseImports")) {
	      node.phase = null;
	    }
	  }
	  parseMaybeImportPhase(node, isExport) {
	    if (!this.isPotentialImportPhase(isExport)) {
	      this.applyImportPhase(node, isExport, null);
	      return null;
	    }
	    const phaseIdentifier = this.startNode();
	    const phaseIdentifierName = this.parseIdentifierName(true);
	    const {
	      type
	    } = this.state;
	    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
	    if (isImportPhase) {
	      this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
	      return null;
	    } else {
	      this.applyImportPhase(node, isExport, null);
	      return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
	    }
	  }
	  isPrecedingIdImportPhase(phase) {
	    const {
	      type
	    } = this.state;
	    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
	  }
	  parseImport(node) {
	    if (this.match(134)) {
	      return this.parseImportSourceAndAttributes(node);
	    }
	    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
	  }
	  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
	    node.specifiers = [];
	    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
	    const parseNext = !hasDefault || this.eat(12);
	    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
	    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
	    this.expectContextual(98);
	    return this.parseImportSourceAndAttributes(node);
	  }
	  parseImportSourceAndAttributes(node) {
	    var _node$specifiers2;
	    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
	    node.source = this.parseImportSource();
	    this.maybeParseImportAttributes(node);
	    this.checkImportReflection(node);
	    this.checkJSONModuleImport(node);
	    this.semicolon();
	    this.sawUnambiguousESM = true;
	    return this.finishNode(node, "ImportDeclaration");
	  }
	  parseImportSource() {
	    if (!this.match(134)) this.unexpected();
	    return this.parseExprAtom();
	  }
	  parseImportSpecifierLocal(node, specifier, type) {
	    specifier.local = this.parseIdentifier();
	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
	  }
	  finishImportSpecifier(specifier, type, bindingType = 8201) {
	    this.checkLVal(specifier.local, {
	      type
	    }, bindingType);
	    return this.finishNode(specifier, type);
	  }
	  parseImportAttributes() {
	    this.expect(5);
	    const attrs = [];
	    const attrNames = /* @__PURE__ */ new Set();
	    do {
	      if (this.match(8)) {
	        break;
	      }
	      const node = this.startNode();
	      const keyName = this.state.value;
	      if (attrNames.has(keyName)) {
	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
	          key: keyName
	        });
	      }
	      attrNames.add(keyName);
	      if (this.match(134)) {
	        node.key = this.parseStringLiteral(keyName);
	      } else {
	        node.key = this.parseIdentifier(true);
	      }
	      this.expect(14);
	      if (!this.match(134)) {
	        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
	      }
	      node.value = this.parseStringLiteral(this.state.value);
	      attrs.push(this.finishNode(node, "ImportAttribute"));
	    } while (this.eat(12));
	    this.expect(8);
	    return attrs;
	  }
	  parseModuleAttributes() {
	    const attrs = [];
	    const attributes = /* @__PURE__ */ new Set();
	    do {
	      const node = this.startNode();
	      node.key = this.parseIdentifier(true);
	      if (node.key.name !== "type") {
	        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
	      }
	      if (attributes.has(node.key.name)) {
	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
	          key: node.key.name
	        });
	      }
	      attributes.add(node.key.name);
	      this.expect(14);
	      if (!this.match(134)) {
	        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
	      }
	      node.value = this.parseStringLiteral(this.state.value);
	      attrs.push(this.finishNode(node, "ImportAttribute"));
	    } while (this.eat(12));
	    return attrs;
	  }
	  maybeParseImportAttributes(node) {
	    let attributes;
	    {
	      var useWith = false;
	    }
	    if (this.match(76)) {
	      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
	        return;
	      }
	      this.next();
	      if (this.hasPlugin("moduleAttributes")) {
	        attributes = this.parseModuleAttributes();
	        this.addExtra(node, "deprecatedWithLegacySyntax", true);
	      } else {
	        attributes = this.parseImportAttributes();
	      }
	      {
	        useWith = true;
	      }
	    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
	      if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
	        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
	      }
	      if (!this.hasPlugin("importAssertions")) {
	        this.addExtra(node, "deprecatedAssertSyntax", true);
	      }
	      this.next();
	      attributes = this.parseImportAttributes();
	    } else {
	      attributes = [];
	    }
	    if (!useWith && this.hasPlugin("importAssertions")) {
	      node.assertions = attributes;
	    } else {
	      node.attributes = attributes;
	    }
	  }
	  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
	    if (maybeDefaultIdentifier) {
	      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
	      specifier.local = maybeDefaultIdentifier;
	      node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
	      return true;
	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
	      return true;
	    }
	    return false;
	  }
	  maybeParseStarImportSpecifier(node) {
	    if (this.match(55)) {
	      const specifier = this.startNode();
	      this.next();
	      this.expectContextual(93);
	      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
	      return true;
	    }
	    return false;
	  }
	  parseNamedImportSpecifiers(node) {
	    let first = true;
	    this.expect(5);
	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        if (this.eat(14)) {
	          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
	        }
	        this.expect(12);
	        if (this.eat(8)) break;
	      }
	      const specifier = this.startNode();
	      const importedIsString = this.match(134);
	      const isMaybeTypeOnly = this.isContextual(130);
	      specifier.imported = this.parseModuleExportName();
	      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
	      node.specifiers.push(importSpecifier);
	    }
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    if (this.eatContextual(93)) {
	      specifier.local = this.parseIdentifier();
	    } else {
	      const {
	        imported
	      } = specifier;
	      if (importedIsString) {
	        throw this.raise(Errors.ImportBindingIsString, specifier, {
	          importName: imported.value
	        });
	      }
	      this.checkReservedWord(imported.name, specifier.loc.start, true, true);
	      if (!specifier.local) {
	        specifier.local = this.cloneIdentifier(imported);
	      }
	    }
	    return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
	  }
	  isThisParam(param) {
	    return param.type === "Identifier" && param.name === "this";
	  }
	}
	class Parser extends StatementParser {
	  constructor(options, input, pluginsMap) {
	    options = getOptions(options);
	    super(options, input);
	    this.options = options;
	    this.initializeScopes();
	    this.plugins = pluginsMap;
	    this.filename = options.sourceFilename;
	    this.startIndex = options.startIndex;
	    let optionFlags = 0;
	    if (options.allowAwaitOutsideFunction) {
	      optionFlags |= 1;
	    }
	    if (options.allowReturnOutsideFunction) {
	      optionFlags |= 2;
	    }
	    if (options.allowImportExportEverywhere) {
	      optionFlags |= 8;
	    }
	    if (options.allowSuperOutsideMethod) {
	      optionFlags |= 16;
	    }
	    if (options.allowUndeclaredExports) {
	      optionFlags |= 64;
	    }
	    if (options.allowNewTargetOutsideFunction) {
	      optionFlags |= 4;
	    }
	    if (options.allowYieldOutsideFunction) {
	      optionFlags |= 32;
	    }
	    if (options.ranges) {
	      optionFlags |= 128;
	    }
	    if (options.tokens) {
	      optionFlags |= 256;
	    }
	    if (options.createImportExpressions) {
	      optionFlags |= 512;
	    }
	    if (options.createParenthesizedExpressions) {
	      optionFlags |= 1024;
	    }
	    if (options.errorRecovery) {
	      optionFlags |= 2048;
	    }
	    if (options.attachComment) {
	      optionFlags |= 4096;
	    }
	    if (options.annexB) {
	      optionFlags |= 8192;
	    }
	    this.optionFlags = optionFlags;
	  }
	  getScopeHandler() {
	    return ScopeHandler;
	  }
	  parse() {
	    this.enterInitialScopes();
	    const file = this.startNode();
	    const program = this.startNode();
	    this.nextToken();
	    file.errors = null;
	    this.parseTopLevel(file, program);
	    file.errors = this.state.errors;
	    file.comments.length = this.state.commentsLen;
	    return file;
	  }
	}
	function parse(input, options) {
	  var _options;
	  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
	    options = Object.assign({}, options);
	    try {
	      options.sourceType = "module";
	      const parser = getParser(options, input);
	      const ast = parser.parse();
	      if (parser.sawUnambiguousESM) {
	        return ast;
	      }
	      if (parser.ambiguousScriptDifferentAst) {
	        try {
	          options.sourceType = "script";
	          return getParser(options, input).parse();
	        } catch (_unused) {
	        }
	      } else {
	        ast.program.sourceType = "script";
	      }
	      return ast;
	    } catch (moduleError) {
	      try {
	        options.sourceType = "script";
	        return getParser(options, input).parse();
	      } catch (_unused2) {
	      }
	      throw moduleError;
	    }
	  } else {
	    return getParser(options, input).parse();
	  }
	}
	function parseExpression(input, options) {
	  const parser = getParser(options, input);
	  if (parser.options.strictMode) {
	    parser.state.strict = true;
	  }
	  return parser.getExpression();
	}
	function generateExportedTokenTypes(internalTokenTypes) {
	  const tokenTypes2 = {};
	  for (const typeName of Object.keys(internalTokenTypes)) {
	    tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
	  }
	  return tokenTypes2;
	}
	const tokTypes = generateExportedTokenTypes(tt);
	function getParser(options, input) {
	  let cls = Parser;
	  const pluginsMap = /* @__PURE__ */ new Map();
	  if (options != null && options.plugins) {
	    for (const plugin of options.plugins) {
	      let name, opts;
	      if (typeof plugin === "string") {
	        name = plugin;
	      } else {
	        [name, opts] = plugin;
	      }
	      if (!pluginsMap.has(name)) {
	        pluginsMap.set(name, opts || {});
	      }
	    }
	    validatePlugins(pluginsMap);
	    cls = getParserClass(pluginsMap);
	  }
	  return new cls(options, input, pluginsMap);
	}
	const parserClassCache = /* @__PURE__ */ new Map();
	function getParserClass(pluginsMap) {
	  const pluginList = [];
	  for (const name of mixinPluginNames) {
	    if (pluginsMap.has(name)) {
	      pluginList.push(name);
	    }
	  }
	  const key = pluginList.join("|");
	  let cls = parserClassCache.get(key);
	  if (!cls) {
	    cls = Parser;
	    for (const plugin of pluginList) {
	      cls = mixinPlugins[plugin](cls);
	    }
	    parserClassCache.set(key, cls);
	  }
	  return cls;
	}
	lib$17.parse = parse;
	lib$17.parseExpression = parseExpression;
	lib$17.tokTypes = tokTypes;
	return lib$17;
}

var lib$16 = {};

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
	let formatter = (open, close, replace = open) => (input) => {
	  let string = "" + input, index = string.indexOf(close, open.length);
	  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	};
	let replaceClose = (string, close, replace, index) => {
	  let result = "", cursor = 0;
	  do {
	    result += string.substring(cursor, index) + replace;
	    cursor = index + close.length;
	    index = string.indexOf(close, cursor);
	  } while (~index);
	  return result + string.substring(cursor);
	};
	let createColors = (enabled = isColorSupported) => {
	  let f = enabled ? formatter : () => String;
	  return {
	    isColorSupported: enabled,
	    reset: f("\x1B[0m", "\x1B[0m"),
	    bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
	    dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
	    italic: f("\x1B[3m", "\x1B[23m"),
	    underline: f("\x1B[4m", "\x1B[24m"),
	    inverse: f("\x1B[7m", "\x1B[27m"),
	    hidden: f("\x1B[8m", "\x1B[28m"),
	    strikethrough: f("\x1B[9m", "\x1B[29m"),
	    black: f("\x1B[30m", "\x1B[39m"),
	    red: f("\x1B[31m", "\x1B[39m"),
	    green: f("\x1B[32m", "\x1B[39m"),
	    yellow: f("\x1B[33m", "\x1B[39m"),
	    blue: f("\x1B[34m", "\x1B[39m"),
	    magenta: f("\x1B[35m", "\x1B[39m"),
	    cyan: f("\x1B[36m", "\x1B[39m"),
	    white: f("\x1B[37m", "\x1B[39m"),
	    gray: f("\x1B[90m", "\x1B[39m"),
	    bgBlack: f("\x1B[40m", "\x1B[49m"),
	    bgRed: f("\x1B[41m", "\x1B[49m"),
	    bgGreen: f("\x1B[42m", "\x1B[49m"),
	    bgYellow: f("\x1B[43m", "\x1B[49m"),
	    bgBlue: f("\x1B[44m", "\x1B[49m"),
	    bgMagenta: f("\x1B[45m", "\x1B[49m"),
	    bgCyan: f("\x1B[46m", "\x1B[49m"),
	    bgWhite: f("\x1B[47m", "\x1B[49m"),
	    blackBright: f("\x1B[90m", "\x1B[39m"),
	    redBright: f("\x1B[91m", "\x1B[39m"),
	    greenBright: f("\x1B[92m", "\x1B[39m"),
	    yellowBright: f("\x1B[93m", "\x1B[39m"),
	    blueBright: f("\x1B[94m", "\x1B[39m"),
	    magentaBright: f("\x1B[95m", "\x1B[39m"),
	    cyanBright: f("\x1B[96m", "\x1B[39m"),
	    whiteBright: f("\x1B[97m", "\x1B[39m"),
	    bgBlackBright: f("\x1B[100m", "\x1B[49m"),
	    bgRedBright: f("\x1B[101m", "\x1B[49m"),
	    bgGreenBright: f("\x1B[102m", "\x1B[49m"),
	    bgYellowBright: f("\x1B[103m", "\x1B[49m"),
	    bgBlueBright: f("\x1B[104m", "\x1B[49m"),
	    bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
	    bgCyanBright: f("\x1B[106m", "\x1B[49m"),
	    bgWhiteBright: f("\x1B[107m", "\x1B[49m")
	  };
	};
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var jsTokens = {};

var hasRequiredJsTokens;

function requireJsTokens () {
	if (hasRequiredJsTokens) return jsTokens;
	hasRequiredJsTokens = 1;
	Object.defineProperty(jsTokens, "__esModule", {
	  value: true
	});
	jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
	jsTokens.matchToToken = function(match) {
	  var token = { type: "invalid", value: match[0], closed: void 0 };
	  if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
	  else if (match[5]) token.type = "comment";
	  else if (match[6]) token.type = "comment", token.closed = !!match[7];
	  else if (match[8]) token.type = "regex";
	  else if (match[9]) token.type = "number";
	  else if (match[10]) token.type = "name";
	  else if (match[11]) token.type = "punctuator";
	  else if (match[12]) token.type = "whitespace";
	  return token;
	};
	return jsTokens;
}

var lib$15 = {};

var identifier = {};

var hasRequiredIdentifier;

function requireIdentifier () {
	if (hasRequiredIdentifier) return identifier;
	hasRequiredIdentifier = 1;
	Object.defineProperty(identifier, "__esModule", {
	  value: true
	});
	identifier.isIdentifierChar = isIdentifierChar;
	identifier.isIdentifierName = isIdentifierName;
	identifier.isIdentifierStart = isIdentifierStart;
	let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
	let nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
	function isInAstralSet(code, set) {
	  let pos = 65536;
	  for (let i = 0, length = set.length; i < length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	  return false;
	}
	function isIdentifierStart(code) {
	  if (code < 65) return code === 36;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 65535) {
	    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 65535) {
	    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	function isIdentifierName(name) {
	  let isFirst = true;
	  for (let i = 0; i < name.length; i++) {
	    let cp = name.charCodeAt(i);
	    if ((cp & 64512) === 55296 && i + 1 < name.length) {
	      const trail = name.charCodeAt(++i);
	      if ((trail & 64512) === 56320) {
	        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
	      }
	    }
	    if (isFirst) {
	      isFirst = false;
	      if (!isIdentifierStart(cp)) {
	        return false;
	      }
	    } else if (!isIdentifierChar(cp)) {
	      return false;
	    }
	  }
	  return !isFirst;
	}
	return identifier;
}

var keyword = {};

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", {
	  value: true
	});
	keyword.isKeyword = isKeyword;
	keyword.isReservedWord = isReservedWord;
	keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
	keyword.isStrictBindReservedWord = isStrictBindReservedWord;
	keyword.isStrictReservedWord = isStrictReservedWord;
	const reservedWords = {
	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
	  strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
	  return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
	  return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
	  return keywords.has(word);
	}
	return keyword;
}

var hasRequiredLib$1b;

function requireLib$1b () {
	if (hasRequiredLib$1b) return lib$15;
	hasRequiredLib$1b = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "isIdentifierChar", {
		  enumerable: true,
		  get: function() {
		    return _identifier.isIdentifierChar;
		  }
		});
		Object.defineProperty(exports, "isIdentifierName", {
		  enumerable: true,
		  get: function() {
		    return _identifier.isIdentifierName;
		  }
		});
		Object.defineProperty(exports, "isIdentifierStart", {
		  enumerable: true,
		  get: function() {
		    return _identifier.isIdentifierStart;
		  }
		});
		Object.defineProperty(exports, "isKeyword", {
		  enumerable: true,
		  get: function() {
		    return _keyword.isKeyword;
		  }
		});
		Object.defineProperty(exports, "isReservedWord", {
		  enumerable: true,
		  get: function() {
		    return _keyword.isReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
		  enumerable: true,
		  get: function() {
		    return _keyword.isStrictBindOnlyReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictBindReservedWord", {
		  enumerable: true,
		  get: function() {
		    return _keyword.isStrictBindReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictReservedWord", {
		  enumerable: true,
		  get: function() {
		    return _keyword.isStrictReservedWord;
		  }
		});
		var _identifier = requireIdentifier();
		var _keyword = requireKeyword(); 
	} (lib$15));
	return lib$15;
}

var hasRequiredLib$1a;

function requireLib$1a () {
	if (hasRequiredLib$1a) return lib$16;
	hasRequiredLib$1a = 1;
	Object.defineProperty(lib$16, "__esModule", { value: true });
	var picocolors = /*@__PURE__*/ requirePicocolors();
	var jsTokens = requireJsTokens();
	var helperValidatorIdentifier = requireLib$1b();
	function isColorSupported() {
	  return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
	}
	const compose = (f, g) => (v) => f(g(v));
	function buildDefs(colors) {
	  return {
	    keyword: colors.cyan,
	    capitalized: colors.yellow,
	    jsxIdentifier: colors.yellow,
	    punctuator: colors.yellow,
	    number: colors.magenta,
	    string: colors.green,
	    regex: colors.magenta,
	    comment: colors.gray,
	    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
	    gutter: colors.gray,
	    marker: compose(colors.red, colors.bold),
	    message: compose(colors.red, colors.bold),
	    reset: colors.reset
	  };
	}
	const defsOn = buildDefs(picocolors.createColors(true));
	const defsOff = buildDefs(picocolors.createColors(false));
	function getDefs(enabled) {
	  return enabled ? defsOn : defsOff;
	}
	const sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
	const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
	const BRACKET = /^[()[\]{}]$/;
	let tokenize;
	{
	  const JSX_TAG = /^[a-z][\w-]*$/i;
	  const getTokenType = function(token, offset, text) {
	    if (token.type === "name") {
	      if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
	        return "keyword";
	      }
	      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
	        return "jsxIdentifier";
	      }
	      if (token.value[0] !== token.value[0].toLowerCase()) {
	        return "capitalized";
	      }
	    }
	    if (token.type === "punctuator" && BRACKET.test(token.value)) {
	      return "bracket";
	    }
	    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
	      return "punctuator";
	    }
	    return token.type;
	  };
	  tokenize = function* (text) {
	    let match;
	    while (match = jsTokens.default.exec(text)) {
	      const token = jsTokens.matchToToken(match);
	      yield {
	        type: getTokenType(token, match.index, text),
	        value: token.value
	      };
	    }
	  };
	}
	function highlight(text) {
	  if (text === "") return "";
	  const defs = getDefs(true);
	  let highlighted = "";
	  for (const {
	    type,
	    value
	  } of tokenize(text)) {
	    if (type in defs) {
	      highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
	    } else {
	      highlighted += value;
	    }
	  }
	  return highlighted;
	}
	let deprecationWarningShown = false;
	const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
	function getMarkerLines(loc, source, opts) {
	  const startLoc = Object.assign({
	    column: 0,
	    line: -1
	  }, loc.start);
	  const endLoc = Object.assign({}, startLoc, loc.end);
	  const {
	    linesAbove = 2,
	    linesBelow = 3
	  } = opts || {};
	  const startLine = startLoc.line;
	  const startColumn = startLoc.column;
	  const endLine = endLoc.line;
	  const endColumn = endLoc.column;
	  let start = Math.max(startLine - (linesAbove + 1), 0);
	  let end = Math.min(source.length, endLine + linesBelow);
	  if (startLine === -1) {
	    start = 0;
	  }
	  if (endLine === -1) {
	    end = source.length;
	  }
	  const lineDiff = endLine - startLine;
	  const markerLines = {};
	  if (lineDiff) {
	    for (let i = 0; i <= lineDiff; i++) {
	      const lineNumber = i + startLine;
	      if (!startColumn) {
	        markerLines[lineNumber] = true;
	      } else if (i === 0) {
	        const sourceLength = source[lineNumber - 1].length;
	        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
	      } else if (i === lineDiff) {
	        markerLines[lineNumber] = [0, endColumn];
	      } else {
	        const sourceLength = source[lineNumber - i].length;
	        markerLines[lineNumber] = [0, sourceLength];
	      }
	    }
	  } else {
	    if (startColumn === endColumn) {
	      if (startColumn) {
	        markerLines[startLine] = [startColumn, 0];
	      } else {
	        markerLines[startLine] = true;
	      }
	    } else {
	      markerLines[startLine] = [startColumn, endColumn - startColumn];
	    }
	  }
	  return {
	    start,
	    end,
	    markerLines
	  };
	}
	function codeFrameColumns(rawLines, loc, opts = {}) {
	  const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
	  const defs = getDefs(shouldHighlight);
	  const lines = rawLines.split(NEWLINE);
	  const {
	    start,
	    end,
	    markerLines
	  } = getMarkerLines(loc, lines, opts);
	  const hasColumns = loc.start && typeof loc.start.column === "number";
	  const numberMaxWidth = String(end).length;
	  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
	  let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index2) => {
	    const number = start + 1 + index2;
	    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
	    const gutter = ` ${paddedNumber} |`;
	    const hasMarker = markerLines[number];
	    const lastMarkerLine = !markerLines[number + 1];
	    if (hasMarker) {
	      let markerLine = "";
	      if (Array.isArray(hasMarker)) {
	        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
	        const numberOfMarkers = hasMarker[1] || 1;
	        markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
	        if (lastMarkerLine && opts.message) {
	          markerLine += " " + defs.message(opts.message);
	        }
	      }
	      return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
	    } else {
	      return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
	    }
	  }).join("\n");
	  if (opts.message && !hasColumns) {
	    frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
	  }
	  if (shouldHighlight) {
	    return defs.reset(frame);
	  } else {
	    return frame;
	  }
	}
	function index(rawLines, lineNumber, colNumber, opts = {}) {
	  if (!deprecationWarningShown) {
	    deprecationWarningShown = true;
	    const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
	    if (process.emitWarning) {
	      process.emitWarning(message, "DeprecationWarning");
	    } else {
	      const deprecationError = new Error(message);
	      deprecationError.name = "DeprecationWarning";
	      console.warn(new Error(message));
	    }
	  }
	  colNumber = Math.max(colNumber, 0);
	  const location = {
	    start: {
	      column: colNumber,
	      line: lineNumber
	    }
	  };
	  return codeFrameColumns(rawLines, location, opts);
	}
	lib$16.codeFrameColumns = codeFrameColumns;
	lib$16.default = index;
	lib$16.highlight = highlight;
	return lib$16;
}

var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;
	Object.defineProperty(parse, "__esModule", {
	  value: true
	});
	parse.default = parseAndBuildMetadata;
	var _t = require$$0$a;
	var _parser = requireLib$1c();
	var _codeFrame = requireLib$1a();
	const {
	  isCallExpression,
	  isExpressionStatement,
	  isFunction,
	  isIdentifier,
	  isJSXIdentifier,
	  isNewExpression,
	  isPlaceholder,
	  isStatement,
	  isStringLiteral,
	  removePropertiesDeep,
	  traverse
	} = _t;
	const PATTERN = /^[_$A-Z0-9]+$/;
	function parseAndBuildMetadata(formatter, code, opts) {
	  const {
	    placeholderWhitelist,
	    placeholderPattern,
	    preserveComments,
	    syntacticPlaceholders
	  } = opts;
	  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
	  removePropertiesDeep(ast, {
	    preserveComments
	  });
	  formatter.validate(ast);
	  const state = {
	    syntactic: {
	      placeholders: [],
	      placeholderNames: /* @__PURE__ */ new Set()
	    },
	    legacy: {
	      placeholders: [],
	      placeholderNames: /* @__PURE__ */ new Set()
	    },
	    placeholderWhitelist,
	    placeholderPattern,
	    syntacticPlaceholders
	  };
	  traverse(ast, placeholderVisitorHandler, state);
	  return Object.assign({
	    ast
	  }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
	}
	function placeholderVisitorHandler(node, ancestors, state) {
	  var _state$placeholderWhi;
	  let name;
	  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
	  if (isPlaceholder(node)) {
	    if (state.syntacticPlaceholders === false) {
	      throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
	    }
	    name = node.name.name;
	    hasSyntacticPlaceholders = true;
	  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
	    return;
	  } else if (isIdentifier(node) || isJSXIdentifier(node)) {
	    name = node.name;
	  } else if (isStringLiteral(node)) {
	    name = node.value;
	  } else {
	    return;
	  }
	  if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
	    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
	  }
	  if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
	    return;
	  }
	  ancestors = ancestors.slice();
	  const {
	    node: parent,
	    key
	  } = ancestors[ancestors.length - 1];
	  let type;
	  if (isStringLiteral(node) || isPlaceholder(node, {
	    expectedNode: "StringLiteral"
	  })) {
	    type = "string";
	  } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
	    type = "param";
	  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
	    type = "statement";
	    ancestors = ancestors.slice(0, -1);
	  } else if (isStatement(node) && isPlaceholder(node)) {
	    type = "statement";
	  } else {
	    type = "other";
	  }
	  const {
	    placeholders,
	    placeholderNames
	  } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
	  placeholders.push({
	    name,
	    type,
	    resolve: (ast) => resolveAncestors(ast, ancestors),
	    isDuplicate: placeholderNames.has(name)
	  });
	  placeholderNames.add(name);
	}
	function resolveAncestors(ast, ancestors) {
	  let parent = ast;
	  for (let i = 0; i < ancestors.length - 1; i++) {
	    const {
	      key: key2,
	      index: index2
	    } = ancestors[i];
	    if (index2 === void 0) {
	      parent = parent[key2];
	    } else {
	      parent = parent[key2][index2];
	    }
	  }
	  const {
	    key,
	    index
	  } = ancestors[ancestors.length - 1];
	  return {
	    parent,
	    key,
	    index
	  };
	}
	function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
	  const plugins = (parserOpts.plugins || []).slice();
	  if (syntacticPlaceholders !== false) {
	    plugins.push("placeholders");
	  }
	  parserOpts = Object.assign({
	    allowAwaitOutsideFunction: true,
	    allowReturnOutsideFunction: true,
	    allowNewTargetOutsideFunction: true,
	    allowSuperOutsideMethod: true,
	    allowYieldOutsideFunction: true,
	    sourceType: "module"
	  }, parserOpts, {
	    plugins
	  });
	  try {
	    return (0, _parser.parse)(code, parserOpts);
	  } catch (err) {
	    const loc = err.loc;
	    if (loc) {
	      err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
	        start: loc
	      });
	      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
	    }
	    throw err;
	  }
	}
	return parse;
}

var populate = {};

var hasRequiredPopulate;

function requirePopulate () {
	if (hasRequiredPopulate) return populate;
	hasRequiredPopulate = 1;
	Object.defineProperty(populate, "__esModule", {
	  value: true
	});
	populate.default = populatePlaceholders;
	var _t = require$$0$a;
	const {
	  blockStatement,
	  cloneNode,
	  emptyStatement,
	  expressionStatement,
	  identifier,
	  isStatement,
	  isStringLiteral,
	  stringLiteral,
	  validate
	} = _t;
	function populatePlaceholders(metadata, replacements) {
	  const ast = cloneNode(metadata.ast);
	  if (replacements) {
	    metadata.placeholders.forEach((placeholder) => {
	      if (!hasOwnProperty.call(replacements, placeholder.name)) {
	        const placeholderName = placeholder.name;
	        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
	      }
	    });
	    Object.keys(replacements).forEach((key) => {
	      if (!metadata.placeholderNames.has(key)) {
	        throw new Error(`Unknown substitution "${key}" given`);
	      }
	    });
	  }
	  metadata.placeholders.slice().reverse().forEach((placeholder) => {
	    try {
	      var _ref;
	      applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
	    } catch (e) {
	      e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
	      throw e;
	    }
	  });
	  return ast;
	}
	function applyReplacement(placeholder, ast, replacement) {
	  if (placeholder.isDuplicate) {
	    if (Array.isArray(replacement)) {
	      replacement = replacement.map((node) => cloneNode(node));
	    } else if (typeof replacement === "object") {
	      replacement = cloneNode(replacement);
	    }
	  }
	  const {
	    parent,
	    key,
	    index
	  } = placeholder.resolve(ast);
	  if (placeholder.type === "string") {
	    if (typeof replacement === "string") {
	      replacement = stringLiteral(replacement);
	    }
	    if (!replacement || !isStringLiteral(replacement)) {
	      throw new Error("Expected string substitution");
	    }
	  } else if (placeholder.type === "statement") {
	    if (index === void 0) {
	      if (!replacement) {
	        replacement = emptyStatement();
	      } else if (Array.isArray(replacement)) {
	        replacement = blockStatement(replacement);
	      } else if (typeof replacement === "string") {
	        replacement = expressionStatement(identifier(replacement));
	      } else if (!isStatement(replacement)) {
	        replacement = expressionStatement(replacement);
	      }
	    } else {
	      if (replacement && !Array.isArray(replacement)) {
	        if (typeof replacement === "string") {
	          replacement = identifier(replacement);
	        }
	        if (!isStatement(replacement)) {
	          replacement = expressionStatement(replacement);
	        }
	      }
	    }
	  } else if (placeholder.type === "param") {
	    if (typeof replacement === "string") {
	      replacement = identifier(replacement);
	    }
	    if (index === void 0) throw new Error("Assertion failure.");
	  } else {
	    if (typeof replacement === "string") {
	      replacement = identifier(replacement);
	    }
	    if (Array.isArray(replacement)) {
	      throw new Error("Cannot replace single expression with an array.");
	    }
	  }
	  function set(parent2, key2, value) {
	    const node = parent2[key2];
	    parent2[key2] = value;
	    if (node.type === "Identifier" || node.type === "Placeholder") {
	      if (node.typeAnnotation) {
	        value.typeAnnotation = node.typeAnnotation;
	      }
	      if (node.optional) {
	        value.optional = node.optional;
	      }
	      if (node.decorators) {
	        value.decorators = node.decorators;
	      }
	    }
	  }
	  if (index === void 0) {
	    validate(parent, key, replacement);
	    set(parent, key, replacement);
	  } else {
	    const items = parent[key].slice();
	    if (placeholder.type === "statement" || placeholder.type === "param") {
	      if (replacement == null) {
	        items.splice(index, 1);
	      } else if (Array.isArray(replacement)) {
	        items.splice(index, 1, ...replacement);
	      } else {
	        set(items, index, replacement);
	      }
	    } else {
	      set(items, index, replacement);
	    }
	    validate(parent, key, items);
	    parent[key] = items;
	  }
	}
	return populate;
}

var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;
	Object.defineProperty(string, "__esModule", {
	  value: true
	});
	string.default = stringTemplate;
	var _options = requireOptions$1();
	var _parse = requireParse();
	var _populate = requirePopulate();
	function stringTemplate(formatter, code, opts) {
	  code = formatter.code(code);
	  let metadata;
	  return (arg) => {
	    const replacements = (0, _options.normalizeReplacements)(arg);
	    if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
	    return formatter.unwrap((0, _populate.default)(metadata, replacements));
	  };
	}
	return string;
}

var literal = {};

var hasRequiredLiteral;

function requireLiteral () {
	if (hasRequiredLiteral) return literal;
	hasRequiredLiteral = 1;
	Object.defineProperty(literal, "__esModule", {
	  value: true
	});
	literal.default = literalTemplate;
	var _options = requireOptions$1();
	var _parse = requireParse();
	var _populate = requirePopulate();
	function literalTemplate(formatter, tpl, opts) {
	  const {
	    metadata,
	    names
	  } = buildLiteralData(formatter, tpl, opts);
	  return (arg) => {
	    const defaultReplacements = {};
	    arg.forEach((replacement, i) => {
	      defaultReplacements[names[i]] = replacement;
	    });
	    return (arg2) => {
	      const replacements = (0, _options.normalizeReplacements)(arg2);
	      if (replacements) {
	        Object.keys(replacements).forEach((key) => {
	          if (hasOwnProperty.call(defaultReplacements, key)) {
	            throw new Error("Unexpected replacement overlap.");
	          }
	        });
	      }
	      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
	    };
	  };
	}
	function buildLiteralData(formatter, tpl, opts) {
	  let prefix = "BABEL_TPL$";
	  const raw = tpl.join("");
	  do {
	    prefix = "$$" + prefix;
	  } while (raw.includes(prefix));
	  const {
	    names,
	    code
	  } = buildTemplateCode(tpl, prefix);
	  const metadata = (0, _parse.default)(formatter, formatter.code(code), {
	    parser: opts.parser,
	    placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
	    placeholderPattern: opts.placeholderPattern,
	    preserveComments: opts.preserveComments,
	    syntacticPlaceholders: opts.syntacticPlaceholders
	  });
	  return {
	    metadata,
	    names
	  };
	}
	function buildTemplateCode(tpl, prefix) {
	  const names = [];
	  let code = tpl[0];
	  for (let i = 1; i < tpl.length; i++) {
	    const value = `${prefix}${i - 1}`;
	    names.push(value);
	    code += value + tpl[i];
	  }
	  return {
	    names,
	    code
	  };
	}
	return literal;
}

var hasRequiredBuilder;

function requireBuilder () {
	if (hasRequiredBuilder) return builder;
	hasRequiredBuilder = 1;
	Object.defineProperty(builder, "__esModule", {
	  value: true
	});
	builder.default = createTemplateBuilder;
	var _options = requireOptions$1();
	var _string = requireString();
	var _literal = requireLiteral();
	const NO_PLACEHOLDER = (0, _options.validate)({
	  placeholderPattern: false
	});
	function createTemplateBuilder(formatter, defaultOpts) {
	  const templateFnCache = /* @__PURE__ */ new WeakMap();
	  const templateAstCache = /* @__PURE__ */ new WeakMap();
	  const cachedOpts = defaultOpts || (0, _options.validate)(null);
	  return Object.assign((tpl, ...args) => {
	    if (typeof tpl === "string") {
	      if (args.length > 1) throw new Error("Unexpected extra params.");
	      return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
	    } else if (Array.isArray(tpl)) {
	      let builder = templateFnCache.get(tpl);
	      if (!builder) {
	        builder = (0, _literal.default)(formatter, tpl, cachedOpts);
	        templateFnCache.set(tpl, builder);
	      }
	      return extendedTrace(builder(args));
	    } else if (typeof tpl === "object" && tpl) {
	      if (args.length > 0) throw new Error("Unexpected extra params.");
	      return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
	    }
	    throw new Error(`Unexpected template param ${typeof tpl}`);
	  }, {
	    ast: (tpl, ...args) => {
	      if (typeof tpl === "string") {
	        if (args.length > 1) throw new Error("Unexpected extra params.");
	        return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
	      } else if (Array.isArray(tpl)) {
	        let builder = templateAstCache.get(tpl);
	        if (!builder) {
	          builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
	          templateAstCache.set(tpl, builder);
	        }
	        return builder(args)();
	      }
	      throw new Error(`Unexpected template param ${typeof tpl}`);
	    }
	  });
	}
	function extendedTrace(fn) {
	  let rootStack = "";
	  try {
	    throw new Error();
	  } catch (error) {
	    if (error.stack) {
	      rootStack = error.stack.split("\n").slice(3).join("\n");
	    }
	  }
	  return (arg) => {
	    try {
	      return fn(arg);
	    } catch (err) {
	      err.stack += `
    =============
${rootStack}`;
	      throw err;
	    }
	  };
	}
	return builder;
}

var hasRequiredLib$19;

function requireLib$19 () {
	if (hasRequiredLib$19) return lib$18;
	hasRequiredLib$19 = 1;
	Object.defineProperty(lib$18, "__esModule", {
	  value: true
	});
	lib$18.statements = lib$18.statement = lib$18.smart = lib$18.program = lib$18.expression = lib$18.default = void 0;
	var formatters = requireFormatters();
	var _builder = requireBuilder();
	const smart = lib$18.smart = (0, _builder.default)(formatters.smart);
	const statement = lib$18.statement = (0, _builder.default)(formatters.statement);
	const statements = lib$18.statements = (0, _builder.default)(formatters.statements);
	const expression = lib$18.expression = (0, _builder.default)(formatters.expression);
	const program = lib$18.program = (0, _builder.default)(formatters.program);
	lib$18.default = Object.assign(smart.bind(void 0), {
	  smart,
	  statement,
	  statements,
	  expression,
	  program,
	  ast: smart.ast
	});
	return lib$18;
}

var hasRequiredLib$18;

function requireLib$18 () {
	if (hasRequiredLib$18) return lib$19;
	hasRequiredLib$18 = 1;
	Object.defineProperty(lib$19, "__esModule", {
	  value: true
	});
	lib$19.default = wrapFunction;
	var _template = requireLib$19();
	var _t = require$$0$a;
	const {
	  blockStatement,
	  callExpression,
	  functionExpression,
	  isAssignmentPattern,
	  isFunctionDeclaration,
	  isRestElement,
	  returnStatement,
	  isCallExpression,
	  memberExpression,
	  identifier,
	  thisExpression,
	  isPattern
	} = _t;
	const buildAnonymousExpressionWrapper = _template.default.expression(`
  (function () {
    var REF = FUNCTION;
    return function NAME(PARAMS) {
      return REF.apply(this, arguments);
    };
  })()
`);
	const buildNamedExpressionWrapper = _template.default.expression(`
  (function () {
    var REF = FUNCTION;
    function NAME(PARAMS) {
      return REF.apply(this, arguments);
    }
    return NAME;
  })()
`);
	const buildDeclarationWrapper = _template.default.statements(`
  function NAME(PARAMS) { return REF.apply(this, arguments); }
  function REF() {
    REF = FUNCTION;
    return REF.apply(this, arguments);
  }
`);
	function classOrObjectMethod(path, callId, ignoreFunctionLength) {
	  const node = path.node;
	  const body = node.body;
	  let params = [];
	  const shoudlForwardParams = node.params.some((p) => isPattern(p));
	  if (shoudlForwardParams) {
	    params = node.params;
	    node.params = [];
	    if (!ignoreFunctionLength) {
	      for (const param of params) {
	        if (isAssignmentPattern(param) || isRestElement(param)) {
	          break;
	        }
	        node.params.push(path.scope.generateUidIdentifier("x"));
	      }
	    }
	  }
	  const container = functionExpression(null, params, blockStatement(body.body), true);
	  if (shoudlForwardParams) {
	    body.body = [returnStatement(callExpression(memberExpression(callExpression(callId, [container]), identifier("apply")), [thisExpression(), identifier("arguments")]))];
	    path.get("body.body.0.argument.callee.object.arguments.0").unwrapFunctionEnvironment();
	  } else {
	    body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];
	    path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
	  }
	  node.async = false;
	  node.generator = false;
	}
	function plainFunction(inPath, callId, noNewArrows, ignoreFunctionLength, hadName) {
	  let path = inPath;
	  let node;
	  let functionId = null;
	  const nodeParams = inPath.node.params;
	  if (path.isArrowFunctionExpression()) {
	    {
	      var _path$arrowFunctionTo;
	      path = (_path$arrowFunctionTo = path.arrowFunctionToExpression({
	        noNewArrows
	      })) != null ? _path$arrowFunctionTo : path;
	    }
	    node = path.node;
	  } else {
	    node = path.node;
	  }
	  const isDeclaration = isFunctionDeclaration(node);
	  let built = node;
	  if (!isCallExpression(node)) {
	    functionId = node.id;
	    node.id = null;
	    node.type = "FunctionExpression";
	    built = callExpression(callId, [node]);
	  }
	  const params = [];
	  for (const param of nodeParams) {
	    if (isAssignmentPattern(param) || isRestElement(param)) {
	      break;
	    }
	    params.push(path.scope.generateUidIdentifier("x"));
	  }
	  const wrapperArgs = {
	    NAME: functionId || null,
	    REF: path.scope.generateUidIdentifier(hadName ? functionId.name : "ref"),
	    FUNCTION: built,
	    PARAMS: params
	  };
	  if (isDeclaration) {
	    const container = buildDeclarationWrapper(wrapperArgs);
	    path.replaceWith(container[0]);
	    path.insertAfter(container[1]);
	  } else {
	    let container;
	    if (hadName) {
	      container = buildNamedExpressionWrapper(wrapperArgs);
	    } else {
	      container = buildAnonymousExpressionWrapper(wrapperArgs);
	    }
	    if (functionId || !ignoreFunctionLength && params.length) {
	      path.replaceWith(container);
	    } else {
	      path.replaceWith(built);
	    }
	  }
	}
	function wrapFunction(path, callId, noNewArrows = true, ignoreFunctionLength = false) {
	  if (path.isMethod()) {
	    classOrObjectMethod(path, callId, ignoreFunctionLength);
	  } else {
	    const hadName = "id" in path.node && !!path.node.id;
	    {
	      var _path, _path$ensureFunctionN;
	      (_path$ensureFunctionN = (_path = path).ensureFunctionName) != null ? _path$ensureFunctionN : _path.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	    }
	    path = path.ensureFunctionName(false);
	    plainFunction(path, callId, noNewArrows, ignoreFunctionLength, hadName);
	  }
	}
	return lib$19;
}

var lib$14 = {};

var hasRequiredLib$17;

function requireLib$17 () {
	if (hasRequiredLib$17) return lib$14;
	hasRequiredLib$17 = 1;
	Object.defineProperty(lib$14, "__esModule", {
	  value: true
	});
	lib$14.default = annotateAsPure;
	var _t = require$$0$a;
	const {
	  addComment
	} = _t;
	const PURE_ANNOTATION = "#__PURE__";
	const isPureAnnotated = ({
	  leadingComments
	}) => !!leadingComments && leadingComments.some((comment) => /[@#]__PURE__/.test(comment.value));
	function annotateAsPure(pathOrNode) {
	  const node = pathOrNode.node || pathOrNode;
	  if (isPureAnnotated(node)) {
	    return;
	  }
	  addComment(node, "leading", PURE_ANNOTATION);
	}
	return lib$14;
}

var hasRequiredLib$16;

function requireLib$16 () {
	if (hasRequiredLib$16) return lib$1a;
	hasRequiredLib$16 = 1;
	Object.defineProperty(lib$1a, "__esModule", {
	  value: true
	});
	lib$1a.default = _default;
	var _helperWrapFunction = requireLib$18();
	var _helperAnnotateAsPure = requireLib$17();
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	const {
	  callExpression,
	  cloneNode,
	  isIdentifier,
	  isThisExpression,
	  yieldExpression
	} = _core.types;
	const awaitVisitor = _traverse.visitors.environmentVisitor({
	  ArrowFunctionExpression(path) {
	    path.skip();
	  },
	  AwaitExpression(path, {
	    wrapAwait
	  }) {
	    const argument = path.get("argument");
	    path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));
	  }
	});
	function _default(path, helpers, noNewArrows, ignoreFunctionLength) {
	  path.traverse(awaitVisitor, {
	    wrapAwait: helpers.wrapAwait
	  });
	  const isIIFE = checkIsIIFE(path);
	  path.node.async = false;
	  path.node.generator = true;
	  (0, _helperWrapFunction.default)(path, cloneNode(helpers.wrapAsync), noNewArrows, ignoreFunctionLength);
	  const isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();
	  if (!isProperty && !isIIFE && path.isExpression()) {
	    (0, _helperAnnotateAsPure.default)(path);
	  }
	  function checkIsIIFE(path2) {
	    if (path2.parentPath.isCallExpression({
	      callee: path2.node
	    })) {
	      return true;
	    }
	    const {
	      parentPath
	    } = path2;
	    if (parentPath.isMemberExpression()) {
	      if (isIdentifier(parentPath.node.property, {
	        name: "bind"
	      })) {
	        const {
	          parentPath: bindCall
	        } = parentPath;
	        return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
	          callee: bindCall.node
	        });
	      }
	      return true;
	    }
	    return false;
	  }
	}
	return lib$1a;
}

var forAwait = {};

var hasRequiredForAwait;

function requireForAwait () {
	if (hasRequiredForAwait) return forAwait;
	hasRequiredForAwait = 1;
	Object.defineProperty(forAwait, "__esModule", {
	  value: true
	});
	forAwait.default = _default;
	var _core = require$$0$b;
	const buildForAwait = (0, _core.template)(`
  async function wrapper() {
    var ITERATOR_ABRUPT_COMPLETION = false;
    var ITERATOR_HAD_ERROR_KEY = false;
    var ITERATOR_ERROR_KEY;
    try {
      for (
        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;
        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;
        ITERATOR_ABRUPT_COMPLETION = false
      ) {
      }
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {
          await ITERATOR_KEY.return();
        }
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) {
          throw ITERATOR_ERROR_KEY;
        }
      }
    }
  }
`);
	function _default(path, {
	  getAsyncIterator
	}) {
	  const {
	    node,
	    scope,
	    parent
	  } = path;
	  const stepKey = scope.generateUidIdentifier("step");
	  const stepValue = _core.types.memberExpression(stepKey, _core.types.identifier("value"));
	  const left = node.left;
	  let declar;
	  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
	    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
	  } else if (_core.types.isVariableDeclaration(left)) {
	    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
	  }
	  let template = buildForAwait({
	    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
	    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
	    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
	    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
	    GET_ITERATOR: getAsyncIterator,
	    OBJECT: node.right,
	    STEP_KEY: _core.types.cloneNode(stepKey)
	  });
	  template = template.body.body;
	  const isLabeledParent = _core.types.isLabeledStatement(parent);
	  const tryBody = template[3].block.body;
	  const loop = tryBody[0];
	  if (isLabeledParent) {
	    tryBody[0] = _core.types.labeledStatement(parent.label, loop);
	  }
	  return {
	    replaceParent: isLabeledParent,
	    node: template,
	    declar,
	    loop
	  };
	}
	return forAwait;
}

var hasRequiredLib$15;

function requireLib$15 () {
	if (hasRequiredLib$15) return lib$1b;
	hasRequiredLib$15 = 1;
	Object.defineProperty(lib$1b, "__esModule", {
	  value: true
	});
	lib$1b.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperRemapAsyncToGenerator = requireLib$16();
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	var _forAwait = requireForAwait();
	lib$1b.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const yieldStarVisitor = _traverse.visitors.environmentVisitor({
	    ArrowFunctionExpression(path) {
	      path.skip();
	    },
	    YieldExpression({
	      node
	    }, state) {
	      if (!node.delegate) return;
	      const asyncIter = _core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]);
	      node.argument = _core.types.callExpression(state.addHelper("asyncGeneratorDelegate"), [asyncIter, state.addHelper("awaitAsyncGenerator")]);
	    }
	  });
	  const forAwaitVisitor = _traverse.visitors.environmentVisitor({
	    ArrowFunctionExpression(path) {
	      path.skip();
	    },
	    ForOfStatement(path, {
	      file
	    }) {
	      const {
	        node
	      } = path;
	      if (!node.await) return;
	      const build = (0, _forAwait.default)(path, {
	        getAsyncIterator: file.addHelper("asyncIterator")
	      });
	      const {
	        declar,
	        loop
	      } = build;
	      const block = loop.body;
	      path.ensureBlock();
	      if (declar) {
	        block.body.push(declar);
	        if (path.node.body.body.length) {
	          block.body.push(_core.types.blockStatement(path.node.body.body));
	        }
	      } else {
	        block.body.push(...path.node.body.body);
	      }
	      _core.types.inherits(loop, node);
	      _core.types.inherits(loop.body, node.body);
	      const p = build.replaceParent ? path.parentPath : path;
	      p.replaceWithMultiple(build.node);
	      p.scope.parent.crawl();
	    }
	  });
	  const visitor = {
	    Function(path, state) {
	      if (!path.node.async) return;
	      path.traverse(forAwaitVisitor, state);
	      if (!path.node.generator) return;
	      path.traverse(yieldStarVisitor, state);
	      path.setData("@babel/plugin-transform-async-generator-functions/async_generator_function", true);
	      (0, _helperRemapAsyncToGenerator.default)(path, {
	        wrapAsync: state.addHelper("wrapAsyncGenerator"),
	        wrapAwait: state.addHelper("awaitAsyncGenerator")
	      });
	    }
	  };
	  return {
	    name: "transform-async-generator-functions",
	    manipulateOptions: (_, parser) => parser.plugins.push("asyncGenerators"),
	    visitor: {
	      Program(path, state) {
	        path.traverse(visitor, state);
	      }
	    }
	  };
	});
	return lib$1b;
}

var lib$13 = {};

var lib$12 = {};

var importInjector = {};

var importBuilder = {};

var hasRequiredImportBuilder;

function requireImportBuilder () {
	if (hasRequiredImportBuilder) return importBuilder;
	hasRequiredImportBuilder = 1;
	Object.defineProperty(importBuilder, "__esModule", {
	  value: true
	});
	importBuilder.default = void 0;
	var _assert = require$$0$c;
	var _t = require$$0$a;
	const {
	  callExpression,
	  cloneNode,
	  expressionStatement,
	  identifier,
	  importDeclaration,
	  importDefaultSpecifier,
	  importNamespaceSpecifier,
	  importSpecifier,
	  memberExpression,
	  stringLiteral,
	  variableDeclaration,
	  variableDeclarator
	} = _t;
	class ImportBuilder {
	  constructor(importedSource, scope, hub) {
	    this._statements = [];
	    this._resultName = null;
	    this._importedSource = void 0;
	    this._scope = scope;
	    this._hub = hub;
	    this._importedSource = importedSource;
	  }
	  done() {
	    return {
	      statements: this._statements,
	      resultName: this._resultName
	    };
	  }
	  import() {
	    this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
	    return this;
	  }
	  require() {
	    this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));
	    return this;
	  }
	  namespace(name = "namespace") {
	    const local = this._scope.generateUidIdentifier(name);
	    const statement = this._statements[this._statements.length - 1];
	    _assert(statement.type === "ImportDeclaration");
	    _assert(statement.specifiers.length === 0);
	    statement.specifiers = [importNamespaceSpecifier(local)];
	    this._resultName = cloneNode(local);
	    return this;
	  }
	  default(name) {
	    const id = this._scope.generateUidIdentifier(name);
	    const statement = this._statements[this._statements.length - 1];
	    _assert(statement.type === "ImportDeclaration");
	    _assert(statement.specifiers.length === 0);
	    statement.specifiers = [importDefaultSpecifier(id)];
	    this._resultName = cloneNode(id);
	    return this;
	  }
	  named(name, importName) {
	    if (importName === "default") return this.default(name);
	    const id = this._scope.generateUidIdentifier(name);
	    const statement = this._statements[this._statements.length - 1];
	    _assert(statement.type === "ImportDeclaration");
	    _assert(statement.specifiers.length === 0);
	    statement.specifiers = [importSpecifier(id, identifier(importName))];
	    this._resultName = cloneNode(id);
	    return this;
	  }
	  var(name) {
	    const id = this._scope.generateUidIdentifier(name);
	    let statement = this._statements[this._statements.length - 1];
	    if (statement.type !== "ExpressionStatement") {
	      _assert(this._resultName);
	      statement = expressionStatement(this._resultName);
	      this._statements.push(statement);
	    }
	    this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id, statement.expression)]);
	    this._resultName = cloneNode(id);
	    return this;
	  }
	  defaultInterop() {
	    return this._interop(this._hub.addHelper("interopRequireDefault"));
	  }
	  wildcardInterop() {
	    return this._interop(this._hub.addHelper("interopRequireWildcard"));
	  }
	  _interop(callee) {
	    const statement = this._statements[this._statements.length - 1];
	    if (statement.type === "ExpressionStatement") {
	      statement.expression = callExpression(callee, [statement.expression]);
	    } else if (statement.type === "VariableDeclaration") {
	      _assert(statement.declarations.length === 1);
	      statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
	    } else {
	      _assert.fail("Unexpected type.");
	    }
	    return this;
	  }
	  prop(name) {
	    const statement = this._statements[this._statements.length - 1];
	    if (statement.type === "ExpressionStatement") {
	      statement.expression = memberExpression(statement.expression, identifier(name));
	    } else if (statement.type === "VariableDeclaration") {
	      _assert(statement.declarations.length === 1);
	      statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
	    } else {
	      _assert.fail("Unexpected type:" + statement.type);
	    }
	    return this;
	  }
	  read(name) {
	    this._resultName = memberExpression(this._resultName, identifier(name));
	  }
	}
	importBuilder.default = ImportBuilder;
	return importBuilder;
}

var isModule = {};

var hasRequiredIsModule;

function requireIsModule () {
	if (hasRequiredIsModule) return isModule;
	hasRequiredIsModule = 1;
	Object.defineProperty(isModule, "__esModule", {
	  value: true
	});
	isModule.default = isModule$1;
	function isModule$1(path) {
	  return path.node.sourceType === "module";
	}
	return isModule;
}

var hasRequiredImportInjector;

function requireImportInjector () {
	if (hasRequiredImportInjector) return importInjector;
	hasRequiredImportInjector = 1;
	Object.defineProperty(importInjector, "__esModule", {
	  value: true
	});
	importInjector.default = void 0;
	var _assert = require$$0$c;
	var _t = require$$0$a;
	var _importBuilder = requireImportBuilder();
	var _isModule = requireIsModule();
	const {
	  identifier,
	  importSpecifier,
	  numericLiteral,
	  sequenceExpression,
	  isImportDeclaration
	} = _t;
	class ImportInjector {
	  constructor(path, importedSource, opts) {
	    this._defaultOpts = {
	      importedSource: null,
	      importedType: "commonjs",
	      importedInterop: "babel",
	      importingInterop: "babel",
	      ensureLiveReference: false,
	      ensureNoContext: false,
	      importPosition: "before"
	    };
	    const programPath = path.find((p) => p.isProgram());
	    this._programPath = programPath;
	    this._programScope = programPath.scope;
	    this._hub = programPath.hub;
	    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
	  }
	  addDefault(importedSourceIn, opts) {
	    return this.addNamed("default", importedSourceIn, opts);
	  }
	  addNamed(importName, importedSourceIn, opts) {
	    _assert(typeof importName === "string");
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
	  }
	  addNamespace(importedSourceIn, opts) {
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
	  }
	  addSideEffect(importedSourceIn, opts) {
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
	  }
	  _applyDefaults(importedSource, opts, isInit = false) {
	    let newOpts;
	    if (typeof importedSource === "string") {
	      newOpts = Object.assign({}, this._defaultOpts, {
	        importedSource
	      }, opts);
	    } else {
	      _assert(!opts, "Unexpected secondary arguments.");
	      newOpts = Object.assign({}, this._defaultOpts, importedSource);
	    }
	    if (!isInit && opts) {
	      if (opts.nameHint !== void 0) newOpts.nameHint = opts.nameHint;
	      if (opts.blockHoist !== void 0) newOpts.blockHoist = opts.blockHoist;
	    }
	    return newOpts;
	  }
	  _generateImport(opts, importName) {
	    const isDefault = importName === "default";
	    const isNamed = !!importName && !isDefault;
	    const isNamespace = importName === null;
	    const {
	      importedSource,
	      importedType,
	      importedInterop,
	      importingInterop,
	      ensureLiveReference,
	      ensureNoContext,
	      nameHint,
	      importPosition,
	      blockHoist
	    } = opts;
	    let name = nameHint || importName;
	    const isMod = (0, _isModule.default)(this._programPath);
	    const isModuleForNode = isMod && importingInterop === "node";
	    const isModuleForBabel = isMod && importingInterop === "babel";
	    if (importPosition === "after" && !isMod) {
	      throw new Error(`"importPosition": "after" is only supported in modules`);
	    }
	    const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
	    if (importedType === "es6") {
	      if (!isModuleForNode && !isModuleForBabel) {
	        throw new Error("Cannot import an ES6 module from CommonJS");
	      }
	      builder.import();
	      if (isNamespace) {
	        builder.namespace(nameHint || importedSource);
	      } else if (isDefault || isNamed) {
	        builder.named(name, importName);
	      }
	    } else if (importedType !== "commonjs") {
	      throw new Error(`Unexpected interopType "${importedType}"`);
	    } else if (importedInterop === "babel") {
	      if (isModuleForNode) {
	        name = name !== "default" ? name : importedSource;
	        const es6Default = `${importedSource}$es6Default`;
	        builder.import();
	        if (isNamespace) {
	          builder.default(es6Default).var(name || importedSource).wildcardInterop();
	        } else if (isDefault) {
	          if (ensureLiveReference) {
	            builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
	          } else {
	            builder.default(es6Default).var(name).defaultInterop().prop(importName);
	          }
	        } else if (isNamed) {
	          builder.default(es6Default).read(importName);
	        }
	      } else if (isModuleForBabel) {
	        builder.import();
	        if (isNamespace) {
	          builder.namespace(name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();
	        if (isNamespace) {
	          builder.var(name || importedSource).wildcardInterop();
	        } else if ((isDefault || isNamed) && ensureLiveReference) {
	          if (isDefault) {
	            name = name !== "default" ? name : importedSource;
	            builder.var(name).read(importName);
	            builder.defaultInterop();
	          } else {
	            builder.var(importedSource).read(importName);
	          }
	        } else if (isDefault) {
	          builder.var(name).defaultInterop().prop(importName);
	        } else if (isNamed) {
	          builder.var(name).prop(importName);
	        }
	      }
	    } else if (importedInterop === "compiled") {
	      if (isModuleForNode) {
	        builder.import();
	        if (isNamespace) {
	          builder.default(name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder.default(importedSource).read(name);
	        }
	      } else if (isModuleForBabel) {
	        builder.import();
	        if (isNamespace) {
	          builder.namespace(name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();
	        if (isNamespace) {
	          builder.var(name || importedSource);
	        } else if (isDefault || isNamed) {
	          if (ensureLiveReference) {
	            builder.var(importedSource).read(name);
	          } else {
	            builder.prop(importName).var(name);
	          }
	        }
	      }
	    } else if (importedInterop === "uncompiled") {
	      if (isDefault && ensureLiveReference) {
	        throw new Error("No live reference for commonjs default");
	      }
	      if (isModuleForNode) {
	        builder.import();
	        if (isNamespace) {
	          builder.default(name || importedSource);
	        } else if (isDefault) {
	          builder.default(name);
	        } else if (isNamed) {
	          builder.default(importedSource).read(name);
	        }
	      } else if (isModuleForBabel) {
	        builder.import();
	        if (isNamespace) {
	          builder.default(name || importedSource);
	        } else if (isDefault) {
	          builder.default(name);
	        } else if (isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();
	        if (isNamespace) {
	          builder.var(name || importedSource);
	        } else if (isDefault) {
	          builder.var(name);
	        } else if (isNamed) {
	          if (ensureLiveReference) {
	            builder.var(importedSource).read(name);
	          } else {
	            builder.var(name).prop(importName);
	          }
	        }
	      }
	    } else {
	      throw new Error(`Unknown importedInterop "${importedInterop}".`);
	    }
	    const {
	      statements,
	      resultName
	    } = builder.done();
	    this._insertStatements(statements, importPosition, blockHoist);
	    if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
	      return sequenceExpression([numericLiteral(0), resultName]);
	    }
	    return resultName;
	  }
	  _insertStatements(statements, importPosition = "before", blockHoist = 3) {
	    if (importPosition === "after") {
	      if (this._insertStatementsAfter(statements)) return;
	    } else {
	      if (this._insertStatementsBefore(statements, blockHoist)) return;
	    }
	    this._programPath.unshiftContainer("body", statements);
	  }
	  _insertStatementsBefore(statements, blockHoist) {
	    if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {
	      const firstImportDecl = this._programPath.get("body").find((p) => {
	        return p.isImportDeclaration() && isValueImport(p.node);
	      });
	      if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {
	        return true;
	      }
	    }
	    statements.forEach((node) => {
	      node._blockHoist = blockHoist;
	    });
	    const targetPath = this._programPath.get("body").find((p) => {
	      const val = p.node._blockHoist;
	      return Number.isFinite(val) && val < 4;
	    });
	    if (targetPath) {
	      targetPath.insertBefore(statements);
	      return true;
	    }
	    return false;
	  }
	  _insertStatementsAfter(statements) {
	    const statementsSet = new Set(statements);
	    const importDeclarations = /* @__PURE__ */ new Map();
	    for (const statement of statements) {
	      if (isImportDeclaration(statement) && isValueImport(statement)) {
	        const source = statement.source.value;
	        if (!importDeclarations.has(source)) importDeclarations.set(source, []);
	        importDeclarations.get(source).push(statement);
	      }
	    }
	    let lastImportPath = null;
	    for (const bodyStmt of this._programPath.get("body")) {
	      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {
	        lastImportPath = bodyStmt;
	        const source = bodyStmt.node.source.value;
	        const newImports = importDeclarations.get(source);
	        if (!newImports) continue;
	        for (const decl of newImports) {
	          if (!statementsSet.has(decl)) continue;
	          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {
	            statementsSet.delete(decl);
	          }
	        }
	      }
	    }
	    if (statementsSet.size === 0) return true;
	    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));
	    return !!lastImportPath;
	  }
	}
	importInjector.default = ImportInjector;
	function isValueImport(node) {
	  return node.importKind !== "type" && node.importKind !== "typeof";
	}
	function hasNamespaceImport(node) {
	  return node.specifiers.length === 1 && node.specifiers[0].type === "ImportNamespaceSpecifier" || node.specifiers.length === 2 && node.specifiers[1].type === "ImportNamespaceSpecifier";
	}
	function hasDefaultImport(node) {
	  return node.specifiers.length > 0 && node.specifiers[0].type === "ImportDefaultSpecifier";
	}
	function maybeAppendImportSpecifiers(target, source) {
	  if (!target.specifiers.length) {
	    target.specifiers = source.specifiers;
	    return true;
	  }
	  if (!source.specifiers.length) return true;
	  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;
	  if (hasDefaultImport(source)) {
	    if (hasDefaultImport(target)) {
	      source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier("default"));
	    } else {
	      target.specifiers.unshift(source.specifiers.shift());
	    }
	  }
	  target.specifiers.push(...source.specifiers);
	  return true;
	}
	return importInjector;
}

var hasRequiredLib$14;

function requireLib$14 () {
	if (hasRequiredLib$14) return lib$12;
	hasRequiredLib$14 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "ImportInjector", {
		  enumerable: true,
		  get: function() {
		    return _importInjector.default;
		  }
		});
		exports.addDefault = addDefault;
		exports.addNamed = addNamed;
		exports.addNamespace = addNamespace;
		exports.addSideEffect = addSideEffect;
		Object.defineProperty(exports, "isModule", {
		  enumerable: true,
		  get: function() {
		    return _isModule.default;
		  }
		});
		var _importInjector = requireImportInjector();
		var _isModule = requireIsModule();
		function addDefault(path, importedSource, opts) {
		  return new _importInjector.default(path).addDefault(importedSource, opts);
		}
		function addNamed(path, name, importedSource, opts) {
		  return new _importInjector.default(path).addNamed(name, importedSource, opts);
		}
		function addNamespace(path, importedSource, opts) {
		  return new _importInjector.default(path).addNamespace(importedSource, opts);
		}
		function addSideEffect(path, importedSource, opts) {
		  return new _importInjector.default(path).addSideEffect(importedSource, opts);
		} 
	} (lib$12));
	return lib$12;
}

var hasRequiredLib$13;

function requireLib$13 () {
	if (hasRequiredLib$13) return lib$13;
	hasRequiredLib$13 = 1;
	Object.defineProperty(lib$13, "__esModule", {
	  value: true
	});
	lib$13.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperRemapAsyncToGenerator = requireLib$16();
	var _helperModuleImports = requireLib$14();
	var _core = require$$0$b;
	lib$13.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    method,
	    module
	  } = options;
	  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : true;
	  const ignoreFunctionLength = (_api$assumption2 = api.assumption("ignoreFunctionLength")) != null ? _api$assumption2 : false;
	  if (method && module) {
	    return {
	      name: "transform-async-to-generator",
	      visitor: {
	        Function(path, state) {
	          if (!path.node.async || path.node.generator) return;
	          let wrapAsync = state.methodWrapper;
	          if (wrapAsync) {
	            wrapAsync = _core.types.cloneNode(wrapAsync);
	          } else {
	            wrapAsync = state.methodWrapper = (0, _helperModuleImports.addNamed)(path, method, module);
	          }
	          (0, _helperRemapAsyncToGenerator.default)(path, {
	            wrapAsync
	          }, noNewArrows, ignoreFunctionLength);
	        }
	      }
	    };
	  }
	  return {
	    name: "transform-async-to-generator",
	    visitor: {
	      Function(path, state) {
	        if (!path.node.async || path.node.generator) return;
	        (0, _helperRemapAsyncToGenerator.default)(path, {
	          wrapAsync: state.addHelper("asyncToGenerator")
	        }, noNewArrows, ignoreFunctionLength);
	      }
	    }
	  };
	});
	return lib$13;
}

var lib$11 = {};

var hasRequiredLib$12;

function requireLib$12 () {
	if (hasRequiredLib$12) return lib$11;
	hasRequiredLib$12 = 1;
	Object.defineProperty(lib$11, "__esModule", {
	  value: true
	});
	lib$11.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$11.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption;
	  api.assertVersion(7);
	  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
	  return {
	    name: "transform-arrow-functions",
	    visitor: {
	      ArrowFunctionExpression(path) {
	        if (!path.isArrowFunctionExpression()) return;
	        {
	          path.arrowFunctionToExpression({
	            allowInsertArrow: false,
	            noNewArrows,
	            specCompliant: !noNewArrows
	          });
	        }
	      }
	    }
	  };
	});
	return lib$11;
}

var lib$10 = {};

var hasRequiredLib$11;

function requireLib$11 () {
	if (hasRequiredLib$11) return lib$10;
	hasRequiredLib$11 = 1;
	Object.defineProperty(lib$10, "__esModule", {
	  value: true
	});
	lib$10.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$10.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  function transformStatementList(parentPath, paths) {
	    for (const path of paths) {
	      if (!path.isFunctionDeclaration()) continue;
	      const func = path.node;
	      const declar = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(func.id, _core.types.toExpression(func))]);
	      declar._blockHoist = 2;
	      func.id = null;
	      path.replaceWith(declar);
	    }
	  }
	  return {
	    name: "transform-block-scoped-functions",
	    visitor: {
	      BlockStatement(path) {
	        const {
	          node,
	          parent
	        } = path;
	        if (_core.types.isFunction(parent, {
	          body: node
	        }) || _core.types.isExportDeclaration(parent)) {
	          return;
	        }
	        transformStatementList(path, path.get("body"));
	      },
	      SwitchCase(path) {
	        transformStatementList(path, path.get("consequent"));
	      }
	    }
	  };
	});
	return lib$10;
}

var lib$$ = {};

var loop = {};

var hasRequiredLoop;

function requireLoop () {
	if (hasRequiredLoop) return loop;
	hasRequiredLoop = 1;
	Object.defineProperty(loop, "__esModule", {
	  value: true
	});
	loop.getLoopBodyBindings = getLoopBodyBindings;
	loop.getUsageInBody = getUsageInBody;
	loop.isVarInLoopHead = isVarInLoopHead;
	loop.wrapLoopBody = wrapLoopBody;
	var _core = require$$0$b;
	const collectLoopBodyBindingsVisitor = {
	  "Expression|Declaration|Loop"(path) {
	    path.skip();
	  },
	  Scope(path, state) {
	    if (path.isFunctionParent()) path.skip();
	    const {
	      bindings
	    } = path.scope;
	    for (const name of Object.keys(bindings)) {
	      const binding = bindings[name];
	      if (binding.kind === "let" || binding.kind === "const" || binding.kind === "hoisted") {
	        state.blockScoped.push(binding);
	      }
	    }
	  }
	};
	function getLoopBodyBindings(loopPath) {
	  const state = {
	    blockScoped: []
	  };
	  loopPath.traverse(collectLoopBodyBindingsVisitor, state);
	  return state.blockScoped;
	}
	function getUsageInBody(binding, loopPath) {
	  const seen = /* @__PURE__ */ new WeakSet();
	  let capturedInClosure = false;
	  const constantViolations = filterMap(binding.constantViolations, (path) => {
	    const {
	      inBody,
	      inClosure
	    } = relativeLoopLocation(path, loopPath);
	    if (!inBody) return null;
	    capturedInClosure || (capturedInClosure = inClosure);
	    const id = path.isUpdateExpression() ? path.get("argument") : path.isAssignmentExpression() ? path.get("left") : null;
	    if (id) seen.add(id.node);
	    return id;
	  });
	  const references = filterMap(binding.referencePaths, (path) => {
	    if (seen.has(path.node)) return null;
	    const {
	      inBody,
	      inClosure
	    } = relativeLoopLocation(path, loopPath);
	    if (!inBody) return null;
	    capturedInClosure || (capturedInClosure = inClosure);
	    return path;
	  });
	  return {
	    capturedInClosure,
	    hasConstantViolations: constantViolations.length > 0,
	    usages: references.concat(constantViolations)
	  };
	}
	function relativeLoopLocation(path, loopPath) {
	  const bodyPath = loopPath.get("body");
	  let inClosure = false;
	  for (let currPath = path; currPath; currPath = currPath.parentPath) {
	    if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {
	      inClosure = true;
	    }
	    if (currPath === bodyPath) {
	      return {
	        inBody: true,
	        inClosure
	      };
	    } else if (currPath === loopPath) {
	      return {
	        inBody: false,
	        inClosure
	      };
	    }
	  }
	  throw new Error("Internal Babel error: path is not in loop. Please report this as a bug.");
	}
	const collectCompletionsAndVarsVisitor = {
	  Function(path) {
	    path.skip();
	  },
	  LabeledStatement: {
	    enter({
	      node
	    }, state) {
	      state.labelsStack.push(node.label.name);
	    },
	    exit({
	      node
	    }, state) {
	      const popped = state.labelsStack.pop();
	      if (popped !== node.label.name) {
	        throw new Error("Assertion failure. Please report this bug to Babel.");
	      }
	    }
	  },
	  Loop: {
	    enter(_, state) {
	      state.labellessContinueTargets++;
	      state.labellessBreakTargets++;
	    },
	    exit(_, state) {
	      state.labellessContinueTargets--;
	      state.labellessBreakTargets--;
	    }
	  },
	  SwitchStatement: {
	    enter(_, state) {
	      state.labellessBreakTargets++;
	    },
	    exit(_, state) {
	      state.labellessBreakTargets--;
	    }
	  },
	  "BreakStatement|ContinueStatement"(path, state) {
	    const {
	      label
	    } = path.node;
	    if (label) {
	      if (state.labelsStack.includes(label.name)) return;
	    } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0) {
	      return;
	    }
	    state.breaksContinues.push(path);
	  },
	  ReturnStatement(path, state) {
	    state.returns.push(path);
	  },
	  VariableDeclaration(path, state) {
	    if (path.parent === state.loopNode && isVarInLoopHead(path)) return;
	    if (path.node.kind === "var") state.vars.push(path);
	  }
	};
	function wrapLoopBody(loopPath, captured, updatedBindingsUsages) {
	  const loopNode = loopPath.node;
	  const state = {
	    breaksContinues: [],
	    returns: [],
	    labelsStack: [],
	    labellessBreakTargets: 0,
	    labellessContinueTargets: 0,
	    vars: [],
	    loopNode
	  };
	  loopPath.traverse(collectCompletionsAndVarsVisitor, state);
	  const callArgs = [];
	  const closureParams = [];
	  const updater = [];
	  for (const [name, updatedUsage] of updatedBindingsUsages) {
	    callArgs.push(_core.types.identifier(name));
	    const innerName = loopPath.scope.generateUid(name);
	    closureParams.push(_core.types.identifier(innerName));
	    updater.push(_core.types.assignmentExpression("=", _core.types.identifier(name), _core.types.identifier(innerName)));
	    for (const path of updatedUsage) path.replaceWith(_core.types.identifier(innerName));
	  }
	  for (const name of captured) {
	    if (updatedBindingsUsages.has(name)) continue;
	    callArgs.push(_core.types.identifier(name));
	    closureParams.push(_core.types.identifier(name));
	  }
	  const id = loopPath.scope.generateUid("loop");
	  const fn = _core.types.functionExpression(null, closureParams, _core.types.toBlock(loopNode.body));
	  let call = _core.types.callExpression(_core.types.identifier(id), callArgs);
	  const fnParent = loopPath.findParent((p) => p.isFunction());
	  if (fnParent) {
	    const {
	      async,
	      generator
	    } = fnParent.node;
	    fn.async = async;
	    fn.generator = generator;
	    if (generator) call = _core.types.yieldExpression(call, true);
	    else if (async) call = _core.types.awaitExpression(call);
	  }
	  const updaterNode = updater.length > 0 ? _core.types.expressionStatement(_core.types.sequenceExpression(updater)) : null;
	  if (updaterNode) fn.body.body.push(updaterNode);
	  const [varPath] = loopPath.insertBefore(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(id), fn)]));
	  const bodyStmts = [];
	  const varNames = [];
	  for (const varPath2 of state.vars) {
	    const assign = [];
	    for (const decl of varPath2.node.declarations) {
	      varNames.push(...Object.keys(_core.types.getBindingIdentifiers(decl.id)));
	      if (decl.init) {
	        assign.push(_core.types.assignmentExpression("=", decl.id, decl.init));
	      } else if (_core.types.isForXStatement(varPath2.parent, {
	        left: varPath2.node
	      })) {
	        assign.push(decl.id);
	      }
	    }
	    if (assign.length > 0) {
	      const replacement = assign.length === 1 ? assign[0] : _core.types.sequenceExpression(assign);
	      varPath2.replaceWith(replacement);
	    } else {
	      varPath2.remove();
	    }
	  }
	  if (varNames.length) {
	    varPath.pushContainer("declarations", varNames.map((name) => _core.types.variableDeclarator(_core.types.identifier(name))));
	  }
	  const labelNum = state.breaksContinues.length;
	  const returnNum = state.returns.length;
	  if (labelNum + returnNum === 0) {
	    bodyStmts.push(_core.types.expressionStatement(call));
	  } else if (labelNum === 1 && returnNum === 0) {
	    for (const path of state.breaksContinues) {
	      const {
	        node
	      } = path;
	      const {
	        type,
	        label
	      } = node;
	      let name = type === "BreakStatement" ? "break" : "continue";
	      if (label) name += " " + label.name;
	      path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(1)), "trailing", " " + name, true));
	      if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
	      bodyStmts.push(_core.template.statement.ast`
        if (${call}) ${node}
      `);
	    }
	  } else {
	    const completionId = loopPath.scope.generateUid("ret");
	    if (varPath.isVariableDeclaration()) {
	      varPath.pushContainer("declarations", [_core.types.variableDeclarator(_core.types.identifier(completionId))]);
	      bodyStmts.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(completionId), call)));
	    } else {
	      bodyStmts.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(completionId), call)]));
	    }
	    const injected = [];
	    for (const path of state.breaksContinues) {
	      const {
	        node
	      } = path;
	      const {
	        type,
	        label
	      } = node;
	      let name = type === "BreakStatement" ? "break" : "continue";
	      if (label) name += " " + label.name;
	      let i = injected.indexOf(name);
	      const hasInjected = i !== -1;
	      if (!hasInjected) {
	        injected.push(name);
	        i = injected.length - 1;
	      }
	      path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(i)), "trailing", " " + name, true));
	      if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
	      if (hasInjected) continue;
	      bodyStmts.push(_core.template.statement.ast`
        if (${_core.types.identifier(completionId)} === ${_core.types.numericLiteral(i)}) ${node}
      `);
	    }
	    if (returnNum) {
	      for (const path of state.returns) {
	        const arg = path.node.argument || path.scope.buildUndefinedNode();
	        path.replaceWith(_core.template.statement.ast`
          return { v: ${arg} };
        `);
	      }
	      bodyStmts.push(_core.template.statement.ast`
          if (${_core.types.identifier(completionId)}) return ${_core.types.identifier(completionId)}.v;
        `);
	    }
	  }
	  loopNode.body = _core.types.blockStatement(bodyStmts);
	  return varPath;
	}
	function isVarInLoopHead(path) {
	  if (_core.types.isForStatement(path.parent)) return path.key === "init";
	  if (_core.types.isForXStatement(path.parent)) return path.key === "left";
	  return false;
	}
	function filterMap(list, fn) {
	  const result = [];
	  for (const item of list) {
	    const mapped = fn(item);
	    if (mapped) result.push(mapped);
	  }
	  return result;
	}
	return loop;
}

var validation = {};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;
	Object.defineProperty(validation, "__esModule", {
	  value: true
	});
	validation.validateUsage = validateUsage;
	var _core = require$$0$b;
	function validateUsage(path, state, tdzEnabled) {
	  const dynamicTDZNames = [];
	  for (const name of Object.keys(path.getBindingIdentifiers())) {
	    const binding = path.scope.getBinding(name);
	    if (!binding) continue;
	    if (tdzEnabled) {
	      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);
	    }
	    if (path.node.kind === "const") {
	      disallowConstantViolations(name, binding, state);
	    }
	  }
	  return dynamicTDZNames;
	}
	function disallowConstantViolations(name, binding, state) {
	  for (const violation of binding.constantViolations) {
	    const readOnlyError = state.addHelper("readOnlyError");
	    const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);
	    if (violation.isAssignmentExpression()) {
	      const {
	        operator,
	        left,
	        right
	      } = violation.node;
	      if (operator === "=") {
	        const exprs = [right];
	        exprs.push(throwNode);
	        violation.replaceWith(_core.types.sequenceExpression(exprs));
	      } else if (["&&=", "||=", "??="].includes(operator)) {
	        violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), left, _core.types.sequenceExpression([right, throwNode])));
	      } else {
	        violation.replaceWith(_core.types.sequenceExpression([_core.types.binaryExpression(operator.slice(0, -1), left, right), throwNode]));
	      }
	    } else if (violation.isUpdateExpression()) {
	      violation.replaceWith(_core.types.sequenceExpression([_core.types.unaryExpression("+", violation.get("argument").node), throwNode]));
	    } else if (violation.isForXStatement()) {
	      violation.ensureBlock();
	      violation.get("left").replaceWith(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))]));
	      violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));
	    }
	  }
	}
	function getTDZStatus(refPath, bindingPath) {
	  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
	  if (executionStatus === "before") {
	    return "outside";
	  } else if (executionStatus === "after") {
	    return "inside";
	  } else {
	    return "maybe";
	  }
	}
	const skipTDZChecks = /* @__PURE__ */ new WeakSet();
	function buildTDZAssert(status, node, state) {
	  if (status === "maybe") {
	    const clone = _core.types.cloneNode(node);
	    skipTDZChecks.add(clone);
	    return _core.types.callExpression(state.addHelper("temporalRef"), [clone, _core.types.stringLiteral(node.name)]);
	  } else {
	    return _core.types.callExpression(state.addHelper("tdz"), [_core.types.stringLiteral(node.name)]);
	  }
	}
	function getTDZReplacement(path, state, id = path.node) {
	  var _path$scope$getBindin;
	  if (skipTDZChecks.has(id)) return;
	  skipTDZChecks.add(id);
	  const bindingPath = (_path$scope$getBindin = path.scope.getBinding(id.name)) == null ? void 0 : _path$scope$getBindin.path;
	  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;
	  const status = getTDZStatus(path, bindingPath);
	  if (status === "outside") return;
	  if (status === "maybe") {
	    bindingPath.parent._tdzThis = true;
	  }
	  return {
	    status,
	    node: buildTDZAssert(status, id, state)
	  };
	}
	function injectTDZChecks(binding, state) {
	  const allUsages = new Set(binding.referencePaths);
	  binding.constantViolations.forEach(allUsages.add, allUsages);
	  let dynamicTdz = false;
	  for (const path of binding.constantViolations) {
	    const {
	      node
	    } = path;
	    if (skipTDZChecks.has(node)) continue;
	    skipTDZChecks.add(node);
	    if (path.isUpdateExpression()) {
	      const arg = path.get("argument");
	      const replacement = getTDZReplacement(path, state, arg.node);
	      if (!replacement) continue;
	      if (replacement.status === "maybe") {
	        dynamicTdz = true;
	        path.insertBefore(replacement.node);
	      } else {
	        path.replaceWith(replacement.node);
	      }
	    } else if (path.isAssignmentExpression()) {
	      const nodes = [];
	      const ids = path.getBindingIdentifiers();
	      for (const name of Object.keys(ids)) {
	        const replacement = getTDZReplacement(path, state, ids[name]);
	        if (replacement) {
	          nodes.push(_core.types.expressionStatement(replacement.node));
	          if (replacement.status === "inside") break;
	          if (replacement.status === "maybe") dynamicTdz = true;
	        }
	      }
	      if (nodes.length > 0) path.insertBefore(nodes);
	    }
	  }
	  for (const path of binding.referencePaths) {
	    if (path.parentPath.isUpdateExpression()) continue;
	    if (path.parentPath.isFor({
	      left: path.node
	    })) continue;
	    const replacement = getTDZReplacement(path, state);
	    if (!replacement) continue;
	    if (replacement.status === "maybe") dynamicTdz = true;
	    path.replaceWith(replacement.node);
	  }
	  return dynamicTdz;
	}
	return validation;
}

var annexB_3_3 = {};

var hasRequiredAnnexB_3_3;

function requireAnnexB_3_3 () {
	if (hasRequiredAnnexB_3_3) return annexB_3_3;
	hasRequiredAnnexB_3_3 = 1;
	Object.defineProperty(annexB_3_3, "__esModule", {
	  value: true
	});
	annexB_3_3.annexB33FunctionsVisitor = void 0;
	annexB_3_3.isVarScope = isVarScope;
	var _core = require$$0$b;
	annexB_3_3.annexB33FunctionsVisitor = Object.assign({
	  VariableDeclaration(path) {
	    if (isStrict(path)) return;
	    if (path.node.kind !== "var") return;
	    const varScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
	    varScope.path.traverse(functionsToVarVisitor, {
	      names: Object.keys(path.getBindingIdentifiers())
	    });
	  }
	}, {
	  BlockStatement(path) {
	    if (isStrict(path)) return;
	    if (_core.types.isFunction(path.parent, {
	      body: path.node
	    })) return;
	    transformStatementList(path.get("body"));
	  },
	  SwitchCase(path) {
	    if (isStrict(path)) return;
	    transformStatementList(path.get("consequent"));
	  }
	});
	function transformStatementList(paths) {
	  outer: for (const path of paths) {
	    if (!path.isFunctionDeclaration()) continue;
	    if (path.node.async || path.node.generator) return;
	    const {
	      scope
	    } = path.parentPath;
	    if (isVarScope(scope)) return;
	    const {
	      name
	    } = path.node.id;
	    let currScope = scope;
	    do {
	      if (currScope.parent.hasOwnBinding(name)) continue outer;
	      currScope = currScope.parent;
	    } while (!isVarScope(currScope));
	    maybeTransformBlockScopedFunction(path);
	  }
	}
	function maybeTransformBlockScopedFunction(path) {
	  const {
	    node,
	    parentPath: {
	      scope
	    }
	  } = path;
	  const {
	    id
	  } = node;
	  scope.removeOwnBinding(id.name);
	  node.id = null;
	  const varNode = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(id, _core.types.toExpression(node))]);
	  varNode._blockHoist = 2;
	  const [varPath] = path.replaceWith(varNode);
	  scope.registerDeclaration(varPath);
	}
	const functionsToVarVisitor = {
	  Scope(path, {
	    names
	  }) {
	    for (const name of names) {
	      const binding = path.scope.getOwnBinding(name);
	      if (binding && binding.kind === "hoisted") {
	        maybeTransformBlockScopedFunction(binding.path);
	      }
	    }
	  },
	  "Expression|Declaration"(path) {
	    path.skip();
	  }
	};
	function isVarScope(scope) {
	  return scope.path.isFunctionParent() || scope.path.isProgram();
	}
	function isStrict(path) {
	  return !!path.find(({
	    node
	  }) => {
	    var _node$directives;
	    if (_core.types.isProgram(node)) {
	      if (node.sourceType === "module") return true;
	    } else if (_core.types.isClass(node)) {
	      return true;
	    } else if (!_core.types.isBlockStatement(node)) {
	      return false;
	    }
	    return (_node$directives = node.directives) == null ? void 0 : _node$directives.some((directive) => directive.value.value === "use strict");
	  });
	}
	return annexB_3_3;
}

var hasRequiredLib$10;

function requireLib$10 () {
	if (hasRequiredLib$10) return lib$$;
	hasRequiredLib$10 = 1;
	Object.defineProperty(lib$$, "__esModule", {
	  value: true
	});
	lib$$.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	var _loop = requireLoop();
	var _validation = requireValidation();
	var _annexB_3_ = requireAnnexB_3_3();
	lib$$.default = (0, _helperPluginUtils.declare)((api, opts) => {
	  api.assertVersion(7);
	  const {
	    throwIfClosureRequired = false,
	    tdz: tdzEnabled = false
	  } = opts;
	  if (typeof throwIfClosureRequired !== "boolean") {
	    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);
	  }
	  if (typeof tdzEnabled !== "boolean") {
	    throw new Error(`.tdz must be a boolean, or undefined`);
	  }
	  return {
	    name: "transform-block-scoping",
	    visitor: _core.traverse.visitors.merge([_annexB_3_.annexB33FunctionsVisitor, {
	      Loop(path, state) {
	        const isForStatement = path.isForStatement();
	        const headPath = isForStatement ? path.get("init") : path.isForXStatement() ? path.get("left") : null;
	        let needsBodyWrap = false;
	        const markNeedsBodyWrap = () => {
	          if (throwIfClosureRequired) {
	            throw path.buildCodeFrameError("Compiling let/const in this block would add a closure (throwIfClosureRequired).");
	          }
	          needsBodyWrap = true;
	        };
	        const body = path.get("body");
	        let bodyScope;
	        if (body.isBlockStatement()) {
	          bodyScope = body.scope;
	        }
	        const bindings = (0, _loop.getLoopBodyBindings)(path);
	        for (const binding of bindings) {
	          const {
	            capturedInClosure
	          } = (0, _loop.getUsageInBody)(binding, path);
	          if (capturedInClosure) markNeedsBodyWrap();
	        }
	        const captured = [];
	        const updatedBindingsUsages = /* @__PURE__ */ new Map();
	        if (headPath && isBlockScoped(headPath)) {
	          const names = Object.keys(headPath.getBindingIdentifiers());
	          const headScope = headPath.scope;
	          for (let name of names) {
	            var _bodyScope;
	            if ((_bodyScope = bodyScope) != null && _bodyScope.hasOwnBinding(name)) continue;
	            let binding = headScope.getOwnBinding(name);
	            if (!binding) {
	              headScope.crawl();
	              binding = headScope.getOwnBinding(name);
	            }
	            const {
	              usages,
	              capturedInClosure,
	              hasConstantViolations
	            } = (0, _loop.getUsageInBody)(binding, path);
	            if (headScope.parent.hasBinding(name) || headScope.parent.hasGlobal(name)) {
	              const newName = headScope.generateUid(name);
	              headScope.rename(name, newName);
	              name = newName;
	            }
	            if (capturedInClosure) {
	              markNeedsBodyWrap();
	              captured.push(name);
	            }
	            if (isForStatement && hasConstantViolations) {
	              updatedBindingsUsages.set(name, usages);
	            }
	          }
	        }
	        if (needsBodyWrap) {
	          const varPath = (0, _loop.wrapLoopBody)(path, captured, updatedBindingsUsages);
	          if (headPath != null && headPath.isVariableDeclaration()) {
	            transformBlockScopedVariable(headPath, state, tdzEnabled);
	          }
	          varPath.get("declarations.0.init").unwrapFunctionEnvironment();
	        }
	      },
	      VariableDeclaration(path, state) {
	        transformBlockScopedVariable(path, state, tdzEnabled);
	      },
	      ClassDeclaration(path) {
	        const {
	          id
	        } = path.node;
	        if (!id) return;
	        const {
	          scope
	        } = path.parentPath;
	        if (!(0, _annexB_3_.isVarScope)(scope) && scope.parent.hasBinding(id.name, {
	          noUids: true
	        })) {
	          path.scope.rename(id.name);
	        }
	      }
	    }])
	  };
	});
	const conflictingFunctionsVisitor = {
	  Scope(path, {
	    names
	  }) {
	    for (const name of names) {
	      const binding = path.scope.getOwnBinding(name);
	      if (binding && binding.kind === "hoisted") {
	        path.scope.rename(name);
	      }
	    }
	  },
	  "Expression|Declaration"(path) {
	    path.skip();
	  }
	};
	function transformBlockScopedVariable(path, state, tdzEnabled) {
	  if (!isBlockScoped(path)) return;
	  const dynamicTDZNames = (0, _validation.validateUsage)(path, state, tdzEnabled);
	  path.node.kind = "var";
	  const bindingNames = Object.keys(path.getBindingIdentifiers());
	  for (const name of bindingNames) {
	    const binding = path.scope.getOwnBinding(name);
	    if (!binding) continue;
	    binding.kind = "var";
	  }
	  if (isInLoop(path) && !(0, _loop.isVarInLoopHead)(path) || dynamicTDZNames.length > 0) {
	    for (const decl of path.node.declarations) {
	      var _decl$init;
	      (_decl$init = decl.init) != null ? _decl$init : decl.init = path.scope.buildUndefinedNode();
	    }
	  }
	  const blockScope = path.scope;
	  const varScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
	  if (varScope !== blockScope) {
	    for (const name of bindingNames) {
	      let newName = name;
	      if (blockScope.parent.hasBinding(name, {
	        noUids: true
	      }) || blockScope.parent.hasGlobal(name)) {
	        newName = blockScope.generateUid(name);
	        blockScope.rename(name, newName);
	      }
	      blockScope.moveBindingTo(newName, varScope);
	    }
	  }
	  blockScope.path.traverse(conflictingFunctionsVisitor, {
	    names: bindingNames
	  });
	  for (const name of dynamicTDZNames) {
	    path.scope.push({
	      id: _core.types.identifier(name),
	      init: state.addHelper("temporalUndefined")
	    });
	  }
	}
	function isLetOrConst(kind) {
	  return kind === "let" || kind === "const";
	}
	function isInLoop(path) {
	  if (!path.parentPath) return false;
	  if (path.parentPath.isLoop()) return true;
	  if (path.parentPath.isFunctionParent()) return false;
	  return isInLoop(path.parentPath);
	}
	function isBlockScoped(path) {
	  const {
	    node
	  } = path;
	  if (!_core.types.isVariableDeclaration(node)) return false;
	  const {
	    kind
	  } = node;
	  if (kind === "using" || kind === "await using") {
	    throw path.buildCodeFrameError(`The ${kind} declaration should be first transformed by \`@babel/plugin-proposal-explicit-resource-management\`.`);
	  } else if (!isLetOrConst(kind)) {
	    return false;
	  }
	  return true;
	}
	return lib$$;
}

var lib$_ = {};

var builtin = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es5 = {
	"Array": false,
	"Boolean": false,
	constructor: false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	propertyIsEnumerable: false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false
};
var es2015 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2017 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var browser = {
	AbortController: false,
	AbortSignal: false,
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	Animation: false,
	AnimationEffectReadOnly: false,
	AnimationEffectTiming: false,
	AnimationEffectTimingReadOnly: false,
	AnimationEvent: false,
	AnimationPlaybackEvent: false,
	AnimationTimeline: false,
	applicationCache: false,
	ApplicationCache: false,
	ApplicationCacheErrorEvent: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioDestinationNode: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioProcessingEvent: false,
	AudioScheduledSourceNode: false,
	"AudioWorkletGlobalScope ": false,
	AudioWorkletNode: false,
	AudioWorkletProcessor: false,
	BarProp: false,
	BaseAudioContext: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	BlobEvent: false,
	blur: false,
	BroadcastChannel: false,
	btoa: false,
	BudgetService: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	cancelIdleCallback: false,
	CanvasCaptureMediaStreamTrack: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	ClipboardEvent: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	confirm: false,
	console: false,
	ConstantSourceNode: false,
	ConvolverNode: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	Credential: false,
	CredentialsContainer: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSConditionRule: false,
	CSSFontFaceRule: false,
	CSSGroupingRule: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSMediaRule: false,
	CSSNamespaceRule: false,
	CSSPageRule: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSSupportsRule: false,
	CustomElementRegistry: false,
	customElements: false,
	CustomEvent: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	defaultstatus: false,
	defaultStatus: false,
	DelayNode: false,
	DeviceMotionEvent: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMParser: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	Element: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontFace: false,
	FontFaceSetLoadEvent: false,
	FormData: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadButton: false,
	GamepadEvent: false,
	getComputedStyle: false,
	getSelection: false,
	HashChangeEvent: false,
	Headers: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLContentElement: false,
	HTMLDataElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLLabelElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLShadowElement: false,
	HTMLSlotElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTimeElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdleDeadline: false,
	IIRFilterNode: false,
	Image: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageCapture: false,
	ImageData: false,
	indexedDB: false,
	innerHeight: false,
	innerWidth: false,
	InputEvent: false,
	IntersectionObserver: false,
	IntersectionObserverEntry: false,
	"Intl": false,
	isSecureContext: false,
	KeyboardEvent: false,
	KeyframeEffect: false,
	KeyframeEffectReadOnly: false,
	length: false,
	localStorage: false,
	location: true,
	Location: false,
	locationbar: false,
	matchMedia: false,
	MediaDeviceInfo: false,
	MediaDevices: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyMessageEvent: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaRecorder: false,
	MediaSettingsRange: false,
	MediaSource: false,
	MediaStream: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	MediaStreamTrackEvent: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	NavigationPreloadManager: false,
	navigator: false,
	Navigator: false,
	NetworkInformation: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	OffscreenCanvas: true,
	onabort: true,
	onafterprint: true,
	onanimationend: true,
	onanimationiteration: true,
	onanimationstart: true,
	onappinstalled: true,
	onauxclick: true,
	onbeforeinstallprompt: true,
	onbeforeprint: true,
	onbeforeunload: true,
	onblur: true,
	oncancel: true,
	oncanplay: true,
	oncanplaythrough: true,
	onchange: true,
	onclick: true,
	onclose: true,
	oncontextmenu: true,
	oncuechange: true,
	ondblclick: true,
	ondevicemotion: true,
	ondeviceorientation: true,
	ondeviceorientationabsolute: true,
	ondrag: true,
	ondragend: true,
	ondragenter: true,
	ondragleave: true,
	ondragover: true,
	ondragstart: true,
	ondrop: true,
	ondurationchange: true,
	onemptied: true,
	onended: true,
	onerror: true,
	onfocus: true,
	ongotpointercapture: true,
	onhashchange: true,
	oninput: true,
	oninvalid: true,
	onkeydown: true,
	onkeypress: true,
	onkeyup: true,
	onlanguagechange: true,
	onload: true,
	onloadeddata: true,
	onloadedmetadata: true,
	onloadstart: true,
	onlostpointercapture: true,
	onmessage: true,
	onmessageerror: true,
	onmousedown: true,
	onmouseenter: true,
	onmouseleave: true,
	onmousemove: true,
	onmouseout: true,
	onmouseover: true,
	onmouseup: true,
	onmousewheel: true,
	onoffline: true,
	ononline: true,
	onpagehide: true,
	onpageshow: true,
	onpause: true,
	onplay: true,
	onplaying: true,
	onpointercancel: true,
	onpointerdown: true,
	onpointerenter: true,
	onpointerleave: true,
	onpointermove: true,
	onpointerout: true,
	onpointerover: true,
	onpointerup: true,
	onpopstate: true,
	onprogress: true,
	onratechange: true,
	onrejectionhandled: true,
	onreset: true,
	onresize: true,
	onscroll: true,
	onsearch: true,
	onseeked: true,
	onseeking: true,
	onselect: true,
	onstalled: true,
	onstorage: true,
	onsubmit: true,
	onsuspend: true,
	ontimeupdate: true,
	ontoggle: true,
	ontransitionend: true,
	onunhandledrejection: true,
	onunload: true,
	onvolumechange: true,
	onwaiting: true,
	onwheel: true,
	open: false,
	openDatabase: false,
	opener: false,
	Option: false,
	origin: false,
	OscillatorNode: false,
	outerHeight: false,
	outerWidth: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	PannerNode: false,
	parent: false,
	Path2D: false,
	PaymentAddress: false,
	PaymentRequest: false,
	PaymentRequestUpdateEvent: false,
	PaymentResponse: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceLongTaskTiming: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceNavigationTiming: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformancePaintTiming: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	personalbar: false,
	PhotoCapabilities: false,
	Plugin: false,
	PluginArray: false,
	PointerEvent: false,
	PopStateEvent: false,
	postMessage: false,
	Presentation: false,
	PresentationAvailability: false,
	PresentationConnection: false,
	PresentationConnectionAvailableEvent: false,
	PresentationConnectionCloseEvent: false,
	PresentationConnectionList: false,
	PresentationReceiver: false,
	PresentationRequest: false,
	print: false,
	ProcessingInstruction: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	prompt: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queueMicrotask: false,
	RadioNodeList: false,
	Range: false,
	ReadableStream: false,
	registerProcessor: false,
	RemotePlayback: false,
	removeEventListener: false,
	Request: false,
	requestAnimationFrame: false,
	requestIdleCallback: false,
	resizeBy: false,
	ResizeObserver: false,
	ResizeObserverEntry: false,
	resizeTo: false,
	Response: false,
	RTCCertificate: false,
	RTCDataChannel: false,
	RTCDataChannelEvent: false,
	RTCDtlsTransport: false,
	RTCIceCandidate: false,
	RTCIceGatherer: false,
	RTCIceTransport: false,
	RTCPeerConnection: false,
	RTCPeerConnectionIceEvent: false,
	RTCRtpContributingSource: false,
	RTCRtpReceiver: false,
	RTCRtpSender: false,
	RTCSctpTransport: false,
	RTCSessionDescription: false,
	RTCStatsReport: false,
	RTCTrackEvent: false,
	screen: false,
	Screen: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	SourceBuffer: false,
	SourceBufferList: false,
	speechSynthesis: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	StaticRange: false,
	status: false,
	statusbar: false,
	StereoPannerNode: false,
	stop: false,
	Storage: false,
	StorageEvent: false,
	StorageManager: false,
	styleMedia: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAngle: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGComponentTransferFunctionElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGDiscardElement: false,
	SVGElement: false,
	SVGEllipseElement: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGImageElement: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPathElement: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformList: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGUseElement: false,
	SVGViewElement: false,
	TaskAttributionTiming: false,
	Text: false,
	TextDecoder: false,
	TextEncoder: false,
	TextEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TimeRanges: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransitionEvent: false,
	TreeWalker: false,
	UIEvent: false,
	URL: false,
	URLSearchParams: false,
	ValidityState: false,
	visualViewport: false,
	VisualViewport: false,
	VTTCue: false,
	WaveShaperNode: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	WebSocket: false,
	WheelEvent: false,
	window: false,
	Window: false,
	Worker: false,
	WritableStream: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathExpression: false,
	XPathResult: false,
	XSLTProcessor: false
};
var worker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	clearInterval: false,
	clearTimeout: false,
	close: true,
	console: false,
	fetch: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: true,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onoffline: true,
	ononline: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: true,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var node = {
	__dirname: false,
	__filename: false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	exports: true,
	global: false,
	"Intl": false,
	module: false,
	process: false,
	queueMicrotask: false,
	require: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var commonjs = {
	exports: true,
	global: false,
	module: false,
	require: false
};
var amd = {
	define: false,
	require: false
};
var mocha = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	run: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	spyOnProperty: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fdescribe: false,
	fit: false,
	it: false,
	jest: false,
	pit: false,
	require: false,
	test: false,
	xdescribe: false,
	xit: false,
	xtest: false
};
var qunit = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	java: false,
	Java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh = {
	ActiveXObject: true,
	Enumerator: true,
	GetObject: true,
	ScriptEngine: true,
	ScriptEngineBuildVersion: true,
	ScriptEngineMajorVersion: true,
	ScriptEngineMinorVersion: true,
	VBArray: true,
	WScript: true,
	WSH: true,
	XDomainRequest: true
};
var jquery = {
	$: false,
	jQuery: false
};
var yui = {
	YAHOO: false,
	YAHOO_config: false,
	YUI: false,
	YUI_config: false
};
var shelljs = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	ln: false,
	ls: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	set: false,
	target: false,
	tempdir: false,
	test: false,
	touch: false,
	which: false
};
var prototypejs = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor = {
	_: false,
	$: false,
	Accounts: false,
	AccountsClient: false,
	AccountsCommon: false,
	AccountsServer: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPRateLimiter: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	ServiceConfiguration: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	ISODate: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	NumberInt: false,
	NumberLong: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	clearInterval: false,
	clearTimeout: false,
	Client: false,
	clients: false,
	Clients: false,
	close: true,
	console: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	fetch: false,
	FetchEvent: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: false,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onfetch: true,
	oninstall: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onnotificationclick: true,
	onnotificationclose: true,
	onoffline: true,
	ononline: true,
	onpush: true,
	onpushsubscriptionchange: true,
	onrejectionhandled: true,
	onsync: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	registration: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	skipWaiting: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	WindowClient: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var atomtest = {
	advanceClock: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findAll: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	resumeTest: false,
	triggerEvent: false,
	visit: false,
	wait: false
};
var protractor = {
	$: false,
	$$: false,
	browser: false,
	by: false,
	By: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey = {
	cloneInto: false,
	createObjectIn: false,
	exportFunction: false,
	GM: false,
	GM_addStyle: false,
	GM_deleteValue: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var devtools = {
	$: false,
	$_: false,
	$$: false,
	$0: false,
	$1: false,
	$2: false,
	$3: false,
	$4: false,
	$x: false,
	chrome: false,
	clear: false,
	copy: false,
	debug: false,
	dir: false,
	dirxml: false,
	getEventListeners: false,
	inspect: false,
	keys: false,
	monitor: false,
	monitorEvents: false,
	profile: false,
	profileEnd: false,
	queryObjects: false,
	table: false,
	undebug: false,
	unmonitor: false,
	unmonitorEvents: false,
	values: false
};
var require$$0$5 = {
	builtin: builtin,
	es5: es5,
	es2015: es2015,
	es2017: es2017,
	browser: browser,
	worker: worker,
	node: node,
	commonjs: commonjs,
	amd: amd,
	mocha: mocha,
	jasmine: jasmine,
	jest: jest,
	qunit: qunit,
	phantomjs: phantomjs,
	couch: couch,
	rhino: rhino,
	nashorn: nashorn,
	wsh: wsh,
	jquery: jquery,
	yui: yui,
	shelljs: shelljs,
	prototypejs: prototypejs,
	meteor: meteor,
	mongo: mongo,
	applescript: applescript,
	serviceworker: serviceworker,
	atomtest: atomtest,
	embertest: embertest,
	protractor: protractor,
	"shared-node-browser": {
	clearInterval: false,
	clearTimeout: false,
	console: false,
	setInterval: false,
	setTimeout: false,
	URL: false,
	URLSearchParams: false
},
	webextensions: webextensions,
	greasemonkey: greasemonkey,
	devtools: devtools
};

var globals;
var hasRequiredGlobals;

function requireGlobals () {
	if (hasRequiredGlobals) return globals;
	hasRequiredGlobals = 1;
	globals = require$$0$5;
	return globals;
}

var transformClass = {};

var lib$Z = {};

var lib$Y = {};

var hasRequiredLib$$;

function requireLib$$ () {
	if (hasRequiredLib$$) return lib$Y;
	hasRequiredLib$$ = 1;
	Object.defineProperty(lib$Y, "__esModule", { value: true });
	var _t = require$$0$a;
	function _interopNamespace(e) {
	  if (e && e.__esModule) return e;
	  var n = /* @__PURE__ */ Object.create(null);
	  if (e) {
	    Object.keys(e).forEach(function(k) {
	      if (k !== "default") {
	        var d = Object.getOwnPropertyDescriptor(e, k);
	        Object.defineProperty(n, k, d.get ? d : {
	          enumerable: true,
	          get: function() {
	            return e[k];
	          }
	        });
	      }
	    });
	  }
	  n.default = e;
	  return Object.freeze(n);
	}
	var _t__namespace = /* @__PURE__ */ _interopNamespace(_t);
	function willPathCastToBoolean(path) {
	  const maybeWrapped = path;
	  const {
	    node,
	    parentPath
	  } = maybeWrapped;
	  if (parentPath.isLogicalExpression()) {
	    const {
	      operator,
	      right
	    } = parentPath.node;
	    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
	      return willPathCastToBoolean(parentPath);
	    }
	  }
	  if (parentPath.isSequenceExpression()) {
	    const {
	      expressions
	    } = parentPath.node;
	    if (expressions[expressions.length - 1] === node) {
	      return willPathCastToBoolean(parentPath);
	    } else {
	      return true;
	    }
	  }
	  return parentPath.isConditional({
	    test: node
	  }) || parentPath.isUnaryExpression({
	    operator: "!"
	  }) || parentPath.isLoop({
	    test: node
	  });
	}
	const {
	  LOGICAL_OPERATORS,
	  arrowFunctionExpression,
	  assignmentExpression,
	  binaryExpression,
	  booleanLiteral,
	  callExpression,
	  cloneNode,
	  conditionalExpression,
	  identifier,
	  isMemberExpression,
	  isOptionalCallExpression,
	  isOptionalMemberExpression,
	  isUpdateExpression,
	  logicalExpression,
	  memberExpression,
	  nullLiteral,
	  optionalCallExpression,
	  optionalMemberExpression,
	  sequenceExpression,
	  updateExpression
	} = _t__namespace;
	class AssignmentMemoiser {
	  constructor() {
	    this._map = void 0;
	    this._map = /* @__PURE__ */ new WeakMap();
	  }
	  has(key) {
	    return this._map.has(key);
	  }
	  get(key) {
	    if (!this.has(key)) return;
	    const record = this._map.get(key);
	    const {
	      value
	    } = record;
	    record.count--;
	    if (record.count === 0) {
	      return assignmentExpression("=", value, key);
	    }
	    return value;
	  }
	  set(key, value, count) {
	    return this._map.set(key, {
	      count,
	      value
	    });
	  }
	}
	function toNonOptional(path, base) {
	  const {
	    node
	  } = path;
	  if (isOptionalMemberExpression(node)) {
	    return memberExpression(base, node.property, node.computed);
	  }
	  if (path.isOptionalCallExpression()) {
	    const callee = path.get("callee");
	    if (path.node.optional && callee.isOptionalMemberExpression()) {
	      const object = callee.node.object;
	      const context = path.scope.maybeGenerateMemoised(object);
	      callee.get("object").replaceWith(assignmentExpression("=", context, object));
	      return callExpression(memberExpression(base, identifier("call")), [context, ...path.node.arguments]);
	    }
	    return callExpression(base, path.node.arguments);
	  }
	  return path.node;
	}
	function isInDetachedTree(path) {
	  while (path) {
	    if (path.isProgram()) break;
	    const {
	      parentPath,
	      container,
	      listKey
	    } = path;
	    const parentNode = parentPath.node;
	    if (listKey) {
	      if (container !== parentNode[listKey]) {
	        return true;
	      }
	    } else {
	      if (container !== parentNode) return true;
	    }
	    path = parentPath;
	  }
	  return false;
	}
	const handle = {
	  memoise() {
	  },
	  handle(member, noDocumentAll) {
	    const {
	      node,
	      parent,
	      parentPath,
	      scope
	    } = member;
	    if (member.isOptionalMemberExpression()) {
	      if (isInDetachedTree(member)) return;
	      const endPath = member.find(({
	        node: node2,
	        parent: parent2
	      }) => {
	        if (isOptionalMemberExpression(parent2)) {
	          return parent2.optional || parent2.object !== node2;
	        }
	        if (isOptionalCallExpression(parent2)) {
	          return node2 !== member.node && parent2.optional || parent2.callee !== node2;
	        }
	        return true;
	      });
	      if (scope.path.isPattern()) {
	        endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
	        return;
	      }
	      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);
	      const rootParentPath = endPath.parentPath;
	      if (rootParentPath.isUpdateExpression({
	        argument: node
	      })) {
	        throw member.buildCodeFrameError(`can't handle update expression`);
	      }
	      const isAssignment = rootParentPath.isAssignmentExpression({
	        left: endPath.node
	      });
	      const isDeleteOperation = rootParentPath.isUnaryExpression({
	        operator: "delete"
	      });
	      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
	        throw member.buildCodeFrameError(`can't delete a private class element`);
	      }
	      let startingOptional = member;
	      for (; ; ) {
	        if (startingOptional.isOptionalMemberExpression()) {
	          if (startingOptional.node.optional) break;
	          startingOptional = startingOptional.get("object");
	          continue;
	        } else if (startingOptional.isOptionalCallExpression()) {
	          if (startingOptional.node.optional) break;
	          startingOptional = startingOptional.get("callee");
	          continue;
	        }
	        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
	      }
	      const startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee;
	      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
	      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
	      const parentIsOptionalCall = parentPath.isOptionalCallExpression({
	        callee: node
	      });
	      const isOptionalCall = (parent2) => parentIsOptionalCall;
	      const parentIsCall = parentPath.isCallExpression({
	        callee: node
	      });
	      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));
	      if (isOptionalCall()) {
	        if (parent.optional) {
	          parentPath.replaceWith(this.optionalCall(member, parent.arguments));
	        } else {
	          parentPath.replaceWith(this.call(member, parent.arguments));
	        }
	      } else if (parentIsCall) {
	        member.replaceWith(this.boundGet(member));
	      } else if (this.delete && parentPath.isUnaryExpression({
	        operator: "delete"
	      })) {
	        parentPath.replaceWith(this.delete(member));
	      } else if (parentPath.isAssignmentExpression()) {
	        handleAssignment(this, member, parentPath);
	      } else {
	        member.replaceWith(this.get(member));
	      }
	      let regular = member.node;
	      for (let current = member; current !== endPath; ) {
	        const parentPath2 = current.parentPath;
	        if (parentPath2 === endPath && isOptionalCall() && parent.optional) {
	          regular = parentPath2.node;
	          break;
	        }
	        regular = toNonOptional(parentPath2, regular);
	        current = parentPath2;
	      }
	      let context;
	      const endParentPath = endPath.parentPath;
	      if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
	        callee: endPath.node,
	        optional: true
	      })) {
	        const {
	          object
	        } = regular;
	        context = member.scope.maybeGenerateMemoised(object);
	        if (context) {
	          regular.object = assignmentExpression("=", context, object);
	        }
	      }
	      let replacementPath = endPath;
	      if (isDeleteOperation || isAssignment) {
	        replacementPath = endParentPath;
	        regular = endParentPath.node;
	      }
	      const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
	      if (willEndPathCastToBoolean) {
	        let nonNullishCheck;
	        if (noDocumentAll) {
	          nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral());
	        } else {
	          nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode()));
	        }
	        replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
	      } else {
	        let nullishCheck;
	        if (noDocumentAll) {
	          nullishCheck = binaryExpression("==", baseMemoised, nullLiteral());
	        } else {
	          nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode()));
	        }
	        replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
	      }
	      if (context) {
	        const endParent = endParentPath.node;
	        endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context), ...endParent.arguments], false));
	      }
	      return;
	    }
	    if (isUpdateExpression(parent, {
	      argument: node
	    })) {
	      if (this.simpleSet) {
	        member.replaceWith(this.simpleSet(member));
	        return;
	      }
	      const {
	        operator,
	        prefix
	      } = parent;
	      this.memoise(member, 2);
	      const ref = scope.generateUidIdentifierBasedOnNode(node);
	      scope.push({
	        id: ref
	      });
	      const seq = [assignmentExpression("=", cloneNode(ref), this.get(member))];
	      if (prefix) {
	        seq.push(updateExpression(operator, cloneNode(ref), prefix));
	        const value = sequenceExpression(seq);
	        parentPath.replaceWith(this.set(member, value));
	        return;
	      } else {
	        const ref2 = scope.generateUidIdentifierBasedOnNode(node);
	        scope.push({
	          id: ref2
	        });
	        seq.push(assignmentExpression("=", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));
	        const value = sequenceExpression(seq);
	        parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref2)]));
	        return;
	      }
	    }
	    if (parentPath.isAssignmentExpression({
	      left: node
	    })) {
	      handleAssignment(this, member, parentPath);
	      return;
	    }
	    if (parentPath.isCallExpression({
	      callee: node
	    })) {
	      parentPath.replaceWith(this.call(member, parentPath.node.arguments));
	      return;
	    }
	    if (parentPath.isOptionalCallExpression({
	      callee: node
	    })) {
	      if (scope.path.isPattern()) {
	        parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
	        return;
	      }
	      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
	      return;
	    }
	    if (this.delete && parentPath.isUnaryExpression({
	      operator: "delete"
	    })) {
	      parentPath.replaceWith(this.delete(member));
	      return;
	    }
	    if (parentPath.isForXStatement({
	      left: node
	    }) || parentPath.isObjectProperty({
	      value: node
	    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
	      left: node
	    }) && parentPath.parentPath.isObjectProperty({
	      value: parent
	    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
	      left: node
	    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
	      member.replaceWith(this.destructureSet(member));
	      return;
	    }
	    if (parentPath.isTaggedTemplateExpression()) {
	      member.replaceWith(this.boundGet(member));
	    } else {
	      member.replaceWith(this.get(member));
	    }
	  }
	};
	function handleAssignment(state, member, parentPath) {
	  if (state.simpleSet) {
	    member.replaceWith(state.simpleSet(member));
	    return;
	  }
	  const {
	    operator,
	    right: value
	  } = parentPath.node;
	  if (operator === "=") {
	    parentPath.replaceWith(state.set(member, value));
	  } else {
	    const operatorTrunc = operator.slice(0, -1);
	    if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
	      state.memoise(member, 1);
	      parentPath.replaceWith(logicalExpression(operatorTrunc, state.get(member), state.set(member, value)));
	    } else {
	      state.memoise(member, 2);
	      parentPath.replaceWith(state.set(member, binaryExpression(operatorTrunc, state.get(member), value)));
	    }
	  }
	}
	function memberExpressionToFunctions(path, visitor, state) {
	  path.traverse(visitor, Object.assign({}, handle, state, {
	    memoiser: new AssignmentMemoiser()
	  }));
	}
	lib$Y.default = memberExpressionToFunctions;
	return lib$Y;
}

var lib$X = {};

var hasRequiredLib$_;

function requireLib$_ () {
	if (hasRequiredLib$_) return lib$X;
	hasRequiredLib$_ = 1;
	Object.defineProperty(lib$X, "__esModule", {
	  value: true
	});
	lib$X.default = optimiseCallExpression;
	var _t = require$$0$a;
	const {
	  callExpression,
	  identifier,
	  isIdentifier,
	  isSpreadElement,
	  memberExpression,
	  optionalCallExpression,
	  optionalMemberExpression
	} = _t;
	function optimiseCallExpression(callee, thisNode, args, optional) {
	  if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
	    name: "arguments"
	  })) {
	    if (optional) {
	      return optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false);
	    }
	    return callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]);
	  } else {
	    if (optional) {
	      return optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode, ...args], false);
	    }
	    return callExpression(memberExpression(callee, identifier("call")), [thisNode, ...args]);
	  }
	}
	return lib$X;
}

var hasRequiredLib$Z;

function requireLib$Z () {
	if (hasRequiredLib$Z) return lib$Z;
	hasRequiredLib$Z = 1;
	Object.defineProperty(lib$Z, "__esModule", {
	  value: true
	});
	lib$Z.default = void 0;
	var _helperMemberExpressionToFunctions = requireLib$$();
	var _helperOptimiseCallExpression = requireLib$_();
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	const {
	  assignmentExpression,
	  callExpression,
	  cloneNode,
	  identifier,
	  memberExpression,
	  sequenceExpression,
	  stringLiteral,
	  thisExpression
	} = _core.types;
	{
	  lib$Z.environmentVisitor = _traverse.visitors.environmentVisitor({});
	  lib$Z.skipAllButComputedKey = function skipAllButComputedKey(path) {
	    path.skip();
	    if (path.node.computed) {
	      path.context.maybeQueue(path.get("key"));
	    }
	  };
	}
	const visitor = _traverse.visitors.environmentVisitor({
	  Super(path, state) {
	    const {
	      node,
	      parentPath
	    } = path;
	    if (!parentPath.isMemberExpression({
	      object: node
	    })) return;
	    state.handle(parentPath);
	  }
	});
	const unshadowSuperBindingVisitor = _traverse.visitors.environmentVisitor({
	  Scopable(path, {
	    refName
	  }) {
	    const binding = path.scope.getOwnBinding(refName);
	    if (binding && binding.identifier.name === refName) {
	      path.scope.rename(refName);
	    }
	  }
	});
	const specHandlers = {
	  memoise(superMember, count) {
	    const {
	      scope,
	      node
	    } = superMember;
	    const {
	      computed,
	      property
	    } = node;
	    if (!computed) {
	      return;
	    }
	    const memo = scope.maybeGenerateMemoised(property);
	    if (!memo) {
	      return;
	    }
	    this.memoiser.set(property, memo, count);
	  },
	  prop(superMember) {
	    const {
	      computed,
	      property
	    } = superMember.node;
	    if (this.memoiser.has(property)) {
	      return cloneNode(this.memoiser.get(property));
	    }
	    if (computed) {
	      return cloneNode(property);
	    }
	    return stringLiteral(property.name);
	  },
	  _getPrototypeOfExpression() {
	    const objectRef = cloneNode(this.getObjectRef());
	    const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
	    return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
	  },
	  get(superMember) {
	    const objectRef = cloneNode(this.getObjectRef());
	    return callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), ...this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)]]);
	  },
	  _call(superMember, args, optional) {
	    const objectRef = cloneNode(this.getObjectRef());
	    let argsNode;
	    if (args.length === 1 && _core.types.isSpreadElement(args[0]) && (_core.types.isIdentifier(args[0].argument) || _core.types.isArrayExpression(args[0].argument))) {
	      argsNode = args[0].argument;
	    } else {
	      argsNode = _core.types.arrayExpression(args);
	    }
	    const call = _core.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), _core.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
	    if (optional) {
	      return _core.types.optionalCallExpression(call, [argsNode], true);
	    }
	    return callExpression(call, [argsNode]);
	  },
	  set(superMember, value) {
	    const objectRef = cloneNode(this.getObjectRef());
	    return callExpression(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), value, thisExpression(), _core.types.numericLiteral(superMember.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)]]);
	  },
	  destructureSet(superMember) {
	    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
	  },
	  call(superMember, args) {
	    return this._call(superMember, args, false);
	  },
	  optionalCall(superMember, args) {
	    return this._call(superMember, args, true);
	  },
	  delete(superMember) {
	    if (superMember.node.computed) {
	      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]);
	    } else {
	      return _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
	    }
	  }
	};
	const specHandlers_old = {
	  memoise(superMember, count) {
	    const {
	      scope,
	      node
	    } = superMember;
	    const {
	      computed,
	      property
	    } = node;
	    if (!computed) {
	      return;
	    }
	    const memo = scope.maybeGenerateMemoised(property);
	    if (!memo) {
	      return;
	    }
	    this.memoiser.set(property, memo, count);
	  },
	  prop(superMember) {
	    const {
	      computed,
	      property
	    } = superMember.node;
	    if (this.memoiser.has(property)) {
	      return cloneNode(this.memoiser.get(property));
	    }
	    if (computed) {
	      return cloneNode(property);
	    }
	    return stringLiteral(property.name);
	  },
	  _getPrototypeOfExpression() {
	    const objectRef = cloneNode(this.getObjectRef());
	    const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
	    return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
	  },
	  get(superMember) {
	    return this._get(superMember);
	  },
	  _get(superMember) {
	    const proto = this._getPrototypeOfExpression();
	    return callExpression(this.file.addHelper("get"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), thisExpression()]);
	  },
	  set(superMember, value) {
	    const proto = this._getPrototypeOfExpression();
	    return callExpression(this.file.addHelper("set"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), value, thisExpression(), _core.types.booleanLiteral(superMember.isInStrictMode())]);
	  },
	  destructureSet(superMember) {
	    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
	  },
	  call(superMember, args) {
	    return (0, _helperOptimiseCallExpression.default)(this._get(superMember), thisExpression(), args, false);
	  },
	  optionalCall(superMember, args) {
	    return (0, _helperOptimiseCallExpression.default)(this._get(superMember), cloneNode(thisExpression()), args, true);
	  },
	  delete(superMember) {
	    if (superMember.node.computed) {
	      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]);
	    } else {
	      return _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
	    }
	  }
	};
	const looseHandlers = Object.assign({}, specHandlers, {
	  prop(superMember) {
	    const {
	      property
	    } = superMember.node;
	    if (this.memoiser.has(property)) {
	      return cloneNode(this.memoiser.get(property));
	    }
	    return cloneNode(property);
	  },
	  get(superMember) {
	    const {
	      isStatic,
	      getSuperRef
	    } = this;
	    const {
	      computed
	    } = superMember.node;
	    const prop = this.prop(superMember);
	    let object;
	    if (isStatic) {
	      var _getSuperRef;
	      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
	    } else {
	      var _getSuperRef2;
	      object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
	    }
	    return memberExpression(object, prop, computed);
	  },
	  set(superMember, value) {
	    const {
	      computed
	    } = superMember.node;
	    const prop = this.prop(superMember);
	    return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
	  },
	  destructureSet(superMember) {
	    const {
	      computed
	    } = superMember.node;
	    const prop = this.prop(superMember);
	    return memberExpression(thisExpression(), prop, computed);
	  },
	  call(superMember, args) {
	    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);
	  },
	  optionalCall(superMember, args) {
	    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);
	  }
	});
	class ReplaceSupers {
	  constructor(opts) {
	    var _opts$constantSuper;
	    const path = opts.methodPath;
	    this.methodPath = path;
	    this.isDerivedConstructor = path.isClassMethod({
	      kind: "constructor"
	    }) && !!opts.superRef;
	    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
	    this.isPrivateMethod = path.isPrivate() && path.isMethod();
	    this.file = opts.file;
	    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
	    this.opts = opts;
	  }
	  getObjectRef() {
	    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
	  }
	  getSuperRef() {
	    if (this.opts.superRef) return cloneNode(this.opts.superRef);
	    if (this.opts.getSuperRef) {
	      return cloneNode(this.opts.getSuperRef());
	    }
	  }
	  replace() {
	    const {
	      methodPath
	    } = this;
	    if (this.opts.refToPreserve) {
	      methodPath.traverse(unshadowSuperBindingVisitor, {
	        refName: this.opts.refToPreserve.name
	      });
	    }
	    const handler = this.constantSuper ? looseHandlers : this.file.availableHelper("superPropSet") ? specHandlers : specHandlers_old;
	    visitor.shouldSkip = (path) => {
	      if (path.parentPath === methodPath) {
	        if (path.parentKey === "decorators" || path.parentKey === "key") {
	          return true;
	        }
	      }
	    };
	    (0, _helperMemberExpressionToFunctions.default)(methodPath, visitor, Object.assign({
	      file: this.file,
	      scope: this.methodPath.scope,
	      isDerivedConstructor: this.isDerivedConstructor,
	      isStatic: this.isStatic,
	      isPrivateMethod: this.isPrivateMethod,
	      getObjectRef: this.getObjectRef.bind(this),
	      getSuperRef: this.getSuperRef.bind(this),
	      boundGet: handler.get
	    }, handler));
	  }
	}
	lib$Z.default = ReplaceSupers;
	return lib$Z;
}

var inlineCallSuperHelpers = {};

var hasRequiredInlineCallSuperHelpers;

function requireInlineCallSuperHelpers () {
	if (hasRequiredInlineCallSuperHelpers) return inlineCallSuperHelpers;
	hasRequiredInlineCallSuperHelpers = 1;
	Object.defineProperty(inlineCallSuperHelpers, "__esModule", {
	  value: true
	});
	inlineCallSuperHelpers.default = addCallSuperHelper;
	var _core = require$$0$b;
	const helper = _core.template.statement`
  function CALL_SUPER(
    _this,
    derived,
    args,
  ) {
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;

      // core-js@3
      if (Reflect.construct.sham) return false;

      // Proxy can't be polyfilled. Every browser implemented
      // proxies before or at the same time as Reflect.construct,
      // so if they support Proxy they also support Reflect.construct.
      if (typeof Proxy === "function") return true;

      // Since Reflect.construct can't be properly polyfilled, some
      // implementations (e.g. core-js@2) don't set the correct internal slots.
      // Those polyfills don't allow us to subclass built-ins, so we need to
      // use our fallback implementation.
      try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}),);
      } catch (e) {
        return false;
      }
    }

    // Super
    derived = GET_PROTOTYPE_OF(derived);
    return POSSIBLE_CONSTRUCTOR_RETURN(
      _this,
      isNativeReflectConstruct()
        ? // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          Reflect.construct(
            derived,
            args || [],
            GET_PROTOTYPE_OF(_this).constructor,
          )
        : derived.apply(_this, args),
    );
  }
`;
	const helperIDs = /* @__PURE__ */ new WeakMap();
	function addCallSuperHelper(file) {
	  if (helperIDs.has(file)) {
	    return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));
	  }
	  try {
	    return file.addHelper("callSuper");
	  } catch (_unused) {
	  }
	  const id = file.scope.generateUidIdentifier("callSuper");
	  helperIDs.set(file, id);
	  const fn = helper({
	    CALL_SUPER: id,
	    GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
	    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
	  });
	  file.path.unshiftContainer("body", [fn]);
	  file.scope.registerDeclaration(file.path.get("body.0"));
	  return _core.types.cloneNode(id);
	}
	return inlineCallSuperHelpers;
}

var hasRequiredTransformClass;

function requireTransformClass () {
	if (hasRequiredTransformClass) return transformClass;
	hasRequiredTransformClass = 1;
	Object.defineProperty(transformClass, "__esModule", {
	  value: true
	});
	transformClass.default = transformClass$1;
	var _helperReplaceSupers = requireLib$Z();
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	var _helperAnnotateAsPure = requireLib$17();
	var _inlineCallSuperHelpers = requireInlineCallSuperHelpers();
	function buildConstructor(classRef, constructorBody, node) {
	  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);
	  _core.types.inherits(func, node);
	  return func;
	}
	function transformClass$1(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {
	  const classState = {
	    parent: void 0,
	    scope: void 0,
	    node: void 0,
	    path: void 0,
	    file: void 0,
	    classId: void 0,
	    classRef: void 0,
	    superName: null,
	    superReturns: [],
	    isDerived: false,
	    extendsNative: false,
	    construct: void 0,
	    constructorBody: void 0,
	    userConstructor: void 0,
	    userConstructorPath: void 0,
	    hasConstructor: false,
	    body: [],
	    superThises: [],
	    pushedInherits: false,
	    pushedCreateClass: false,
	    protoAlias: null,
	    isLoose: false,
	    dynamicKeys: /* @__PURE__ */ new Map(),
	    methods: {
	      instance: {
	        hasComputed: false,
	        list: [],
	        map: /* @__PURE__ */ new Map()
	      },
	      static: {
	        hasComputed: false,
	        list: [],
	        map: /* @__PURE__ */ new Map()
	      }
	    }
	  };
	  const setState = (newState) => {
	    Object.assign(classState, newState);
	  };
	  const findThisesVisitor = _traverse.visitors.environmentVisitor({
	    ThisExpression(path2) {
	      classState.superThises.push(path2);
	    }
	  });
	  function createClassHelper(args) {
	    return _core.types.callExpression(classState.file.addHelper("createClass"), args);
	  }
	  function maybeCreateConstructor() {
	    const classBodyPath = classState.path.get("body");
	    for (const path2 of classBodyPath.get("body")) {
	      if (path2.isClassMethod({
	        kind: "constructor"
	      })) return;
	    }
	    let params, body;
	    if (classState.isDerived) {
	      const constructor = _core.template.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
	      params = constructor.params;
	      body = constructor.body;
	    } else {
	      params = [];
	      body = _core.types.blockStatement([]);
	    }
	    classBodyPath.unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
	  }
	  function buildBody() {
	    maybeCreateConstructor();
	    pushBody();
	    verifyConstructor();
	    if (classState.userConstructor) {
	      const {
	        constructorBody,
	        userConstructor,
	        construct
	      } = classState;
	      constructorBody.body.push(...userConstructor.body.body);
	      _core.types.inherits(construct, userConstructor);
	      _core.types.inherits(constructorBody, userConstructor.body);
	    }
	    pushDescriptors();
	  }
	  function pushBody() {
	    const classBodyPaths = classState.path.get("body.body");
	    for (const path2 of classBodyPaths) {
	      const node = path2.node;
	      if (path2.isClassProperty() || path2.isClassPrivateProperty()) {
	        throw path2.buildCodeFrameError("Missing class properties transform.");
	      }
	      if (node.decorators) {
	        throw path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
	      }
	      if (_core.types.isClassMethod(node)) {
	        const isConstructor = node.kind === "constructor";
	        const replaceSupers = new _helperReplaceSupers.default({
	          methodPath: path2,
	          objectRef: classState.classRef,
	          superRef: classState.superName,
	          constantSuper: assumptions.constantSuper,
	          file: classState.file,
	          refToPreserve: classState.classRef
	        });
	        replaceSupers.replace();
	        const superReturns = [];
	        path2.traverse(_traverse.visitors.environmentVisitor({
	          ReturnStatement(path3) {
	            if (!path3.getFunctionParent().isArrowFunctionExpression()) {
	              superReturns.push(path3);
	            }
	          }
	        }));
	        if (isConstructor) {
	          pushConstructor(superReturns, node, path2);
	        } else {
	          {
	            var _path$ensureFunctionN;
	            (_path$ensureFunctionN = path2.ensureFunctionName) != null ? _path$ensureFunctionN : path2.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	          }
	          path2.ensureFunctionName(supportUnicodeId);
	          let wrapped;
	          if (node !== path2.node) {
	            wrapped = path2.node;
	            path2.replaceWith(node);
	          }
	          pushMethod(node, wrapped);
	        }
	      }
	    }
	  }
	  function pushDescriptors() {
	    pushInheritsToBody();
	    const {
	      body
	    } = classState;
	    const props = {
	      instance: null,
	      static: null
	    };
	    for (const placement of ["static", "instance"]) {
	      if (classState.methods[placement].list.length) {
	        props[placement] = classState.methods[placement].list.map((desc) => {
	          const obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("key"), desc.key)]);
	          for (const kind of ["get", "set", "value"]) {
	            if (desc[kind] != null) {
	              obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));
	            }
	          }
	          return obj;
	        });
	      }
	    }
	    if (props.instance || props.static) {
	      let args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()];
	      let lastNonNullIndex = 0;
	      for (let i = 0; i < args.length; i++) {
	        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;
	      }
	      args = args.slice(0, lastNonNullIndex + 1);
	      body.push(_core.types.returnStatement(createClassHelper(args)));
	      classState.pushedCreateClass = true;
	    }
	  }
	  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
	    const bareSuperNode = bareSuper.node;
	    let call;
	    if (assumptions.superIsCallableConstructor) {
	      bareSuperNode.arguments.unshift(_core.types.thisExpression());
	      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
	        name: "arguments"
	      })) {
	        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
	        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"));
	      } else {
	        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call"));
	      }
	      call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression());
	    } else {
	      var _bareSuperNode$argume;
	      const args = [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)];
	      if ((_bareSuperNode$argume = bareSuperNode.arguments) != null && _bareSuperNode$argume.length) {
	        const bareSuperNodeArguments = bareSuperNode.arguments;
	        if (bareSuperNodeArguments.length === 1 && _core.types.isSpreadElement(bareSuperNodeArguments[0]) && _core.types.isIdentifier(bareSuperNodeArguments[0].argument, {
	          name: "arguments"
	        })) {
	          args.push(bareSuperNodeArguments[0].argument);
	        } else {
	          args.push(_core.types.arrayExpression(bareSuperNodeArguments));
	        }
	      }
	      call = _core.types.callExpression((0, _inlineCallSuperHelpers.default)(classState.file), args);
	    }
	    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
	      if (classState.superThises.length) {
	        call = _core.types.assignmentExpression("=", thisRef(), call);
	      }
	      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));
	    } else {
	      bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
	    }
	  }
	  function verifyConstructor() {
	    if (!classState.isDerived) return;
	    const path2 = classState.userConstructorPath;
	    const body = path2.get("body");
	    const constructorBody = path2.get("body");
	    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;
	    path2.traverse(findThisesVisitor);
	    let thisRef = function() {
	      const ref = path2.scope.generateDeclaredUidIdentifier("this");
	      maxGuaranteedSuperBeforeIndex++;
	      thisRef = () => _core.types.cloneNode(ref);
	      return ref;
	    };
	    const buildAssertThisInitialized = function() {
	      return _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]);
	    };
	    const bareSupers = [];
	    path2.traverse(_traverse.visitors.environmentVisitor({
	      Super(path3) {
	        const {
	          node,
	          parentPath
	        } = path3;
	        if (parentPath.isCallExpression({
	          callee: node
	        })) {
	          bareSupers.unshift(parentPath);
	        }
	      }
	    }));
	    for (const bareSuper of bareSupers) {
	      wrapSuperCall(bareSuper, classState.superName, thisRef, body);
	      if (maxGuaranteedSuperBeforeIndex >= 0) {
	        let lastParentPath;
	        bareSuper.find(function(parentPath) {
	          if (parentPath === constructorBody) {
	            maxGuaranteedSuperBeforeIndex = Math.min(maxGuaranteedSuperBeforeIndex, lastParentPath.key);
	            return true;
	          }
	          const {
	            type
	          } = parentPath;
	          switch (type) {
	            case "ExpressionStatement":
	            case "SequenceExpression":
	            case "AssignmentExpression":
	            case "BinaryExpression":
	            case "MemberExpression":
	            case "CallExpression":
	            case "NewExpression":
	            case "VariableDeclarator":
	            case "VariableDeclaration":
	            case "BlockStatement":
	            case "ArrayExpression":
	            case "ObjectExpression":
	            case "ObjectProperty":
	            case "TemplateLiteral":
	              lastParentPath = parentPath;
	              return false;
	            default:
	              if (type === "LogicalExpression" && parentPath.node.left === lastParentPath.node || parentPath.isConditional() && parentPath.node.test === lastParentPath.node || type === "OptionalCallExpression" && parentPath.node.callee === lastParentPath.node || type === "OptionalMemberExpression" && parentPath.node.object === lastParentPath.node) {
	                lastParentPath = parentPath;
	                return false;
	              }
	          }
	          maxGuaranteedSuperBeforeIndex = -1;
	          return true;
	        });
	      }
	    }
	    const guaranteedCalls = /* @__PURE__ */ new Set();
	    for (const thisPath of classState.superThises) {
	      const {
	        node,
	        parentPath
	      } = thisPath;
	      if (parentPath.isMemberExpression({
	        object: node
	      })) {
	        thisPath.replaceWith(thisRef());
	        continue;
	      }
	      let thisIndex;
	      thisPath.find(function(parentPath2) {
	        if (parentPath2.parentPath === constructorBody) {
	          thisIndex = parentPath2.key;
	          return true;
	        }
	      });
	      let exprPath = thisPath.parentPath.isSequenceExpression() ? thisPath.parentPath : thisPath;
	      if (exprPath.listKey === "arguments" && (exprPath.parentPath.isCallExpression() || exprPath.parentPath.isOptionalCallExpression())) {
	        exprPath = exprPath.parentPath;
	      } else {
	        exprPath = null;
	      }
	      if (maxGuaranteedSuperBeforeIndex !== -1 && thisIndex > maxGuaranteedSuperBeforeIndex || guaranteedCalls.has(exprPath)) {
	        thisPath.replaceWith(thisRef());
	      } else {
	        if (exprPath) {
	          guaranteedCalls.add(exprPath);
	        }
	        thisPath.replaceWith(buildAssertThisInitialized());
	      }
	    }
	    let wrapReturn;
	    if (classState.isLoose) {
	      wrapReturn = (returnArg) => {
	        const thisExpr = buildAssertThisInitialized();
	        return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
	      };
	    } else {
	      wrapReturn = (returnArg) => {
	        const returnParams = [thisRef()];
	        if (returnArg != null) {
	          returnParams.push(returnArg);
	        }
	        return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), returnParams);
	      };
	    }
	    const bodyPaths = body.get("body");
	    const guaranteedSuperBeforeFinish = maxGuaranteedSuperBeforeIndex !== -1 && maxGuaranteedSuperBeforeIndex < bodyPaths.length;
	    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
	      body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : buildAssertThisInitialized()));
	    }
	    for (const returnPath of classState.superReturns) {
	      returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
	    }
	  }
	  function pushMethod(node, wrapped) {
	    if (node.kind === "method") {
	      if (processMethod(node)) return;
	    }
	    const placement = node.static ? "static" : "instance";
	    const methods = classState.methods[placement];
	    const descKey = node.kind === "method" ? "value" : node.kind;
	    const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);
	    methods.hasComputed = !_core.types.isStringLiteral(key);
	    const fn = wrapped != null ? wrapped : _core.types.toExpression(node);
	    let descriptor;
	    if (!methods.hasComputed && methods.map.has(key.value)) {
	      descriptor = methods.map.get(key.value);
	      descriptor[descKey] = fn;
	      if (descKey === "value") {
	        descriptor.get = null;
	        descriptor.set = null;
	      } else {
	        descriptor.value = null;
	      }
	    } else {
	      descriptor = {
	        key,
	        [descKey]: fn
	      };
	      methods.list.push(descriptor);
	      if (!methods.hasComputed) {
	        methods.map.set(key.value, descriptor);
	      }
	    }
	  }
	  function processMethod(node) {
	    if (assumptions.setClassMethods && !node.decorators) {
	      let {
	        classRef
	      } = classState;
	      if (!node.static) {
	        insertProtoAliasOnce();
	        classRef = classState.protoAlias;
	      }
	      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));
	      const func = _core.types.functionExpression(node.id, node.params, node.body, node.generator, node.async);
	      _core.types.inherits(func, node);
	      const expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));
	      _core.types.inheritsComments(expr, node);
	      classState.body.push(expr);
	      return true;
	    }
	    return false;
	  }
	  function insertProtoAliasOnce() {
	    if (classState.protoAlias === null) {
	      setState({
	        protoAlias: classState.scope.generateUidIdentifier("proto")
	      });
	      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype"));
	      const protoDeclaration = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);
	      classState.body.push(protoDeclaration);
	    }
	  }
	  function pushConstructor(superReturns, method, path2) {
	    setState({
	      userConstructorPath: path2,
	      userConstructor: method,
	      hasConstructor: true,
	      superReturns
	    });
	    const {
	      construct
	    } = classState;
	    _core.types.inheritsComments(construct, method);
	    construct.params = method.params;
	    _core.types.inherits(construct.body, method.body);
	    construct.body.directives = method.body.directives;
	    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
	      pushDescriptors();
	    }
	    pushInheritsToBody();
	  }
	  function pushInheritsToBody() {
	    if (!classState.isDerived || classState.pushedInherits) return;
	    classState.pushedInherits = true;
	    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));
	  }
	  function extractDynamicKeys() {
	    const {
	      dynamicKeys,
	      node,
	      scope
	    } = classState;
	    for (const elem of node.body.body) {
	      if (!_core.types.isClassMethod(elem) || !elem.computed) continue;
	      if (scope.isPure(elem.key, true)) continue;
	      const id = scope.generateUidIdentifierBasedOnNode(elem.key);
	      dynamicKeys.set(id.name, elem.key);
	      elem.key = id;
	    }
	  }
	  function setupClosureParamsArgs() {
	    const {
	      superName,
	      dynamicKeys
	    } = classState;
	    const closureParams = [];
	    const closureArgs = [];
	    if (classState.isDerived) {
	      let arg = _core.types.cloneNode(superName);
	      if (classState.extendsNative) {
	        arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
	        (0, _helperAnnotateAsPure.default)(arg);
	      }
	      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
	      closureParams.push(param);
	      closureArgs.push(arg);
	      setState({
	        superName: _core.types.cloneNode(param)
	      });
	    }
	    for (const [name, value] of dynamicKeys) {
	      closureParams.push(_core.types.identifier(name));
	      closureArgs.push(value);
	    }
	    return {
	      closureParams,
	      closureArgs
	    };
	  }
	  function classTransformer(path2, file2, builtinClasses2, isLoose2) {
	    setState({
	      parent: path2.parent,
	      scope: path2.scope,
	      node: path2.node,
	      path: path2,
	      file: file2,
	      isLoose: isLoose2
	    });
	    setState({
	      classId: classState.node.id,
	      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
	      superName: classState.node.superClass,
	      isDerived: !!classState.node.superClass,
	      constructorBody: _core.types.blockStatement([])
	    });
	    setState({
	      extendsNative: _core.types.isIdentifier(classState.superName) && builtinClasses2.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
	    });
	    const {
	      classRef,
	      node,
	      constructorBody
	    } = classState;
	    setState({
	      construct: buildConstructor(classRef, constructorBody, node)
	    });
	    extractDynamicKeys();
	    const {
	      body
	    } = classState;
	    const {
	      closureParams,
	      closureArgs
	    } = setupClosureParamsArgs();
	    buildBody();
	    if (!assumptions.noClassCalls) {
	      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));
	    }
	    const isStrict = path2.isInStrictMode();
	    let constructorOnly = body.length === 0;
	    if (constructorOnly && !isStrict) {
	      for (const param of classState.construct.params) {
	        if (!_core.types.isIdentifier(param)) {
	          constructorOnly = false;
	          break;
	        }
	      }
	    }
	    const directives = constructorOnly ? classState.construct.body.directives : [];
	    if (!isStrict) {
	      directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
	    }
	    if (constructorOnly) {
	      const expr = _core.types.toExpression(classState.construct);
	      return classState.isLoose ? expr : createClassHelper([expr]);
	    }
	    if (!classState.pushedCreateClass) {
	      body.push(_core.types.returnStatement(classState.isLoose ? _core.types.cloneNode(classState.classRef) : createClassHelper([_core.types.cloneNode(classState.classRef)])));
	    }
	    body.unshift(classState.construct);
	    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));
	    return _core.types.callExpression(container, closureArgs);
	  }
	  return classTransformer(path, file, builtinClasses, isLoose);
	}
	return transformClass;
}

var hasRequiredLib$Y;

function requireLib$Y () {
	if (hasRequiredLib$Y) return lib$_;
	hasRequiredLib$Y = 1;
	Object.defineProperty(lib$_, "__esModule", {
	  value: true
	});
	lib$_.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperCompilationTargets = requireLib$1g();
	var _helperAnnotateAsPure = requireLib$17();
	var _core = require$$0$b;
	var _globals = requireGlobals();
	var _transformClass = requireTransformClass();
	const getBuiltinClasses = (category) => Object.keys(_globals[category]).filter((name) => /^[A-Z]/.test(name));
	const builtinClasses = /* @__PURE__ */ new Set([...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser")]);
	lib$_.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
	  api.assertVersion(7);
	  const {
	    loose = false
	  } = options;
	  const setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : loose;
	  const constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : loose;
	  const superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : loose;
	  const noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : loose;
	  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
	  const VISITED = /* @__PURE__ */ new WeakSet();
	  return {
	    name: "transform-classes",
	    visitor: {
	      ExportDefaultDeclaration(path) {
	        if (!path.get("declaration").isClassDeclaration()) return;
	        {
	          var _path$splitExportDecl;
	          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require$$2$2.NodePath.prototype.splitExportDeclaration;
	        }
	        path.splitExportDeclaration();
	      },
	      ClassDeclaration(path) {
	        const {
	          node
	        } = path;
	        const ref = node.id ? _core.types.cloneNode(node.id) : path.scope.generateUidIdentifier("class");
	        path.replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]));
	      },
	      ClassExpression(path, state) {
	        const {
	          node
	        } = path;
	        if (VISITED.has(node)) return;
	        {
	          var _path$ensureFunctionN;
	          (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	        }
	        const replacement = path.ensureFunctionName(supportUnicodeId);
	        if (replacement && replacement.node !== node) return;
	        VISITED.add(node);
	        const [replacedPath] = path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {
	          setClassMethods,
	          constantSuper,
	          superIsCallableConstructor,
	          noClassCalls
	        }, supportUnicodeId));
	        if (replacedPath.isCallExpression()) {
	          (0, _helperAnnotateAsPure.default)(replacedPath);
	          const callee = replacedPath.get("callee");
	          if (callee.isArrowFunctionExpression()) {
	            callee.arrowFunctionToExpression();
	          }
	        }
	      }
	    }
	  };
	});
	return lib$_;
}

var lib$W = {};

var lib$V = {};

var fields = {};

var lib$U = {};

var hasRequiredLib$X;

function requireLib$X () {
	if (hasRequiredLib$X) return lib$U;
	hasRequiredLib$X = 1;
	Object.defineProperty(lib$U, "__esModule", {
	  value: true
	});
	lib$U.isTransparentExprWrapper = isTransparentExprWrapper;
	lib$U.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
	lib$U.skipTransparentExprWrappers = skipTransparentExprWrappers;
	var _t = require$$0$a;
	const {
	  isParenthesizedExpression,
	  isTSAsExpression,
	  isTSNonNullExpression,
	  isTSSatisfiesExpression,
	  isTSTypeAssertion,
	  isTypeCastExpression
	} = _t;
	function isTransparentExprWrapper(node) {
	  return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
	}
	function skipTransparentExprWrappers(path) {
	  while (isTransparentExprWrapper(path.node)) {
	    path = path.get("expression");
	  }
	  return path;
	}
	function skipTransparentExprWrapperNodes(node) {
	  while (isTransparentExprWrapper(node)) {
	    node = node.expression;
	  }
	  return node;
	}
	return lib$U;
}

var typescript = {};

var hasRequiredTypescript;

function requireTypescript () {
	if (hasRequiredTypescript) return typescript;
	hasRequiredTypescript = 1;
	Object.defineProperty(typescript, "__esModule", {
	  value: true
	});
	typescript.assertFieldTransformed = assertFieldTransformed;
	function assertFieldTransformed(path) {
	  if (path.node.declare || false) {
	    throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
	If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
	 - @babel/plugin-transform-class-properties
	 - @babel/plugin-transform-private-methods
	 - @babel/plugin-proposal-decorators`);
	  }
	}
	return typescript;
}

var hasRequiredFields;

function requireFields () {
	if (hasRequiredFields) return fields;
	hasRequiredFields = 1;
	Object.defineProperty(fields, "__esModule", {
	  value: true
	});
	fields.buildCheckInRHS = buildCheckInRHS;
	fields.buildFieldsInitNodes = buildFieldsInitNodes;
	fields.buildPrivateNamesMap = buildPrivateNamesMap;
	fields.buildPrivateNamesNodes = buildPrivateNamesNodes;
	fields.privateNameVisitorFactory = privateNameVisitorFactory;
	fields.transformPrivateNamesUsage = transformPrivateNamesUsage;
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	var _helperReplaceSupers = requireLib$Z();
	var _helperMemberExpressionToFunctions = requireLib$$();
	var _helperOptimiseCallExpression = requireLib$_();
	var _helperAnnotateAsPure = requireLib$17();
	var _helperSkipTransparentExpressionWrappers = requireLib$X();
	var ts = requireTypescript();
	{
	  var newHelpers = (file) => {
	    return file.availableHelper("classPrivateFieldGet2");
	  };
	}
	function buildPrivateNamesMap(className, privateFieldsAsSymbolsOrProperties, props, file) {
	  const privateNamesMap = /* @__PURE__ */ new Map();
	  let classBrandId;
	  for (const prop of props) {
	    if (prop.isPrivate()) {
	      const {
	        name
	      } = prop.node.key.id;
	      let update = privateNamesMap.get(name);
	      if (!update) {
	        const isMethod = !prop.isProperty();
	        const isStatic = prop.node.static;
	        let initAdded = false;
	        let id;
	        if (!privateFieldsAsSymbolsOrProperties && newHelpers(file) && isMethod && !isStatic) {
	          initAdded = !!classBrandId;
	          classBrandId != null ? classBrandId : classBrandId = prop.scope.generateUidIdentifier(`${className}_brand`);
	          id = classBrandId;
	        } else {
	          id = prop.scope.generateUidIdentifier(name);
	        }
	        update = {
	          id,
	          static: isStatic,
	          method: isMethod,
	          initAdded
	        };
	        privateNamesMap.set(name, update);
	      }
	      if (prop.isClassPrivateMethod()) {
	        if (prop.node.kind === "get") {
	          const {
	            body
	          } = prop.node.body;
	          let $;
	          if (body.length === 1 && _core.types.isReturnStatement($ = body[0]) && _core.types.isCallExpression($ = $.argument) && $.arguments.length === 1 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($ = $.callee)) {
	            update.getId = _core.types.cloneNode($);
	            update.getterDeclared = true;
	          } else {
	            update.getId = prop.scope.generateUidIdentifier(`get_${name}`);
	          }
	        } else if (prop.node.kind === "set") {
	          const {
	            params
	          } = prop.node;
	          const {
	            body
	          } = prop.node.body;
	          let $;
	          if (body.length === 1 && _core.types.isExpressionStatement($ = body[0]) && _core.types.isCallExpression($ = $.expression) && $.arguments.length === 2 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($.arguments[1], {
	            name: params[0].name
	          }) && _core.types.isIdentifier($ = $.callee)) {
	            update.setId = _core.types.cloneNode($);
	            update.setterDeclared = true;
	          } else {
	            update.setId = prop.scope.generateUidIdentifier(`set_${name}`);
	          }
	        } else if (prop.node.kind === "method") {
	          update.methodId = prop.scope.generateUidIdentifier(name);
	        }
	      }
	      privateNamesMap.set(name, update);
	    }
	  }
	  return privateNamesMap;
	}
	function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
	  const initNodes = [];
	  const injectedIds = /* @__PURE__ */ new Set();
	  for (const [name, value] of privateNamesMap) {
	    const {
	      static: isStatic,
	      method: isMethod,
	      getId,
	      setId
	    } = value;
	    const isGetterOrSetter = getId || setId;
	    const id = _core.types.cloneNode(value.id);
	    let init;
	    if (privateFieldsAsProperties) {
	      init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]);
	    } else if (privateFieldsAsSymbols) {
	      init = _core.types.callExpression(_core.types.identifier("Symbol"), [_core.types.stringLiteral(name)]);
	    } else if (!isStatic) {
	      if (injectedIds.has(id.name)) continue;
	      injectedIds.add(id.name);
	      init = _core.types.newExpression(_core.types.identifier(isMethod && (!isGetterOrSetter || newHelpers(state)) ? "WeakSet" : "WeakMap"), []);
	    }
	    if (init) {
	      if (!privateFieldsAsSymbols) {
	        (0, _helperAnnotateAsPure.default)(init);
	      }
	      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);
	    }
	  }
	  return initNodes;
	}
	function privateNameVisitorFactory(visitor) {
	  const nestedVisitor = _traverse.visitors.environmentVisitor(Object.assign({}, visitor));
	  const privateNameVisitor2 = Object.assign({}, visitor, {
	    Class(path) {
	      const {
	        privateNamesMap
	      } = this;
	      const body = path.get("body.body");
	      const visiblePrivateNames = new Map(privateNamesMap);
	      const redeclared = [];
	      for (const prop of body) {
	        if (!prop.isPrivate()) continue;
	        const {
	          name
	        } = prop.node.key.id;
	        visiblePrivateNames.delete(name);
	        redeclared.push(name);
	      }
	      if (!redeclared.length) {
	        return;
	      }
	      path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
	        redeclared
	      }));
	      path.traverse(privateNameVisitor2, Object.assign({}, this, {
	        privateNamesMap: visiblePrivateNames
	      }));
	      path.skipKey("body");
	    }
	  });
	  return privateNameVisitor2;
	}
	const privateNameVisitor = privateNameVisitorFactory({
	  PrivateName(path, {
	    noDocumentAll
	  }) {
	    const {
	      privateNamesMap,
	      redeclared
	    } = this;
	    const {
	      node,
	      parentPath
	    } = path;
	    if (!parentPath.isMemberExpression({
	      property: node
	    }) && !parentPath.isOptionalMemberExpression({
	      property: node
	    })) {
	      return;
	    }
	    const {
	      name
	    } = node.id;
	    if (!privateNamesMap.has(name)) return;
	    if (redeclared != null && redeclared.includes(name)) return;
	    this.handle(parentPath, noDocumentAll);
	  }
	});
	function unshadow(name, scope, innerBinding) {
	  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
	    var _scope;
	    scope.rename(name);
	    scope = scope.parent;
	  }
	}
	function buildCheckInRHS(rhs, file, inRHSIsObject) {
	  if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper("checkInRHS"))) return rhs;
	  return _core.types.callExpression(file.addHelper("checkInRHS"), [rhs]);
	}
	const privateInVisitor = privateNameVisitorFactory({
	  BinaryExpression(path, {
	    file
	  }) {
	    const {
	      operator,
	      left,
	      right
	    } = path.node;
	    if (operator !== "in") return;
	    if (!_core.types.isPrivateName(left)) return;
	    const {
	      privateFieldsAsProperties,
	      privateNamesMap,
	      redeclared
	    } = this;
	    const {
	      name
	    } = left.id;
	    if (!privateNamesMap.has(name)) return;
	    if (redeclared != null && redeclared.includes(name)) return;
	    unshadow(this.classRef.name, path.scope, this.innerBinding);
	    if (privateFieldsAsProperties) {
	      const {
	        id: id2
	      } = privateNamesMap.get(name);
	      path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id2)})
      `);
	      return;
	    }
	    const {
	      id,
	      static: isStatic
	    } = privateNamesMap.get(name);
	    if (isStatic) {
	      path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`);
	      return;
	    }
	    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);
	  }
	});
	function readOnlyError(file, name) {
	  return _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral(`#${name}`)]);
	}
	function writeOnlyError(file, name) {
	  if (!file.availableHelper("writeOnlyError")) {
	    console.warn(`@babel/helpers is outdated, update it to silence this warning.`);
	    return _core.types.buildUndefinedNode();
	  }
	  return _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral(`#${name}`)]);
	}
	function buildStaticPrivateFieldAccess(expr, noUninitializedPrivateFieldAccess) {
	  if (noUninitializedPrivateFieldAccess) return expr;
	  return _core.types.memberExpression(expr, _core.types.identifier("_"));
	}
	function autoInherits(fn) {
	  return function(member) {
	    return _core.types.inherits(fn.apply(this, arguments), member.node);
	  };
	}
	const privateNameHandlerSpec = {
	  memoise(member, count) {
	    const {
	      scope
	    } = member;
	    const {
	      object
	    } = member.node;
	    const memo = scope.maybeGenerateMemoised(object);
	    if (!memo) {
	      return;
	    }
	    this.memoiser.set(object, memo, count);
	  },
	  receiver(member) {
	    const {
	      object
	    } = member.node;
	    if (this.memoiser.has(object)) {
	      return _core.types.cloneNode(this.memoiser.get(object));
	    }
	    return _core.types.cloneNode(object);
	  },
	  get: autoInherits(function(member) {
	    const {
	      classRef,
	      privateNamesMap,
	      file,
	      innerBinding,
	      noUninitializedPrivateFieldAccess
	    } = this;
	    const privateName = member.node.property;
	    const {
	      name
	    } = privateName.id;
	    const {
	      id,
	      static: isStatic,
	      method: isMethod,
	      methodId,
	      getId,
	      setId
	    } = privateNamesMap.get(name);
	    const isGetterOrSetter = getId || setId;
	    const cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
	    if (isStatic) {
	      unshadow(classRef.name, member.scope, innerBinding);
	      if (!newHelpers(file)) {
	        const helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
	        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]);
	      }
	      const receiver = this.receiver(member);
	      const skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
	      if (!isMethod) {
	        if (skipCheck) {
	          return buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess);
	        }
	        return buildStaticPrivateFieldAccess(_core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]), noUninitializedPrivateFieldAccess);
	      }
	      if (getId) {
	        if (skipCheck) {
	          return _core.types.callExpression(cloneId(getId), [receiver]);
	        }
	        return _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(classRef), receiver, cloneId(getId)]);
	      }
	      if (setId) {
	        const err = _core.types.buildUndefinedNode();
	        if (skipCheck) return err;
	        return _core.types.sequenceExpression([_core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), err]);
	      }
	      if (skipCheck) return cloneId(id);
	      return _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]);
	    }
	    if (isMethod) {
	      if (isGetterOrSetter) {
	        if (!getId) {
	          return _core.types.sequenceExpression([this.receiver(member), writeOnlyError(file, name)]);
	        }
	        if (!newHelpers(file)) {
	          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]);
	        }
	        return _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(id), this.receiver(member), cloneId(getId)]);
	      }
	      if (!newHelpers(file)) {
	        return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), cloneId(methodId)]);
	      }
	      return _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(id), this.receiver(member), cloneId(methodId)]);
	    }
	    if (newHelpers(file)) {
	      return _core.types.callExpression(file.addHelper("classPrivateFieldGet2"), [cloneId(id), this.receiver(member)]);
	    }
	    return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]);
	  }),
	  boundGet(member) {
	    this.memoise(member, 1);
	    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
	  },
	  set: autoInherits(function(member, value) {
	    const {
	      classRef,
	      privateNamesMap,
	      file,
	      noUninitializedPrivateFieldAccess
	    } = this;
	    const privateName = member.node.property;
	    const {
	      name
	    } = privateName.id;
	    const {
	      id,
	      static: isStatic,
	      method: isMethod,
	      setId,
	      getId
	    } = privateNamesMap.get(name);
	    const isGetterOrSetter = getId || setId;
	    const cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
	    if (isStatic) {
	      if (!newHelpers(file)) {
	        const helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
	        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id), value]);
	      }
	      const receiver = this.receiver(member);
	      const skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
	      if (isMethod && !setId) {
	        const err = readOnlyError(file, name);
	        if (skipCheck) return _core.types.sequenceExpression([value, err]);
	        return _core.types.sequenceExpression([value, _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), readOnlyError(file, name)]);
	      }
	      if (setId) {
	        if (skipCheck) {
	          return _core.types.callExpression(_core.types.cloneNode(setId), [receiver, value]);
	        }
	        return _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(classRef), cloneId(setId), receiver, value]);
	      }
	      return _core.types.assignmentExpression("=", buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess), skipCheck ? value : _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, value]));
	    }
	    if (isMethod) {
	      if (setId) {
	        if (!newHelpers(file)) {
	          return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value]);
	        }
	        return _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(id), cloneId(setId), this.receiver(member), value]);
	      }
	      return _core.types.sequenceExpression([this.receiver(member), value, readOnlyError(file, name)]);
	    }
	    if (newHelpers(file)) {
	      return _core.types.callExpression(file.addHelper("classPrivateFieldSet2"), [cloneId(id), this.receiver(member), value]);
	    }
	    return _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value]);
	  }),
	  destructureSet(member) {
	    const {
	      classRef,
	      privateNamesMap,
	      file,
	      noUninitializedPrivateFieldAccess
	    } = this;
	    const privateName = member.node.property;
	    const {
	      name
	    } = privateName.id;
	    const {
	      id,
	      static: isStatic,
	      method: isMethod,
	      setId
	    } = privateNamesMap.get(name);
	    const cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
	    if (!newHelpers(file)) {
	      if (isStatic) {
	        try {
	          var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
	        } catch (_unused) {
	          throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
	        }
	        return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]), _core.types.identifier("value"));
	      }
	      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneId(id)]), _core.types.identifier("value"));
	    }
	    if (isMethod && !setId) {
	      return _core.types.memberExpression(_core.types.sequenceExpression([member.node.object, readOnlyError(file, name)]), _core.types.identifier("_"));
	    }
	    if (isStatic && !isMethod) {
	      const getCall = this.get(member);
	      if (!noUninitializedPrivateFieldAccess || !_core.types.isCallExpression(getCall)) {
	        return getCall;
	      }
	      const ref = getCall.arguments.pop();
	      getCall.arguments.push(_core.template.expression.ast`(_) => ${ref} = _`);
	      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), [getCall]), _core.types.identifier("_"));
	    }
	    const setCall = this.set(member, _core.types.identifier("_"));
	    if (!_core.types.isCallExpression(setCall) || !_core.types.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {
	      name: "_"
	    })) {
	      throw member.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
	    }
	    let args;
	    if (_core.types.isMemberExpression(setCall.callee, {
	      computed: false
	    }) && _core.types.isIdentifier(setCall.callee.property) && setCall.callee.property.name === "call") {
	      args = [setCall.callee.object, _core.types.arrayExpression(setCall.arguments.slice(1, -1)), setCall.arguments[0]];
	    } else {
	      args = [setCall.callee, _core.types.arrayExpression(setCall.arguments.slice(0, -1))];
	    }
	    return _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), args), _core.types.identifier("_"));
	  },
	  call(member, args) {
	    this.memoise(member, 1);
	    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);
	  },
	  optionalCall(member, args) {
	    this.memoise(member, 1);
	    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);
	  },
	  delete() {
	    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
	  }
	};
	const privateNameHandlerLoose = {
	  get(member) {
	    const {
	      privateNamesMap,
	      file
	    } = this;
	    const {
	      object
	    } = member.node;
	    const {
	      name
	    } = member.node.property.id;
	    return _core.template.expression`BASE(REF, PROP)[PROP]`({
	      BASE: file.addHelper("classPrivateFieldLooseBase"),
	      REF: _core.types.cloneNode(object),
	      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
	    });
	  },
	  set() {
	    throw new Error("private name handler with loose = true don't need set()");
	  },
	  boundGet(member) {
	    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
	  },
	  simpleSet(member) {
	    return this.get(member);
	  },
	  destructureSet(member) {
	    return this.get(member);
	  },
	  call(member, args) {
	    return _core.types.callExpression(this.get(member), args);
	  },
	  optionalCall(member, args) {
	    return _core.types.optionalCallExpression(this.get(member), args, true);
	  },
	  delete() {
	    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
	  }
	};
	function transformPrivateNamesUsage(ref, path, privateNamesMap, {
	  privateFieldsAsProperties,
	  noUninitializedPrivateFieldAccess,
	  noDocumentAll,
	  innerBinding
	}, state) {
	  if (!privateNamesMap.size) return;
	  const body = path.get("body");
	  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
	  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({
	    privateNamesMap,
	    classRef: ref,
	    file: state
	  }, handler, {
	    noDocumentAll,
	    noUninitializedPrivateFieldAccess,
	    innerBinding
	  }));
	  body.traverse(privateInVisitor, {
	    privateNamesMap,
	    classRef: ref,
	    file: state,
	    privateFieldsAsProperties,
	    innerBinding
	  });
	}
	function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
	  const {
	    id
	  } = privateNamesMap.get(prop.node.key.id.name);
	  const value = prop.node.value || prop.scope.buildUndefinedNode();
	  return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value}
      });
    `, prop);
	}
	function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
	  const {
	    id
	  } = privateNamesMap.get(prop.node.key.id.name);
	  const value = prop.node.value || prop.scope.buildUndefinedNode();
	  {
	    if (!state.availableHelper("classPrivateFieldInitSpec")) {
	      return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${value},
        })`, prop);
	    }
	  }
	  const helper = state.addHelper("classPrivateFieldInitSpec");
	  return inheritLoc(inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(helper, [_core.types.thisExpression(), inheritLoc(_core.types.cloneNode(id), prop.node.key), newHelpers(state) ? value : _core.template.expression.ast`{ writable: true, value: ${value} }`])), prop), prop.node);
	}
	function buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const value = noUninitializedPrivateFieldAccess ? prop.node.value : _core.template.expression.ast`{
        _: ${prop.node.value || _core.types.buildUndefinedNode()}
      }`;
	  return inheritPropComments(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.cloneNode(privateName.id), value)]), prop);
	}
	{
	  var buildPrivateStaticFieldInitSpecOld = function(prop, privateNamesMap) {
	    const privateName = privateNamesMap.get(prop.node.key.id.name);
	    const {
	      id,
	      getId,
	      setId,
	      initAdded
	    } = privateName;
	    const isGetterOrSetter = getId || setId;
	    if (!prop.isProperty() && (initAdded || !isGetterOrSetter)) return;
	    if (isGetterOrSetter) {
	      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	        initAdded: true
	      }));
	      return inheritPropComments(_core.template.statement.ast`
          var ${_core.types.cloneNode(id)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
          }
        `, prop);
	    }
	    const value = prop.node.value || prop.scope.buildUndefinedNode();
	    return inheritPropComments(_core.template.statement.ast`
        var ${_core.types.cloneNode(id)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${value}
        };
      `, prop);
	  };
	}
	function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const {
	    methodId,
	    id,
	    getId,
	    setId,
	    initAdded
	  } = privateName;
	  if (initAdded) return;
	  if (methodId) {
	    return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `, prop);
	  }
	  const isGetterOrSetter = getId || setId;
	  if (isGetterOrSetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop);
	  }
	}
	function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  if (privateName.initAdded) return;
	  if (!newHelpers(state)) {
	    const isGetterOrSetter = privateName.getId || privateName.setId;
	    if (isGetterOrSetter) {
	      return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);
	    }
	  }
	  return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);
	}
	function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const {
	    id,
	    getId,
	    setId
	  } = privateName;
	  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	    initAdded: true
	  }));
	  {
	    if (!state.availableHelper("classPrivateFieldInitSpec")) {
	      return inheritPropComments(_core.template.statement.ast`
          ${id}.set(${ref}, {
            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
          });
        `, prop);
	    }
	  }
	  const helper = state.addHelper("classPrivateFieldInitSpec");
	  return inheritLoc(inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      },
    )`, prop), prop.node);
	}
	function buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const {
	    id
	  } = privateName;
	  {
	    if (!state.availableHelper("classPrivateMethodInitSpec")) {
	      return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);
	    }
	  }
	  const helper = state.addHelper("classPrivateMethodInitSpec");
	  return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)}
    )`, prop);
	}
	function buildPublicFieldInitLoose(ref, prop) {
	  const {
	    key,
	    computed
	  } = prop.node;
	  const value = prop.node.value || prop.scope.buildUndefinedNode();
	  return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);
	}
	function buildPublicFieldInitSpec(ref, prop, state) {
	  const {
	    key,
	    computed
	  } = prop.node;
	  const value = prop.node.value || prop.scope.buildUndefinedNode();
	  return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);
	}
	function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const {
	    id,
	    methodId,
	    getId,
	    setId,
	    initAdded
	  } = privateName;
	  if (initAdded) return;
	  const isGetterOrSetter = getId || setId;
	  if (isGetterOrSetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        })
      `, prop);
	  }
	  return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${methodId.name}
      });
    `, prop);
	}
	function buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties = false) {
	  const privateName = privateNamesMap.get(prop.node.key.id.name);
	  const {
	    id,
	    methodId,
	    getId,
	    setId,
	    getterDeclared,
	    setterDeclared,
	    static: isStatic
	  } = privateName;
	  const {
	    params,
	    body,
	    generator,
	    async
	  } = prop.node;
	  const isGetter = getId && params.length === 0;
	  const isSetter = setId && params.length > 0;
	  if (isGetter && getterDeclared || isSetter && setterDeclared) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return null;
	  }
	  if (newHelpers(file) && (isGetter || isSetter) && !privateFieldsAsSymbolsOrProperties) {
	    const scope = prop.get("body").scope;
	    const thisArg = scope.generateUidIdentifier("this");
	    const state = {
	      thisRef: thisArg,
	      argumentsPath: []
	    };
	    prop.traverse(thisContextVisitor, state);
	    if (state.argumentsPath.length) {
	      const argumentsId = scope.generateUidIdentifier("arguments");
	      scope.push({
	        id: argumentsId,
	        init: _core.template.expression.ast`[].slice.call(arguments, 1)`
	      });
	      for (const path of state.argumentsPath) {
	        path.replaceWith(_core.types.cloneNode(argumentsId));
	      }
	    }
	    params.unshift(_core.types.cloneNode(thisArg));
	  }
	  let declId = methodId;
	  if (isGetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      getterDeclared: true,
	      initAdded: true
	    }));
	    declId = getId;
	  } else if (isSetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      setterDeclared: true,
	      initAdded: true
	    }));
	    declId = setId;
	  } else if (isStatic && !privateFieldsAsSymbolsOrProperties) {
	    declId = id;
	  }
	  return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);
	}
	const thisContextVisitor = _traverse.visitors.environmentVisitor({
	  Identifier(path, state) {
	    if (state.argumentsPath && path.node.name === "arguments") {
	      state.argumentsPath.push(path);
	    }
	  },
	  UnaryExpression(path) {
	    const {
	      node
	    } = path;
	    if (node.operator === "delete") {
	      const argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);
	      if (_core.types.isThisExpression(argument)) {
	        path.replaceWith(_core.types.booleanLiteral(true));
	      }
	    }
	  },
	  ThisExpression(path, state) {
	    state.needsClassRef = true;
	    path.replaceWith(_core.types.cloneNode(state.thisRef));
	  },
	  MetaProperty(path) {
	    const {
	      node,
	      scope
	    } = path;
	    if (node.meta.name === "new" && node.property.name === "target") {
	      path.replaceWith(scope.buildUndefinedNode());
	    }
	  }
	});
	const innerReferencesVisitor = {
	  ReferencedIdentifier(path, state) {
	    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
	      state.needsClassRef = true;
	      path.node.name = state.thisRef.name;
	    }
	  }
	};
	function replaceThisContext(path, ref, innerBindingRef) {
	  var _state$thisRef;
	  const state = {
	    thisRef: ref,
	    needsClassRef: false,
	    innerBinding: innerBindingRef
	  };
	  if (!path.isMethod()) {
	    path.traverse(thisContextVisitor, state);
	  }
	  if (innerBindingRef != null && (_state$thisRef = state.thisRef) != null && _state$thisRef.name && state.thisRef.name !== innerBindingRef.name) {
	    path.traverse(innerReferencesVisitor, state);
	  }
	  return state.needsClassRef;
	}
	function isNameOrLength({
	  key,
	  computed
	}) {
	  if (key.type === "Identifier") {
	    return !computed && (key.name === "name" || key.name === "length");
	  }
	  if (key.type === "StringLiteral") {
	    return key.value === "name" || key.value === "length";
	  }
	  return false;
	}
	function inheritPropComments(node, prop) {
	  _core.types.inheritLeadingComments(node, prop.node);
	  _core.types.inheritInnerComments(node, prop.node);
	  return node;
	}
	function inheritLoc(node, original) {
	  node.start = original.start;
	  node.end = original.end;
	  node.loc = original.loc;
	  return node;
	}
	function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, file, setPublicClassFields, privateFieldsAsSymbolsOrProperties, noUninitializedPrivateFieldAccess, constantSuper, innerBindingRef) {
	  let classRefFlags = 0;
	  let injectSuperRef;
	  const staticNodes = [];
	  const instanceNodes = [];
	  let lastInstanceNodeReturnsThis = false;
	  const pureStaticNodes = [];
	  let classBindingNode = null;
	  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {
	    injectSuperRef != null ? injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);
	    return injectSuperRef;
	  };
	  const classRefForInnerBinding = ref != null ? ref : props[0].scope.generateUidIdentifier((innerBindingRef == null ? void 0 : innerBindingRef.name) || "Class");
	  ref != null ? ref : ref = _core.types.cloneNode(innerBindingRef);
	  for (const prop of props) {
	    if (prop.isClassProperty()) {
	      ts.assertFieldTransformed(prop);
	    }
	    const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;
	    const isInstance = !isStatic;
	    const isPrivate = prop.isPrivate();
	    const isPublic = !isPrivate;
	    const isField = prop.isProperty();
	    const isMethod = !isField;
	    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();
	    if (isStatic) classRefFlags |= 1;
	    if (isStatic || isMethod && isPrivate || isStaticBlock) {
	      new _helperReplaceSupers.default({
	        methodPath: prop,
	        constantSuper,
	        file,
	        refToPreserve: innerBindingRef,
	        getSuperRef,
	        getObjectRef() {
	          classRefFlags |= 2;
	          if (isStatic || isStaticBlock) {
	            return classRefForInnerBinding;
	          } else {
	            return _core.types.memberExpression(classRefForInnerBinding, _core.types.identifier("prototype"));
	          }
	        }
	      }).replace();
	      const replaced = replaceThisContext(prop, classRefForInnerBinding, innerBindingRef);
	      if (replaced) {
	        classRefFlags |= 2;
	      }
	    }
	    lastInstanceNodeReturnsThis = false;
	    switch (true) {
	      case isStaticBlock: {
	        const blockBody = prop.node.body;
	        if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {
	          staticNodes.push(inheritPropComments(blockBody[0], prop));
	        } else {
	          staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));
	        }
	        break;
	      }
	      case (isStatic && isPrivate && isField && privateFieldsAsSymbolsOrProperties):
	        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
	        break;
	      case (isStatic && isPrivate && isField && !privateFieldsAsSymbolsOrProperties):
	        if (!newHelpers(file)) {
	          staticNodes.push(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));
	        } else {
	          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess));
	        }
	        break;
	      case (isStatic && isPublic && isField && setPublicClassFields):
	        if (!isNameOrLength(prop.node)) {
	          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
	          break;
	        }
	      case (isStatic && isPublic && isField && !setPublicClassFields):
	        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, file));
	        break;
	      case (isInstance && isPrivate && isField && privateFieldsAsSymbolsOrProperties):
	        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
	        break;
	      case (isInstance && isPrivate && isField && !privateFieldsAsSymbolsOrProperties):
	        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
	        break;
	      case (isInstance && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties):
	        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
	        break;
	      case (isInstance && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties):
	        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
	        break;
	      case (isStatic && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties):
	        if (!newHelpers(file)) {
	          staticNodes.unshift(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));
	        }
	        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
	        break;
	      case (isStatic && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties):
	        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, file, privateNamesMap));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
	        break;
	      case (isInstance && isPublic && isField && setPublicClassFields):
	        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
	        break;
	      case (isInstance && isPublic && isField && !setPublicClassFields):
	        lastInstanceNodeReturnsThis = true;
	        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, file));
	        break;
	      default:
	        throw new Error("Unreachable.");
	    }
	  }
	  if (classRefFlags & 2 && innerBindingRef != null) {
	    classBindingNode = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classRefForInnerBinding), _core.types.cloneNode(innerBindingRef)));
	  }
	  return {
	    staticNodes: staticNodes.filter(Boolean),
	    instanceNodes: instanceNodes.filter(Boolean),
	    lastInstanceNodeReturnsThis,
	    pureStaticNodes: pureStaticNodes.filter(Boolean),
	    classBindingNode,
	    wrapClass(path) {
	      for (const prop of props) {
	        prop.node.leadingComments = null;
	        prop.remove();
	      }
	      if (injectSuperRef) {
	        path.scope.push({
	          id: _core.types.cloneNode(injectSuperRef)
	        });
	        path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass));
	      }
	      if (classRefFlags !== 0) {
	        if (path.isClassExpression()) {
	          path.scope.push({
	            id: ref
	          });
	          path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node));
	        } else {
	          if (innerBindingRef == null) {
	            path.node.id = ref;
	          }
	          if (classBindingNode != null) {
	            path.scope.push({
	              id: classRefForInnerBinding
	            });
	          }
	        }
	      }
	      return path;
	    }
	  };
	}
	return fields;
}

var decorators = {};

var misc = {};

var hasRequiredMisc;

function requireMisc () {
	if (hasRequiredMisc) return misc;
	hasRequiredMisc = 1;
	Object.defineProperty(misc, "__esModule", {
	  value: true
	});
	misc.extractComputedKeys = extractComputedKeys;
	misc.injectInitialization = injectInitialization;
	misc.memoiseComputedKey = memoiseComputedKey;
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	const findBareSupers = _traverse.visitors.environmentVisitor({
	  Super(path) {
	    const {
	      node,
	      parentPath
	    } = path;
	    if (parentPath.isCallExpression({
	      callee: node
	    })) {
	      this.push(parentPath);
	    }
	  }
	});
	const referenceVisitor = {
	  "TSTypeAnnotation|TypeAnnotation"(path) {
	    path.skip();
	  },
	  ReferencedIdentifier(path, {
	    scope
	  }) {
	    if (scope.hasOwnBinding(path.node.name)) {
	      scope.rename(path.node.name);
	      path.skip();
	    }
	  }
	};
	function handleClassTDZ(path, state) {
	  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
	    const classNameTDZError = state.file.addHelper("classNameTDZError");
	    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);
	    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));
	    path.skip();
	  }
	}
	const classFieldDefinitionEvaluationTDZVisitor = {
	  ReferencedIdentifier: handleClassTDZ,
	  "TSTypeAnnotation|TypeAnnotation"(path) {
	    path.skip();
	  }
	};
	function injectInitialization(path, constructor, nodes, renamer, lastReturnsThis) {
	  if (!nodes.length) return;
	  const isDerived = !!path.node.superClass;
	  if (!constructor) {
	    const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
	    if (isDerived) {
	      newConstructor.params = [_core.types.restElement(_core.types.identifier("args"))];
	      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);
	    }
	    [constructor] = path.get("body").unshiftContainer("body", newConstructor);
	  }
	  if (renamer) {
	    renamer(referenceVisitor, {
	      scope: constructor.scope
	    });
	  }
	  if (isDerived) {
	    const bareSupers = [];
	    constructor.traverse(findBareSupers, bareSupers);
	    let isFirst = true;
	    for (const bareSuper of bareSupers) {
	      if (isFirst) {
	        isFirst = false;
	      } else {
	        nodes = nodes.map((n) => _core.types.cloneNode(n));
	      }
	      if (!bareSuper.parentPath.isExpressionStatement()) {
	        const allNodes = [bareSuper.node, ...nodes.map((n) => _core.types.toExpression(n))];
	        if (!lastReturnsThis) allNodes.push(_core.types.thisExpression());
	        bareSuper.replaceWith(_core.types.sequenceExpression(allNodes));
	      } else {
	        bareSuper.insertAfter(nodes);
	      }
	    }
	  } else {
	    constructor.get("body").unshiftContainer("body", nodes);
	  }
	}
	function memoiseComputedKey(keyNode, scope, hint) {
	  const isUidReference = _core.types.isIdentifier(keyNode) && scope.hasUid(keyNode.name);
	  if (isUidReference) {
	    return;
	  }
	  const isMemoiseAssignment = _core.types.isAssignmentExpression(keyNode, {
	    operator: "="
	  }) && _core.types.isIdentifier(keyNode.left) && scope.hasUid(keyNode.left.name);
	  if (isMemoiseAssignment) {
	    return _core.types.cloneNode(keyNode);
	  } else {
	    const ident = _core.types.identifier(hint);
	    scope.push({
	      id: ident,
	      kind: "let"
	    });
	    return _core.types.assignmentExpression("=", _core.types.cloneNode(ident), keyNode);
	  }
	}
	function extractComputedKeys(path, computedPaths, file) {
	  const {
	    scope
	  } = path;
	  const declarations = [];
	  const state = {
	    classBinding: path.node.id && scope.getBinding(path.node.id.name),
	    file
	  };
	  for (const computedPath of computedPaths) {
	    const computedKey = computedPath.get("key");
	    if (computedKey.isReferencedIdentifier()) {
	      handleClassTDZ(computedKey, state);
	    } else {
	      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
	    }
	    const computedNode = computedPath.node;
	    if (!computedKey.isConstantExpression()) {
	      const assignment = memoiseComputedKey(computedKey.node, scope, scope.generateUidBasedOnNode(computedKey.node));
	      if (assignment) {
	        declarations.push(_core.types.expressionStatement(assignment));
	        computedNode.key = _core.types.cloneNode(assignment.left);
	      }
	    }
	  }
	  return declarations;
	}
	return misc;
}

var hasRequiredDecorators;

function requireDecorators () {
	if (hasRequiredDecorators) return decorators;
	hasRequiredDecorators = 1;
	Object.defineProperty(decorators, "__esModule", {
	  value: true
	});
	decorators.default = _default;
	decorators.hasDecorators = hasDecorators;
	decorators.hasOwnDecorators = hasOwnDecorators;
	var _core = require$$0$b;
	var _helperReplaceSupers = requireLib$Z();
	var _helperSkipTransparentExpressionWrappers = requireLib$X();
	var _fields = requireFields();
	var _misc = requireMisc();
	function hasOwnDecorators(node) {
	  var _node$decorators;
	  return !!((_node$decorators = node.decorators) != null && _node$decorators.length);
	}
	function hasDecorators(node) {
	  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
	}
	function incrementId(id, idx = id.length - 1) {
	  if (idx === -1) {
	    id.unshift(65);
	    return;
	  }
	  const current = id[idx];
	  if (current === 90) {
	    id[idx] = 97;
	  } else if (current === 122) {
	    id[idx] = 65;
	    incrementId(id, idx - 1);
	  } else {
	    id[idx] = current + 1;
	  }
	}
	function createPrivateUidGeneratorForClass(classPath) {
	  const currentPrivateId = [];
	  const privateNames = /* @__PURE__ */ new Set();
	  classPath.traverse({
	    PrivateName(path) {
	      privateNames.add(path.node.id.name);
	    }
	  });
	  return () => {
	    let reifiedId;
	    do {
	      incrementId(currentPrivateId);
	      reifiedId = String.fromCharCode(...currentPrivateId);
	    } while (privateNames.has(reifiedId));
	    return _core.types.privateName(_core.types.identifier(reifiedId));
	  };
	}
	function createLazyPrivateUidGeneratorForClass(classPath) {
	  let generator;
	  return () => {
	    if (!generator) {
	      generator = createPrivateUidGeneratorForClass(classPath);
	    }
	    return generator();
	  };
	}
	function replaceClassWithVar(path, className) {
	  const id = path.node.id;
	  const scope = path.scope;
	  if (path.type === "ClassDeclaration") {
	    const className2 = id.name;
	    const varId = scope.generateUidIdentifierBasedOnNode(id);
	    const classId = _core.types.identifier(className2);
	    scope.rename(className2, varId.name);
	    path.get("id").replaceWith(classId);
	    return {
	      id: _core.types.cloneNode(varId),
	      path
	    };
	  } else {
	    let varId;
	    if (id) {
	      className = id.name;
	      varId = generateLetUidIdentifier(scope.parent, className);
	      scope.rename(className, varId.name);
	    } else {
	      varId = generateLetUidIdentifier(scope.parent, typeof className === "string" ? className : "decorated_class");
	    }
	    const newClassExpr = _core.types.classExpression(typeof className === "string" ? _core.types.identifier(className) : null, path.node.superClass, path.node.body);
	    const [newPath] = path.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));
	    return {
	      id: _core.types.cloneNode(varId),
	      path: newPath.get("expressions.0")
	    };
	  }
	}
	function generateClassProperty(key, value, isStatic) {
	  if (key.type === "PrivateName") {
	    return _core.types.classPrivateProperty(key, value, void 0, isStatic);
	  } else {
	    return _core.types.classProperty(key, value, void 0, void 0, isStatic);
	  }
	}
	function assignIdForAnonymousClass(path, className) {
	  if (!path.node.id) {
	    path.node.id = typeof className === "string" ? _core.types.identifier(className) : path.scope.generateUidIdentifier("Class");
	  }
	}
	function addProxyAccessorsFor(className, element, getterKey, setterKey, targetKey, isComputed, isStatic, version) {
	  const thisArg = (version === "2023-11" || version === "2023-05") && isStatic ? className : _core.types.thisExpression();
	  const getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]);
	  const setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier("v")))]);
	  let getter, setter;
	  if (getterKey.type === "PrivateName") {
	    getter = _core.types.classPrivateMethod("get", getterKey, [], getterBody, isStatic);
	    setter = _core.types.classPrivateMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isStatic);
	  } else {
	    getter = _core.types.classMethod("get", getterKey, [], getterBody, isComputed, isStatic);
	    setter = _core.types.classMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isComputed, isStatic);
	  }
	  element.insertAfter(setter);
	  element.insertAfter(getter);
	}
	function extractProxyAccessorsFor(targetKey, version) {
	  if (version !== "2023-11" && version !== "2023-05" && version !== "2023-01") {
	    return [_core.template.expression.ast`
        function () {
          return this.${_core.types.cloneNode(targetKey)};
        }
      `, _core.template.expression.ast`
        function (value) {
          this.${_core.types.cloneNode(targetKey)} = value;
        }
      `];
	  }
	  return [_core.template.expression.ast`
      o => o.${_core.types.cloneNode(targetKey)}
    `, _core.template.expression.ast`
      (o, v) => o.${_core.types.cloneNode(targetKey)} = v
    `];
	}
	function getComputedKeyLastElement(path) {
	  path = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path);
	  if (path.isSequenceExpression()) {
	    const expressions = path.get("expressions");
	    return getComputedKeyLastElement(expressions[expressions.length - 1]);
	  }
	  return path;
	}
	function getComputedKeyMemoiser(path) {
	  const element = getComputedKeyLastElement(path);
	  if (element.isConstantExpression()) {
	    return _core.types.cloneNode(path.node);
	  } else if (element.isIdentifier() && path.scope.hasUid(element.node.name)) {
	    return _core.types.cloneNode(path.node);
	  } else if (element.isAssignmentExpression() && element.get("left").isIdentifier()) {
	    return _core.types.cloneNode(element.node.left);
	  } else {
	    throw new Error(`Internal Error: the computed key ${path.toString()} has not yet been memoised.`);
	  }
	}
	function prependExpressionsToComputedKey(expressions, fieldPath) {
	  const key = fieldPath.get("key");
	  if (key.isSequenceExpression()) {
	    expressions.push(...key.node.expressions);
	  } else {
	    expressions.push(key.node);
	  }
	  key.replaceWith(maybeSequenceExpression(expressions));
	}
	function appendExpressionsToComputedKey(expressions, fieldPath) {
	  const key = fieldPath.get("key");
	  const completion = getComputedKeyLastElement(key);
	  if (completion.isConstantExpression()) {
	    prependExpressionsToComputedKey(expressions, fieldPath);
	  } else {
	    const scopeParent = key.scope.parent;
	    const maybeAssignment = (0, _misc.memoiseComputedKey)(completion.node, scopeParent, scopeParent.generateUid("computedKey"));
	    if (!maybeAssignment) {
	      prependExpressionsToComputedKey(expressions, fieldPath);
	    } else {
	      const expressionSequence = [...expressions, _core.types.cloneNode(maybeAssignment.left)];
	      const completionParent = completion.parentPath;
	      if (completionParent.isSequenceExpression()) {
	        completionParent.pushContainer("expressions", expressionSequence);
	      } else {
	        completion.replaceWith(maybeSequenceExpression([_core.types.cloneNode(maybeAssignment), ...expressionSequence]));
	      }
	    }
	  }
	}
	function prependExpressionsToFieldInitializer(expressions, fieldPath) {
	  const initializer = fieldPath.get("value");
	  if (initializer.node) {
	    expressions.push(initializer.node);
	  } else if (expressions.length > 0) {
	    expressions[expressions.length - 1] = _core.types.unaryExpression("void", expressions[expressions.length - 1]);
	  }
	  initializer.replaceWith(maybeSequenceExpression(expressions));
	}
	function prependExpressionsToStaticBlock(expressions, blockPath) {
	  blockPath.unshiftContainer("body", _core.types.expressionStatement(maybeSequenceExpression(expressions)));
	}
	function prependExpressionsToConstructor(expressions, constructorPath) {
	  constructorPath.node.body.body.unshift(_core.types.expressionStatement(maybeSequenceExpression(expressions)));
	}
	function isProtoInitCallExpression(expression, protoInitCall) {
	  return _core.types.isCallExpression(expression) && _core.types.isIdentifier(expression.callee, {
	    name: protoInitCall.name
	  });
	}
	function optimizeSuperCallAndExpressions(expressions, protoInitLocal) {
	  if (protoInitLocal) {
	    if (expressions.length >= 2 && isProtoInitCallExpression(expressions[1], protoInitLocal)) {
	      const mergedSuperCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [expressions[0]]);
	      expressions.splice(0, 2, mergedSuperCall);
	    }
	    if (expressions.length >= 2 && _core.types.isThisExpression(expressions[expressions.length - 1]) && isProtoInitCallExpression(expressions[expressions.length - 2], protoInitLocal)) {
	      expressions.splice(expressions.length - 1, 1);
	    }
	  }
	  return maybeSequenceExpression(expressions);
	}
	function insertExpressionsAfterSuperCallAndOptimize(expressions, constructorPath, protoInitLocal) {
	  constructorPath.traverse({
	    CallExpression: {
	      exit(path) {
	        if (!path.get("callee").isSuper()) return;
	        const newNodes = [path.node, ...expressions.map((expr) => _core.types.cloneNode(expr))];
	        if (path.isCompletionRecord()) {
	          newNodes.push(_core.types.thisExpression());
	        }
	        path.replaceWith(optimizeSuperCallAndExpressions(newNodes, protoInitLocal));
	        path.skip();
	      }
	    },
	    ClassMethod(path) {
	      if (path.node.kind === "constructor") {
	        path.skip();
	      }
	    }
	  });
	}
	function createConstructorFromExpressions(expressions, isDerivedClass) {
	  const body = [_core.types.expressionStatement(maybeSequenceExpression(expressions))];
	  if (isDerivedClass) {
	    body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier("args"))])));
	  }
	  return _core.types.classMethod("constructor", _core.types.identifier("constructor"), isDerivedClass ? [_core.types.restElement(_core.types.identifier("args"))] : [], _core.types.blockStatement(body));
	}
	function createStaticBlockFromExpressions(expressions) {
	  return _core.types.staticBlock([_core.types.expressionStatement(maybeSequenceExpression(expressions))]);
	}
	const FIELD = 0;
	const ACCESSOR = 1;
	const METHOD = 2;
	const GETTER = 3;
	const SETTER = 4;
	const STATIC_OLD_VERSION = 5;
	const STATIC = 8;
	const DECORATORS_HAVE_THIS = 16;
	function getElementKind(element) {
	  switch (element.node.type) {
	    case "ClassProperty":
	    case "ClassPrivateProperty":
	      return FIELD;
	    case "ClassAccessorProperty":
	      return ACCESSOR;
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	      if (element.node.kind === "get") {
	        return GETTER;
	      } else if (element.node.kind === "set") {
	        return SETTER;
	      } else {
	        return METHOD;
	      }
	  }
	}
	function toSortedDecoratorInfo(info) {
	  return [...info.filter((el) => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter((el) => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter((el) => el.isStatic && el.kind === FIELD), ...info.filter((el) => !el.isStatic && el.kind === FIELD)];
	}
	function generateDecorationList(decorators, decoratorsThis, version) {
	  const decsCount = decorators.length;
	  const haveOneThis = decoratorsThis.some(Boolean);
	  const decs = [];
	  for (let i = 0; i < decsCount; i++) {
	    if ((version === "2023-11" || version === "2023-05") && haveOneThis) {
	      decs.push(decoratorsThis[i] || _core.types.unaryExpression("void", _core.types.numericLiteral(0)));
	    }
	    decs.push(decorators[i].expression);
	  }
	  return {
	    haveThis: haveOneThis,
	    decs
	  };
	}
	function generateDecorationExprs(decorationInfo, version) {
	  return _core.types.arrayExpression(decorationInfo.map((el) => {
	    let flag = el.kind;
	    if (el.isStatic) {
	      flag += version === "2023-11" || version === "2023-05" ? STATIC : STATIC_OLD_VERSION;
	    }
	    if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;
	    return _core.types.arrayExpression([el.decoratorsArray, _core.types.numericLiteral(flag), el.name, ...el.privateMethods || []]);
	  }));
	}
	function extractElementLocalAssignments(decorationInfo) {
	  const localIds = [];
	  for (const el of decorationInfo) {
	    const {
	      locals
	    } = el;
	    if (Array.isArray(locals)) {
	      localIds.push(...locals);
	    } else if (locals !== void 0) {
	      localIds.push(locals);
	    }
	  }
	  return localIds;
	}
	function addCallAccessorsFor(version, element, key, getId, setId, isStatic) {
	  element.insertAfter(_core.types.classPrivateMethod("get", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()]))]), isStatic));
	  element.insertAfter(_core.types.classPrivateMethod("set", _core.types.cloneNode(key), [_core.types.identifier("v")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), version === "2023-11" && isStatic ? [_core.types.identifier("v")] : [_core.types.thisExpression(), _core.types.identifier("v")]))]), isStatic));
	}
	function movePrivateAccessor(element, key, methodLocalVar, isStatic) {
	  let params;
	  let block;
	  if (element.node.kind === "set") {
	    params = [_core.types.identifier("v")];
	    block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier("v")]))];
	  } else {
	    params = [];
	    block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];
	  }
	  element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));
	}
	function isClassDecoratableElementPath(path) {
	  const {
	    type
	  } = path;
	  return type !== "TSDeclareMethod" && type !== "TSIndexSignature" && type !== "StaticBlock";
	}
	function staticBlockToIIFE(block) {
	  return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);
	}
	function staticBlockToFunctionClosure(block) {
	  return _core.types.functionExpression(null, [], _core.types.blockStatement(block.body));
	}
	function fieldInitializerToClosure(value) {
	  return _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(value)]));
	}
	function maybeSequenceExpression(exprs) {
	  if (exprs.length === 0) return _core.types.unaryExpression("void", _core.types.numericLiteral(0));
	  if (exprs.length === 1) return exprs[0];
	  return _core.types.sequenceExpression(exprs);
	}
	function createFunctionExpressionFromPrivateMethod(node) {
	  const {
	    params,
	    body,
	    generator: isGenerator,
	    async: isAsync
	  } = node;
	  return _core.types.functionExpression(void 0, params, body, isGenerator, isAsync);
	}
	function createSetFunctionNameCall(state, className) {
	  return _core.types.callExpression(state.addHelper("setFunctionName"), [_core.types.thisExpression(), className]);
	}
	function createToPropertyKeyCall(state, propertyKey) {
	  return _core.types.callExpression(state.addHelper("toPropertyKey"), [propertyKey]);
	}
	function createPrivateBrandCheckClosure(brandName) {
	  return _core.types.arrowFunctionExpression([_core.types.identifier("_")], _core.types.binaryExpression("in", _core.types.cloneNode(brandName), _core.types.identifier("_")));
	}
	function usesPrivateField(expression) {
	  {
	    try {
	      _core.types.traverseFast(expression, (node) => {
	        if (_core.types.isPrivateName(node)) {
	          throw null;
	        }
	      });
	      return false;
	    } catch (_unused) {
	      return true;
	    }
	  }
	}
	function convertToComputedKey(path) {
	  const {
	    node
	  } = path;
	  node.computed = true;
	  if (_core.types.isIdentifier(node.key)) {
	    node.key = _core.types.stringLiteral(node.key.name);
	  }
	}
	function hasInstancePrivateAccess(path, privateNames) {
	  let containsInstancePrivateAccess = false;
	  if (privateNames.length > 0) {
	    const privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
	      PrivateName(path2, state) {
	        if (state.privateNamesMap.has(path2.node.id.name)) {
	          containsInstancePrivateAccess = true;
	          path2.stop();
	        }
	      }
	    });
	    const privateNamesMap = /* @__PURE__ */ new Map();
	    for (const name of privateNames) {
	      privateNamesMap.set(name, null);
	    }
	    path.traverse(privateNameVisitor, {
	      privateNamesMap
	    });
	  }
	  return containsInstancePrivateAccess;
	}
	function checkPrivateMethodUpdateError(path, decoratedPrivateMethods) {
	  const privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
	    PrivateName(path2, state) {
	      if (!state.privateNamesMap.has(path2.node.id.name)) return;
	      const parentPath = path2.parentPath;
	      const parentParentPath = parentPath.parentPath;
	      if (parentParentPath.node.type === "AssignmentExpression" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === "UpdateExpression" || parentParentPath.node.type === "RestElement" || parentParentPath.node.type === "ArrayPattern" || parentParentPath.node.type === "ObjectProperty" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === "ObjectPattern" || parentParentPath.node.type === "ForOfStatement" && parentParentPath.node.left === parentPath.node) {
	        throw path2.buildCodeFrameError(`Decorated private methods are read-only, but "#${path2.node.id.name}" is updated via this expression.`);
	      }
	    }
	  });
	  const privateNamesMap = /* @__PURE__ */ new Map();
	  for (const name of decoratedPrivateMethods) {
	    privateNamesMap.set(name, null);
	  }
	  path.traverse(privateNameVisitor, {
	    privateNamesMap
	  });
	}
	function transformClass(path, state, constantSuper, ignoreFunctionLength, className, propertyVisitor, version) {
	  var _path$node$id;
	  const body = path.get("body.body");
	  const classDecorators = path.node.decorators;
	  let hasElementDecorators = false;
	  let hasComputedKeysSideEffects = false;
	  let elemDecsUseFnContext = false;
	  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);
	  const classAssignments = [];
	  const scopeParent = path.scope.parent;
	  const memoiseExpression = (expression, hint, assignments) => {
	    const localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);
	    assignments.push(_core.types.assignmentExpression("=", localEvaluatedId, expression));
	    return _core.types.cloneNode(localEvaluatedId);
	  };
	  let protoInitLocal;
	  let staticInitLocal;
	  const classIdName = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
	  const setClassName = typeof className === "object" ? className : void 0;
	  const usesFunctionContextOrYieldAwait = (decorator) => {
	    {
	      try {
	        _core.types.traverseFast(decorator, (node) => {
	          if (_core.types.isThisExpression(node) || _core.types.isSuper(node) || _core.types.isYieldExpression(node) || _core.types.isAwaitExpression(node) || _core.types.isIdentifier(node, {
	            name: "arguments"
	          }) || classIdName && _core.types.isIdentifier(node, {
	            name: classIdName
	          }) || _core.types.isMetaProperty(node) && node.meta.name !== "import") {
	            throw null;
	          }
	        });
	        return false;
	      } catch (_unused2) {
	        return true;
	      }
	    }
	  };
	  const instancePrivateNames = [];
	  for (const element of body) {
	    if (!isClassDecoratableElementPath(element)) {
	      continue;
	    }
	    const elementNode = element.node;
	    if (!elementNode.static && _core.types.isPrivateName(elementNode.key)) {
	      instancePrivateNames.push(elementNode.key.id.name);
	    }
	    if (isDecorated(elementNode)) {
	      switch (elementNode.type) {
	        case "ClassProperty":
	          propertyVisitor.ClassProperty(element, state);
	          break;
	        case "ClassPrivateProperty":
	          propertyVisitor.ClassPrivateProperty(element, state);
	          break;
	        case "ClassAccessorProperty":
	          propertyVisitor.ClassAccessorProperty(element, state);
	          if (version === "2023-11") {
	            break;
	          }
	        default:
	          if (elementNode.static) {
	            staticInitLocal != null ? staticInitLocal : staticInitLocal = generateLetUidIdentifier(scopeParent, "initStatic");
	          } else {
	            protoInitLocal != null ? protoInitLocal : protoInitLocal = generateLetUidIdentifier(scopeParent, "initProto");
	          }
	          break;
	      }
	      hasElementDecorators = true;
	      elemDecsUseFnContext || (elemDecsUseFnContext = elementNode.decorators.some(usesFunctionContextOrYieldAwait));
	    } else if (elementNode.type === "ClassAccessorProperty") {
	      propertyVisitor.ClassAccessorProperty(element, state);
	      const {
	        key,
	        value,
	        static: isStatic,
	        computed
	      } = elementNode;
	      const newId = generateClassPrivateUid();
	      const newField = generateClassProperty(newId, value, isStatic);
	      const keyPath = element.get("key");
	      const [newPath] = element.replaceWith(newField);
	      let getterKey, setterKey;
	      if (computed && !keyPath.isConstantExpression()) {
	        getterKey = (0, _misc.memoiseComputedKey)(createToPropertyKeyCall(state, key), scopeParent, scopeParent.generateUid("computedKey"));
	        setterKey = _core.types.cloneNode(getterKey.left);
	      } else {
	        getterKey = _core.types.cloneNode(key);
	        setterKey = _core.types.cloneNode(key);
	      }
	      assignIdForAnonymousClass(path, className);
	      addProxyAccessorsFor(path.node.id, newPath, getterKey, setterKey, newId, computed, isStatic, version);
	    }
	    if ("computed" in element.node && element.node.computed) {
	      hasComputedKeysSideEffects || (hasComputedKeysSideEffects = !scopeParent.isStatic(element.node.key));
	    }
	  }
	  if (!classDecorators && !hasElementDecorators) {
	    if (!path.node.id && typeof className === "string") {
	      path.node.id = _core.types.identifier(className);
	    }
	    if (setClassName) {
	      path.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(state, setClassName)]));
	    }
	    return;
	  }
	  const elementDecoratorInfo = [];
	  let constructorPath;
	  const decoratedPrivateMethods = /* @__PURE__ */ new Set();
	  let classInitLocal, classIdLocal;
	  let decoratorReceiverId = null;
	  function handleDecorators(decorators) {
	    let hasSideEffects = false;
	    let usesFnContext = false;
	    const decoratorsThis = [];
	    for (const decorator of decorators) {
	      const {
	        expression
	      } = decorator;
	      let object;
	      if ((version === "2023-11" || version === "2023-05") && _core.types.isMemberExpression(expression)) {
	        if (_core.types.isSuper(expression.object)) {
	          object = _core.types.thisExpression();
	        } else if (scopeParent.isStatic(expression.object)) {
	          object = _core.types.cloneNode(expression.object);
	        } else {
	          decoratorReceiverId != null ? decoratorReceiverId : decoratorReceiverId = generateLetUidIdentifier(scopeParent, "obj");
	          object = _core.types.assignmentExpression("=", _core.types.cloneNode(decoratorReceiverId), expression.object);
	          expression.object = _core.types.cloneNode(decoratorReceiverId);
	        }
	      }
	      decoratorsThis.push(object);
	      hasSideEffects || (hasSideEffects = !scopeParent.isStatic(expression));
	      usesFnContext || (usesFnContext = usesFunctionContextOrYieldAwait(decorator));
	    }
	    return {
	      hasSideEffects,
	      usesFnContext,
	      decoratorsThis
	    };
	  }
	  const willExtractSomeElemDecs = hasComputedKeysSideEffects || elemDecsUseFnContext || version !== "2023-11";
	  let needsDeclaraionForClassBinding = false;
	  let classDecorationsFlag = 0;
	  let classDecorations = [];
	  let classDecorationsId;
	  let computedKeyAssignments = [];
	  if (classDecorators) {
	    classInitLocal = generateLetUidIdentifier(scopeParent, "initClass");
	    needsDeclaraionForClassBinding = path.isClassDeclaration();
	    ({
	      id: classIdLocal,
	      path
	    } = replaceClassWithVar(path, className));
	    path.node.decorators = null;
	    const classDecsUsePrivateName = classDecorators.some(usesPrivateField);
	    const {
	      hasSideEffects,
	      usesFnContext,
	      decoratorsThis
	    } = handleDecorators(classDecorators);
	    const {
	      haveThis,
	      decs
	    } = generateDecorationList(classDecorators, decoratorsThis, version);
	    classDecorationsFlag = haveThis ? 1 : 0;
	    classDecorations = decs;
	    if (usesFnContext || hasSideEffects && willExtractSomeElemDecs || classDecsUsePrivateName) {
	      classDecorationsId = memoiseExpression(_core.types.arrayExpression(classDecorations), "classDecs", classAssignments);
	    }
	    if (!hasElementDecorators) {
	      for (const element of path.get("body.body")) {
	        const {
	          node
	        } = element;
	        const isComputed = "computed" in node && node.computed;
	        if (isComputed) {
	          if (element.isClassProperty({
	            static: true
	          })) {
	            if (!element.get("key").isConstantExpression()) {
	              const key = node.key;
	              const maybeAssignment = (0, _misc.memoiseComputedKey)(key, scopeParent, scopeParent.generateUid("computedKey"));
	              if (maybeAssignment != null) {
	                node.key = _core.types.cloneNode(maybeAssignment.left);
	                computedKeyAssignments.push(maybeAssignment);
	              }
	            }
	          } else if (computedKeyAssignments.length > 0) {
	            prependExpressionsToComputedKey(computedKeyAssignments, element);
	            computedKeyAssignments = [];
	          }
	        }
	      }
	    }
	  } else {
	    assignIdForAnonymousClass(path, className);
	    classIdLocal = _core.types.cloneNode(path.node.id);
	  }
	  let lastInstancePrivateName;
	  let needsInstancePrivateBrandCheck = false;
	  let fieldInitializerExpressions = [];
	  let staticFieldInitializerExpressions = [];
	  if (hasElementDecorators) {
	    if (protoInitLocal) {
	      const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);
	      fieldInitializerExpressions.push(protoInitCall);
	    }
	    for (const element of body) {
	      if (!isClassDecoratableElementPath(element)) {
	        if (staticFieldInitializerExpressions.length > 0 && element.isStaticBlock()) {
	          prependExpressionsToStaticBlock(staticFieldInitializerExpressions, element);
	          staticFieldInitializerExpressions = [];
	        }
	        continue;
	      }
	      const {
	        node
	      } = element;
	      const decorators = node.decorators;
	      const hasDecorators2 = !!(decorators != null && decorators.length);
	      const isComputed = "computed" in node && node.computed;
	      let name = "computedKey";
	      if (node.key.type === "PrivateName") {
	        name = node.key.id.name;
	      } else if (!isComputed && node.key.type === "Identifier") {
	        name = node.key.name;
	      }
	      let decoratorsArray;
	      let decoratorsHaveThis;
	      if (hasDecorators2) {
	        const {
	          hasSideEffects,
	          usesFnContext,
	          decoratorsThis
	        } = handleDecorators(decorators);
	        const {
	          decs,
	          haveThis
	        } = generateDecorationList(decorators, decoratorsThis, version);
	        decoratorsHaveThis = haveThis;
	        decoratorsArray = decs.length === 1 ? decs[0] : _core.types.arrayExpression(decs);
	        if (usesFnContext || hasSideEffects && willExtractSomeElemDecs) {
	          decoratorsArray = memoiseExpression(decoratorsArray, name + "Decs", computedKeyAssignments);
	        }
	      }
	      if (isComputed) {
	        if (!element.get("key").isConstantExpression()) {
	          const key2 = node.key;
	          const maybeAssignment = (0, _misc.memoiseComputedKey)(hasDecorators2 ? createToPropertyKeyCall(state, key2) : key2, scopeParent, scopeParent.generateUid("computedKey"));
	          if (maybeAssignment != null) {
	            if (classDecorators && element.isClassProperty({
	              static: true
	            })) {
	              node.key = _core.types.cloneNode(maybeAssignment.left);
	              computedKeyAssignments.push(maybeAssignment);
	            } else {
	              node.key = maybeAssignment;
	            }
	          }
	        }
	      }
	      const {
	        key,
	        static: isStatic
	      } = node;
	      const isPrivate = key.type === "PrivateName";
	      const kind = getElementKind(element);
	      if (isPrivate && !isStatic) {
	        if (hasDecorators2) {
	          needsInstancePrivateBrandCheck = true;
	        }
	        if (_core.types.isClassPrivateProperty(node) || !lastInstancePrivateName) {
	          lastInstancePrivateName = key;
	        }
	      }
	      if (element.isClassMethod({
	        kind: "constructor"
	      })) {
	        constructorPath = element;
	      }
	      let locals;
	      if (hasDecorators2) {
	        let privateMethods;
	        let nameExpr;
	        if (isComputed) {
	          nameExpr = getComputedKeyMemoiser(element.get("key"));
	        } else if (key.type === "PrivateName") {
	          nameExpr = _core.types.stringLiteral(key.id.name);
	        } else if (key.type === "Identifier") {
	          nameExpr = _core.types.stringLiteral(key.name);
	        } else {
	          nameExpr = _core.types.cloneNode(key);
	        }
	        if (kind === ACCESSOR) {
	          const {
	            value
	          } = element.node;
	          const params = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
	          if (value) {
	            params.push(_core.types.cloneNode(value));
	          }
	          const newId = generateClassPrivateUid();
	          const newFieldInitId = generateLetUidIdentifier(scopeParent, `init_${name}`);
	          const newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);
	          const newField = generateClassProperty(newId, newValue, isStatic);
	          const [newPath] = element.replaceWith(newField);
	          if (isPrivate) {
	            privateMethods = extractProxyAccessorsFor(newId, version);
	            const getId = generateLetUidIdentifier(scopeParent, `get_${name}`);
	            const setId = generateLetUidIdentifier(scopeParent, `set_${name}`);
	            addCallAccessorsFor(version, newPath, key, getId, setId, isStatic);
	            locals = [newFieldInitId, getId, setId];
	          } else {
	            assignIdForAnonymousClass(path, className);
	            addProxyAccessorsFor(path.node.id, newPath, _core.types.cloneNode(key), _core.types.isAssignmentExpression(key) ? _core.types.cloneNode(key.left) : _core.types.cloneNode(key), newId, isComputed, isStatic, version);
	            locals = [newFieldInitId];
	          }
	        } else if (kind === FIELD) {
	          const initId = generateLetUidIdentifier(scopeParent, `init_${name}`);
	          const valuePath = element.get("value");
	          const args = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
	          if (valuePath.node) args.push(valuePath.node);
	          valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), args));
	          locals = [initId];
	          if (isPrivate) {
	            privateMethods = extractProxyAccessorsFor(key, version);
	          }
	        } else if (isPrivate) {
	          const callId = generateLetUidIdentifier(scopeParent, `call_${name}`);
	          locals = [callId];
	          const replaceSupers = new _helperReplaceSupers.default({
	            constantSuper,
	            methodPath: element,
	            objectRef: classIdLocal,
	            superRef: path.node.superClass,
	            file: state.file,
	            refToPreserve: classIdLocal
	          });
	          replaceSupers.replace();
	          privateMethods = [createFunctionExpressionFromPrivateMethod(element.node)];
	          if (kind === GETTER || kind === SETTER) {
	            movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(callId), isStatic);
	          } else {
	            const node2 = element.node;
	            path.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(callId), [], node2.static));
	            decoratedPrivateMethods.add(key.id.name);
	            element.remove();
	          }
	        }
	        elementDecoratorInfo.push({
	          kind,
	          decoratorsArray,
	          decoratorsHaveThis,
	          name: nameExpr,
	          isStatic,
	          privateMethods,
	          locals
	        });
	        if (element.node) {
	          element.node.decorators = null;
	        }
	      }
	      if (isComputed && computedKeyAssignments.length > 0) {
	        if (classDecorators && element.isClassProperty({
	          static: true
	        })) ; else {
	          prependExpressionsToComputedKey(computedKeyAssignments, kind === ACCESSOR ? element.getNextSibling() : element);
	          computedKeyAssignments = [];
	        }
	      }
	      if (fieldInitializerExpressions.length > 0 && !isStatic && (kind === FIELD || kind === ACCESSOR)) {
	        prependExpressionsToFieldInitializer(fieldInitializerExpressions, element);
	        fieldInitializerExpressions = [];
	      }
	      if (staticFieldInitializerExpressions.length > 0 && isStatic && (kind === FIELD || kind === ACCESSOR)) {
	        prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element);
	        staticFieldInitializerExpressions = [];
	      }
	      if (hasDecorators2 && version === "2023-11") {
	        if (kind === FIELD || kind === ACCESSOR) {
	          const initExtraId = generateLetUidIdentifier(scopeParent, `init_extra_${name}`);
	          locals.push(initExtraId);
	          const initExtraCall = _core.types.callExpression(_core.types.cloneNode(initExtraId), isStatic ? [] : [_core.types.thisExpression()]);
	          if (!isStatic) {
	            fieldInitializerExpressions.push(initExtraCall);
	          } else {
	            staticFieldInitializerExpressions.push(initExtraCall);
	          }
	        }
	      }
	    }
	  }
	  if (computedKeyAssignments.length > 0) {
	    const elements = path.get("body.body");
	    let lastComputedElement;
	    for (let i = elements.length - 1; i >= 0; i--) {
	      const path2 = elements[i];
	      const node = path2.node;
	      if (node.computed) {
	        if (classDecorators && _core.types.isClassProperty(node, {
	          static: true
	        })) {
	          continue;
	        }
	        lastComputedElement = path2;
	        break;
	      }
	    }
	    if (lastComputedElement != null) {
	      appendExpressionsToComputedKey(computedKeyAssignments, lastComputedElement);
	      computedKeyAssignments = [];
	    }
	  }
	  if (fieldInitializerExpressions.length > 0) {
	    const isDerivedClass = !!path.node.superClass;
	    if (constructorPath) {
	      if (isDerivedClass) {
	        insertExpressionsAfterSuperCallAndOptimize(fieldInitializerExpressions, constructorPath, protoInitLocal);
	      } else {
	        prependExpressionsToConstructor(fieldInitializerExpressions, constructorPath);
	      }
	    } else {
	      path.node.body.body.unshift(createConstructorFromExpressions(fieldInitializerExpressions, isDerivedClass));
	    }
	    fieldInitializerExpressions = [];
	  }
	  if (staticFieldInitializerExpressions.length > 0) {
	    path.node.body.body.push(createStaticBlockFromExpressions(staticFieldInitializerExpressions));
	    staticFieldInitializerExpressions = [];
	  }
	  const sortedElementDecoratorInfo = toSortedDecoratorInfo(elementDecoratorInfo);
	  const elementDecorations = generateDecorationExprs(version === "2023-11" ? elementDecoratorInfo : sortedElementDecoratorInfo, version);
	  const elementLocals = extractElementLocalAssignments(sortedElementDecoratorInfo);
	  if (protoInitLocal) {
	    elementLocals.push(protoInitLocal);
	  }
	  if (staticInitLocal) {
	    elementLocals.push(staticInitLocal);
	  }
	  const classLocals = [];
	  let classInitInjected = false;
	  const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);
	  let originalClassPath = path;
	  const originalClass = path.node;
	  const staticClosures = [];
	  if (classDecorators) {
	    classLocals.push(classIdLocal, classInitLocal);
	    const statics = [];
	    path.get("body.body").forEach((element) => {
	      if (element.isStaticBlock()) {
	        if (hasInstancePrivateAccess(element, instancePrivateNames)) {
	          const staticBlockClosureId = memoiseExpression(staticBlockToFunctionClosure(element.node), "staticBlock", staticClosures);
	          staticFieldInitializerExpressions.push(_core.types.callExpression(_core.types.memberExpression(staticBlockClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
	        } else {
	          staticFieldInitializerExpressions.push(staticBlockToIIFE(element.node));
	        }
	        element.remove();
	        return;
	      }
	      if ((element.isClassProperty() || element.isClassPrivateProperty()) && element.node.static) {
	        const valuePath = element.get("value");
	        if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {
	          const fieldValueClosureId = memoiseExpression(fieldInitializerToClosure(valuePath.node), "fieldValue", staticClosures);
	          valuePath.replaceWith(_core.types.callExpression(_core.types.memberExpression(fieldValueClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
	        }
	        if (staticFieldInitializerExpressions.length > 0) {
	          prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element);
	          staticFieldInitializerExpressions = [];
	        }
	        element.node.static = false;
	        statics.push(element.node);
	        element.remove();
	      } else if (element.isClassPrivateMethod({
	        static: true
	      })) {
	        if (hasInstancePrivateAccess(element, instancePrivateNames)) {
	          const replaceSupers = new _helperReplaceSupers.default({
	            constantSuper,
	            methodPath: element,
	            objectRef: classIdLocal,
	            superRef: path.node.superClass,
	            file: state.file,
	            refToPreserve: classIdLocal
	          });
	          replaceSupers.replace();
	          const privateMethodDelegateId = memoiseExpression(createFunctionExpressionFromPrivateMethod(element.node), element.get("key.id").node.name, staticClosures);
	          if (ignoreFunctionLength) {
	            element.node.params = [_core.types.restElement(_core.types.identifier("arg"))];
	            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arg")]))]);
	          } else {
	            element.node.params = element.node.params.map((p, i) => {
	              if (_core.types.isRestElement(p)) {
	                return _core.types.restElement(_core.types.identifier("arg"));
	              } else {
	                return _core.types.identifier("_" + i);
	              }
	            });
	            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arguments")]))]);
	          }
	        }
	        element.node.static = false;
	        statics.push(element.node);
	        element.remove();
	      }
	    });
	    if (statics.length > 0 || staticFieldInitializerExpressions.length > 0) {
	      const staticsClass = _core.template.expression.ast`
        class extends ${state.addHelper("identity")} {}
      `;
	      staticsClass.body.body = [_core.types.classProperty(_core.types.toExpression(originalClass), void 0, void 0, void 0, true, true), ...statics];
	      const constructorBody = [];
	      const newExpr = _core.types.newExpression(staticsClass, []);
	      if (staticFieldInitializerExpressions.length > 0) {
	        constructorBody.push(...staticFieldInitializerExpressions);
	      }
	      if (classInitCall) {
	        classInitInjected = true;
	        constructorBody.push(classInitCall);
	      }
	      if (constructorBody.length > 0) {
	        constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classIdLocal)]));
	        staticsClass.body.body.push(createConstructorFromExpressions(constructorBody, false));
	      } else {
	        newExpr.arguments.push(_core.types.cloneNode(classIdLocal));
	      }
	      const [newPath] = path.replaceWith(newExpr);
	      originalClassPath = newPath.get("callee").get("body").get("body.0.key");
	    }
	  }
	  if (!classInitInjected && classInitCall) {
	    path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));
	  }
	  let {
	    superClass
	  } = originalClass;
	  if (superClass && (version === "2023-11" || version === "2023-05")) {
	    const id = path.scope.maybeGenerateMemoised(superClass);
	    if (id) {
	      originalClass.superClass = _core.types.assignmentExpression("=", id, superClass);
	      superClass = id;
	    }
	  }
	  const applyDecoratorWrapper = _core.types.staticBlock([]);
	  originalClass.body.body.unshift(applyDecoratorWrapper);
	  const applyDecsBody = applyDecoratorWrapper.body;
	  if (computedKeyAssignments.length > 0) {
	    const elements = originalClassPath.get("body.body");
	    let firstPublicElement;
	    for (const path2 of elements) {
	      if ((path2.isClassProperty() || path2.isClassMethod()) && path2.node.kind !== "constructor") {
	        firstPublicElement = path2;
	        break;
	      }
	    }
	    if (firstPublicElement != null) {
	      convertToComputedKey(firstPublicElement);
	      prependExpressionsToComputedKey(computedKeyAssignments, firstPublicElement);
	    } else {
	      originalClass.body.body.unshift(_core.types.classProperty(_core.types.sequenceExpression([...computedKeyAssignments, _core.types.stringLiteral("_")]), void 0, void 0, void 0, true, true));
	      applyDecsBody.push(_core.types.expressionStatement(_core.types.unaryExpression("delete", _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("_")))));
	    }
	    computedKeyAssignments = [];
	  }
	  applyDecsBody.push(_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorationsId != null ? classDecorationsId : _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, setClassName, _core.types.cloneNode(superClass), state, version)));
	  if (staticInitLocal) {
	    applyDecsBody.push(_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()])));
	  }
	  if (staticClosures.length > 0) {
	    applyDecsBody.push(...staticClosures.map((expr) => _core.types.expressionStatement(expr)));
	  }
	  path.insertBefore(classAssignments.map((expr) => _core.types.expressionStatement(expr)));
	  if (needsDeclaraionForClassBinding) {
	    const classBindingInfo = scopeParent.getBinding(classIdLocal.name);
	    if (!classBindingInfo.constantViolations.length) {
	      path.insertBefore(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));
	    } else {
	      const classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier("t" + classIdLocal.name);
	      const classOuterBindingLocal = classIdLocal;
	      path.replaceWithMultiple([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classOuterBindingLocal)), _core.types.variableDeclarator(classOuterBindingDelegateLocal)]), _core.types.blockStatement([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]), path.node, _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingDelegateLocal), _core.types.cloneNode(classIdLocal)))]), _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingLocal), _core.types.cloneNode(classOuterBindingDelegateLocal)))]);
	    }
	  }
	  if (decoratedPrivateMethods.size > 0) {
	    checkPrivateMethodUpdateError(path, decoratedPrivateMethods);
	  }
	  path.scope.crawl();
	  return path;
	}
	function createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBrandName, setClassName, superClass, state, version) {
	  let lhs, rhs;
	  const args = [setClassName ? createSetFunctionNameCall(state, setClassName) : _core.types.thisExpression(), classDecorations, elementDecorations];
	  {
	    if (version !== "2023-11") {
	      args.splice(1, 2, elementDecorations, classDecorations);
	    }
	    if (version === "2021-12" || version === "2022-03" && !state.availableHelper("applyDecs2203R")) {
	      lhs = _core.types.arrayPattern([...elementLocals, ...classLocals]);
	      rhs = _core.types.callExpression(state.addHelper(version === "2021-12" ? "applyDecs" : "applyDecs2203"), args);
	      return _core.types.assignmentExpression("=", lhs, rhs);
	    } else if (version === "2022-03") {
	      rhs = _core.types.callExpression(state.addHelper("applyDecs2203R"), args);
	    } else if (version === "2023-01") {
	      if (maybePrivateBrandName) {
	        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
	      }
	      rhs = _core.types.callExpression(state.addHelper("applyDecs2301"), args);
	    } else if (version === "2023-05") {
	      if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {
	        args.push(classDecorationsFlag);
	      }
	      if (maybePrivateBrandName) {
	        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
	      } else if (superClass) {
	        args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0)));
	      }
	      if (superClass) args.push(superClass);
	      rhs = _core.types.callExpression(state.addHelper("applyDecs2305"), args);
	    }
	  }
	  if (version === "2023-11") {
	    if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {
	      args.push(classDecorationsFlag);
	    }
	    if (maybePrivateBrandName) {
	      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));
	    } else if (superClass) {
	      args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0)));
	    }
	    if (superClass) args.push(superClass);
	    rhs = _core.types.callExpression(state.addHelper("applyDecs2311"), args);
	  }
	  if (elementLocals.length > 0) {
	    if (classLocals.length > 0) {
	      lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier("c"), _core.types.arrayPattern(classLocals))]);
	    } else {
	      lhs = _core.types.arrayPattern(elementLocals);
	      rhs = _core.types.memberExpression(rhs, _core.types.identifier("e"), false, false);
	    }
	  } else {
	    lhs = _core.types.arrayPattern(classLocals);
	    rhs = _core.types.memberExpression(rhs, _core.types.identifier("c"), false, false);
	  }
	  return _core.types.assignmentExpression("=", lhs, rhs);
	}
	function isProtoKey(node) {
	  return node.type === "Identifier" ? node.name === "__proto__" : node.value === "__proto__";
	}
	function isDecorated(node) {
	  return node.decorators && node.decorators.length > 0;
	}
	function shouldTransformElement(node) {
	  switch (node.type) {
	    case "ClassAccessorProperty":
	      return true;
	    case "ClassMethod":
	    case "ClassProperty":
	    case "ClassPrivateMethod":
	    case "ClassPrivateProperty":
	      return isDecorated(node);
	    default:
	      return false;
	  }
	}
	function shouldTransformClass(node) {
	  return isDecorated(node) || node.body.body.some(shouldTransformElement);
	}
	function NamedEvaluationVisitoryFactory(isAnonymous, visitor) {
	  function handleComputedProperty(propertyPath, key, state) {
	    switch (key.type) {
	      case "StringLiteral":
	        return _core.types.stringLiteral(key.value);
	      case "NumericLiteral":
	      case "BigIntLiteral": {
	        const keyValue = key.value + "";
	        propertyPath.get("key").replaceWith(_core.types.stringLiteral(keyValue));
	        return _core.types.stringLiteral(keyValue);
	      }
	      default: {
	        const ref = propertyPath.scope.maybeGenerateMemoised(key);
	        propertyPath.get("key").replaceWith(_core.types.assignmentExpression("=", ref, createToPropertyKeyCall(state, key)));
	        return _core.types.cloneNode(ref);
	      }
	    }
	  }
	  return {
	    VariableDeclarator(path, state) {
	      const id = path.node.id;
	      if (id.type === "Identifier") {
	        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("init"));
	        if (isAnonymous(initializer)) {
	          const name = id.name;
	          visitor(initializer, state, name);
	        }
	      }
	    },
	    AssignmentExpression(path, state) {
	      const id = path.node.left;
	      if (id.type === "Identifier") {
	        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
	        if (isAnonymous(initializer)) {
	          switch (path.node.operator) {
	            case "=":
	            case "&&=":
	            case "||=":
	            case "??=":
	              visitor(initializer, state, id.name);
	          }
	        }
	      }
	    },
	    AssignmentPattern(path, state) {
	      const id = path.node.left;
	      if (id.type === "Identifier") {
	        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
	        if (isAnonymous(initializer)) {
	          const name = id.name;
	          visitor(initializer, state, name);
	        }
	      }
	    },
	    ObjectExpression(path, state) {
	      for (const propertyPath of path.get("properties")) {
	        if (!propertyPath.isObjectProperty()) continue;
	        const {
	          node
	        } = propertyPath;
	        const id = node.key;
	        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get("value"));
	        if (isAnonymous(initializer)) {
	          if (!node.computed) {
	            if (!isProtoKey(id)) {
	              if (id.type === "Identifier") {
	                visitor(initializer, state, id.name);
	              } else {
	                const className = _core.types.stringLiteral(id.value + "");
	                visitor(initializer, state, className);
	              }
	            }
	          } else {
	            const ref = handleComputedProperty(propertyPath, id, state);
	            visitor(initializer, state, ref);
	          }
	        }
	      }
	    },
	    ClassPrivateProperty(path, state) {
	      const {
	        node
	      } = path;
	      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
	      if (isAnonymous(initializer)) {
	        const className = _core.types.stringLiteral("#" + node.key.id.name);
	        visitor(initializer, state, className);
	      }
	    },
	    ClassAccessorProperty(path, state) {
	      const {
	        node
	      } = path;
	      const id = node.key;
	      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
	      if (isAnonymous(initializer)) {
	        if (!node.computed) {
	          if (id.type === "Identifier") {
	            visitor(initializer, state, id.name);
	          } else if (id.type === "PrivateName") {
	            const className = _core.types.stringLiteral("#" + id.id.name);
	            visitor(initializer, state, className);
	          } else {
	            const className = _core.types.stringLiteral(id.value + "");
	            visitor(initializer, state, className);
	          }
	        } else {
	          const ref = handleComputedProperty(path, id, state);
	          visitor(initializer, state, ref);
	        }
	      }
	    },
	    ClassProperty(path, state) {
	      const {
	        node
	      } = path;
	      const id = node.key;
	      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
	      if (isAnonymous(initializer)) {
	        if (!node.computed) {
	          if (id.type === "Identifier") {
	            visitor(initializer, state, id.name);
	          } else {
	            const className = _core.types.stringLiteral(id.value + "");
	            visitor(initializer, state, className);
	          }
	        } else {
	          const ref = handleComputedProperty(path, id, state);
	          visitor(initializer, state, ref);
	        }
	      }
	    }
	  };
	}
	function isDecoratedAnonymousClassExpression(path) {
	  return path.isClassExpression({
	    id: null
	  }) && shouldTransformClass(path.node);
	}
	function generateLetUidIdentifier(scope, name) {
	  const id = scope.generateUidIdentifier(name);
	  scope.push({
	    id,
	    kind: "let"
	  });
	  return _core.types.cloneNode(id);
	}
	function _default({
	  assertVersion,
	  assumption
	}, {
	  loose
	}, version, inherits) {
	  var _assumption, _assumption2;
	  {
	    if (version === "2023-11" || version === "2023-05" || version === "2023-01") {
	      assertVersion("^7.21.0");
	    } else if (version === "2021-12") {
	      assertVersion("^7.16.0");
	    } else {
	      assertVersion("^7.19.0");
	    }
	  }
	  const VISITED = /* @__PURE__ */ new WeakSet();
	  const constantSuper = (_assumption = assumption("constantSuper")) != null ? _assumption : loose;
	  const ignoreFunctionLength = (_assumption2 = assumption("ignoreFunctionLength")) != null ? _assumption2 : loose;
	  const namedEvaluationVisitor = NamedEvaluationVisitoryFactory(isDecoratedAnonymousClassExpression, visitClass);
	  function visitClass(path, state, className) {
	    var _node$id;
	    if (VISITED.has(path)) return;
	    const {
	      node
	    } = path;
	    className != null ? className : className = (_node$id = node.id) == null ? void 0 : _node$id.name;
	    const newPath = transformClass(path, state, constantSuper, ignoreFunctionLength, className, namedEvaluationVisitor, version);
	    if (newPath) {
	      VISITED.add(newPath);
	      return;
	    }
	    VISITED.add(path);
	  }
	  return {
	    name: "proposal-decorators",
	    inherits,
	    visitor: Object.assign({
	      ExportDefaultDeclaration(path, state) {
	        const {
	          declaration
	        } = path.node;
	        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
	          const isAnonymous = !declaration.id;
	          {
	            var _path$splitExportDecl;
	            (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require$$2$2.NodePath.prototype.splitExportDeclaration;
	          }
	          const updatedVarDeclarationPath = path.splitExportDeclaration();
	          if (isAnonymous) {
	            visitClass(updatedVarDeclarationPath, state, _core.types.stringLiteral("default"));
	          }
	        }
	      },
	      ExportNamedDeclaration(path) {
	        const {
	          declaration
	        } = path.node;
	        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && isDecorated(declaration)) {
	          {
	            var _path$splitExportDecl2;
	            (_path$splitExportDecl2 = path.splitExportDeclaration) != null ? _path$splitExportDecl2 : path.splitExportDeclaration = require$$2$2.NodePath.prototype.splitExportDeclaration;
	          }
	          path.splitExportDeclaration();
	        }
	      },
	      Class(path, state) {
	        visitClass(path, state, void 0);
	      }
	    }, namedEvaluationVisitor)
	  };
	}
	return decorators;
}

var decorators201809 = {};

var hasRequiredDecorators201809;

function requireDecorators201809 () {
	if (hasRequiredDecorators201809) return decorators201809;
	hasRequiredDecorators201809 = 1;
	Object.defineProperty(decorators201809, "__esModule", {
	  value: true
	});
	decorators201809.buildDecoratedClass = buildDecoratedClass;
	var _core = require$$0$b;
	var _helperReplaceSupers = requireLib$Z();
	function prop(key, value) {
	  if (!value) return null;
	  return _core.types.objectProperty(_core.types.identifier(key), value);
	}
	function method(key, body) {
	  return _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body));
	}
	function takeDecorators(node) {
	  let result;
	  if (node.decorators && node.decorators.length > 0) {
	    result = _core.types.arrayExpression(node.decorators.map((decorator) => decorator.expression));
	  }
	  node.decorators = void 0;
	  return result;
	}
	function getKey(node) {
	  if (node.computed) {
	    return node.key;
	  } else if (_core.types.isIdentifier(node.key)) {
	    return _core.types.stringLiteral(node.key.name);
	  } else {
	    return _core.types.stringLiteral(String(node.key.value));
	  }
	}
	function extractElementDescriptor(file, classRef, superRef, path) {
	  const isMethod = path.isClassMethod();
	  if (path.isPrivate()) {
	    throw path.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
	  }
	  if (path.node.type === "ClassAccessorProperty") {
	    throw path.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
	  }
	  if (path.node.type === "StaticBlock") {
	    throw path.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
	  }
	  const {
	    node,
	    scope
	  } = path;
	  if (!path.isTSDeclareMethod()) {
	    new _helperReplaceSupers.default({
	      methodPath: path,
	      objectRef: classRef,
	      superRef,
	      file,
	      refToPreserve: classRef
	    }).replace();
	  }
	  const properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core.types.booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);
	  if (isMethod) {
	    {
	      var _path$ensureFunctionN;
	      (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	    }
	    path.ensureFunctionName(false);
	    properties.push(prop("value", _core.types.toExpression(path.node)));
	  } else if (_core.types.isClassProperty(node) && node.value) {
	    properties.push(method("value", _core.template.statements.ast`return ${node.value}`));
	  } else {
	    properties.push(prop("value", scope.buildUndefinedNode()));
	  }
	  path.remove();
	  return _core.types.objectExpression(properties);
	}
	function addDecorateHelper(file) {
	  return file.addHelper("decorate");
	}
	function buildDecoratedClass(ref, path, elements, file) {
	  const {
	    node,
	    scope
	  } = path;
	  const initializeId = scope.generateUidIdentifier("initialize");
	  const isDeclaration = node.id && path.isDeclaration();
	  const isStrict = path.isInStrictMode();
	  const {
	    superClass
	  } = node;
	  node.type = "ClassDeclaration";
	  if (!node.id) node.id = _core.types.cloneNode(ref);
	  let superId;
	  if (superClass) {
	    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
	    node.superClass = superId;
	  }
	  const classDecorators = takeDecorators(node);
	  const definitions = _core.types.arrayExpression(elements.filter((element) => !element.node.abstract && element.node.type !== "TSIndexSignature").map((path2) => extractElementDescriptor(file, node.id, superId, path2)));
	  const wrapperCall = _core.template.expression.ast`
    ${addDecorateHelper(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
	  if (!isStrict) {
	    wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
	  }
	  let replacement = wrapperCall;
	  let classPathDesc = "arguments.1.body.body.0";
	  if (isDeclaration) {
	    replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;
	    classPathDesc = "declarations.0.init." + classPathDesc;
	  }
	  return {
	    instanceNodes: [_core.template.statement.ast`
        ${_core.types.cloneNode(initializeId)}(this)
      `],
	    wrapClass(path2) {
	      path2.replaceWith(replacement);
	      return path2.get(classPathDesc);
	    }
	  };
	}
	return decorators201809;
}

var features$1 = {};

var hasRequiredFeatures$1;

function requireFeatures$1 () {
	if (hasRequiredFeatures$1) return features$1;
	hasRequiredFeatures$1 = 1;
	Object.defineProperty(features$1, "__esModule", {
	  value: true
	});
	features$1.FEATURES = void 0;
	features$1.enableFeature = enableFeature;
	features$1.isLoose = isLoose;
	features$1.shouldTransform = shouldTransform;
	var _decorators = requireDecorators();
	const FEATURES = features$1.FEATURES = Object.freeze({
	  fields: 1 << 1,
	  privateMethods: 1 << 2,
	  decorators: 1 << 3,
	  privateIn: 1 << 4,
	  staticBlocks: 1 << 5
	});
	const featuresSameLoose = /* @__PURE__ */ new Map([[FEATURES.fields, "@babel/plugin-transform-class-properties"], [FEATURES.privateMethods, "@babel/plugin-transform-private-methods"], [FEATURES.privateIn, "@babel/plugin-transform-private-property-in-object"]]);
	const featuresKey = "@babel/plugin-class-features/featuresKey";
	const looseKey = "@babel/plugin-class-features/looseKey";
	{
	  var looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
	}
	{
	  var canIgnoreLoose = function(file, feature) {
	    return !!(file.get(looseLowPriorityKey) & feature);
	  };
	}
	function enableFeature(file, feature, loose) {
	  if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {
	    file.set(featuresKey, file.get(featuresKey) | feature);
	    if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
	      setLoose(file, feature, true);
	      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
	    } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
	      setLoose(file, feature, false);
	      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
	    } else {
	      setLoose(file, feature, loose);
	    }
	  }
	  let resolvedLoose;
	  for (const [mask, name] of featuresSameLoose) {
	    if (!hasFeature(file, mask)) continue;
	    {
	      if (canIgnoreLoose(file, mask)) continue;
	    }
	    const loose2 = isLoose(file, mask);
	    if (resolvedLoose === !loose2) {
	      throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).\n\n" + getBabelShowConfigForHint(file));
	    } else {
	      resolvedLoose = loose2;
	      {
	        var higherPriorityPluginName = name;
	      }
	    }
	  }
	  if (resolvedLoose !== void 0) {
	    for (const [mask, name] of featuresSameLoose) {
	      if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {
	        setLoose(file, mask, resolvedLoose);
	        console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${name}", { "loose": ${resolvedLoose} }]
to the "plugins" section of your Babel config.

` + getBabelShowConfigForHint(file));
	      }
	    }
	  }
	}
	function getBabelShowConfigForHint(file) {
	  let {
	    filename
	  } = file.opts;
	  if (!filename || filename === "unknown") {
	    filename = "[name of the input file]";
	  }
	  return `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${filename} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
	}
	function hasFeature(file, feature) {
	  return !!(file.get(featuresKey) & feature);
	}
	function isLoose(file, feature) {
	  return !!(file.get(looseKey) & feature);
	}
	function setLoose(file, feature, loose) {
	  if (loose) file.set(looseKey, file.get(looseKey) | feature);
	  else file.set(looseKey, file.get(looseKey) & ~feature);
	  {
	    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
	  }
	}
	function shouldTransform(path, file) {
	  let decoratorPath = null;
	  let publicFieldPath = null;
	  let privateFieldPath = null;
	  let privateMethodPath = null;
	  let staticBlockPath = null;
	  if ((0, _decorators.hasOwnDecorators)(path.node)) {
	    decoratorPath = path.get("decorators.0");
	  }
	  for (const el of path.get("body.body")) {
	    if (!decoratorPath && (0, _decorators.hasOwnDecorators)(el.node)) {
	      decoratorPath = el.get("decorators.0");
	    }
	    if (!publicFieldPath && el.isClassProperty()) {
	      publicFieldPath = el;
	    }
	    if (!privateFieldPath && el.isClassPrivateProperty()) {
	      privateFieldPath = el;
	    }
	    if (!privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod()) {
	      privateMethodPath = el;
	    }
	    if (!staticBlockPath && el.isStaticBlock != null && el.isStaticBlock()) {
	      staticBlockPath = el;
	    }
	  }
	  if (decoratorPath && privateFieldPath) {
	    throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
	  }
	  if (decoratorPath && privateMethodPath) {
	    throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
	  }
	  if (decoratorPath && !hasFeature(file, FEATURES.decorators)) {
	    throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n	["@babel/plugin-transform-class-properties", { "loose": true }]');
	  }
	  if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) {
	    throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
	  }
	  if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods)) {
	    throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
	  }
	  if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) {
	    throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
	  }
	  if (decoratorPath || privateMethodPath || staticBlockPath) {
	    return true;
	  }
	  if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields)) {
	    return true;
	  }
	  return false;
	}
	return features$1;
}

var hasRequiredLib$W;

function requireLib$W () {
	if (hasRequiredLib$W) return lib$V;
	hasRequiredLib$W = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "FEATURES", {
		  enumerable: true,
		  get: function() {
		    return _features.FEATURES;
		  }
		});
		Object.defineProperty(exports, "buildCheckInRHS", {
		  enumerable: true,
		  get: function() {
		    return _fields.buildCheckInRHS;
		  }
		});
		exports.createClassFeaturePlugin = createClassFeaturePlugin;
		Object.defineProperty(exports, "enableFeature", {
		  enumerable: true,
		  get: function() {
		    return _features.enableFeature;
		  }
		});
		Object.defineProperty(exports, "injectInitialization", {
		  enumerable: true,
		  get: function() {
		    return _misc.injectInitialization;
		  }
		});
		var _core = require$$0$b;
		var _semver = requireSemver();
		var _fields = requireFields();
		var _decorators = requireDecorators();
		var _decorators2 = requireDecorators201809();
		var _misc = requireMisc();
		var _features = requireFeatures$1();
		var _typescript = requireTypescript();
		const versionKey = "@babel/plugin-class-features/version";
		function createClassFeaturePlugin({
		  name,
		  feature,
		  loose,
		  manipulateOptions,
		  api,
		  inherits,
		  decoratorVersion
		}) {
		  var _api$assumption;
		  if (feature & _features.FEATURES.decorators) {
		    {
		      if (decoratorVersion === "2023-11" || decoratorVersion === "2023-05" || decoratorVersion === "2023-01" || decoratorVersion === "2022-03" || decoratorVersion === "2021-12") {
		        return (0, _decorators.default)(api, {
		          loose
		        }, decoratorVersion, inherits);
		      }
		    }
		  }
		  {
		    api != null ? api : api = {
		      assumption: () => void 0
		    };
		  }
		  const setPublicClassFields = api.assumption("setPublicClassFields");
		  const privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols");
		  const privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
		  const noUninitializedPrivateFieldAccess = (_api$assumption = api.assumption("noUninitializedPrivateFieldAccess")) != null ? _api$assumption : false;
		  const constantSuper = api.assumption("constantSuper");
		  const noDocumentAll = api.assumption("noDocumentAll");
		  if (privateFieldsAsProperties && privateFieldsAsSymbols) {
		    throw new Error(`Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.`);
		  }
		  const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
		  if (loose === true) {
		    const explicit = [];
		    if (setPublicClassFields !== void 0) {
		      explicit.push(`"setPublicClassFields"`);
		    }
		    if (privateFieldsAsProperties !== void 0) {
		      explicit.push(`"privateFieldsAsProperties"`);
		    }
		    if (privateFieldsAsSymbols !== void 0) {
		      explicit.push(`"privateFieldsAsSymbols"`);
		    }
		    if (explicit.length !== 0) {
		      console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
		    }
		  }
		  return {
		    name,
		    manipulateOptions,
		    inherits,
		    pre(file) {
		      (0, _features.enableFeature)(file, feature, loose);
		      {
		        if (typeof file.get(versionKey) === "number") {
		          file.set(versionKey, "7.27.1");
		          return;
		        }
		      }
		      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.27.1")) {
		        file.set(versionKey, "7.27.1");
		      }
		    },
		    visitor: {
		      Class(path, {
		        file
		      }) {
		        if (file.get(versionKey) !== "7.27.1") return;
		        if (!(0, _features.shouldTransform)(path, file)) return;
		        const pathIsClassDeclaration = path.isClassDeclaration();
		        if (pathIsClassDeclaration) (0, _typescript.assertFieldTransformed)(path);
		        const loose2 = (0, _features.isLoose)(file, feature);
		        let constructor;
		        const isDecorated = (0, _decorators.hasDecorators)(path.node);
		        const props = [];
		        const elements = [];
		        const computedPaths = [];
		        const privateNames = /* @__PURE__ */ new Set();
		        const body = path.get("body");
		        for (const path2 of body.get("body")) {
		          if ((path2.isClassProperty() || path2.isClassMethod()) && path2.node.computed) {
		            computedPaths.push(path2);
		          }
		          if (path2.isPrivate()) {
		            const {
		              name: name2
		            } = path2.node.key.id;
		            const getName = `get ${name2}`;
		            const setName = `set ${name2}`;
		            if (path2.isClassPrivateMethod()) {
		              if (path2.node.kind === "get") {
		                if (privateNames.has(getName) || privateNames.has(name2) && !privateNames.has(setName)) {
		                  throw path2.buildCodeFrameError("Duplicate private field");
		                }
		                privateNames.add(getName).add(name2);
		              } else if (path2.node.kind === "set") {
		                if (privateNames.has(setName) || privateNames.has(name2) && !privateNames.has(getName)) {
		                  throw path2.buildCodeFrameError("Duplicate private field");
		                }
		                privateNames.add(setName).add(name2);
		              }
		            } else {
		              if (privateNames.has(name2) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name2) && (privateNames.has(getName) || privateNames.has(setName))) {
		                throw path2.buildCodeFrameError("Duplicate private field");
		              }
		              privateNames.add(name2);
		            }
		          }
		          if (path2.isClassMethod({
		            kind: "constructor"
		          })) {
		            constructor = path2;
		          } else {
		            elements.push(path2);
		            if (path2.isProperty() || path2.isPrivate() || path2.isStaticBlock != null && path2.isStaticBlock()) {
		              props.push(path2);
		            }
		          }
		        }
		        {
		          if (!props.length && !isDecorated) return;
		        }
		        const innerBinding = path.node.id;
		        let ref;
		        if (!innerBinding || !pathIsClassDeclaration) {
		          {
		            var _path$ensureFunctionN;
		            (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
		          }
		          path.ensureFunctionName(false);
		          ref = path.scope.generateUidIdentifier((innerBinding == null ? void 0 : innerBinding.name) || "Class");
		        }
		        const classRefForDefine = ref != null ? ref : _core.types.cloneNode(innerBinding);
		        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(classRefForDefine.name, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose2, props, file);
		        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose2, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);
		        (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path, privateNamesMap, {
		          privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose2,
		          noUninitializedPrivateFieldAccess,
		          noDocumentAll,
		          innerBinding
		        }, file);
		        let keysNodes, staticNodes, instanceNodes, lastInstanceNodeReturnsThis, pureStaticNodes, classBindingNode, wrapClass;
		        {
		          if (isDecorated) {
		            staticNodes = pureStaticNodes = keysNodes = [];
		            ({
		              instanceNodes,
		              wrapClass
		            } = (0, _decorators2.buildDecoratedClass)(classRefForDefine, path, elements, file));
		          } else {
		            keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);
		            ({
		              staticNodes,
		              pureStaticNodes,
		              instanceNodes,
		              lastInstanceNodeReturnsThis,
		              classBindingNode,
		              wrapClass
		            } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose2, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose2, noUninitializedPrivateFieldAccess, constantSuper != null ? constantSuper : loose2, innerBinding));
		          }
		        }
		        if (instanceNodes.length > 0) {
		          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {
		            {
		              if (isDecorated) return;
		            }
		            for (const prop of props) {
		              if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static) continue;
		              prop.traverse(referenceVisitor, state);
		            }
		          }, lastInstanceNodeReturnsThis);
		        }
		        const wrappedPath = wrapClass(path);
		        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);
		        if (staticNodes.length > 0) {
		          wrappedPath.insertAfter(staticNodes);
		        }
		        if (pureStaticNodes.length > 0) {
		          wrappedPath.find((parent) => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);
		        }
		        if (classBindingNode != null && pathIsClassDeclaration) {
		          wrappedPath.insertAfter(classBindingNode);
		        }
		      },
		      ExportDefaultDeclaration(path, {
		        file
		      }) {
		        {
		          if (file.get(versionKey) !== "7.27.1") return;
		          const decl = path.get("declaration");
		          if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {
		            if (decl.node.id) {
		              {
		                var _path$splitExportDecl;
		                (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require$$2$2.NodePath.prototype.splitExportDeclaration;
		              }
		              path.splitExportDeclaration();
		            } else {
		              decl.node.type = "ClassExpression";
		            }
		          }
		        }
		      }
		    }
		  };
		} 
	} (lib$V));
	return lib$V;
}

var hasRequiredLib$V;

function requireLib$V () {
	if (hasRequiredLib$V) return lib$W;
	hasRequiredLib$V = 1;
	Object.defineProperty(lib$W, "__esModule", {
	  value: true
	});
	lib$W.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperCreateClassFeaturesPlugin = requireLib$W();
	lib$W.default = (0, _helperPluginUtils.declare)((api, options) => {
	  api.assertVersion(7);
	  return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
	    name: "transform-class-properties",
	    api,
	    feature: _helperCreateClassFeaturesPlugin.FEATURES.fields,
	    loose: options.loose,
	    manipulateOptions(opts, parserOpts) {
	      {
	        parserOpts.plugins.push("classProperties", "classPrivateProperties");
	      }
	    }
	  });
	});
	return lib$W;
}

var lib$T = {};

var hasRequiredLib$U;

function requireLib$U () {
	if (hasRequiredLib$U) return lib$T;
	hasRequiredLib$U = 1;
	Object.defineProperty(lib$T, "__esModule", {
	  value: true
	});
	lib$T.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperCreateClassFeaturesPlugin = requireLib$W();
	function generateUid(scope, denyList) {
	  const name = "";
	  let uid;
	  let i = 1;
	  do {
	    uid = `_${name}`;
	    if (i > 1) uid += i;
	    i++;
	  } while (denyList.has(uid));
	  return uid;
	}
	lib$T.default = (0, _helperPluginUtils.declare)(({
	  types: t,
	  template,
	  assertVersion
	}) => {
	  assertVersion("^7.12.0 || >8.0.0-alpha <8.0.0-beta");
	  return {
	    name: "transform-class-static-block",
	    manipulateOptions: (_, parser) => parser.plugins.push("classStaticBlock"),
	    pre() {
	      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);
	    },
	    visitor: {
	      ClassBody(classBody) {
	        const {
	          scope
	        } = classBody;
	        const privateNames = /* @__PURE__ */ new Set();
	        const body = classBody.get("body");
	        for (const path of body) {
	          if (path.isPrivate()) {
	            privateNames.add(path.get("key.id").node.name);
	          }
	        }
	        for (const path of body) {
	          if (!path.isStaticBlock()) continue;
	          const staticBlockPrivateId = generateUid(scope, privateNames);
	          privateNames.add(staticBlockPrivateId);
	          const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));
	          let replacement;
	          const blockBody = path.node.body;
	          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {
	            replacement = t.inheritsComments(blockBody[0].expression, blockBody[0]);
	          } else {
	            replacement = template.expression.ast`(() => { ${blockBody} })()`;
	          }
	          path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));
	        }
	      }
	    }
	  };
	});
	return lib$T;
}

var lib$S = {};

var hasRequiredLib$T;

function requireLib$T () {
	if (hasRequiredLib$T) return lib$S;
	hasRequiredLib$T = 1;
	Object.defineProperty(lib$S, "__esModule", {
	  value: true
	});
	lib$S.default = void 0;
	var _core = require$$0$b;
	var _helperPluginUtils = requireLib$1f();
	var _template = requireLib$19();
	{
	  var DefineAccessorHelper = _template.default.expression.ast`
    function (type, obj, key, fn) {
      var desc = { configurable: true, enumerable: true };
      desc[type] = fn;
      return Object.defineProperty(obj, key, desc);
    }
  `;
	  DefineAccessorHelper._compact = true;
	}
	lib$S.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption;
	  api.assertVersion(7);
	  const setComputedProperties = (_api$assumption = api.assumption("setComputedProperties")) != null ? _api$assumption : options.loose;
	  const pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;
	  function buildDefineAccessor(state, obj, prop) {
	    const type = prop.kind;
	    const key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;
	    const fn = getValue(prop);
	    {
	      let helper;
	      if (state.availableHelper("defineAccessor")) {
	        helper = state.addHelper("defineAccessor");
	      } else {
	        const file = state.file;
	        helper = file.get("fallbackDefineAccessorHelper");
	        if (!helper) {
	          const id = file.scope.generateUidIdentifier("defineAccessor");
	          file.scope.push({
	            id,
	            init: DefineAccessorHelper
	          });
	          file.set("fallbackDefineAccessorHelper", helper = id);
	        }
	        helper = _core.types.cloneNode(helper);
	      }
	      return _core.types.callExpression(helper, [_core.types.stringLiteral(type), obj, key, fn]);
	    }
	  }
	  function getValue(prop) {
	    if (_core.types.isObjectProperty(prop)) {
	      return prop.value;
	    } else if (_core.types.isObjectMethod(prop)) {
	      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
	    }
	  }
	  function pushAssign(objId, prop, body) {
	    body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));
	  }
	  function pushComputedPropsLoose(info) {
	    const {
	      computedProps,
	      state,
	      initPropExpression,
	      objId,
	      body
	    } = info;
	    for (const prop of computedProps) {
	      if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
	        if (computedProps.length === 1) {
	          return buildDefineAccessor(state, initPropExpression, prop);
	        } else {
	          body.push(_core.types.expressionStatement(buildDefineAccessor(state, _core.types.cloneNode(objId), prop)));
	        }
	      } else {
	        pushAssign(_core.types.cloneNode(objId), prop, body);
	      }
	    }
	  }
	  function pushComputedPropsSpec(info) {
	    const {
	      objId,
	      body,
	      computedProps,
	      state
	    } = info;
	    const CHUNK_LENGTH_CAP = 10;
	    let currentChunk = null;
	    const computedPropsChunks = [];
	    for (const prop of computedProps) {
	      if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {
	        currentChunk = [];
	        computedPropsChunks.push(currentChunk);
	      }
	      currentChunk.push(prop);
	    }
	    for (const chunk of computedPropsChunks) {
	      const single = computedPropsChunks.length === 1;
	      let node = single ? info.initPropExpression : _core.types.cloneNode(objId);
	      for (const prop of chunk) {
	        if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
	          node = buildDefineAccessor(info.state, node, prop);
	        } else {
	          node = _core.types.callExpression(state.addHelper("defineProperty"), [node, _core.types.toComputedKey(prop), getValue(prop)]);
	        }
	      }
	      if (single) return node;
	      body.push(_core.types.expressionStatement(node));
	    }
	  }
	  return {
	    name: "transform-computed-properties",
	    visitor: {
	      ObjectExpression: {
	        exit(path, state) {
	          const {
	            node,
	            parent,
	            scope
	          } = path;
	          let hasComputed = false;
	          for (const prop of node.properties) {
	            hasComputed = prop.computed === true;
	            if (hasComputed) break;
	          }
	          if (!hasComputed) return;
	          const initProps = [];
	          const computedProps = [];
	          let foundComputed = false;
	          for (const prop of node.properties) {
	            if (_core.types.isSpreadElement(prop)) {
	              continue;
	            }
	            if (prop.computed) {
	              foundComputed = true;
	            }
	            if (foundComputed) {
	              computedProps.push(prop);
	            } else {
	              initProps.push(prop);
	            }
	          }
	          const objId = scope.generateUidIdentifierBasedOnNode(parent);
	          const initPropExpression = _core.types.objectExpression(initProps);
	          const body = [];
	          body.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(objId, initPropExpression)]));
	          const single = pushComputedProps({
	            objId,
	            body,
	            computedProps,
	            initPropExpression,
	            state
	          });
	          if (single) {
	            path.replaceWith(single);
	          } else {
	            if (setComputedProperties) {
	              body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));
	            }
	            path.replaceWithMultiple(body);
	          }
	        }
	      }
	    }
	  };
	});
	return lib$S;
}

var lib$R = {};

var hasRequiredLib$S;

function requireLib$S () {
	if (hasRequiredLib$S) return lib$R;
	hasRequiredLib$S = 1;
	Object.defineProperty(lib$R, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	var core = require$$0$b;
	function isPureVoid(node) {
	  return core.types.isUnaryExpression(node) && node.operator === "void" && core.types.isPureish(node.argument);
	}
	function unshiftForXStatementBody(statementPath, newStatements) {
	  statementPath.ensureBlock();
	  const {
	    scope,
	    node
	  } = statementPath;
	  const bodyScopeBindings = statementPath.get("body").scope.bindings;
	  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some((name) => scope.hasBinding(name));
	  if (hasShadowedBlockScopedBindings) {
	    node.body = core.types.blockStatement([...newStatements, node.body]);
	  } else {
	    node.body.body.unshift(...newStatements);
	  }
	}
	function hasArrayRest(pattern) {
	  return pattern.elements.some((elem) => core.types.isRestElement(elem));
	}
	function hasObjectRest(pattern) {
	  return pattern.properties.some((prop) => core.types.isRestElement(prop));
	}
	const STOP_TRAVERSAL = {};
	const arrayUnpackVisitor = (node, ancestors, state) => {
	  if (!ancestors.length) {
	    return;
	  }
	  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {
	    state.deopt = true;
	    throw STOP_TRAVERSAL;
	  }
	};
	class DestructuringTransformer {
	  constructor(opts) {
	    this.blockHoist = void 0;
	    this.operator = void 0;
	    this.arrayRefSet = void 0;
	    this.nodes = void 0;
	    this.scope = void 0;
	    this.kind = void 0;
	    this.iterableIsArray = void 0;
	    this.arrayLikeIsIterable = void 0;
	    this.objectRestNoSymbols = void 0;
	    this.useBuiltIns = void 0;
	    this.addHelper = void 0;
	    this.blockHoist = opts.blockHoist;
	    this.operator = opts.operator;
	    this.arrayRefSet = /* @__PURE__ */ new Set();
	    this.nodes = opts.nodes || [];
	    this.scope = opts.scope;
	    this.kind = opts.kind;
	    this.iterableIsArray = opts.iterableIsArray;
	    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
	    this.objectRestNoSymbols = opts.objectRestNoSymbols;
	    this.useBuiltIns = opts.useBuiltIns;
	    this.addHelper = opts.addHelper;
	  }
	  getExtendsHelper() {
	    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : this.addHelper("extends");
	  }
	  buildVariableAssignment(id, init) {
	    let op = this.operator;
	    if (core.types.isMemberExpression(id) || core.types.isOptionalMemberExpression(id)) op = "=";
	    let node;
	    if (op) {
	      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
	    } else {
	      let nodeInit;
	      if (this.kind === "const" && init === null) {
	        nodeInit = this.scope.buildUndefinedNode();
	      } else {
	        nodeInit = core.types.cloneNode(init);
	      }
	      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);
	    }
	    node._blockHoist = this.blockHoist;
	    return node;
	  }
	  buildVariableDeclaration(id, init) {
	    const declar = core.types.variableDeclaration("var", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);
	    declar._blockHoist = this.blockHoist;
	    return declar;
	  }
	  push(id, _init) {
	    const init = core.types.cloneNode(_init);
	    if (core.types.isObjectPattern(id)) {
	      this.pushObjectPattern(id, init);
	    } else if (core.types.isArrayPattern(id)) {
	      this.pushArrayPattern(id, init);
	    } else if (core.types.isAssignmentPattern(id)) {
	      this.pushAssignmentPattern(id, init);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(id, init));
	    }
	  }
	  toArray(node, count) {
	    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {
	      return node;
	    } else {
	      const {
	        scope,
	        arrayLikeIsIterable
	      } = this;
	      if (core.types.isIdentifier(node)) {
	        const binding = scope.getBinding(node.name);
	        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
	          return node;
	        }
	      }
	      if (core.types.isArrayExpression(node)) {
	        return node;
	      }
	      if (core.types.isIdentifier(node, {
	        name: "arguments"
	      })) {
	        return core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
	      }
	      let helperName;
	      const args = [node];
	      if (typeof count === "number") {
	        args.push(core.types.numericLiteral(count));
	        helperName = "slicedToArray";
	      } else {
	        helperName = "toArray";
	      }
	      if (arrayLikeIsIterable) {
	        args.unshift(scope.path.hub.addHelper(helperName));
	        helperName = "maybeArrayLike";
	      }
	      return core.types.callExpression(scope.path.hub.addHelper(helperName), args);
	    }
	  }
	  pushAssignmentPattern({
	    left,
	    right
	  }, valueRef) {
	    if (isPureVoid(valueRef)) {
	      this.push(left, right);
	      return;
	    }
	    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
	    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
	    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression("===", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));
	    if (core.types.isPattern(left)) {
	      let patternId;
	      let node;
	      if (this.kind === "const" || this.kind === "let") {
	        patternId = this.scope.generateUidIdentifier(tempId.name);
	        node = this.buildVariableDeclaration(patternId, tempConditional);
	      } else {
	        patternId = tempId;
	        node = core.types.expressionStatement(core.types.assignmentExpression("=", core.types.cloneNode(tempId), tempConditional));
	      }
	      this.nodes.push(node);
	      this.push(left, patternId);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(left, tempConditional));
	    }
	  }
	  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
	    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, (name) => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);
	    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
	  }
	  pushObjectProperty(prop, propRef) {
	    if (core.types.isLiteral(prop.key)) prop.computed = true;
	    const pattern = prop.value;
	    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);
	    if (core.types.isPattern(pattern)) {
	      this.push(pattern, objRef);
	    } else {
	      this.nodes.push(this.buildVariableAssignment(pattern, objRef));
	    }
	  }
	  pushObjectPattern(pattern, objRef) {
	    if (!pattern.properties.length) {
	      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), isPureVoid(objRef) ? [] : [objRef])));
	      return;
	    }
	    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
	      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
	      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
	      objRef = temp;
	    }
	    if (hasObjectRest(pattern)) {
	      let copiedPattern;
	      for (let i = 0; i < pattern.properties.length; i++) {
	        const prop = pattern.properties[i];
	        if (core.types.isRestElement(prop)) {
	          break;
	        }
	        const key = prop.key;
	        if (prop.computed && !this.scope.isPure(key)) {
	          const name = this.scope.generateUidIdentifierBasedOnNode(key);
	          this.nodes.push(this.buildVariableDeclaration(name, key));
	          if (!copiedPattern) {
	            copiedPattern = pattern = Object.assign({}, pattern, {
	              properties: pattern.properties.slice()
	            });
	          }
	          copiedPattern.properties[i] = Object.assign({}, prop, {
	            key: name
	          });
	        }
	      }
	    }
	    for (let i = 0; i < pattern.properties.length; i++) {
	      const prop = pattern.properties[i];
	      if (core.types.isRestElement(prop)) {
	        this.pushObjectRest(pattern, objRef, prop, i);
	      } else {
	        this.pushObjectProperty(prop, objRef);
	      }
	    }
	  }
	  canUnpackArrayPattern(pattern, arr) {
	    if (!core.types.isArrayExpression(arr)) return false;
	    if (pattern.elements.length > arr.elements.length) return;
	    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {
	      return false;
	    }
	    for (const elem of pattern.elements) {
	      if (!elem) return false;
	      if (core.types.isMemberExpression(elem)) return false;
	    }
	    for (const elem of arr.elements) {
	      if (core.types.isSpreadElement(elem)) return false;
	      if (core.types.isCallExpression(elem)) return false;
	      if (core.types.isMemberExpression(elem)) return false;
	    }
	    const bindings = core.types.getBindingIdentifiers(pattern);
	    const state = {
	      deopt: false,
	      bindings
	    };
	    try {
	      core.types.traverse(arr, arrayUnpackVisitor, state);
	    } catch (e) {
	      if (e !== STOP_TRAVERSAL) throw e;
	    }
	    return !state.deopt;
	  }
	  pushUnpackedArrayPattern(pattern, arr) {
	    const holeToUndefined = (el) => el != null ? el : this.scope.buildUndefinedNode();
	    for (let i = 0; i < pattern.elements.length; i++) {
	      const elem = pattern.elements[i];
	      if (core.types.isRestElement(elem)) {
	        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));
	      } else {
	        this.push(elem, holeToUndefined(arr.elements[i]));
	      }
	    }
	  }
	  pushArrayPattern(pattern, arrayRef) {
	    if (arrayRef === null) {
	      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [])));
	      return;
	    }
	    if (!pattern.elements) return;
	    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
	      this.pushUnpackedArrayPattern(pattern, arrayRef);
	      return;
	    }
	    const count = !hasArrayRest(pattern) && pattern.elements.length;
	    const toArray = this.toArray(arrayRef, count);
	    if (core.types.isIdentifier(toArray)) {
	      arrayRef = toArray;
	    } else {
	      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
	      this.arrayRefSet.add(arrayRef.name);
	      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
	    }
	    for (let i = 0; i < pattern.elements.length; i++) {
	      const elem = pattern.elements[i];
	      if (!elem) continue;
	      let elemRef;
	      if (core.types.isRestElement(elem)) {
	        elemRef = this.toArray(arrayRef);
	        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier("slice")), [core.types.numericLiteral(i)]);
	        this.push(elem.argument, elemRef);
	      } else {
	        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);
	        this.push(elem, elemRef);
	      }
	    }
	  }
	  init(pattern, ref) {
	    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {
	      const memo = this.scope.maybeGenerateMemoised(ref, true);
	      if (memo) {
	        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));
	        ref = memo;
	      }
	    }
	    this.push(pattern, ref);
	    return this.nodes;
	  }
	}
	function buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
	  const keys = [];
	  let allLiteral = true;
	  let hasTemplateLiteral = false;
	  for (let i = 0; i < excludedKeys.length; i++) {
	    const prop = excludedKeys[i];
	    const key = prop.key;
	    if (core.types.isIdentifier(key) && !prop.computed) {
	      keys.push(core.types.stringLiteral(key.name));
	    } else if (core.types.isTemplateLiteral(key)) {
	      keys.push(core.types.cloneNode(key));
	      hasTemplateLiteral = true;
	    } else if (core.types.isLiteral(key)) {
	      keys.push(core.types.stringLiteral(String(key.value)));
	    } else if (core.types.isPrivateName(key)) ;
	    else {
	      keys.push(core.types.cloneNode(key));
	      allLiteral = false;
	    }
	  }
	  let value;
	  if (keys.length === 0) {
	    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : addHelper("extends");
	    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(addHelper("objectDestructuringEmpty"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])]);
	  } else {
	    let keyExpression = core.types.arrayExpression(keys);
	    if (!allLiteral) {
	      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier("map")), [addHelper("toPropertyKey")]);
	    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {
	      const programScope = scope.getProgramParent();
	      const id = programScope.generateUidIdentifier("excluded");
	      programScope.push({
	        id,
	        init: keyExpression,
	        kind: "const"
	      });
	      keyExpression = core.types.cloneNode(id);
	    }
	    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [core.types.cloneNode(objRef), keyExpression]);
	  }
	  return value;
	}
	function convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
	  const {
	    node,
	    scope
	  } = path;
	  const nodeKind = node.kind;
	  const nodeLoc = node.loc;
	  const nodes = [];
	  for (let i = 0; i < node.declarations.length; i++) {
	    const declar = node.declarations[i];
	    const patternId = declar.init;
	    const pattern = declar.id;
	    const destructuring = new DestructuringTransformer({
	      blockHoist: node._blockHoist,
	      nodes,
	      scope,
	      kind: node.kind,
	      iterableIsArray,
	      arrayLikeIsIterable,
	      useBuiltIns,
	      objectRestNoSymbols,
	      addHelper
	    });
	    if (core.types.isPattern(pattern)) {
	      destructuring.init(pattern, patternId);
	      if (+i !== node.declarations.length - 1) {
	        core.types.inherits(nodes[nodes.length - 1], declar);
	      }
	    } else {
	      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
	    }
	  }
	  let tail = null;
	  let nodesOut = [];
	  for (const node2 of nodes) {
	    if (core.types.isVariableDeclaration(node2)) {
	      if (tail !== null) {
	        tail.declarations.push(...node2.declarations);
	        continue;
	      } else {
	        node2.kind = nodeKind;
	        tail = node2;
	      }
	    } else {
	      tail = null;
	    }
	    if (!node2.loc) {
	      node2.loc = nodeLoc;
	    }
	    nodesOut.push(node2);
	  }
	  if (nodesOut.length === 2 && core.types.isVariableDeclaration(nodesOut[0]) && core.types.isExpressionStatement(nodesOut[1]) && core.types.isCallExpression(nodesOut[1].expression) && nodesOut[0].declarations.length === 1) {
	    const expr = nodesOut[1].expression;
	    expr.arguments = [nodesOut[0].declarations[0].init];
	    nodesOut = [expr];
	  } else {
	    if (core.types.isForStatement(path.parent, {
	      init: node
	    }) && !nodesOut.some((v) => core.types.isVariableDeclaration(v))) {
	      for (let i = 0; i < nodesOut.length; i++) {
	        const node2 = nodesOut[i];
	        if (core.types.isExpressionStatement(node2)) {
	          nodesOut[i] = node2.expression;
	        }
	      }
	    }
	  }
	  if (nodesOut.length === 1) {
	    path.replaceWith(nodesOut[0]);
	  } else {
	    path.replaceWithMultiple(nodesOut);
	  }
	  scope.crawl();
	}
	function convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
	  const {
	    node,
	    scope,
	    parentPath
	  } = path;
	  const nodes = [];
	  const destructuring = new DestructuringTransformer({
	    operator: node.operator,
	    scope,
	    nodes,
	    arrayLikeIsIterable,
	    iterableIsArray,
	    objectRestNoSymbols,
	    useBuiltIns,
	    addHelper
	  });
	  let ref;
	  if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {
	    ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
	    nodes.push(core.types.variableDeclaration("var", [core.types.variableDeclarator(ref, node.right)]));
	    if (core.types.isArrayExpression(node.right)) {
	      destructuring.arrayRefSet.add(ref.name);
	    }
	  }
	  destructuring.init(node.left, ref || node.right);
	  if (ref) {
	    if (parentPath.isArrowFunctionExpression()) {
	      path.replaceWith(core.types.blockStatement([]));
	      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));
	    } else {
	      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));
	    }
	  }
	  path.replaceWithMultiple(nodes);
	  scope.crawl();
	}
	function variableDeclarationHasPattern(node) {
	  for (const declar of node.declarations) {
	    if (core.types.isPattern(declar.id)) {
	      return true;
	    }
	  }
	  return false;
	}
	var index = helperPluginUtils.declare((api, options) => {
	  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;
	  api.assertVersion(7);
	  const {
	    useBuiltIns = false
	  } = options;
	  const iterableIsArray = (_ref = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose) != null ? _ref : false;
	  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable")) != null ? _ref2 : false;
	  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;
	  return {
	    name: "transform-destructuring",
	    visitor: {
	      ExportNamedDeclaration(path) {
	        const declaration = path.get("declaration");
	        if (!declaration.isVariableDeclaration()) return;
	        if (!variableDeclarationHasPattern(declaration.node)) return;
	        const specifiers = [];
	        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {
	          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
	        }
	        path.replaceWith(declaration.node);
	        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
	        path.scope.crawl();
	      },
	      ForXStatement(path) {
	        const {
	          node,
	          scope
	        } = path;
	        const left = node.left;
	        if (core.types.isPattern(left)) {
	          const temp = scope.generateUidIdentifier("ref");
	          node.left = core.types.variableDeclaration("var", [core.types.variableDeclarator(temp)]);
	          path.ensureBlock();
	          const statementBody = path.node.body.body;
	          const nodes2 = [];
	          if (statementBody.length === 0 && path.isCompletionRecord()) {
	            nodes2.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
	          }
	          nodes2.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, core.types.cloneNode(temp))));
	          unshiftForXStatementBody(path, nodes2);
	          scope.crawl();
	          return;
	        }
	        if (!core.types.isVariableDeclaration(left)) return;
	        const pattern = left.declarations[0].id;
	        if (!core.types.isPattern(pattern)) return;
	        const key = scope.generateUidIdentifier("ref");
	        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);
	        const nodes = [];
	        const destructuring = new DestructuringTransformer({
	          kind: left.kind,
	          scope,
	          nodes,
	          arrayLikeIsIterable,
	          iterableIsArray,
	          objectRestNoSymbols,
	          useBuiltIns,
	          addHelper: (name) => this.addHelper(name)
	        });
	        destructuring.init(pattern, key);
	        unshiftForXStatementBody(path, nodes);
	        scope.crawl();
	      },
	      CatchClause({
	        node,
	        scope
	      }) {
	        const pattern = node.param;
	        if (!core.types.isPattern(pattern)) return;
	        const ref = scope.generateUidIdentifier("ref");
	        node.param = ref;
	        const nodes = [];
	        const destructuring = new DestructuringTransformer({
	          kind: "let",
	          scope,
	          nodes,
	          arrayLikeIsIterable,
	          iterableIsArray,
	          objectRestNoSymbols,
	          useBuiltIns,
	          addHelper: (name) => this.addHelper(name)
	        });
	        destructuring.init(pattern, ref);
	        node.body.body = [...nodes, ...node.body.body];
	        scope.crawl();
	      },
	      AssignmentExpression(path, state) {
	        if (!core.types.isPattern(path.node.left)) return;
	        convertAssignmentExpression(path, (name) => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
	      },
	      VariableDeclaration(path, state) {
	        const {
	          node,
	          parent
	        } = path;
	        if (core.types.isForXStatement(parent)) return;
	        if (!parent || !path.container) return;
	        if (!variableDeclarationHasPattern(node)) return;
	        convertVariableDeclaration(path, (name) => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
	      }
	    }
	  };
	});
	lib$R.buildObjectExcludingKeys = buildObjectExcludingKeys;
	lib$R.default = index;
	lib$R.unshiftForXStatementBody = unshiftForXStatementBody;
	return lib$R;
}

var lib$Q = {};

var lib$P = {};

var regjsgen$1 = {exports: {}};

/*!
 * regjsgen 0.8.0
 * Copyright 2014-2023 Benjamin Tan <https://ofcr.se/>
 * Available under the MIT license <https://github.com/bnjmnt4n/regjsgen/blob/main/LICENSE-MIT.txt>
 */
var regjsgen = regjsgen$1.exports;

var hasRequiredRegjsgen;

function requireRegjsgen () {
	if (hasRequiredRegjsgen) return regjsgen$1.exports;
	hasRequiredRegjsgen = 1;
	(function (module, exports) {
		(function() {
		  var objectTypes = {
		    "function": true,
		    "object": true
		  };
		  var root = objectTypes[typeof window] && window || this;
		  var freeExports = exports && !exports.nodeType && exports;
		  var hasFreeModule = module && !module.nodeType;
		  var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal == "object" && commonjsGlobal;
		  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
		    root = freeGlobal;
		  }
		  var hasOwnProperty = Object.prototype.hasOwnProperty;
		  function fromCodePoint() {
		    var codePoint = Number(arguments[0]);
		    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
		    codePoint < 0 || // not a valid Unicode code point
		    codePoint > 1114111 || // not a valid Unicode code point
		    Math.floor(codePoint) != codePoint) {
		      throw RangeError("Invalid code point: " + codePoint);
		    }
		    if (codePoint <= 65535) {
		      return String.fromCharCode(codePoint);
		    } else {
		      codePoint -= 65536;
		      var highSurrogate = (codePoint >> 10) + 55296;
		      var lowSurrogate = codePoint % 1024 + 56320;
		      return String.fromCharCode(highSurrogate, lowSurrogate);
		    }
		  }
		  var assertTypeRegexMap = {};
		  function assertType(type, expected) {
		    if (expected.indexOf("|") == -1) {
		      if (type == expected) {
		        return;
		      }
		      throw Error("Invalid node type: " + type + "; expected type: " + expected);
		    }
		    expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp("^(?:" + expected + ")$");
		    if (expected.test(type)) {
		      return;
		    }
		    throw Error("Invalid node type: " + type + "; expected types: " + expected);
		  }
		  function generate(node) {
		    var type = node.type;
		    if (hasOwnProperty.call(generators, type)) {
		      return generators[type](node);
		    }
		    throw Error("Invalid node type: " + type);
		  }
		  function generateSequence(generator, terms, separator) {
		    var i = -1, length = terms.length, result = "", term;
		    while (++i < length) {
		      term = terms[i];
		      if (separator && i > 0) result += separator;
		      if (i + 1 < length && terms[i].type == "value" && terms[i].kind == "null" && terms[i + 1].type == "value" && terms[i + 1].kind == "symbol" && terms[i + 1].codePoint >= 48 && terms[i + 1].codePoint <= 57) {
		        result += "\\000";
		        continue;
		      }
		      result += generator(term);
		    }
		    return result;
		  }
		  function generateAlternative(node) {
		    assertType(node.type, "alternative");
		    return generateSequence(generateTerm, node.body);
		  }
		  function generateAnchor(node) {
		    assertType(node.type, "anchor");
		    switch (node.kind) {
		      case "start":
		        return "^";
		      case "end":
		        return "$";
		      case "boundary":
		        return "\\b";
		      case "not-boundary":
		        return "\\B";
		      default:
		        throw Error("Invalid assertion");
		    }
		  }
		  var atomType = "anchor|characterClass|characterClassEscape|dot|group|reference|unicodePropertyEscape|value";
		  function generateAtom(node) {
		    assertType(node.type, atomType);
		    return generate(node);
		  }
		  function generateCharacterClass(node) {
		    assertType(node.type, "characterClass");
		    var kind = node.kind;
		    var separator = kind === "intersection" ? "&&" : kind === "subtraction" ? "--" : "";
		    return "[" + (node.negative ? "^" : "") + generateSequence(generateClassAtom, node.body, separator) + "]";
		  }
		  function generateCharacterClassEscape(node) {
		    assertType(node.type, "characterClassEscape");
		    return "\\" + node.value;
		  }
		  function generateCharacterClassRange(node) {
		    assertType(node.type, "characterClassRange");
		    var min = node.min, max = node.max;
		    if (min.type == "characterClassRange" || max.type == "characterClassRange") {
		      throw Error("Invalid character class range");
		    }
		    return generateClassAtom(min) + "-" + generateClassAtom(max);
		  }
		  function generateClassAtom(node) {
		    assertType(node.type, "anchor|characterClass|characterClassEscape|characterClassRange|dot|value|unicodePropertyEscape|classStrings");
		    return generate(node);
		  }
		  function generateClassStrings(node) {
		    assertType(node.type, "classStrings");
		    return "\\q{" + generateSequence(generateClassString, node.strings, "|") + "}";
		  }
		  function generateClassString(node) {
		    assertType(node.type, "classString");
		    return generateSequence(generate, node.characters);
		  }
		  function generateDisjunction(node) {
		    assertType(node.type, "disjunction");
		    return generateSequence(generate, node.body, "|");
		  }
		  function generateDot(node) {
		    assertType(node.type, "dot");
		    return ".";
		  }
		  function generateGroup(node) {
		    assertType(node.type, "group");
		    var result = "";
		    switch (node.behavior) {
		      case "normal":
		        if (node.name) {
		          result += "?<" + generateIdentifier(node.name) + ">";
		        }
		        break;
		      case "ignore":
		        if (node.modifierFlags) {
		          result += "?";
		          if (node.modifierFlags.enabling) result += node.modifierFlags.enabling;
		          if (node.modifierFlags.disabling) result += "-" + node.modifierFlags.disabling;
		          result += ":";
		        } else {
		          result += "?:";
		        }
		        break;
		      case "lookahead":
		        result += "?=";
		        break;
		      case "negativeLookahead":
		        result += "?!";
		        break;
		      case "lookbehind":
		        result += "?<=";
		        break;
		      case "negativeLookbehind":
		        result += "?<!";
		        break;
		      default:
		        throw Error("Invalid behaviour: " + node.behaviour);
		    }
		    result += generateSequence(generate, node.body);
		    return "(" + result + ")";
		  }
		  function generateIdentifier(node) {
		    assertType(node.type, "identifier");
		    return node.value;
		  }
		  function generateQuantifier(node) {
		    assertType(node.type, "quantifier");
		    var quantifier = "", min = node.min, max = node.max;
		    if (max == null) {
		      if (min == 0) {
		        quantifier = "*";
		      } else if (min == 1) {
		        quantifier = "+";
		      } else {
		        quantifier = "{" + min + ",}";
		      }
		    } else if (min == max) {
		      quantifier = "{" + min + "}";
		    } else if (min == 0 && max == 1) {
		      quantifier = "?";
		    } else {
		      quantifier = "{" + min + "," + max + "}";
		    }
		    if (!node.greedy) {
		      quantifier += "?";
		    }
		    return generateAtom(node.body[0]) + quantifier;
		  }
		  function generateReference(node) {
		    assertType(node.type, "reference");
		    if (node.matchIndex) {
		      return "\\" + node.matchIndex;
		    }
		    if (node.name) {
		      return "\\k<" + generateIdentifier(node.name) + ">";
		    }
		    throw new Error("Unknown reference type");
		  }
		  function generateTerm(node) {
		    assertType(node.type, atomType + "|empty|quantifier");
		    return generate(node);
		  }
		  function generateUnicodePropertyEscape(node) {
		    assertType(node.type, "unicodePropertyEscape");
		    return "\\" + (node.negative ? "P" : "p") + "{" + node.value + "}";
		  }
		  function generateValue(node) {
		    assertType(node.type, "value");
		    var kind = node.kind, codePoint = node.codePoint;
		    if (typeof codePoint != "number") {
		      throw new Error("Invalid code point: " + codePoint);
		    }
		    switch (kind) {
		      case "controlLetter":
		        return "\\c" + fromCodePoint(codePoint + 64);
		      case "hexadecimalEscape":
		        return "\\x" + ("00" + codePoint.toString(16).toUpperCase()).slice(-2);
		      case "identifier":
		        return "\\" + fromCodePoint(codePoint);
		      case "null":
		        return "\\" + codePoint;
		      case "octal":
		        return "\\" + ("000" + codePoint.toString(8)).slice(-3);
		      case "singleEscape":
		        switch (codePoint) {
		          case 8:
		            return "\\b";
		          case 9:
		            return "\\t";
		          case 10:
		            return "\\n";
		          case 11:
		            return "\\v";
		          case 12:
		            return "\\f";
		          case 13:
		            return "\\r";
		          case 45:
		            return "\\-";
		          default:
		            throw Error("Invalid code point: " + codePoint);
		        }
		      case "symbol":
		        return fromCodePoint(codePoint);
		      case "unicodeEscape":
		        return "\\u" + ("0000" + codePoint.toString(16).toUpperCase()).slice(-4);
		      case "unicodeCodePointEscape":
		        return "\\u{" + codePoint.toString(16).toUpperCase() + "}";
		      default:
		        throw Error("Unsupported node kind: " + kind);
		    }
		  }
		  var generators = {
		    "alternative": generateAlternative,
		    "anchor": generateAnchor,
		    "characterClass": generateCharacterClass,
		    "characterClassEscape": generateCharacterClassEscape,
		    "characterClassRange": generateCharacterClassRange,
		    "classStrings": generateClassStrings,
		    "disjunction": generateDisjunction,
		    "dot": generateDot,
		    "group": generateGroup,
		    "quantifier": generateQuantifier,
		    "reference": generateReference,
		    "unicodePropertyEscape": generateUnicodePropertyEscape,
		    "value": generateValue
		  };
		  var regjsgen = {
		    "generate": generate
		  };
		  if (freeExports && hasFreeModule) {
		    freeExports.generate = generate;
		  } else {
		    root.regjsgen = regjsgen;
		  }
		}).call(regjsgen); 
	} (regjsgen$1, regjsgen$1.exports));
	return regjsgen$1.exports;
}

var parser = {exports: {}};

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser.exports;
	hasRequiredParser = 1;
	(function (module) {
		(function() {
		  var fromCodePoint = String.fromCodePoint || function() {
		    var stringFromCharCode = String.fromCharCode;
		    var floor = Math.floor;
		    return function fromCodePoint2() {
		      var MAX_SIZE = 16384;
		      var codeUnits = [];
		      var highSurrogate;
		      var lowSurrogate;
		      var index = -1;
		      var length = arguments.length;
		      if (!length) {
		        return "";
		      }
		      var result = "";
		      while (++index < length) {
		        var codePoint = Number(arguments[index]);
		        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
		        codePoint < 0 || // not a valid Unicode code point
		        codePoint > 1114111 || // not a valid Unicode code point
		        floor(codePoint) != codePoint) {
		          throw RangeError("Invalid code point: " + codePoint);
		        }
		        if (codePoint <= 65535) {
		          codeUnits.push(codePoint);
		        } else {
		          codePoint -= 65536;
		          highSurrogate = (codePoint >> 10) + 55296;
		          lowSurrogate = codePoint % 1024 + 56320;
		          codeUnits.push(highSurrogate, lowSurrogate);
		        }
		        if (index + 1 == length || codeUnits.length > MAX_SIZE) {
		          result += stringFromCharCode.apply(null, codeUnits);
		          codeUnits.length = 0;
		        }
		      }
		      return result;
		    };
		  }();
		  function parse(str, flags, features) {
		    if (!features) {
		      features = {};
		    }
		    function updateRawStart(node, start) {
		      node.range[0] = start;
		      node.raw = str.substring(start, node.range[1]);
		      return node;
		    }
		    function createAnchor(kind, rawLength) {
		      return {
		        type: "anchor",
		        kind,
		        range: [
		          pos - rawLength,
		          pos
		        ],
		        raw: str.substring(pos - rawLength, pos)
		      };
		    }
		    function createValue(kind, codePoint, from, to) {
		      return {
		        type: "value",
		        kind,
		        codePoint,
		        range: [from, to],
		        raw: str.substring(from, to)
		      };
		    }
		    function createEscaped(kind, codePoint, value, fromOffset) {
		      fromOffset = fromOffset || 0;
		      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
		    }
		    function createCharacter(matches) {
		      var _char = matches[0];
		      var first = _char.charCodeAt(0);
		      if (isUnicodeMode) {
		        var second;
		        if (_char.length === 1 && first >= 55296 && first <= 56319) {
		          second = lookahead().charCodeAt(0);
		          if (second >= 56320 && second <= 57343) {
		            pos++;
		            return createValue(
		              "symbol",
		              (first - 55296) * 1024 + second - 56320 + 65536,
		              pos - 2,
		              pos
		            );
		          }
		        }
		      }
		      return createValue("symbol", first, pos - 1, pos);
		    }
		    function createDisjunction(alternatives, from, to) {
		      return {
		        type: "disjunction",
		        body: alternatives,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createDot() {
		      return {
		        type: "dot",
		        range: [
		          pos - 1,
		          pos
		        ],
		        raw: "."
		      };
		    }
		    function createCharacterClassEscape(value) {
		      return {
		        type: "characterClassEscape",
		        value,
		        range: [
		          pos - 2,
		          pos
		        ],
		        raw: str.substring(pos - 2, pos)
		      };
		    }
		    function createReference(matchIndex) {
		      var start = pos - 1 - matchIndex.length;
		      return {
		        type: "reference",
		        matchIndex: parseInt(matchIndex, 10),
		        range: [
		          start,
		          pos
		        ],
		        raw: str.substring(start, pos)
		      };
		    }
		    function createNamedReference(name) {
		      var start = name.range[0] - 3;
		      return {
		        type: "reference",
		        name,
		        range: [
		          start,
		          pos
		        ],
		        raw: str.substring(start, pos)
		      };
		    }
		    function createGroup(behavior, disjunction, from, to) {
		      return {
		        type: "group",
		        behavior,
		        body: disjunction,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createQuantifier(min, max, from, to, symbol) {
		      if (to == null) {
		        from = pos - 1;
		        to = pos;
		      }
		      return {
		        type: "quantifier",
		        min,
		        max,
		        greedy: true,
		        body: null,
		        // set later on
		        symbol,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createAlternative(terms, from, to) {
		      return {
		        type: "alternative",
		        body: terms,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createCharacterClass(contents, negative, from, to) {
		      return {
		        type: "characterClass",
		        kind: contents.kind,
		        body: contents.body,
		        negative,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createClassRange(min, max, from, to) {
		      if (min.codePoint > max.codePoint) {
		        bail("invalid range in character class", min.raw + "-" + max.raw, from, to);
		      }
		      return {
		        type: "characterClassRange",
		        min,
		        max,
		        range: [
		          from,
		          to
		        ],
		        raw: str.substring(from, to)
		      };
		    }
		    function createClassStrings(strings, from, to) {
		      return {
		        type: "classStrings",
		        strings,
		        range: [from, to],
		        raw: str.substring(from, to)
		      };
		    }
		    function createClassString(characters, from, to) {
		      return {
		        type: "classString",
		        characters,
		        range: [from, to],
		        raw: str.substring(from, to)
		      };
		    }
		    function flattenBody(body) {
		      if (body.type === "alternative") {
		        return body.body;
		      } else {
		        return [body];
		      }
		    }
		    function incr(amount) {
		      amount = amount || 1;
		      pos += amount;
		    }
		    function consume(amount) {
		      var res = str.substring(pos, pos += amount);
		      return res;
		    }
		    function skip(value) {
		      if (!match(value)) {
		        bail("character", value);
		      }
		    }
		    function match(value) {
		      var len = value.length;
		      if (str.substring(pos, pos + len) === value) {
		        incr(len);
		        return value;
		      }
		    }
		    function matchOne(value) {
		      if (str[pos] === value) {
		        pos++;
		        return value;
		      }
		    }
		    function lookahead() {
		      return str[pos];
		    }
		    function currentOne(value) {
		      return str[pos] === value;
		    }
		    function current(value) {
		      var len = value.length;
		      return str.substring(pos, pos + len) === value;
		    }
		    function next(value) {
		      return str[pos + 1] === value;
		    }
		    function matchReg(regExp) {
		      var subStr = str.substring(pos);
		      var res = subStr.match(regExp);
		      if (res) {
		        pos += res[0].length;
		      }
		      return res;
		    }
		    function parseDisjunction() {
		      var res = [], from = pos;
		      res.push(parseAlternative());
		      while (matchOne("|")) {
		        res.push(parseAlternative());
		      }
		      if (res.length === 1) {
		        return res[0];
		      }
		      return createDisjunction(res, from, pos);
		    }
		    function parseAlternative() {
		      var res = [], from = pos;
		      var term;
		      while (term = parseTerm()) {
		        res.push(term);
		      }
		      if (res.length === 1) {
		        return res[0];
		      }
		      return createAlternative(res, from, pos);
		    }
		    function parseTerm() {
		      if (pos >= str.length || currentOne("|") || currentOne(")")) {
		        return null;
		      }
		      var anchor = parseAnchor();
		      var quantifier;
		      if (anchor) {
		        var pos_backup = pos;
		        quantifier = parseQuantifier() || false;
		        if (quantifier) {
		          if (!isUnicodeMode && anchor.type === "group") {
		            quantifier.body = flattenBody(anchor);
		            updateRawStart(quantifier, anchor.range[0]);
		            return quantifier;
		          }
		          pos = pos_backup;
		          bail("Expected atom");
		        }
		        return anchor;
		      }
		      var atom = parseAtomAndExtendedAtom();
		      if (!atom) {
		        pos_backup = pos;
		        quantifier = parseQuantifier() || false;
		        if (quantifier) {
		          pos = pos_backup;
		          bail("Expected atom");
		        }
		        if (!isUnicodeMode && matchOne("{")) {
		          atom = createCharacter("{");
		        } else {
		          bail("Expected atom");
		        }
		      }
		      quantifier = parseQuantifier() || false;
		      if (quantifier) {
		        var type = atom.type, behavior = atom.behavior;
		        if (type === "group" && (behavior === "negativeLookbehind" || behavior === "lookbehind")) {
		          bail(
		            "Invalid quantifier",
		            "",
		            quantifier.range[0],
		            quantifier.range[1]
		          );
		        }
		        quantifier.body = flattenBody(atom);
		        updateRawStart(quantifier, atom.range[0]);
		        return quantifier;
		      }
		      return atom;
		    }
		    function parseGroup(matchA, typeA, matchB, typeB) {
		      var type = null, from = pos;
		      if (match(matchA)) {
		        type = typeA;
		      } else if (match(matchB)) {
		        type = typeB;
		      } else {
		        return false;
		      }
		      return finishGroup(type, from);
		    }
		    function finishGroup(type, from) {
		      var body = parseDisjunction();
		      if (!body) {
		        bail("Expected disjunction");
		      }
		      skip(")");
		      var group = createGroup(type, flattenBody(body), from, pos);
		      if (type == "normal") {
		        if (firstIteration) {
		          closedCaptureCounter++;
		        }
		      }
		      return group;
		    }
		    function parseAnchor() {
		      switch (lookahead()) {
		        case "^":
		          incr();
		          return createAnchor(
		            "start",
		            1
		            /* rawLength */
		          );
		        case "$":
		          incr();
		          return createAnchor(
		            "end",
		            1
		            /* rawLength */
		          );
		        case "\\": {
		          if (next("b")) {
		            incr(2);
		            return createAnchor(
		              "boundary",
		              2
		              /* rawLength */
		            );
		          } else if (next("B")) {
		            incr(2);
		            return createAnchor(
		              "not-boundary",
		              2
		              /* rawLength */
		            );
		          }
		          break;
		        }
		        case "(":
		          return parseGroup("(?=", "lookahead", "(?!", "negativeLookahead");
		        default:
		          return;
		      }
		    }
		    function parseQuantifier() {
		      var res, from = pos;
		      var quantifier;
		      var min, max;
		      switch (lookahead()) {
		        case "*":
		          incr();
		          quantifier = createQuantifier(0, void 0, void 0, void 0, "*");
		          break;
		        case "+":
		          incr();
		          quantifier = createQuantifier(1, void 0, void 0, void 0, "+");
		          break;
		        case "?":
		          incr();
		          quantifier = createQuantifier(0, 1, void 0, void 0, "?");
		          break;
		        case "{": {
		          if (res = matchReg(/^\{(\d+)\}/)) {
		            min = parseInt(res[1], 10);
		            quantifier = createQuantifier(min, min, from, pos);
		          } else if (res = matchReg(/^\{(\d+),\}/)) {
		            min = parseInt(res[1], 10);
		            quantifier = createQuantifier(min, void 0, from, pos);
		          } else if (res = matchReg(/^\{(\d+),(\d+)\}/)) {
		            min = parseInt(res[1], 10);
		            max = parseInt(res[2], 10);
		            if (min > max) {
		              bail("numbers out of order in {} quantifier", "", from, pos);
		            }
		            quantifier = createQuantifier(min, max, from, pos);
		          }
		          if (min && !Number.isSafeInteger(min) || max && !Number.isSafeInteger(max)) {
		            bail("iterations outside JS safe integer range in quantifier", "", from, pos);
		          }
		        }
		      }
		      if (quantifier) {
		        if (matchOne("?")) {
		          quantifier.greedy = false;
		          quantifier.range[1] += 1;
		        }
		      }
		      return quantifier;
		    }
		    function parseAtomAndExtendedAtom() {
		      var res;
		      switch (res = lookahead()) {
		        case ".":
		          incr();
		          return createDot();
		        case "\\": {
		          incr();
		          res = parseAtomEscape();
		          if (!res) {
		            if (!isUnicodeMode && lookahead() == "c") {
		              return createValue("symbol", 92, pos - 1, pos);
		            }
		            bail("atomEscape");
		          }
		          return res;
		        }
		        case "[":
		          return parseCharacterClass();
		        case "(": {
		          if (features.lookbehind && (res = parseGroup("(?<=", "lookbehind", "(?<!", "negativeLookbehind"))) {
		            return res;
		          } else if (features.namedGroups && match("(?<")) {
		            var name = parseIdentifier();
		            skip(">");
		            var group = finishGroup("normal", name.range[0] - 3);
		            group.name = name;
		            return group;
		          } else if (features.modifiers && current("(?") && str[pos + 2] != ":") {
		            return parseModifiersGroup();
		          } else {
		            return parseGroup("(?:", "ignore", "(", "normal");
		          }
		        }
		        case "]":
		        case "}":
		          if (!isUnicodeMode) {
		            incr();
		            return createCharacter(res);
		          }
		          break;
		        case "^":
		        case "$":
		        case "*":
		        case "+":
		        case "?":
		        case "{":
		        case ")":
		        case "|":
		          break;
		        default:
		          incr();
		          return createCharacter(res);
		      }
		    }
		    function parseModifiersGroup() {
		      function hasDupChar(str2) {
		        var i = 0;
		        while (i < str2.length) {
		          if (str2.indexOf(str2[i], i + 1) != -1) {
		            return true;
		          }
		          i++;
		        }
		        return false;
		      }
		      var from = pos;
		      incr(2);
		      var enablingFlags = matchReg(/^[sim]+/);
		      var disablingFlags;
		      if (matchOne("-") && lookahead() !== ":") {
		        disablingFlags = matchReg(/^[sim]+/);
		        if (!disablingFlags) {
		          bail("Invalid flags for modifiers group");
		        }
		      } else if (!enablingFlags) {
		        bail("Invalid flags for modifiers group");
		      }
		      enablingFlags = enablingFlags ? enablingFlags[0] : "";
		      disablingFlags = disablingFlags ? disablingFlags[0] : "";
		      var flags2 = enablingFlags + disablingFlags;
		      if (flags2.length > 3 || hasDupChar(flags2)) {
		        bail("flags cannot be duplicated for modifiers group");
		      }
		      if (!matchOne(":")) {
		        bail("Invalid flags for modifiers group");
		      }
		      var modifiersGroup = finishGroup("ignore", from);
		      modifiersGroup.modifierFlags = {
		        enabling: enablingFlags,
		        disabling: disablingFlags
		      };
		      return modifiersGroup;
		    }
		    function parseUnicodeSurrogatePairEscape(firstEscape, isUnicodeMode2) {
		      if (isUnicodeMode2) {
		        var first, second;
		        if (firstEscape.kind == "unicodeEscape" && (first = firstEscape.codePoint) >= 55296 && first <= 56319 && currentOne("\\") && next("u")) {
		          var prevPos = pos;
		          pos++;
		          var secondEscape = parseClassEscape();
		          if (secondEscape.kind == "unicodeEscape" && (second = secondEscape.codePoint) >= 56320 && second <= 57343) {
		            firstEscape.kind = "unicodeCodePointEscape";
		            firstEscape.codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
		            firstEscape.range[1] = pos;
		            firstEscape.raw = str.substring(firstEscape.range[0], pos);
		          } else {
		            pos = prevPos;
		          }
		        }
		      }
		      return firstEscape;
		    }
		    function parseClassEscape() {
		      return parseAtomEscape(true);
		    }
		    function parseAtomEscape(insideCharacterClass) {
		      var res, from = pos, ch;
		      switch (ch = lookahead()) {
		        case "0":
		        case "1":
		        case "2":
		        case "3":
		        case "4":
		        case "5":
		        case "6":
		        case "7":
		        case "8":
		        case "9":
		          return parseDecimalEscape(insideCharacterClass);
		        case "B": {
		          if (insideCharacterClass) {
		            bail("\\B not possible inside of CharacterClass", "", from);
		            break;
		          } else {
		            return parseIdentityEscape();
		          }
		        }
		        case "b": {
		          if (insideCharacterClass) {
		            incr();
		            return createEscaped("singleEscape", 8, "\\b");
		          } else {
		            return parseIdentityEscape();
		          }
		        }
		        case "c": {
		          if (insideCharacterClass) {
		            if (!isUnicodeMode && (res = matchReg(/^c(\d)/))) {
		              return createEscaped("controlLetter", res[1] + 16, res[1], 2);
		            } else if (!isUnicodeMode && match("c_")) {
		              return createEscaped("controlLetter", 31, "_", 2);
		            }
		          }
		          return parseCharacterEscape();
		        }
		        // CharacterClassEscape :: one of d D s S w W
		        case "d":
		        case "D":
		        case "w":
		        case "W":
		        case "s":
		        case "S":
		          incr();
		          return createCharacterClassEscape(ch);
		        case "k":
		          return parseNamedReference() || parseIdentityEscape();
		        case "p":
		        case "P":
		          return parseUnicodePropertyEscape() || parseIdentityEscape();
		        case "-": {
		          if (insideCharacterClass && isUnicodeMode) {
		            incr();
		            return createEscaped("singleEscape", 45, "\\-");
		          }
		          return parseIdentityEscape();
		        }
		        default:
		          return parseCharacterEscape();
		      }
		    }
		    function parseDecimalEscape(insideCharacterClass) {
		      var res, match2, from = pos;
		      if (res = matchReg(/^(?!0)\d+/)) {
		        match2 = res[0];
		        var refIdx = parseInt(res[0], 10);
		        if (refIdx <= closedCaptureCounter && !insideCharacterClass) {
		          return createReference(res[0]);
		        } else {
		          backrefDenied.push(refIdx);
		          if (firstIteration) {
		            shouldReparse = true;
		          } else {
		            bailOctalEscapeIfUnicode(from, pos);
		          }
		          incr(-res[0].length);
		          if (res = matchReg(/^[0-7]{1,3}/)) {
		            return createEscaped("octal", parseInt(res[0], 8), res[0], 1);
		          } else {
		            var start = pos;
		            res = createCharacter(matchReg(/^[89]/));
		            return updateRawStart(res, start - 1);
		          }
		        }
		      } else if (res = matchReg(/^[0-7]{1,3}/)) {
		        match2 = res[0];
		        if (match2 !== "0") {
		          bailOctalEscapeIfUnicode(from, pos);
		        }
		        if (/^0{1,3}$/.test(match2)) {
		          return createEscaped("null", 0, "0", match2.length);
		        } else {
		          return createEscaped("octal", parseInt(match2, 8), match2, 1);
		        }
		      }
		      return false;
		    }
		    function bailOctalEscapeIfUnicode(from, pos2) {
		      if (isUnicodeMode) {
		        bail("Invalid decimal escape in unicode mode", null, from, pos2);
		      }
		    }
		    function parseUnicodePropertyEscape() {
		      var res, from = pos;
		      if (features.unicodePropertyEscape && isUnicodeMode && (res = matchReg(/^([pP])\{([^}]+)\}/))) {
		        return {
		          type: "unicodePropertyEscape",
		          negative: res[1] === "P",
		          value: res[2],
		          range: [from - 1, pos],
		          raw: str.substring(from - 1, pos)
		        };
		      }
		      return false;
		    }
		    function parseNamedReference() {
		      if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
		        var name = parseIdentifier();
		        skip(">");
		        return createNamedReference(name);
		      }
		    }
		    function parseRegExpUnicodeEscapeSequence(isUnicodeMode2) {
		      var res;
		      if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
		        return parseUnicodeSurrogatePairEscape(
		          createEscaped("unicodeEscape", parseInt(res[1], 16), res[1], 2),
		          isUnicodeMode2
		        );
		      } else if (isUnicodeMode2 && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
		        return createEscaped("unicodeCodePointEscape", parseInt(res[1], 16), res[1], 4);
		      }
		    }
		    function parseCharacterEscape() {
		      var res;
		      var from = pos;
		      switch (lookahead()) {
		        case "t":
		          incr();
		          return createEscaped("singleEscape", 9, "\\t");
		        case "n":
		          incr();
		          return createEscaped("singleEscape", 10, "\\n");
		        case "v":
		          incr();
		          return createEscaped("singleEscape", 11, "\\v");
		        case "f":
		          incr();
		          return createEscaped("singleEscape", 12, "\\f");
		        case "r":
		          incr();
		          return createEscaped("singleEscape", 13, "\\r");
		        case "c":
		          if (res = matchReg(/^c([a-zA-Z])/)) {
		            return createEscaped("controlLetter", res[1].charCodeAt(0) % 32, res[1], 2);
		          }
		          break;
		        case "x":
		          if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
		            return createEscaped("hexadecimalEscape", parseInt(res[1], 16), res[1], 2);
		          }
		          break;
		        case "u":
		          if (res = parseRegExpUnicodeEscapeSequence(isUnicodeMode)) {
		            if (!res || res.codePoint > 1114111) {
		              bail("Invalid escape sequence", null, from, pos);
		            }
		            return res;
		          }
		          break;
		      }
		      return parseIdentityEscape();
		    }
		    function parseIdentifierAtom(check) {
		      var ch = lookahead();
		      var from = pos;
		      if (ch === "\\") {
		        incr();
		        var esc = parseRegExpUnicodeEscapeSequence(true);
		        if (!esc || !check(esc.codePoint)) {
		          bail("Invalid escape sequence", null, from, pos);
		        }
		        return fromCodePoint(esc.codePoint);
		      }
		      var code = ch.charCodeAt(0);
		      if (code >= 55296 && code <= 56319) {
		        ch += str[pos + 1];
		        var second = ch.charCodeAt(1);
		        if (second >= 56320 && second <= 57343) {
		          code = (code - 55296) * 1024 + second - 56320 + 65536;
		        }
		      }
		      if (!check(code)) return;
		      incr();
		      if (code > 65535) incr();
		      return ch;
		    }
		    function parseIdentifier() {
		      var start = pos;
		      var res = parseIdentifierAtom(isIdentifierStart);
		      if (!res) {
		        bail("Invalid identifier");
		      }
		      var ch;
		      while (ch = parseIdentifierAtom(isIdentifierPart)) {
		        res += ch;
		      }
		      return {
		        type: "identifier",
		        value: res,
		        range: [start, pos],
		        raw: str.substring(start, pos)
		      };
		    }
		    function isIdentifierStart(ch) {
		      var NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/;
		      return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
		      ch >= 65 && ch <= 90 || // A..Z
		      ch >= 97 && ch <= 122 || // a..z
		      ch >= 128 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
		    }
		    function isIdentifierPart(ch) {
		      var NonAsciiIdentifierPartOnly = /[\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDD40-\uDD49\uDD69-\uDD6D\uDEAB\uDEAC\uDEFC-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE-\uDDD9\uDE2C-\uDE37\uDE3E\uDE41\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74\uDFB8-\uDFC0\uDFC2\uDFC5\uDFC7-\uDFCA\uDFCC-\uDFD0\uDFD2\uDFE1\uDFE2]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDED0-\uDEE3\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDD50-\uDD59\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99\uDFF0-\uDFF9]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6\uDF00\uDF01\uDF03\uDF34-\uDF3A\uDF3E-\uDF42\uDF50-\uDF5A]|\uD80D[\uDC40\uDC47-\uDC55]|\uD818[\uDD1E-\uDD39]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDD70-\uDD79\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDCF0-\uDCF9\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDD40-\uDD49\uDEAE\uDEEC-\uDEF9]|\uD839[\uDCEC-\uDCF9\uDDEE\uDDEF\uDDF1-\uDDFA]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]|\uDB40[\uDD00-\uDDEF]/;
		      return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || // 0..9
		      ch >= 128 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
		    }
		    function parseIdentityEscape() {
		      var tmp;
		      var l = lookahead();
		      if (isUnicodeMode && /[\^$.*+?()\\[\]{}|/]/.test(l) || !isUnicodeMode && l !== "c") {
		        if (l === "k" && features.lookbehind) {
		          return null;
		        }
		        tmp = consume(1);
		        return createEscaped("identifier", tmp.charCodeAt(0), tmp, 1);
		      }
		      return null;
		    }
		    function parseCharacterClass() {
		      var res, from = pos;
		      if (res = match("[^")) {
		        res = parseClassContents();
		        skip("]");
		        return createCharacterClass(res, true, from, pos);
		      } else if (matchOne("[")) {
		        res = parseClassContents();
		        skip("]");
		        return createCharacterClass(res, false, from, pos);
		      }
		      return null;
		    }
		    function parseClassContents() {
		      var res;
		      if (currentOne("]")) {
		        return { kind: "union", body: [] };
		      } else if (hasUnicodeSetFlag) {
		        return parseClassSetExpression();
		      } else {
		        res = parseNonemptyClassRanges();
		        if (!res) {
		          bail("nonEmptyClassRanges");
		        }
		        return { kind: "union", body: res };
		      }
		    }
		    function parseHelperClassContents(atom) {
		      var from, to, res, atomTo, dash;
		      if (currentOne("-") && !next("]")) {
		        from = atom.range[0];
		        incr();
		        dash = createCharacter("-");
		        atomTo = parseClassAtom();
		        if (!atomTo) {
		          bail("classAtom");
		        }
		        to = pos;
		        var classContents = parseClassContents();
		        if (!classContents) {
		          bail("classContents");
		        }
		        if (!("codePoint" in atom) || !("codePoint" in atomTo)) {
		          if (!isUnicodeMode) {
		            res = [atom, dash, atomTo];
		          } else {
		            bail("invalid character class");
		          }
		        } else {
		          res = [createClassRange(atom, atomTo, from, to)];
		        }
		        if (classContents.type === "empty") {
		          return res;
		        }
		        return res.concat(classContents.body);
		      }
		      res = parseNonemptyClassRangesNoDash();
		      if (!res) {
		        bail("nonEmptyClassRangesNoDash");
		      }
		      return [atom].concat(res);
		    }
		    function parseNonemptyClassRanges() {
		      var atom = parseClassAtom();
		      if (!atom) {
		        bail("classAtom");
		      }
		      if (currentOne("]")) {
		        return [atom];
		      }
		      return parseHelperClassContents(atom);
		    }
		    function parseNonemptyClassRangesNoDash() {
		      var res = parseClassAtom();
		      if (!res) {
		        bail("classAtom");
		      }
		      if (currentOne("]")) {
		        return res;
		      }
		      return parseHelperClassContents(res);
		    }
		    function parseClassAtom() {
		      if (matchOne("-")) {
		        return createCharacter("-");
		      } else {
		        return parseClassAtomNoDash();
		      }
		    }
		    function parseClassAtomNoDash() {
		      var res;
		      switch (res = lookahead()) {
		        case "\\": {
		          incr();
		          res = parseClassEscape();
		          if (!res) {
		            if (!isUnicodeMode && lookahead() == "c") {
		              return createCharacter("\\");
		            }
		            bail("classEscape");
		          }
		          return parseUnicodeSurrogatePairEscape(res, isUnicodeMode);
		        }
		        case "]":
		        case "-":
		          break;
		        default:
		          incr();
		          return createCharacter(res);
		      }
		    }
		    function parseClassSetExpression() {
		      var body = [];
		      var kind;
		      var operand = parseClassSetOperand(
		        /* allowRanges*/
		        true
		      );
		      body.push(operand);
		      if (operand.type === "classRange") {
		        kind = "union";
		      } else if (currentOne("&")) {
		        kind = "intersection";
		      } else if (currentOne("-")) {
		        kind = "subtraction";
		      } else {
		        kind = "union";
		      }
		      while (!currentOne("]")) {
		        if (kind === "intersection") {
		          skip("&");
		          skip("&");
		          if (currentOne("&")) {
		            bail("&& cannot be followed by &. Wrap it in brackets: &&[&].");
		          }
		        } else if (kind === "subtraction") {
		          skip("-");
		          skip("-");
		        }
		        operand = parseClassSetOperand(
		          /* allowRanges*/
		          kind === "union"
		        );
		        body.push(operand);
		      }
		      return { kind, body };
		    }
		    function parseClassSetOperand(allowRanges) {
		      var from = pos;
		      var start, res;
		      if (matchOne("\\")) {
		        if (match("q{")) {
		          return parseClassStringDisjunction();
		        } else if (res = parseClassEscape()) {
		          start = res;
		        } else if (res = parseClassSetCharacterEscapedHelper()) {
		          return res;
		        } else {
		          bail("Invalid escape", "\\" + lookahead(), from);
		        }
		      } else if (res = parseClassSetCharacterUnescapedHelper()) {
		        start = res;
		      } else if (res = parseCharacterClass()) {
		        return res;
		      } else {
		        bail("Invalid character", lookahead());
		      }
		      if (allowRanges && currentOne("-") && !next("-")) {
		        incr();
		        if (res = parseClassSetCharacter()) {
		          return createClassRange(start, res, from, pos);
		        }
		        bail("Invalid range end", lookahead());
		      }
		      return start;
		    }
		    function parseClassSetCharacter() {
		      if (matchOne("\\")) {
		        var res, from = pos;
		        if (res = parseClassSetCharacterEscapedHelper()) {
		          return res;
		        } else {
		          bail("Invalid escape", "\\" + lookahead(), from);
		        }
		      }
		      return parseClassSetCharacterUnescapedHelper();
		    }
		    function parseClassSetCharacterUnescapedHelper() {
		      var res;
		      if (matchReg(/^(?:&&|!!|##|\$\$|%%|\*\*|\+\+|,,|\.\.|::|;;|<<|==|>>|\?\?|@@|\^\^|``|~~)/)) {
		        bail("Invalid set operation in character class");
		      }
		      if (res = matchReg(/^[^()[\]{}/\-\\|]/)) {
		        return createCharacter(res);
		      }
		    }
		    function parseClassSetCharacterEscapedHelper() {
		      var res;
		      if (matchOne("b")) {
		        return createEscaped("singleEscape", 8, "\\b");
		      } else if (matchOne("B")) {
		        bail("\\B not possible inside of ClassContents", "", pos - 2);
		      } else if (res = matchReg(/^[&\-!#%,:;<=>@`~]/)) {
		        return createEscaped("identifier", res[0].codePointAt(0), res[0]);
		      } else if (res = parseCharacterEscape()) {
		        return res;
		      } else {
		        return null;
		      }
		    }
		    function parseClassStringDisjunction() {
		      var from = pos - 3;
		      var res = [];
		      do {
		        res.push(parseClassString());
		      } while (matchOne("|"));
		      skip("}");
		      return createClassStrings(res, from, pos);
		    }
		    function parseClassString() {
		      var res = [], from = pos;
		      var char;
		      while (char = parseClassSetCharacter()) {
		        res.push(char);
		      }
		      return createClassString(res, from, pos);
		    }
		    function bail(message, details, from, to) {
		      from = from == null ? pos : from;
		      to = to == null ? from : to;
		      var contextStart = Math.max(0, from - 10);
		      var contextEnd = Math.min(to + 10, str.length);
		      var context = "    " + str.substring(contextStart, contextEnd);
		      var pointer = "    " + new Array(from - contextStart + 1).join(" ") + "^";
		      throw SyntaxError(message + " at position " + from + (details ? ": " + details : "") + "\n" + context + "\n" + pointer);
		    }
		    var backrefDenied = [];
		    var closedCaptureCounter = 0;
		    var firstIteration = true;
		    var shouldReparse = false;
		    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
		    var hasUnicodeSetFlag = (flags || "").indexOf("v") !== -1;
		    var isUnicodeMode = hasUnicodeFlag || hasUnicodeSetFlag;
		    var pos = 0;
		    if (hasUnicodeSetFlag && !features.unicodeSet) {
		      throw new Error('The "v" flag is only supported when the .unicodeSet option is enabled.');
		    }
		    if (hasUnicodeFlag && hasUnicodeSetFlag) {
		      throw new Error('The "u" and "v" flags are mutually exclusive.');
		    }
		    str = String(str);
		    if (str === "") {
		      str = "(?:)";
		    }
		    var result = parseDisjunction();
		    if (result.range[1] !== str.length) {
		      bail("Could not parse entire input - got stuck", "", result.range[1]);
		    }
		    shouldReparse = shouldReparse || backrefDenied.some(function(ref) {
		      return ref <= closedCaptureCounter;
		    });
		    if (shouldReparse) {
		      pos = 0;
		      firstIteration = false;
		      return parseDisjunction();
		    }
		    return result;
		  }
		  var regjsparser = {
		    parse
		  };
		  if (module.exports) {
		    module.exports = regjsparser;
		  } else {
		    window.regjsparser = regjsparser;
		  }
		})(); 
	} (parser));
	return parser.exports;
}

var regenerate$1 = {exports: {}};

/*! https://mths.be/regenerate v1.4.2 by @mathias | MIT license */
var regenerate = regenerate$1.exports;

var hasRequiredRegenerate;

function requireRegenerate () {
	if (hasRequiredRegenerate) return regenerate$1.exports;
	hasRequiredRegenerate = 1;
	(function (module, exports) {
		(function(root) {
		  var freeExports = exports;
		  var freeModule = module && module.exports == freeExports && module;
		  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
		  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		    root = freeGlobal;
		  }
		  var ERRORS = {
		    "rangeOrder": "A range\u2019s `stop` value must be greater than or equal to the `start` value.",
		    "codePointRange": "Invalid code point value. Code points range from U+000000 to U+10FFFF."
		  };
		  var HIGH_SURROGATE_MIN = 55296;
		  var HIGH_SURROGATE_MAX = 56319;
		  var LOW_SURROGATE_MIN = 56320;
		  var LOW_SURROGATE_MAX = 57343;
		  var regexNull = /\\x00([^0123456789]|$)/g;
		  var object = {};
		  var hasOwnProperty = object.hasOwnProperty;
		  var extend = function(destination, source) {
		    var key;
		    for (key in source) {
		      if (hasOwnProperty.call(source, key)) {
		        destination[key] = source[key];
		      }
		    }
		    return destination;
		  };
		  var forEach = function(array, callback) {
		    var index = -1;
		    var length = array.length;
		    while (++index < length) {
		      callback(array[index], index);
		    }
		  };
		  var toString = object.toString;
		  var isArray = function(value) {
		    return toString.call(value) == "[object Array]";
		  };
		  var isNumber = function(value) {
		    return typeof value == "number" || toString.call(value) == "[object Number]";
		  };
		  var zeroes = "0000";
		  var pad = function(number, totalCharacters) {
		    var string = String(number);
		    return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
		  };
		  var hex = function(number) {
		    return Number(number).toString(16).toUpperCase();
		  };
		  var slice = [].slice;
		  var dataFromCodePoints = function(codePoints) {
		    var index = -1;
		    var length = codePoints.length;
		    var max = length - 1;
		    var result = [];
		    var isStart = true;
		    var tmp;
		    var previous = 0;
		    while (++index < length) {
		      tmp = codePoints[index];
		      if (isStart) {
		        result.push(tmp);
		        previous = tmp;
		        isStart = false;
		      } else {
		        if (tmp == previous + 1) {
		          if (index != max) {
		            previous = tmp;
		            continue;
		          } else {
		            isStart = true;
		            result.push(tmp + 1);
		          }
		        } else {
		          result.push(previous + 1, tmp);
		          previous = tmp;
		        }
		      }
		    }
		    if (!isStart) {
		      result.push(tmp + 1);
		    }
		    return result;
		  };
		  var dataRemove = function(data, codePoint) {
		    var index = 0;
		    var start;
		    var end;
		    var length = data.length;
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1];
		      if (codePoint >= start && codePoint < end) {
		        if (codePoint == start) {
		          if (end == start + 1) {
		            data.splice(index, 2);
		            return data;
		          } else {
		            data[index] = codePoint + 1;
		            return data;
		          }
		        } else if (codePoint == end - 1) {
		          data[index + 1] = codePoint;
		          return data;
		        } else {
		          data.splice(index, 2, start, codePoint, codePoint + 1, end);
		          return data;
		        }
		      }
		      index += 2;
		    }
		    return data;
		  };
		  var dataRemoveRange = function(data, rangeStart, rangeEnd) {
		    if (rangeEnd < rangeStart) {
		      throw Error(ERRORS.rangeOrder);
		    }
		    var index = 0;
		    var start;
		    var end;
		    while (index < data.length) {
		      start = data[index];
		      end = data[index + 1] - 1;
		      if (start > rangeEnd) {
		        return data;
		      }
		      if (rangeStart <= start && rangeEnd >= end) {
		        data.splice(index, 2);
		        continue;
		      }
		      if (rangeStart >= start && rangeEnd < end) {
		        if (rangeStart == start) {
		          data[index] = rangeEnd + 1;
		          data[index + 1] = end + 1;
		          return data;
		        }
		        data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
		        return data;
		      }
		      if (rangeStart >= start && rangeStart <= end) {
		        data[index + 1] = rangeStart;
		      } else if (rangeEnd >= start && rangeEnd <= end) {
		        data[index] = rangeEnd + 1;
		        return data;
		      }
		      index += 2;
		    }
		    return data;
		  };
		  var dataAdd = function(data, codePoint) {
		    var index = 0;
		    var start;
		    var end;
		    var lastIndex = null;
		    var length = data.length;
		    if (codePoint < 0 || codePoint > 1114111) {
		      throw RangeError(ERRORS.codePointRange);
		    }
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1];
		      if (codePoint >= start && codePoint < end) {
		        return data;
		      }
		      if (codePoint == start - 1) {
		        data[index] = codePoint;
		        return data;
		      }
		      if (start > codePoint) {
		        data.splice(
		          lastIndex != null ? lastIndex + 2 : 0,
		          0,
		          codePoint,
		          codePoint + 1
		        );
		        return data;
		      }
		      if (codePoint == end) {
		        if (codePoint + 1 == data[index + 2]) {
		          data.splice(index, 4, start, data[index + 3]);
		          return data;
		        }
		        data[index + 1] = codePoint + 1;
		        return data;
		      }
		      lastIndex = index;
		      index += 2;
		    }
		    data.push(codePoint, codePoint + 1);
		    return data;
		  };
		  var dataAddData = function(dataA, dataB) {
		    var index = 0;
		    var start;
		    var end;
		    var data = dataA.slice();
		    var length = dataB.length;
		    while (index < length) {
		      start = dataB[index];
		      end = dataB[index + 1] - 1;
		      if (start == end) {
		        data = dataAdd(data, start);
		      } else {
		        data = dataAddRange(data, start, end);
		      }
		      index += 2;
		    }
		    return data;
		  };
		  var dataRemoveData = function(dataA, dataB) {
		    var index = 0;
		    var start;
		    var end;
		    var data = dataA.slice();
		    var length = dataB.length;
		    while (index < length) {
		      start = dataB[index];
		      end = dataB[index + 1] - 1;
		      if (start == end) {
		        data = dataRemove(data, start);
		      } else {
		        data = dataRemoveRange(data, start, end);
		      }
		      index += 2;
		    }
		    return data;
		  };
		  var dataAddRange = function(data, rangeStart, rangeEnd) {
		    if (rangeEnd < rangeStart) {
		      throw Error(ERRORS.rangeOrder);
		    }
		    if (rangeStart < 0 || rangeStart > 1114111 || rangeEnd < 0 || rangeEnd > 1114111) {
		      throw RangeError(ERRORS.codePointRange);
		    }
		    var index = 0;
		    var start;
		    var end;
		    var added = false;
		    var length = data.length;
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1];
		      if (added) {
		        if (start == rangeEnd + 1) {
		          data.splice(index - 1, 2);
		          return data;
		        }
		        if (start > rangeEnd) {
		          return data;
		        }
		        if (start >= rangeStart && start <= rangeEnd) {
		          if (end > rangeStart && end - 1 <= rangeEnd) {
		            data.splice(index, 2);
		            index -= 2;
		          } else {
		            data.splice(index - 1, 2);
		            index -= 2;
		          }
		        }
		      } else if (start == rangeEnd + 1 || start == rangeEnd) {
		        data[index] = rangeStart;
		        return data;
		      } else if (start > rangeEnd) {
		        data.splice(index, 0, rangeStart, rangeEnd + 1);
		        return data;
		      } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
		        return data;
		      } else if (
		        // E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.
		        rangeStart >= start && rangeStart < end || // E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.
		        end == rangeStart
		      ) {
		        data[index + 1] = rangeEnd + 1;
		        added = true;
		      } else if (rangeStart <= start && rangeEnd + 1 >= end) {
		        data[index] = rangeStart;
		        data[index + 1] = rangeEnd + 1;
		        added = true;
		      }
		      index += 2;
		    }
		    if (!added) {
		      data.push(rangeStart, rangeEnd + 1);
		    }
		    return data;
		  };
		  var dataContains = function(data, codePoint) {
		    var index = 0;
		    var length = data.length;
		    var start = data[index];
		    var end = data[length - 1];
		    if (length >= 2) {
		      if (codePoint < start || codePoint > end) {
		        return false;
		      }
		    }
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1];
		      if (codePoint >= start && codePoint < end) {
		        return true;
		      }
		      index += 2;
		    }
		    return false;
		  };
		  var dataIntersection = function(data, codePoints) {
		    var index = 0;
		    var length = codePoints.length;
		    var codePoint;
		    var result = [];
		    while (index < length) {
		      codePoint = codePoints[index];
		      if (dataContains(data, codePoint)) {
		        result.push(codePoint);
		      }
		      ++index;
		    }
		    return dataFromCodePoints(result);
		  };
		  var dataIsEmpty = function(data) {
		    return !data.length;
		  };
		  var dataIsSingleton = function(data) {
		    return data.length == 2 && data[0] + 1 == data[1];
		  };
		  var dataToArray = function(data) {
		    var index = 0;
		    var start;
		    var end;
		    var result = [];
		    var length = data.length;
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1];
		      while (start < end) {
		        result.push(start);
		        ++start;
		      }
		      index += 2;
		    }
		    return result;
		  };
		  var floor = Math.floor;
		  var highSurrogate = function(codePoint) {
		    return parseInt(
		      floor((codePoint - 65536) / 1024) + HIGH_SURROGATE_MIN,
		      10
		    );
		  };
		  var lowSurrogate = function(codePoint) {
		    return parseInt(
		      (codePoint - 65536) % 1024 + LOW_SURROGATE_MIN,
		      10
		    );
		  };
		  var stringFromCharCode = String.fromCharCode;
		  var codePointToString = function(codePoint) {
		    var string;
		    if (codePoint == 9) {
		      string = "\\t";
		    } else if (codePoint == 10) {
		      string = "\\n";
		    } else if (codePoint == 12) {
		      string = "\\f";
		    } else if (codePoint == 13) {
		      string = "\\r";
		    } else if (codePoint == 45) {
		      string = "\\x2D";
		    } else if (codePoint == 92) {
		      string = "\\\\";
		    } else if (codePoint == 36 || codePoint >= 40 && codePoint <= 43 || codePoint == 46 || codePoint == 47 || codePoint == 63 || codePoint >= 91 && codePoint <= 94 || codePoint >= 123 && codePoint <= 125) {
		      string = "\\" + stringFromCharCode(codePoint);
		    } else if (codePoint >= 32 && codePoint <= 126) {
		      string = stringFromCharCode(codePoint);
		    } else if (codePoint <= 255) {
		      string = "\\x" + pad(hex(codePoint), 2);
		    } else {
		      string = "\\u" + pad(hex(codePoint), 4);
		    }
		    return string;
		  };
		  var codePointToStringUnicode = function(codePoint) {
		    if (codePoint <= 65535) {
		      return codePointToString(codePoint);
		    }
		    return "\\u{" + codePoint.toString(16).toUpperCase() + "}";
		  };
		  var symbolToCodePoint = function(symbol) {
		    var length = symbol.length;
		    var first = symbol.charCodeAt(0);
		    var second;
		    if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
		      second = symbol.charCodeAt(1);
		      return (first - HIGH_SURROGATE_MIN) * 1024 + second - LOW_SURROGATE_MIN + 65536;
		    }
		    return first;
		  };
		  var createBMPCharacterClasses = function(data) {
		    var result = "";
		    var index = 0;
		    var start;
		    var end;
		    var length = data.length;
		    if (dataIsSingleton(data)) {
		      return codePointToString(data[0]);
		    }
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1] - 1;
		      if (start == end) {
		        result += codePointToString(start);
		      } else if (start + 1 == end) {
		        result += codePointToString(start) + codePointToString(end);
		      } else {
		        result += codePointToString(start) + "-" + codePointToString(end);
		      }
		      index += 2;
		    }
		    return "[" + result + "]";
		  };
		  var createUnicodeCharacterClasses = function(data) {
		    var result = "";
		    var index = 0;
		    var start;
		    var end;
		    var length = data.length;
		    if (dataIsSingleton(data)) {
		      return codePointToStringUnicode(data[0]);
		    }
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1] - 1;
		      if (start == end) {
		        result += codePointToStringUnicode(start);
		      } else if (start + 1 == end) {
		        result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
		      } else {
		        result += codePointToStringUnicode(start) + "-" + codePointToStringUnicode(end);
		      }
		      index += 2;
		    }
		    return "[" + result + "]";
		  };
		  var splitAtBMP = function(data) {
		    var loneHighSurrogates = [];
		    var loneLowSurrogates = [];
		    var bmp = [];
		    var astral = [];
		    var index = 0;
		    var start;
		    var end;
		    var length = data.length;
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1] - 1;
		      if (start < HIGH_SURROGATE_MIN) {
		        if (end < HIGH_SURROGATE_MIN) {
		          bmp.push(start, end + 1);
		        }
		        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
		          bmp.push(start, HIGH_SURROGATE_MIN);
		          loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
		        }
		        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
		          bmp.push(start, HIGH_SURROGATE_MIN);
		          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
		          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
		        }
		        if (end > LOW_SURROGATE_MAX) {
		          bmp.push(start, HIGH_SURROGATE_MIN);
		          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
		          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
		          if (end <= 65535) {
		            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
		          } else {
		            bmp.push(LOW_SURROGATE_MAX + 1, 65535 + 1);
		            astral.push(65535 + 1, end + 1);
		          }
		        }
		      } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
		        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
		          loneHighSurrogates.push(start, end + 1);
		        }
		        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
		          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
		          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
		        }
		        if (end > LOW_SURROGATE_MAX) {
		          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
		          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
		          if (end <= 65535) {
		            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
		          } else {
		            bmp.push(LOW_SURROGATE_MAX + 1, 65535 + 1);
		            astral.push(65535 + 1, end + 1);
		          }
		        }
		      } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
		        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
		          loneLowSurrogates.push(start, end + 1);
		        }
		        if (end > LOW_SURROGATE_MAX) {
		          loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
		          if (end <= 65535) {
		            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
		          } else {
		            bmp.push(LOW_SURROGATE_MAX + 1, 65535 + 1);
		            astral.push(65535 + 1, end + 1);
		          }
		        }
		      } else if (start > LOW_SURROGATE_MAX && start <= 65535) {
		        if (end <= 65535) {
		          bmp.push(start, end + 1);
		        } else {
		          bmp.push(start, 65535 + 1);
		          astral.push(65535 + 1, end + 1);
		        }
		      } else {
		        astral.push(start, end + 1);
		      }
		      index += 2;
		    }
		    return {
		      "loneHighSurrogates": loneHighSurrogates,
		      "loneLowSurrogates": loneLowSurrogates,
		      "bmp": bmp,
		      "astral": astral
		    };
		  };
		  var optimizeSurrogateMappings = function(surrogateMappings) {
		    var result = [];
		    var tmpLow = [];
		    var addLow = false;
		    var mapping;
		    var nextMapping;
		    var highSurrogates;
		    var lowSurrogates;
		    var nextHighSurrogates;
		    var nextLowSurrogates;
		    var index = -1;
		    var length = surrogateMappings.length;
		    while (++index < length) {
		      mapping = surrogateMappings[index];
		      nextMapping = surrogateMappings[index + 1];
		      if (!nextMapping) {
		        result.push(mapping);
		        continue;
		      }
		      highSurrogates = mapping[0];
		      lowSurrogates = mapping[1];
		      nextHighSurrogates = nextMapping[0];
		      nextLowSurrogates = nextMapping[1];
		      tmpLow = lowSurrogates;
		      while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
		        if (dataIsSingleton(nextLowSurrogates)) {
		          tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
		        } else {
		          tmpLow = dataAddRange(
		            tmpLow,
		            nextLowSurrogates[0],
		            nextLowSurrogates[1] - 1
		          );
		        }
		        ++index;
		        mapping = surrogateMappings[index];
		        highSurrogates = mapping[0];
		        lowSurrogates = mapping[1];
		        nextMapping = surrogateMappings[index + 1];
		        nextHighSurrogates = nextMapping && nextMapping[0];
		        nextLowSurrogates = nextMapping && nextMapping[1];
		        addLow = true;
		      }
		      result.push([
		        highSurrogates,
		        addLow ? tmpLow : lowSurrogates
		      ]);
		      addLow = false;
		    }
		    return optimizeByLowSurrogates(result);
		  };
		  var optimizeByLowSurrogates = function(surrogateMappings) {
		    if (surrogateMappings.length == 1) {
		      return surrogateMappings;
		    }
		    var index = -1;
		    var innerIndex = -1;
		    while (++index < surrogateMappings.length) {
		      var mapping = surrogateMappings[index];
		      var lowSurrogates = mapping[1];
		      var lowSurrogateStart = lowSurrogates[0];
		      var lowSurrogateEnd = lowSurrogates[1];
		      innerIndex = index;
		      while (++innerIndex < surrogateMappings.length) {
		        var otherMapping = surrogateMappings[innerIndex];
		        var otherLowSurrogates = otherMapping[1];
		        var otherLowSurrogateStart = otherLowSurrogates[0];
		        var otherLowSurrogateEnd = otherLowSurrogates[1];
		        if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd && otherLowSurrogates.length === 2) {
		          if (dataIsSingleton(otherMapping[0])) {
		            mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
		          } else {
		            mapping[0] = dataAddRange(
		              mapping[0],
		              otherMapping[0][0],
		              otherMapping[0][1] - 1
		            );
		          }
		          surrogateMappings.splice(innerIndex, 1);
		          --innerIndex;
		        }
		      }
		    }
		    return surrogateMappings;
		  };
		  var surrogateSet = function(data) {
		    if (!data.length) {
		      return [];
		    }
		    var index = 0;
		    var start;
		    var end;
		    var startHigh;
		    var startLow;
		    var endHigh;
		    var endLow;
		    var surrogateMappings = [];
		    var length = data.length;
		    while (index < length) {
		      start = data[index];
		      end = data[index + 1] - 1;
		      startHigh = highSurrogate(start);
		      startLow = lowSurrogate(start);
		      endHigh = highSurrogate(end);
		      endLow = lowSurrogate(end);
		      var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
		      var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
		      var complete = false;
		      if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
		        surrogateMappings.push([
		          [startHigh, endHigh + 1],
		          [startLow, endLow + 1]
		        ]);
		        complete = true;
		      } else {
		        surrogateMappings.push([
		          [startHigh, startHigh + 1],
		          [startLow, LOW_SURROGATE_MAX + 1]
		        ]);
		      }
		      if (!complete && startHigh + 1 < endHigh) {
		        if (endsWithHighestLowSurrogate) {
		          surrogateMappings.push([
		            [startHigh + 1, endHigh + 1],
		            [LOW_SURROGATE_MIN, endLow + 1]
		          ]);
		          complete = true;
		        } else {
		          surrogateMappings.push([
		            [startHigh + 1, endHigh],
		            [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]
		          ]);
		        }
		      }
		      if (!complete) {
		        surrogateMappings.push([
		          [endHigh, endHigh + 1],
		          [LOW_SURROGATE_MIN, endLow + 1]
		        ]);
		      }
		      index += 2;
		    }
		    return optimizeSurrogateMappings(surrogateMappings);
		  };
		  var createSurrogateCharacterClasses = function(surrogateMappings) {
		    var result = [];
		    forEach(surrogateMappings, function(surrogateMapping) {
		      var highSurrogates = surrogateMapping[0];
		      var lowSurrogates = surrogateMapping[1];
		      result.push(
		        createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates)
		      );
		    });
		    return result.join("|");
		  };
		  var createCharacterClassesFromData = function(data, bmpOnly, hasUnicodeFlag) {
		    if (hasUnicodeFlag) {
		      return createUnicodeCharacterClasses(data);
		    }
		    var result = [];
		    var parts = splitAtBMP(data);
		    var loneHighSurrogates = parts.loneHighSurrogates;
		    var loneLowSurrogates = parts.loneLowSurrogates;
		    var bmp = parts.bmp;
		    var astral = parts.astral;
		    var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
		    var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
		    var surrogateMappings = surrogateSet(astral);
		    if (bmpOnly) {
		      bmp = dataAddData(bmp, loneHighSurrogates);
		      hasLoneHighSurrogates = false;
		      bmp = dataAddData(bmp, loneLowSurrogates);
		      hasLoneLowSurrogates = false;
		    }
		    if (!dataIsEmpty(bmp)) {
		      result.push(createBMPCharacterClasses(bmp));
		    }
		    if (surrogateMappings.length) {
		      result.push(createSurrogateCharacterClasses(surrogateMappings));
		    }
		    if (hasLoneHighSurrogates) {
		      result.push(
		        createBMPCharacterClasses(loneHighSurrogates) + // Make sure the high surrogates aren’t part of a surrogate pair.
		        "(?![\\uDC00-\\uDFFF])"
		      );
		    }
		    if (hasLoneLowSurrogates) {
		      result.push(
		        // It is not possible to accurately assert the low surrogates aren’t
		        // part of a surrogate pair, since JavaScript regular expressions do
		        // not support lookbehind.
		        "(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates)
		      );
		    }
		    return result.join("|");
		  };
		  var regenerate = function(value) {
		    if (arguments.length > 1) {
		      value = slice.call(arguments);
		    }
		    if (this instanceof regenerate) {
		      this.data = [];
		      return value ? this.add(value) : this;
		    }
		    return new regenerate().add(value);
		  };
		  regenerate.version = "1.4.2";
		  var proto = regenerate.prototype;
		  extend(proto, {
		    "add": function(value) {
		      var $this = this;
		      if (value == null) {
		        return $this;
		      }
		      if (value instanceof regenerate) {
		        $this.data = dataAddData($this.data, value.data);
		        return $this;
		      }
		      if (arguments.length > 1) {
		        value = slice.call(arguments);
		      }
		      if (isArray(value)) {
		        forEach(value, function(item) {
		          $this.add(item);
		        });
		        return $this;
		      }
		      $this.data = dataAdd(
		        $this.data,
		        isNumber(value) ? value : symbolToCodePoint(value)
		      );
		      return $this;
		    },
		    "remove": function(value) {
		      var $this = this;
		      if (value == null) {
		        return $this;
		      }
		      if (value instanceof regenerate) {
		        $this.data = dataRemoveData($this.data, value.data);
		        return $this;
		      }
		      if (arguments.length > 1) {
		        value = slice.call(arguments);
		      }
		      if (isArray(value)) {
		        forEach(value, function(item) {
		          $this.remove(item);
		        });
		        return $this;
		      }
		      $this.data = dataRemove(
		        $this.data,
		        isNumber(value) ? value : symbolToCodePoint(value)
		      );
		      return $this;
		    },
		    "addRange": function(start, end) {
		      var $this = this;
		      $this.data = dataAddRange(
		        $this.data,
		        isNumber(start) ? start : symbolToCodePoint(start),
		        isNumber(end) ? end : symbolToCodePoint(end)
		      );
		      return $this;
		    },
		    "removeRange": function(start, end) {
		      var $this = this;
		      var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
		      var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
		      $this.data = dataRemoveRange(
		        $this.data,
		        startCodePoint,
		        endCodePoint
		      );
		      return $this;
		    },
		    "intersection": function(argument) {
		      var $this = this;
		      var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
		      $this.data = dataIntersection($this.data, array);
		      return $this;
		    },
		    "contains": function(codePoint) {
		      return dataContains(
		        this.data,
		        isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint)
		      );
		    },
		    "clone": function() {
		      var set = new regenerate();
		      set.data = this.data.slice(0);
		      return set;
		    },
		    "toString": function(options) {
		      var result = createCharacterClassesFromData(
		        this.data,
		        options ? options.bmpOnly : false,
		        options ? options.hasUnicodeFlag : false
		      );
		      if (!result) {
		        return "[]";
		      }
		      return result.replace(regexNull, "\\0$1");
		    },
		    "toRegExp": function(flags) {
		      var pattern = this.toString(
		        flags && flags.indexOf("u") != -1 ? { "hasUnicodeFlag": true } : null
		      );
		      return RegExp(pattern, flags || "");
		    },
		    "valueOf": function() {
		      return dataToArray(this.data);
		    }
		  });
		  proto.toArray = proto.valueOf;
		  if (freeExports && !freeExports.nodeType) {
		    if (freeModule) {
		      freeModule.exports = regenerate;
		    } else {
		      freeExports.regenerate = regenerate;
		    }
		  } else {
		    root.regenerate = regenerate;
		  }
		})(regenerate); 
	} (regenerate$1, regenerate$1.exports));
	return regenerate$1.exports;
}

var unicodeCanonicalPropertyNamesEcmascript;
var hasRequiredUnicodeCanonicalPropertyNamesEcmascript;

function requireUnicodeCanonicalPropertyNamesEcmascript () {
	if (hasRequiredUnicodeCanonicalPropertyNamesEcmascript) return unicodeCanonicalPropertyNamesEcmascript;
	hasRequiredUnicodeCanonicalPropertyNamesEcmascript = 1;
	unicodeCanonicalPropertyNamesEcmascript = /* @__PURE__ */ new Set([
	  // Non-binary properties:
	  "General_Category",
	  "Script",
	  "Script_Extensions",
	  // Binary properties:
	  "Alphabetic",
	  "Any",
	  "ASCII",
	  "ASCII_Hex_Digit",
	  "Assigned",
	  "Bidi_Control",
	  "Bidi_Mirrored",
	  "Case_Ignorable",
	  "Cased",
	  "Changes_When_Casefolded",
	  "Changes_When_Casemapped",
	  "Changes_When_Lowercased",
	  "Changes_When_NFKC_Casefolded",
	  "Changes_When_Titlecased",
	  "Changes_When_Uppercased",
	  "Dash",
	  "Default_Ignorable_Code_Point",
	  "Deprecated",
	  "Diacritic",
	  "Emoji",
	  "Emoji_Component",
	  "Emoji_Modifier",
	  "Emoji_Modifier_Base",
	  "Emoji_Presentation",
	  "Extended_Pictographic",
	  "Extender",
	  "Grapheme_Base",
	  "Grapheme_Extend",
	  "Hex_Digit",
	  "ID_Continue",
	  "ID_Start",
	  "Ideographic",
	  "IDS_Binary_Operator",
	  "IDS_Trinary_Operator",
	  "Join_Control",
	  "Logical_Order_Exception",
	  "Lowercase",
	  "Math",
	  "Noncharacter_Code_Point",
	  "Pattern_Syntax",
	  "Pattern_White_Space",
	  "Quotation_Mark",
	  "Radical",
	  "Regional_Indicator",
	  "Sentence_Terminal",
	  "Soft_Dotted",
	  "Terminal_Punctuation",
	  "Unified_Ideograph",
	  "Uppercase",
	  "Variation_Selector",
	  "White_Space",
	  "XID_Continue",
	  "XID_Start"
	]);
	return unicodeCanonicalPropertyNamesEcmascript;
}

var unicodePropertyAliasesEcmascript;
var hasRequiredUnicodePropertyAliasesEcmascript;

function requireUnicodePropertyAliasesEcmascript () {
	if (hasRequiredUnicodePropertyAliasesEcmascript) return unicodePropertyAliasesEcmascript;
	hasRequiredUnicodePropertyAliasesEcmascript = 1;
	unicodePropertyAliasesEcmascript = /* @__PURE__ */ new Map([
	  ["scx", "Script_Extensions"],
	  ["sc", "Script"],
	  ["gc", "General_Category"],
	  ["AHex", "ASCII_Hex_Digit"],
	  ["Alpha", "Alphabetic"],
	  ["Bidi_C", "Bidi_Control"],
	  ["Bidi_M", "Bidi_Mirrored"],
	  ["Cased", "Cased"],
	  ["CI", "Case_Ignorable"],
	  ["CWCF", "Changes_When_Casefolded"],
	  ["CWCM", "Changes_When_Casemapped"],
	  ["CWKCF", "Changes_When_NFKC_Casefolded"],
	  ["CWL", "Changes_When_Lowercased"],
	  ["CWT", "Changes_When_Titlecased"],
	  ["CWU", "Changes_When_Uppercased"],
	  ["Dash", "Dash"],
	  ["Dep", "Deprecated"],
	  ["DI", "Default_Ignorable_Code_Point"],
	  ["Dia", "Diacritic"],
	  ["EBase", "Emoji_Modifier_Base"],
	  ["EComp", "Emoji_Component"],
	  ["EMod", "Emoji_Modifier"],
	  ["Emoji", "Emoji"],
	  ["EPres", "Emoji_Presentation"],
	  ["Ext", "Extender"],
	  ["ExtPict", "Extended_Pictographic"],
	  ["Gr_Base", "Grapheme_Base"],
	  ["Gr_Ext", "Grapheme_Extend"],
	  ["Hex", "Hex_Digit"],
	  ["IDC", "ID_Continue"],
	  ["Ideo", "Ideographic"],
	  ["IDS", "ID_Start"],
	  ["IDSB", "IDS_Binary_Operator"],
	  ["IDST", "IDS_Trinary_Operator"],
	  ["Join_C", "Join_Control"],
	  ["LOE", "Logical_Order_Exception"],
	  ["Lower", "Lowercase"],
	  ["Math", "Math"],
	  ["NChar", "Noncharacter_Code_Point"],
	  ["Pat_Syn", "Pattern_Syntax"],
	  ["Pat_WS", "Pattern_White_Space"],
	  ["QMark", "Quotation_Mark"],
	  ["Radical", "Radical"],
	  ["RI", "Regional_Indicator"],
	  ["SD", "Soft_Dotted"],
	  ["STerm", "Sentence_Terminal"],
	  ["Term", "Terminal_Punctuation"],
	  ["UIdeo", "Unified_Ideograph"],
	  ["Upper", "Uppercase"],
	  ["VS", "Variation_Selector"],
	  ["WSpace", "White_Space"],
	  ["space", "White_Space"],
	  ["XIDC", "XID_Continue"],
	  ["XIDS", "XID_Start"]
	]);
	return unicodePropertyAliasesEcmascript;
}

var unicodeMatchPropertyEcmascript;
var hasRequiredUnicodeMatchPropertyEcmascript;

function requireUnicodeMatchPropertyEcmascript () {
	if (hasRequiredUnicodeMatchPropertyEcmascript) return unicodeMatchPropertyEcmascript;
	hasRequiredUnicodeMatchPropertyEcmascript = 1;
	const canonicalProperties = requireUnicodeCanonicalPropertyNamesEcmascript();
	const propertyAliases = requireUnicodePropertyAliasesEcmascript();
	const matchProperty = function(property) {
	  if (canonicalProperties.has(property)) {
	    return property;
	  }
	  if (propertyAliases.has(property)) {
	    return propertyAliases.get(property);
	  }
	  throw new Error(`Unknown property: ${property}`);
	};
	unicodeMatchPropertyEcmascript = matchProperty;
	return unicodeMatchPropertyEcmascript;
}

var mappings;
var hasRequiredMappings;

function requireMappings () {
	if (hasRequiredMappings) return mappings;
	hasRequiredMappings = 1;
	mappings = /* @__PURE__ */ new Map([
	  ["General_Category", /* @__PURE__ */ new Map([
	    ["C", "Other"],
	    ["Cc", "Control"],
	    ["cntrl", "Control"],
	    ["Cf", "Format"],
	    ["Cn", "Unassigned"],
	    ["Co", "Private_Use"],
	    ["Cs", "Surrogate"],
	    ["L", "Letter"],
	    ["LC", "Cased_Letter"],
	    ["Ll", "Lowercase_Letter"],
	    ["Lm", "Modifier_Letter"],
	    ["Lo", "Other_Letter"],
	    ["Lt", "Titlecase_Letter"],
	    ["Lu", "Uppercase_Letter"],
	    ["M", "Mark"],
	    ["Combining_Mark", "Mark"],
	    ["Mc", "Spacing_Mark"],
	    ["Me", "Enclosing_Mark"],
	    ["Mn", "Nonspacing_Mark"],
	    ["N", "Number"],
	    ["Nd", "Decimal_Number"],
	    ["digit", "Decimal_Number"],
	    ["Nl", "Letter_Number"],
	    ["No", "Other_Number"],
	    ["P", "Punctuation"],
	    ["punct", "Punctuation"],
	    ["Pc", "Connector_Punctuation"],
	    ["Pd", "Dash_Punctuation"],
	    ["Pe", "Close_Punctuation"],
	    ["Pf", "Final_Punctuation"],
	    ["Pi", "Initial_Punctuation"],
	    ["Po", "Other_Punctuation"],
	    ["Ps", "Open_Punctuation"],
	    ["S", "Symbol"],
	    ["Sc", "Currency_Symbol"],
	    ["Sk", "Modifier_Symbol"],
	    ["Sm", "Math_Symbol"],
	    ["So", "Other_Symbol"],
	    ["Z", "Separator"],
	    ["Zl", "Line_Separator"],
	    ["Zp", "Paragraph_Separator"],
	    ["Zs", "Space_Separator"],
	    ["Other", "Other"],
	    ["Control", "Control"],
	    ["Format", "Format"],
	    ["Unassigned", "Unassigned"],
	    ["Private_Use", "Private_Use"],
	    ["Surrogate", "Surrogate"],
	    ["Letter", "Letter"],
	    ["Cased_Letter", "Cased_Letter"],
	    ["Lowercase_Letter", "Lowercase_Letter"],
	    ["Modifier_Letter", "Modifier_Letter"],
	    ["Other_Letter", "Other_Letter"],
	    ["Titlecase_Letter", "Titlecase_Letter"],
	    ["Uppercase_Letter", "Uppercase_Letter"],
	    ["Mark", "Mark"],
	    ["Spacing_Mark", "Spacing_Mark"],
	    ["Enclosing_Mark", "Enclosing_Mark"],
	    ["Nonspacing_Mark", "Nonspacing_Mark"],
	    ["Number", "Number"],
	    ["Decimal_Number", "Decimal_Number"],
	    ["Letter_Number", "Letter_Number"],
	    ["Other_Number", "Other_Number"],
	    ["Punctuation", "Punctuation"],
	    ["Connector_Punctuation", "Connector_Punctuation"],
	    ["Dash_Punctuation", "Dash_Punctuation"],
	    ["Close_Punctuation", "Close_Punctuation"],
	    ["Final_Punctuation", "Final_Punctuation"],
	    ["Initial_Punctuation", "Initial_Punctuation"],
	    ["Other_Punctuation", "Other_Punctuation"],
	    ["Open_Punctuation", "Open_Punctuation"],
	    ["Symbol", "Symbol"],
	    ["Currency_Symbol", "Currency_Symbol"],
	    ["Modifier_Symbol", "Modifier_Symbol"],
	    ["Math_Symbol", "Math_Symbol"],
	    ["Other_Symbol", "Other_Symbol"],
	    ["Separator", "Separator"],
	    ["Line_Separator", "Line_Separator"],
	    ["Paragraph_Separator", "Paragraph_Separator"],
	    ["Space_Separator", "Space_Separator"]
	  ])],
	  ["Script", /* @__PURE__ */ new Map([
	    ["Adlm", "Adlam"],
	    ["Aghb", "Caucasian_Albanian"],
	    ["Ahom", "Ahom"],
	    ["Arab", "Arabic"],
	    ["Armi", "Imperial_Aramaic"],
	    ["Armn", "Armenian"],
	    ["Avst", "Avestan"],
	    ["Bali", "Balinese"],
	    ["Bamu", "Bamum"],
	    ["Bass", "Bassa_Vah"],
	    ["Batk", "Batak"],
	    ["Beng", "Bengali"],
	    ["Bhks", "Bhaiksuki"],
	    ["Bopo", "Bopomofo"],
	    ["Brah", "Brahmi"],
	    ["Brai", "Braille"],
	    ["Bugi", "Buginese"],
	    ["Buhd", "Buhid"],
	    ["Cakm", "Chakma"],
	    ["Cans", "Canadian_Aboriginal"],
	    ["Cari", "Carian"],
	    ["Cham", "Cham"],
	    ["Cher", "Cherokee"],
	    ["Chrs", "Chorasmian"],
	    ["Copt", "Coptic"],
	    ["Qaac", "Coptic"],
	    ["Cpmn", "Cypro_Minoan"],
	    ["Cprt", "Cypriot"],
	    ["Cyrl", "Cyrillic"],
	    ["Deva", "Devanagari"],
	    ["Diak", "Dives_Akuru"],
	    ["Dogr", "Dogra"],
	    ["Dsrt", "Deseret"],
	    ["Dupl", "Duployan"],
	    ["Egyp", "Egyptian_Hieroglyphs"],
	    ["Elba", "Elbasan"],
	    ["Elym", "Elymaic"],
	    ["Ethi", "Ethiopic"],
	    ["Gara", "Garay"],
	    ["Geor", "Georgian"],
	    ["Glag", "Glagolitic"],
	    ["Gong", "Gunjala_Gondi"],
	    ["Gonm", "Masaram_Gondi"],
	    ["Goth", "Gothic"],
	    ["Gran", "Grantha"],
	    ["Grek", "Greek"],
	    ["Gujr", "Gujarati"],
	    ["Gukh", "Gurung_Khema"],
	    ["Guru", "Gurmukhi"],
	    ["Hang", "Hangul"],
	    ["Hani", "Han"],
	    ["Hano", "Hanunoo"],
	    ["Hatr", "Hatran"],
	    ["Hebr", "Hebrew"],
	    ["Hira", "Hiragana"],
	    ["Hluw", "Anatolian_Hieroglyphs"],
	    ["Hmng", "Pahawh_Hmong"],
	    ["Hmnp", "Nyiakeng_Puachue_Hmong"],
	    ["Hrkt", "Katakana_Or_Hiragana"],
	    ["Hung", "Old_Hungarian"],
	    ["Ital", "Old_Italic"],
	    ["Java", "Javanese"],
	    ["Kali", "Kayah_Li"],
	    ["Kana", "Katakana"],
	    ["Kawi", "Kawi"],
	    ["Khar", "Kharoshthi"],
	    ["Khmr", "Khmer"],
	    ["Khoj", "Khojki"],
	    ["Kits", "Khitan_Small_Script"],
	    ["Knda", "Kannada"],
	    ["Krai", "Kirat_Rai"],
	    ["Kthi", "Kaithi"],
	    ["Lana", "Tai_Tham"],
	    ["Laoo", "Lao"],
	    ["Latn", "Latin"],
	    ["Lepc", "Lepcha"],
	    ["Limb", "Limbu"],
	    ["Lina", "Linear_A"],
	    ["Linb", "Linear_B"],
	    ["Lisu", "Lisu"],
	    ["Lyci", "Lycian"],
	    ["Lydi", "Lydian"],
	    ["Mahj", "Mahajani"],
	    ["Maka", "Makasar"],
	    ["Mand", "Mandaic"],
	    ["Mani", "Manichaean"],
	    ["Marc", "Marchen"],
	    ["Medf", "Medefaidrin"],
	    ["Mend", "Mende_Kikakui"],
	    ["Merc", "Meroitic_Cursive"],
	    ["Mero", "Meroitic_Hieroglyphs"],
	    ["Mlym", "Malayalam"],
	    ["Modi", "Modi"],
	    ["Mong", "Mongolian"],
	    ["Mroo", "Mro"],
	    ["Mtei", "Meetei_Mayek"],
	    ["Mult", "Multani"],
	    ["Mymr", "Myanmar"],
	    ["Nagm", "Nag_Mundari"],
	    ["Nand", "Nandinagari"],
	    ["Narb", "Old_North_Arabian"],
	    ["Nbat", "Nabataean"],
	    ["Newa", "Newa"],
	    ["Nkoo", "Nko"],
	    ["Nshu", "Nushu"],
	    ["Ogam", "Ogham"],
	    ["Olck", "Ol_Chiki"],
	    ["Onao", "Ol_Onal"],
	    ["Orkh", "Old_Turkic"],
	    ["Orya", "Oriya"],
	    ["Osge", "Osage"],
	    ["Osma", "Osmanya"],
	    ["Ougr", "Old_Uyghur"],
	    ["Palm", "Palmyrene"],
	    ["Pauc", "Pau_Cin_Hau"],
	    ["Perm", "Old_Permic"],
	    ["Phag", "Phags_Pa"],
	    ["Phli", "Inscriptional_Pahlavi"],
	    ["Phlp", "Psalter_Pahlavi"],
	    ["Phnx", "Phoenician"],
	    ["Plrd", "Miao"],
	    ["Prti", "Inscriptional_Parthian"],
	    ["Rjng", "Rejang"],
	    ["Rohg", "Hanifi_Rohingya"],
	    ["Runr", "Runic"],
	    ["Samr", "Samaritan"],
	    ["Sarb", "Old_South_Arabian"],
	    ["Saur", "Saurashtra"],
	    ["Sgnw", "SignWriting"],
	    ["Shaw", "Shavian"],
	    ["Shrd", "Sharada"],
	    ["Sidd", "Siddham"],
	    ["Sind", "Khudawadi"],
	    ["Sinh", "Sinhala"],
	    ["Sogd", "Sogdian"],
	    ["Sogo", "Old_Sogdian"],
	    ["Sora", "Sora_Sompeng"],
	    ["Soyo", "Soyombo"],
	    ["Sund", "Sundanese"],
	    ["Sunu", "Sunuwar"],
	    ["Sylo", "Syloti_Nagri"],
	    ["Syrc", "Syriac"],
	    ["Tagb", "Tagbanwa"],
	    ["Takr", "Takri"],
	    ["Tale", "Tai_Le"],
	    ["Talu", "New_Tai_Lue"],
	    ["Taml", "Tamil"],
	    ["Tang", "Tangut"],
	    ["Tavt", "Tai_Viet"],
	    ["Telu", "Telugu"],
	    ["Tfng", "Tifinagh"],
	    ["Tglg", "Tagalog"],
	    ["Thaa", "Thaana"],
	    ["Thai", "Thai"],
	    ["Tibt", "Tibetan"],
	    ["Tirh", "Tirhuta"],
	    ["Tnsa", "Tangsa"],
	    ["Todr", "Todhri"],
	    ["Toto", "Toto"],
	    ["Tutg", "Tulu_Tigalari"],
	    ["Ugar", "Ugaritic"],
	    ["Vaii", "Vai"],
	    ["Vith", "Vithkuqi"],
	    ["Wara", "Warang_Citi"],
	    ["Wcho", "Wancho"],
	    ["Xpeo", "Old_Persian"],
	    ["Xsux", "Cuneiform"],
	    ["Yezi", "Yezidi"],
	    ["Yiii", "Yi"],
	    ["Zanb", "Zanabazar_Square"],
	    ["Zinh", "Inherited"],
	    ["Qaai", "Inherited"],
	    ["Zyyy", "Common"],
	    ["Zzzz", "Unknown"],
	    ["Adlam", "Adlam"],
	    ["Caucasian_Albanian", "Caucasian_Albanian"],
	    ["Arabic", "Arabic"],
	    ["Imperial_Aramaic", "Imperial_Aramaic"],
	    ["Armenian", "Armenian"],
	    ["Avestan", "Avestan"],
	    ["Balinese", "Balinese"],
	    ["Bamum", "Bamum"],
	    ["Bassa_Vah", "Bassa_Vah"],
	    ["Batak", "Batak"],
	    ["Bengali", "Bengali"],
	    ["Bhaiksuki", "Bhaiksuki"],
	    ["Bopomofo", "Bopomofo"],
	    ["Brahmi", "Brahmi"],
	    ["Braille", "Braille"],
	    ["Buginese", "Buginese"],
	    ["Buhid", "Buhid"],
	    ["Chakma", "Chakma"],
	    ["Canadian_Aboriginal", "Canadian_Aboriginal"],
	    ["Carian", "Carian"],
	    ["Cherokee", "Cherokee"],
	    ["Chorasmian", "Chorasmian"],
	    ["Coptic", "Coptic"],
	    ["Cypro_Minoan", "Cypro_Minoan"],
	    ["Cypriot", "Cypriot"],
	    ["Cyrillic", "Cyrillic"],
	    ["Devanagari", "Devanagari"],
	    ["Dives_Akuru", "Dives_Akuru"],
	    ["Dogra", "Dogra"],
	    ["Deseret", "Deseret"],
	    ["Duployan", "Duployan"],
	    ["Egyptian_Hieroglyphs", "Egyptian_Hieroglyphs"],
	    ["Elbasan", "Elbasan"],
	    ["Elymaic", "Elymaic"],
	    ["Ethiopic", "Ethiopic"],
	    ["Garay", "Garay"],
	    ["Georgian", "Georgian"],
	    ["Glagolitic", "Glagolitic"],
	    ["Gunjala_Gondi", "Gunjala_Gondi"],
	    ["Masaram_Gondi", "Masaram_Gondi"],
	    ["Gothic", "Gothic"],
	    ["Grantha", "Grantha"],
	    ["Greek", "Greek"],
	    ["Gujarati", "Gujarati"],
	    ["Gurung_Khema", "Gurung_Khema"],
	    ["Gurmukhi", "Gurmukhi"],
	    ["Hangul", "Hangul"],
	    ["Han", "Han"],
	    ["Hanunoo", "Hanunoo"],
	    ["Hatran", "Hatran"],
	    ["Hebrew", "Hebrew"],
	    ["Hiragana", "Hiragana"],
	    ["Anatolian_Hieroglyphs", "Anatolian_Hieroglyphs"],
	    ["Pahawh_Hmong", "Pahawh_Hmong"],
	    ["Nyiakeng_Puachue_Hmong", "Nyiakeng_Puachue_Hmong"],
	    ["Katakana_Or_Hiragana", "Katakana_Or_Hiragana"],
	    ["Old_Hungarian", "Old_Hungarian"],
	    ["Old_Italic", "Old_Italic"],
	    ["Javanese", "Javanese"],
	    ["Kayah_Li", "Kayah_Li"],
	    ["Katakana", "Katakana"],
	    ["Kharoshthi", "Kharoshthi"],
	    ["Khmer", "Khmer"],
	    ["Khojki", "Khojki"],
	    ["Khitan_Small_Script", "Khitan_Small_Script"],
	    ["Kannada", "Kannada"],
	    ["Kirat_Rai", "Kirat_Rai"],
	    ["Kaithi", "Kaithi"],
	    ["Tai_Tham", "Tai_Tham"],
	    ["Lao", "Lao"],
	    ["Latin", "Latin"],
	    ["Lepcha", "Lepcha"],
	    ["Limbu", "Limbu"],
	    ["Linear_A", "Linear_A"],
	    ["Linear_B", "Linear_B"],
	    ["Lycian", "Lycian"],
	    ["Lydian", "Lydian"],
	    ["Mahajani", "Mahajani"],
	    ["Makasar", "Makasar"],
	    ["Mandaic", "Mandaic"],
	    ["Manichaean", "Manichaean"],
	    ["Marchen", "Marchen"],
	    ["Medefaidrin", "Medefaidrin"],
	    ["Mende_Kikakui", "Mende_Kikakui"],
	    ["Meroitic_Cursive", "Meroitic_Cursive"],
	    ["Meroitic_Hieroglyphs", "Meroitic_Hieroglyphs"],
	    ["Malayalam", "Malayalam"],
	    ["Mongolian", "Mongolian"],
	    ["Mro", "Mro"],
	    ["Meetei_Mayek", "Meetei_Mayek"],
	    ["Multani", "Multani"],
	    ["Myanmar", "Myanmar"],
	    ["Nag_Mundari", "Nag_Mundari"],
	    ["Nandinagari", "Nandinagari"],
	    ["Old_North_Arabian", "Old_North_Arabian"],
	    ["Nabataean", "Nabataean"],
	    ["Nko", "Nko"],
	    ["Nushu", "Nushu"],
	    ["Ogham", "Ogham"],
	    ["Ol_Chiki", "Ol_Chiki"],
	    ["Ol_Onal", "Ol_Onal"],
	    ["Old_Turkic", "Old_Turkic"],
	    ["Oriya", "Oriya"],
	    ["Osage", "Osage"],
	    ["Osmanya", "Osmanya"],
	    ["Old_Uyghur", "Old_Uyghur"],
	    ["Palmyrene", "Palmyrene"],
	    ["Pau_Cin_Hau", "Pau_Cin_Hau"],
	    ["Old_Permic", "Old_Permic"],
	    ["Phags_Pa", "Phags_Pa"],
	    ["Inscriptional_Pahlavi", "Inscriptional_Pahlavi"],
	    ["Psalter_Pahlavi", "Psalter_Pahlavi"],
	    ["Phoenician", "Phoenician"],
	    ["Miao", "Miao"],
	    ["Inscriptional_Parthian", "Inscriptional_Parthian"],
	    ["Rejang", "Rejang"],
	    ["Hanifi_Rohingya", "Hanifi_Rohingya"],
	    ["Runic", "Runic"],
	    ["Samaritan", "Samaritan"],
	    ["Old_South_Arabian", "Old_South_Arabian"],
	    ["Saurashtra", "Saurashtra"],
	    ["SignWriting", "SignWriting"],
	    ["Shavian", "Shavian"],
	    ["Sharada", "Sharada"],
	    ["Siddham", "Siddham"],
	    ["Khudawadi", "Khudawadi"],
	    ["Sinhala", "Sinhala"],
	    ["Sogdian", "Sogdian"],
	    ["Old_Sogdian", "Old_Sogdian"],
	    ["Sora_Sompeng", "Sora_Sompeng"],
	    ["Soyombo", "Soyombo"],
	    ["Sundanese", "Sundanese"],
	    ["Sunuwar", "Sunuwar"],
	    ["Syloti_Nagri", "Syloti_Nagri"],
	    ["Syriac", "Syriac"],
	    ["Tagbanwa", "Tagbanwa"],
	    ["Takri", "Takri"],
	    ["Tai_Le", "Tai_Le"],
	    ["New_Tai_Lue", "New_Tai_Lue"],
	    ["Tamil", "Tamil"],
	    ["Tangut", "Tangut"],
	    ["Tai_Viet", "Tai_Viet"],
	    ["Telugu", "Telugu"],
	    ["Tifinagh", "Tifinagh"],
	    ["Tagalog", "Tagalog"],
	    ["Thaana", "Thaana"],
	    ["Tibetan", "Tibetan"],
	    ["Tirhuta", "Tirhuta"],
	    ["Tangsa", "Tangsa"],
	    ["Todhri", "Todhri"],
	    ["Tulu_Tigalari", "Tulu_Tigalari"],
	    ["Ugaritic", "Ugaritic"],
	    ["Vai", "Vai"],
	    ["Vithkuqi", "Vithkuqi"],
	    ["Warang_Citi", "Warang_Citi"],
	    ["Wancho", "Wancho"],
	    ["Old_Persian", "Old_Persian"],
	    ["Cuneiform", "Cuneiform"],
	    ["Yezidi", "Yezidi"],
	    ["Yi", "Yi"],
	    ["Zanabazar_Square", "Zanabazar_Square"],
	    ["Inherited", "Inherited"],
	    ["Common", "Common"],
	    ["Unknown", "Unknown"]
	  ])],
	  ["Script_Extensions", /* @__PURE__ */ new Map([
	    ["Adlm", "Adlam"],
	    ["Aghb", "Caucasian_Albanian"],
	    ["Ahom", "Ahom"],
	    ["Arab", "Arabic"],
	    ["Armi", "Imperial_Aramaic"],
	    ["Armn", "Armenian"],
	    ["Avst", "Avestan"],
	    ["Bali", "Balinese"],
	    ["Bamu", "Bamum"],
	    ["Bass", "Bassa_Vah"],
	    ["Batk", "Batak"],
	    ["Beng", "Bengali"],
	    ["Bhks", "Bhaiksuki"],
	    ["Bopo", "Bopomofo"],
	    ["Brah", "Brahmi"],
	    ["Brai", "Braille"],
	    ["Bugi", "Buginese"],
	    ["Buhd", "Buhid"],
	    ["Cakm", "Chakma"],
	    ["Cans", "Canadian_Aboriginal"],
	    ["Cari", "Carian"],
	    ["Cham", "Cham"],
	    ["Cher", "Cherokee"],
	    ["Chrs", "Chorasmian"],
	    ["Copt", "Coptic"],
	    ["Qaac", "Coptic"],
	    ["Cpmn", "Cypro_Minoan"],
	    ["Cprt", "Cypriot"],
	    ["Cyrl", "Cyrillic"],
	    ["Deva", "Devanagari"],
	    ["Diak", "Dives_Akuru"],
	    ["Dogr", "Dogra"],
	    ["Dsrt", "Deseret"],
	    ["Dupl", "Duployan"],
	    ["Egyp", "Egyptian_Hieroglyphs"],
	    ["Elba", "Elbasan"],
	    ["Elym", "Elymaic"],
	    ["Ethi", "Ethiopic"],
	    ["Gara", "Garay"],
	    ["Geor", "Georgian"],
	    ["Glag", "Glagolitic"],
	    ["Gong", "Gunjala_Gondi"],
	    ["Gonm", "Masaram_Gondi"],
	    ["Goth", "Gothic"],
	    ["Gran", "Grantha"],
	    ["Grek", "Greek"],
	    ["Gujr", "Gujarati"],
	    ["Gukh", "Gurung_Khema"],
	    ["Guru", "Gurmukhi"],
	    ["Hang", "Hangul"],
	    ["Hani", "Han"],
	    ["Hano", "Hanunoo"],
	    ["Hatr", "Hatran"],
	    ["Hebr", "Hebrew"],
	    ["Hira", "Hiragana"],
	    ["Hluw", "Anatolian_Hieroglyphs"],
	    ["Hmng", "Pahawh_Hmong"],
	    ["Hmnp", "Nyiakeng_Puachue_Hmong"],
	    ["Hrkt", "Katakana_Or_Hiragana"],
	    ["Hung", "Old_Hungarian"],
	    ["Ital", "Old_Italic"],
	    ["Java", "Javanese"],
	    ["Kali", "Kayah_Li"],
	    ["Kana", "Katakana"],
	    ["Kawi", "Kawi"],
	    ["Khar", "Kharoshthi"],
	    ["Khmr", "Khmer"],
	    ["Khoj", "Khojki"],
	    ["Kits", "Khitan_Small_Script"],
	    ["Knda", "Kannada"],
	    ["Krai", "Kirat_Rai"],
	    ["Kthi", "Kaithi"],
	    ["Lana", "Tai_Tham"],
	    ["Laoo", "Lao"],
	    ["Latn", "Latin"],
	    ["Lepc", "Lepcha"],
	    ["Limb", "Limbu"],
	    ["Lina", "Linear_A"],
	    ["Linb", "Linear_B"],
	    ["Lisu", "Lisu"],
	    ["Lyci", "Lycian"],
	    ["Lydi", "Lydian"],
	    ["Mahj", "Mahajani"],
	    ["Maka", "Makasar"],
	    ["Mand", "Mandaic"],
	    ["Mani", "Manichaean"],
	    ["Marc", "Marchen"],
	    ["Medf", "Medefaidrin"],
	    ["Mend", "Mende_Kikakui"],
	    ["Merc", "Meroitic_Cursive"],
	    ["Mero", "Meroitic_Hieroglyphs"],
	    ["Mlym", "Malayalam"],
	    ["Modi", "Modi"],
	    ["Mong", "Mongolian"],
	    ["Mroo", "Mro"],
	    ["Mtei", "Meetei_Mayek"],
	    ["Mult", "Multani"],
	    ["Mymr", "Myanmar"],
	    ["Nagm", "Nag_Mundari"],
	    ["Nand", "Nandinagari"],
	    ["Narb", "Old_North_Arabian"],
	    ["Nbat", "Nabataean"],
	    ["Newa", "Newa"],
	    ["Nkoo", "Nko"],
	    ["Nshu", "Nushu"],
	    ["Ogam", "Ogham"],
	    ["Olck", "Ol_Chiki"],
	    ["Onao", "Ol_Onal"],
	    ["Orkh", "Old_Turkic"],
	    ["Orya", "Oriya"],
	    ["Osge", "Osage"],
	    ["Osma", "Osmanya"],
	    ["Ougr", "Old_Uyghur"],
	    ["Palm", "Palmyrene"],
	    ["Pauc", "Pau_Cin_Hau"],
	    ["Perm", "Old_Permic"],
	    ["Phag", "Phags_Pa"],
	    ["Phli", "Inscriptional_Pahlavi"],
	    ["Phlp", "Psalter_Pahlavi"],
	    ["Phnx", "Phoenician"],
	    ["Plrd", "Miao"],
	    ["Prti", "Inscriptional_Parthian"],
	    ["Rjng", "Rejang"],
	    ["Rohg", "Hanifi_Rohingya"],
	    ["Runr", "Runic"],
	    ["Samr", "Samaritan"],
	    ["Sarb", "Old_South_Arabian"],
	    ["Saur", "Saurashtra"],
	    ["Sgnw", "SignWriting"],
	    ["Shaw", "Shavian"],
	    ["Shrd", "Sharada"],
	    ["Sidd", "Siddham"],
	    ["Sind", "Khudawadi"],
	    ["Sinh", "Sinhala"],
	    ["Sogd", "Sogdian"],
	    ["Sogo", "Old_Sogdian"],
	    ["Sora", "Sora_Sompeng"],
	    ["Soyo", "Soyombo"],
	    ["Sund", "Sundanese"],
	    ["Sunu", "Sunuwar"],
	    ["Sylo", "Syloti_Nagri"],
	    ["Syrc", "Syriac"],
	    ["Tagb", "Tagbanwa"],
	    ["Takr", "Takri"],
	    ["Tale", "Tai_Le"],
	    ["Talu", "New_Tai_Lue"],
	    ["Taml", "Tamil"],
	    ["Tang", "Tangut"],
	    ["Tavt", "Tai_Viet"],
	    ["Telu", "Telugu"],
	    ["Tfng", "Tifinagh"],
	    ["Tglg", "Tagalog"],
	    ["Thaa", "Thaana"],
	    ["Thai", "Thai"],
	    ["Tibt", "Tibetan"],
	    ["Tirh", "Tirhuta"],
	    ["Tnsa", "Tangsa"],
	    ["Todr", "Todhri"],
	    ["Toto", "Toto"],
	    ["Tutg", "Tulu_Tigalari"],
	    ["Ugar", "Ugaritic"],
	    ["Vaii", "Vai"],
	    ["Vith", "Vithkuqi"],
	    ["Wara", "Warang_Citi"],
	    ["Wcho", "Wancho"],
	    ["Xpeo", "Old_Persian"],
	    ["Xsux", "Cuneiform"],
	    ["Yezi", "Yezidi"],
	    ["Yiii", "Yi"],
	    ["Zanb", "Zanabazar_Square"],
	    ["Zinh", "Inherited"],
	    ["Qaai", "Inherited"],
	    ["Zyyy", "Common"],
	    ["Zzzz", "Unknown"],
	    ["Adlam", "Adlam"],
	    ["Caucasian_Albanian", "Caucasian_Albanian"],
	    ["Arabic", "Arabic"],
	    ["Imperial_Aramaic", "Imperial_Aramaic"],
	    ["Armenian", "Armenian"],
	    ["Avestan", "Avestan"],
	    ["Balinese", "Balinese"],
	    ["Bamum", "Bamum"],
	    ["Bassa_Vah", "Bassa_Vah"],
	    ["Batak", "Batak"],
	    ["Bengali", "Bengali"],
	    ["Bhaiksuki", "Bhaiksuki"],
	    ["Bopomofo", "Bopomofo"],
	    ["Brahmi", "Brahmi"],
	    ["Braille", "Braille"],
	    ["Buginese", "Buginese"],
	    ["Buhid", "Buhid"],
	    ["Chakma", "Chakma"],
	    ["Canadian_Aboriginal", "Canadian_Aboriginal"],
	    ["Carian", "Carian"],
	    ["Cherokee", "Cherokee"],
	    ["Chorasmian", "Chorasmian"],
	    ["Coptic", "Coptic"],
	    ["Cypro_Minoan", "Cypro_Minoan"],
	    ["Cypriot", "Cypriot"],
	    ["Cyrillic", "Cyrillic"],
	    ["Devanagari", "Devanagari"],
	    ["Dives_Akuru", "Dives_Akuru"],
	    ["Dogra", "Dogra"],
	    ["Deseret", "Deseret"],
	    ["Duployan", "Duployan"],
	    ["Egyptian_Hieroglyphs", "Egyptian_Hieroglyphs"],
	    ["Elbasan", "Elbasan"],
	    ["Elymaic", "Elymaic"],
	    ["Ethiopic", "Ethiopic"],
	    ["Garay", "Garay"],
	    ["Georgian", "Georgian"],
	    ["Glagolitic", "Glagolitic"],
	    ["Gunjala_Gondi", "Gunjala_Gondi"],
	    ["Masaram_Gondi", "Masaram_Gondi"],
	    ["Gothic", "Gothic"],
	    ["Grantha", "Grantha"],
	    ["Greek", "Greek"],
	    ["Gujarati", "Gujarati"],
	    ["Gurung_Khema", "Gurung_Khema"],
	    ["Gurmukhi", "Gurmukhi"],
	    ["Hangul", "Hangul"],
	    ["Han", "Han"],
	    ["Hanunoo", "Hanunoo"],
	    ["Hatran", "Hatran"],
	    ["Hebrew", "Hebrew"],
	    ["Hiragana", "Hiragana"],
	    ["Anatolian_Hieroglyphs", "Anatolian_Hieroglyphs"],
	    ["Pahawh_Hmong", "Pahawh_Hmong"],
	    ["Nyiakeng_Puachue_Hmong", "Nyiakeng_Puachue_Hmong"],
	    ["Katakana_Or_Hiragana", "Katakana_Or_Hiragana"],
	    ["Old_Hungarian", "Old_Hungarian"],
	    ["Old_Italic", "Old_Italic"],
	    ["Javanese", "Javanese"],
	    ["Kayah_Li", "Kayah_Li"],
	    ["Katakana", "Katakana"],
	    ["Kharoshthi", "Kharoshthi"],
	    ["Khmer", "Khmer"],
	    ["Khojki", "Khojki"],
	    ["Khitan_Small_Script", "Khitan_Small_Script"],
	    ["Kannada", "Kannada"],
	    ["Kirat_Rai", "Kirat_Rai"],
	    ["Kaithi", "Kaithi"],
	    ["Tai_Tham", "Tai_Tham"],
	    ["Lao", "Lao"],
	    ["Latin", "Latin"],
	    ["Lepcha", "Lepcha"],
	    ["Limbu", "Limbu"],
	    ["Linear_A", "Linear_A"],
	    ["Linear_B", "Linear_B"],
	    ["Lycian", "Lycian"],
	    ["Lydian", "Lydian"],
	    ["Mahajani", "Mahajani"],
	    ["Makasar", "Makasar"],
	    ["Mandaic", "Mandaic"],
	    ["Manichaean", "Manichaean"],
	    ["Marchen", "Marchen"],
	    ["Medefaidrin", "Medefaidrin"],
	    ["Mende_Kikakui", "Mende_Kikakui"],
	    ["Meroitic_Cursive", "Meroitic_Cursive"],
	    ["Meroitic_Hieroglyphs", "Meroitic_Hieroglyphs"],
	    ["Malayalam", "Malayalam"],
	    ["Mongolian", "Mongolian"],
	    ["Mro", "Mro"],
	    ["Meetei_Mayek", "Meetei_Mayek"],
	    ["Multani", "Multani"],
	    ["Myanmar", "Myanmar"],
	    ["Nag_Mundari", "Nag_Mundari"],
	    ["Nandinagari", "Nandinagari"],
	    ["Old_North_Arabian", "Old_North_Arabian"],
	    ["Nabataean", "Nabataean"],
	    ["Nko", "Nko"],
	    ["Nushu", "Nushu"],
	    ["Ogham", "Ogham"],
	    ["Ol_Chiki", "Ol_Chiki"],
	    ["Ol_Onal", "Ol_Onal"],
	    ["Old_Turkic", "Old_Turkic"],
	    ["Oriya", "Oriya"],
	    ["Osage", "Osage"],
	    ["Osmanya", "Osmanya"],
	    ["Old_Uyghur", "Old_Uyghur"],
	    ["Palmyrene", "Palmyrene"],
	    ["Pau_Cin_Hau", "Pau_Cin_Hau"],
	    ["Old_Permic", "Old_Permic"],
	    ["Phags_Pa", "Phags_Pa"],
	    ["Inscriptional_Pahlavi", "Inscriptional_Pahlavi"],
	    ["Psalter_Pahlavi", "Psalter_Pahlavi"],
	    ["Phoenician", "Phoenician"],
	    ["Miao", "Miao"],
	    ["Inscriptional_Parthian", "Inscriptional_Parthian"],
	    ["Rejang", "Rejang"],
	    ["Hanifi_Rohingya", "Hanifi_Rohingya"],
	    ["Runic", "Runic"],
	    ["Samaritan", "Samaritan"],
	    ["Old_South_Arabian", "Old_South_Arabian"],
	    ["Saurashtra", "Saurashtra"],
	    ["SignWriting", "SignWriting"],
	    ["Shavian", "Shavian"],
	    ["Sharada", "Sharada"],
	    ["Siddham", "Siddham"],
	    ["Khudawadi", "Khudawadi"],
	    ["Sinhala", "Sinhala"],
	    ["Sogdian", "Sogdian"],
	    ["Old_Sogdian", "Old_Sogdian"],
	    ["Sora_Sompeng", "Sora_Sompeng"],
	    ["Soyombo", "Soyombo"],
	    ["Sundanese", "Sundanese"],
	    ["Sunuwar", "Sunuwar"],
	    ["Syloti_Nagri", "Syloti_Nagri"],
	    ["Syriac", "Syriac"],
	    ["Tagbanwa", "Tagbanwa"],
	    ["Takri", "Takri"],
	    ["Tai_Le", "Tai_Le"],
	    ["New_Tai_Lue", "New_Tai_Lue"],
	    ["Tamil", "Tamil"],
	    ["Tangut", "Tangut"],
	    ["Tai_Viet", "Tai_Viet"],
	    ["Telugu", "Telugu"],
	    ["Tifinagh", "Tifinagh"],
	    ["Tagalog", "Tagalog"],
	    ["Thaana", "Thaana"],
	    ["Tibetan", "Tibetan"],
	    ["Tirhuta", "Tirhuta"],
	    ["Tangsa", "Tangsa"],
	    ["Todhri", "Todhri"],
	    ["Tulu_Tigalari", "Tulu_Tigalari"],
	    ["Ugaritic", "Ugaritic"],
	    ["Vai", "Vai"],
	    ["Vithkuqi", "Vithkuqi"],
	    ["Warang_Citi", "Warang_Citi"],
	    ["Wancho", "Wancho"],
	    ["Old_Persian", "Old_Persian"],
	    ["Cuneiform", "Cuneiform"],
	    ["Yezidi", "Yezidi"],
	    ["Yi", "Yi"],
	    ["Zanabazar_Square", "Zanabazar_Square"],
	    ["Inherited", "Inherited"],
	    ["Common", "Common"],
	    ["Unknown", "Unknown"]
	  ])]
	]);
	return mappings;
}

var unicodeMatchPropertyValueEcmascript;
var hasRequiredUnicodeMatchPropertyValueEcmascript;

function requireUnicodeMatchPropertyValueEcmascript () {
	if (hasRequiredUnicodeMatchPropertyValueEcmascript) return unicodeMatchPropertyValueEcmascript;
	hasRequiredUnicodeMatchPropertyValueEcmascript = 1;
	const propertyToValueAliases = requireMappings();
	const matchPropertyValue = function(property, value) {
	  const aliasToValue = propertyToValueAliases.get(property);
	  if (!aliasToValue) {
	    throw new Error(`Unknown property \`${property}\`.`);
	  }
	  const canonicalValue = aliasToValue.get(value);
	  if (canonicalValue) {
	    return canonicalValue;
	  }
	  throw new Error(
	    `Unknown value \`${value}\` for property \`${property}\`.`
	  );
	};
	unicodeMatchPropertyValueEcmascript = matchPropertyValue;
	return unicodeMatchPropertyValueEcmascript;
}

var iuMappings;
var hasRequiredIuMappings;

function requireIuMappings () {
	if (hasRequiredIuMappings) return iuMappings;
	hasRequiredIuMappings = 1;
	iuMappings = /* @__PURE__ */ new Map([
	  [75, 8490],
	  [83, 383],
	  [107, 8490],
	  [115, 383],
	  [181, 924],
	  [197, 8491],
	  [223, 7838],
	  [229, 8491],
	  [383, 83],
	  [452, 453],
	  [453, 452],
	  [455, 456],
	  [456, 455],
	  [458, 459],
	  [459, 458],
	  [497, 498],
	  [498, 497],
	  [837, 8126],
	  [912, 8147],
	  [914, 976],
	  [917, 1013],
	  [920, 1012],
	  [921, 8126],
	  [922, 1008],
	  [924, 181],
	  [928, 982],
	  [929, 1009],
	  [931, 962],
	  [934, 981],
	  [937, 8486],
	  [944, 8163],
	  [952, 1012],
	  [962, 931],
	  [969, 8486],
	  [976, 914],
	  [977, 1012],
	  [981, 934],
	  [982, 928],
	  [1008, 922],
	  [1009, 929],
	  [1012, [
	    920,
	    977,
	    952
	  ]],
	  [1013, 917],
	  [1042, 7296],
	  [1044, 7297],
	  [1054, 7298],
	  [1057, 7299],
	  [1058, 7301],
	  [1066, 7302],
	  [1122, 7303],
	  [7296, 1042],
	  [7297, 1044],
	  [7298, 1054],
	  [7299, 1057],
	  [7300, 7301],
	  [7301, [
	    1058,
	    7300
	  ]],
	  [7302, 1066],
	  [7303, 1122],
	  [7304, 42570],
	  [7776, 7835],
	  [7835, 7776],
	  [7838, 223],
	  [8064, 8072],
	  [8065, 8073],
	  [8066, 8074],
	  [8067, 8075],
	  [8068, 8076],
	  [8069, 8077],
	  [8070, 8078],
	  [8071, 8079],
	  [8072, 8064],
	  [8073, 8065],
	  [8074, 8066],
	  [8075, 8067],
	  [8076, 8068],
	  [8077, 8069],
	  [8078, 8070],
	  [8079, 8071],
	  [8080, 8088],
	  [8081, 8089],
	  [8082, 8090],
	  [8083, 8091],
	  [8084, 8092],
	  [8085, 8093],
	  [8086, 8094],
	  [8087, 8095],
	  [8088, 8080],
	  [8089, 8081],
	  [8090, 8082],
	  [8091, 8083],
	  [8092, 8084],
	  [8093, 8085],
	  [8094, 8086],
	  [8095, 8087],
	  [8096, 8104],
	  [8097, 8105],
	  [8098, 8106],
	  [8099, 8107],
	  [8100, 8108],
	  [8101, 8109],
	  [8102, 8110],
	  [8103, 8111],
	  [8104, 8096],
	  [8105, 8097],
	  [8106, 8098],
	  [8107, 8099],
	  [8108, 8100],
	  [8109, 8101],
	  [8110, 8102],
	  [8111, 8103],
	  [8115, 8124],
	  [8124, 8115],
	  [8126, [
	    837,
	    921
	  ]],
	  [8131, 8140],
	  [8140, 8131],
	  [8147, 912],
	  [8163, 944],
	  [8179, 8188],
	  [8188, 8179],
	  [8486, [
	    937,
	    969
	  ]],
	  [8490, 75],
	  [8491, [
	    197,
	    229
	  ]],
	  [42570, 7304],
	  [64261, 64262],
	  [64262, 64261],
	  [66560, 66600],
	  [66561, 66601],
	  [66562, 66602],
	  [66563, 66603],
	  [66564, 66604],
	  [66565, 66605],
	  [66566, 66606],
	  [66567, 66607],
	  [66568, 66608],
	  [66569, 66609],
	  [66570, 66610],
	  [66571, 66611],
	  [66572, 66612],
	  [66573, 66613],
	  [66574, 66614],
	  [66575, 66615],
	  [66576, 66616],
	  [66577, 66617],
	  [66578, 66618],
	  [66579, 66619],
	  [66580, 66620],
	  [66581, 66621],
	  [66582, 66622],
	  [66583, 66623],
	  [66584, 66624],
	  [66585, 66625],
	  [66586, 66626],
	  [66587, 66627],
	  [66588, 66628],
	  [66589, 66629],
	  [66590, 66630],
	  [66591, 66631],
	  [66592, 66632],
	  [66593, 66633],
	  [66594, 66634],
	  [66595, 66635],
	  [66596, 66636],
	  [66597, 66637],
	  [66598, 66638],
	  [66599, 66639],
	  [66600, 66560],
	  [66601, 66561],
	  [66602, 66562],
	  [66603, 66563],
	  [66604, 66564],
	  [66605, 66565],
	  [66606, 66566],
	  [66607, 66567],
	  [66608, 66568],
	  [66609, 66569],
	  [66610, 66570],
	  [66611, 66571],
	  [66612, 66572],
	  [66613, 66573],
	  [66614, 66574],
	  [66615, 66575],
	  [66616, 66576],
	  [66617, 66577],
	  [66618, 66578],
	  [66619, 66579],
	  [66620, 66580],
	  [66621, 66581],
	  [66622, 66582],
	  [66623, 66583],
	  [66624, 66584],
	  [66625, 66585],
	  [66626, 66586],
	  [66627, 66587],
	  [66628, 66588],
	  [66629, 66589],
	  [66630, 66590],
	  [66631, 66591],
	  [66632, 66592],
	  [66633, 66593],
	  [66634, 66594],
	  [66635, 66595],
	  [66636, 66596],
	  [66637, 66597],
	  [66638, 66598],
	  [66639, 66599],
	  [66736, 66776],
	  [66737, 66777],
	  [66738, 66778],
	  [66739, 66779],
	  [66740, 66780],
	  [66741, 66781],
	  [66742, 66782],
	  [66743, 66783],
	  [66744, 66784],
	  [66745, 66785],
	  [66746, 66786],
	  [66747, 66787],
	  [66748, 66788],
	  [66749, 66789],
	  [66750, 66790],
	  [66751, 66791],
	  [66752, 66792],
	  [66753, 66793],
	  [66754, 66794],
	  [66755, 66795],
	  [66756, 66796],
	  [66757, 66797],
	  [66758, 66798],
	  [66759, 66799],
	  [66760, 66800],
	  [66761, 66801],
	  [66762, 66802],
	  [66763, 66803],
	  [66764, 66804],
	  [66765, 66805],
	  [66766, 66806],
	  [66767, 66807],
	  [66768, 66808],
	  [66769, 66809],
	  [66770, 66810],
	  [66771, 66811],
	  [66776, 66736],
	  [66777, 66737],
	  [66778, 66738],
	  [66779, 66739],
	  [66780, 66740],
	  [66781, 66741],
	  [66782, 66742],
	  [66783, 66743],
	  [66784, 66744],
	  [66785, 66745],
	  [66786, 66746],
	  [66787, 66747],
	  [66788, 66748],
	  [66789, 66749],
	  [66790, 66750],
	  [66791, 66751],
	  [66792, 66752],
	  [66793, 66753],
	  [66794, 66754],
	  [66795, 66755],
	  [66796, 66756],
	  [66797, 66757],
	  [66798, 66758],
	  [66799, 66759],
	  [66800, 66760],
	  [66801, 66761],
	  [66802, 66762],
	  [66803, 66763],
	  [66804, 66764],
	  [66805, 66765],
	  [66806, 66766],
	  [66807, 66767],
	  [66808, 66768],
	  [66809, 66769],
	  [66810, 66770],
	  [66811, 66771],
	  [66928, 66967],
	  [66929, 66968],
	  [66930, 66969],
	  [66931, 66970],
	  [66932, 66971],
	  [66933, 66972],
	  [66934, 66973],
	  [66935, 66974],
	  [66936, 66975],
	  [66937, 66976],
	  [66938, 66977],
	  [66940, 66979],
	  [66941, 66980],
	  [66942, 66981],
	  [66943, 66982],
	  [66944, 66983],
	  [66945, 66984],
	  [66946, 66985],
	  [66947, 66986],
	  [66948, 66987],
	  [66949, 66988],
	  [66950, 66989],
	  [66951, 66990],
	  [66952, 66991],
	  [66953, 66992],
	  [66954, 66993],
	  [66956, 66995],
	  [66957, 66996],
	  [66958, 66997],
	  [66959, 66998],
	  [66960, 66999],
	  [66961, 67e3],
	  [66962, 67001],
	  [66964, 67003],
	  [66965, 67004],
	  [66967, 66928],
	  [66968, 66929],
	  [66969, 66930],
	  [66970, 66931],
	  [66971, 66932],
	  [66972, 66933],
	  [66973, 66934],
	  [66974, 66935],
	  [66975, 66936],
	  [66976, 66937],
	  [66977, 66938],
	  [66979, 66940],
	  [66980, 66941],
	  [66981, 66942],
	  [66982, 66943],
	  [66983, 66944],
	  [66984, 66945],
	  [66985, 66946],
	  [66986, 66947],
	  [66987, 66948],
	  [66988, 66949],
	  [66989, 66950],
	  [66990, 66951],
	  [66991, 66952],
	  [66992, 66953],
	  [66993, 66954],
	  [66995, 66956],
	  [66996, 66957],
	  [66997, 66958],
	  [66998, 66959],
	  [66999, 66960],
	  [67e3, 66961],
	  [67001, 66962],
	  [67003, 66964],
	  [67004, 66965],
	  [68736, 68800],
	  [68737, 68801],
	  [68738, 68802],
	  [68739, 68803],
	  [68740, 68804],
	  [68741, 68805],
	  [68742, 68806],
	  [68743, 68807],
	  [68744, 68808],
	  [68745, 68809],
	  [68746, 68810],
	  [68747, 68811],
	  [68748, 68812],
	  [68749, 68813],
	  [68750, 68814],
	  [68751, 68815],
	  [68752, 68816],
	  [68753, 68817],
	  [68754, 68818],
	  [68755, 68819],
	  [68756, 68820],
	  [68757, 68821],
	  [68758, 68822],
	  [68759, 68823],
	  [68760, 68824],
	  [68761, 68825],
	  [68762, 68826],
	  [68763, 68827],
	  [68764, 68828],
	  [68765, 68829],
	  [68766, 68830],
	  [68767, 68831],
	  [68768, 68832],
	  [68769, 68833],
	  [68770, 68834],
	  [68771, 68835],
	  [68772, 68836],
	  [68773, 68837],
	  [68774, 68838],
	  [68775, 68839],
	  [68776, 68840],
	  [68777, 68841],
	  [68778, 68842],
	  [68779, 68843],
	  [68780, 68844],
	  [68781, 68845],
	  [68782, 68846],
	  [68783, 68847],
	  [68784, 68848],
	  [68785, 68849],
	  [68786, 68850],
	  [68800, 68736],
	  [68801, 68737],
	  [68802, 68738],
	  [68803, 68739],
	  [68804, 68740],
	  [68805, 68741],
	  [68806, 68742],
	  [68807, 68743],
	  [68808, 68744],
	  [68809, 68745],
	  [68810, 68746],
	  [68811, 68747],
	  [68812, 68748],
	  [68813, 68749],
	  [68814, 68750],
	  [68815, 68751],
	  [68816, 68752],
	  [68817, 68753],
	  [68818, 68754],
	  [68819, 68755],
	  [68820, 68756],
	  [68821, 68757],
	  [68822, 68758],
	  [68823, 68759],
	  [68824, 68760],
	  [68825, 68761],
	  [68826, 68762],
	  [68827, 68763],
	  [68828, 68764],
	  [68829, 68765],
	  [68830, 68766],
	  [68831, 68767],
	  [68832, 68768],
	  [68833, 68769],
	  [68834, 68770],
	  [68835, 68771],
	  [68836, 68772],
	  [68837, 68773],
	  [68838, 68774],
	  [68839, 68775],
	  [68840, 68776],
	  [68841, 68777],
	  [68842, 68778],
	  [68843, 68779],
	  [68844, 68780],
	  [68845, 68781],
	  [68846, 68782],
	  [68847, 68783],
	  [68848, 68784],
	  [68849, 68785],
	  [68850, 68786],
	  [68944, 68976],
	  [68945, 68977],
	  [68946, 68978],
	  [68947, 68979],
	  [68948, 68980],
	  [68949, 68981],
	  [68950, 68982],
	  [68951, 68983],
	  [68952, 68984],
	  [68953, 68985],
	  [68954, 68986],
	  [68955, 68987],
	  [68956, 68988],
	  [68957, 68989],
	  [68958, 68990],
	  [68959, 68991],
	  [68960, 68992],
	  [68961, 68993],
	  [68962, 68994],
	  [68963, 68995],
	  [68964, 68996],
	  [68965, 68997],
	  [68976, 68944],
	  [68977, 68945],
	  [68978, 68946],
	  [68979, 68947],
	  [68980, 68948],
	  [68981, 68949],
	  [68982, 68950],
	  [68983, 68951],
	  [68984, 68952],
	  [68985, 68953],
	  [68986, 68954],
	  [68987, 68955],
	  [68988, 68956],
	  [68989, 68957],
	  [68990, 68958],
	  [68991, 68959],
	  [68992, 68960],
	  [68993, 68961],
	  [68994, 68962],
	  [68995, 68963],
	  [68996, 68964],
	  [68997, 68965],
	  [71840, 71872],
	  [71841, 71873],
	  [71842, 71874],
	  [71843, 71875],
	  [71844, 71876],
	  [71845, 71877],
	  [71846, 71878],
	  [71847, 71879],
	  [71848, 71880],
	  [71849, 71881],
	  [71850, 71882],
	  [71851, 71883],
	  [71852, 71884],
	  [71853, 71885],
	  [71854, 71886],
	  [71855, 71887],
	  [71856, 71888],
	  [71857, 71889],
	  [71858, 71890],
	  [71859, 71891],
	  [71860, 71892],
	  [71861, 71893],
	  [71862, 71894],
	  [71863, 71895],
	  [71864, 71896],
	  [71865, 71897],
	  [71866, 71898],
	  [71867, 71899],
	  [71868, 71900],
	  [71869, 71901],
	  [71870, 71902],
	  [71871, 71903],
	  [71872, 71840],
	  [71873, 71841],
	  [71874, 71842],
	  [71875, 71843],
	  [71876, 71844],
	  [71877, 71845],
	  [71878, 71846],
	  [71879, 71847],
	  [71880, 71848],
	  [71881, 71849],
	  [71882, 71850],
	  [71883, 71851],
	  [71884, 71852],
	  [71885, 71853],
	  [71886, 71854],
	  [71887, 71855],
	  [71888, 71856],
	  [71889, 71857],
	  [71890, 71858],
	  [71891, 71859],
	  [71892, 71860],
	  [71893, 71861],
	  [71894, 71862],
	  [71895, 71863],
	  [71896, 71864],
	  [71897, 71865],
	  [71898, 71866],
	  [71899, 71867],
	  [71900, 71868],
	  [71901, 71869],
	  [71902, 71870],
	  [71903, 71871],
	  [93760, 93792],
	  [93761, 93793],
	  [93762, 93794],
	  [93763, 93795],
	  [93764, 93796],
	  [93765, 93797],
	  [93766, 93798],
	  [93767, 93799],
	  [93768, 93800],
	  [93769, 93801],
	  [93770, 93802],
	  [93771, 93803],
	  [93772, 93804],
	  [93773, 93805],
	  [93774, 93806],
	  [93775, 93807],
	  [93776, 93808],
	  [93777, 93809],
	  [93778, 93810],
	  [93779, 93811],
	  [93780, 93812],
	  [93781, 93813],
	  [93782, 93814],
	  [93783, 93815],
	  [93784, 93816],
	  [93785, 93817],
	  [93786, 93818],
	  [93787, 93819],
	  [93788, 93820],
	  [93789, 93821],
	  [93790, 93822],
	  [93791, 93823],
	  [93792, 93760],
	  [93793, 93761],
	  [93794, 93762],
	  [93795, 93763],
	  [93796, 93764],
	  [93797, 93765],
	  [93798, 93766],
	  [93799, 93767],
	  [93800, 93768],
	  [93801, 93769],
	  [93802, 93770],
	  [93803, 93771],
	  [93804, 93772],
	  [93805, 93773],
	  [93806, 93774],
	  [93807, 93775],
	  [93808, 93776],
	  [93809, 93777],
	  [93810, 93778],
	  [93811, 93779],
	  [93812, 93780],
	  [93813, 93781],
	  [93814, 93782],
	  [93815, 93783],
	  [93816, 93784],
	  [93817, 93785],
	  [93818, 93786],
	  [93819, 93787],
	  [93820, 93788],
	  [93821, 93789],
	  [93822, 93790],
	  [93823, 93791],
	  [125184, 125218],
	  [125185, 125219],
	  [125186, 125220],
	  [125187, 125221],
	  [125188, 125222],
	  [125189, 125223],
	  [125190, 125224],
	  [125191, 125225],
	  [125192, 125226],
	  [125193, 125227],
	  [125194, 125228],
	  [125195, 125229],
	  [125196, 125230],
	  [125197, 125231],
	  [125198, 125232],
	  [125199, 125233],
	  [125200, 125234],
	  [125201, 125235],
	  [125202, 125236],
	  [125203, 125237],
	  [125204, 125238],
	  [125205, 125239],
	  [125206, 125240],
	  [125207, 125241],
	  [125208, 125242],
	  [125209, 125243],
	  [125210, 125244],
	  [125211, 125245],
	  [125212, 125246],
	  [125213, 125247],
	  [125214, 125248],
	  [125215, 125249],
	  [125216, 125250],
	  [125217, 125251],
	  [125218, 125184],
	  [125219, 125185],
	  [125220, 125186],
	  [125221, 125187],
	  [125222, 125188],
	  [125223, 125189],
	  [125224, 125190],
	  [125225, 125191],
	  [125226, 125192],
	  [125227, 125193],
	  [125228, 125194],
	  [125229, 125195],
	  [125230, 125196],
	  [125231, 125197],
	  [125232, 125198],
	  [125233, 125199],
	  [125234, 125200],
	  [125235, 125201],
	  [125236, 125202],
	  [125237, 125203],
	  [125238, 125204],
	  [125239, 125205],
	  [125240, 125206],
	  [125241, 125207],
	  [125242, 125208],
	  [125243, 125209],
	  [125244, 125210],
	  [125245, 125211],
	  [125246, 125212],
	  [125247, 125213],
	  [125248, 125214],
	  [125249, 125215],
	  [125250, 125216],
	  [125251, 125217]
	]);
	return iuMappings;
}

var iBmpMappings;
var hasRequiredIBmpMappings;

function requireIBmpMappings () {
	if (hasRequiredIBmpMappings) return iBmpMappings;
	hasRequiredIBmpMappings = 1;
	iBmpMappings = /* @__PURE__ */ new Map([
	  [181, 956],
	  [192, 224],
	  [193, 225],
	  [194, 226],
	  [195, 227],
	  [196, 228],
	  [197, 229],
	  [198, 230],
	  [199, 231],
	  [200, 232],
	  [201, 233],
	  [202, 234],
	  [203, 235],
	  [204, 236],
	  [205, 237],
	  [206, 238],
	  [207, 239],
	  [208, 240],
	  [209, 241],
	  [210, 242],
	  [211, 243],
	  [212, 244],
	  [213, 245],
	  [214, 246],
	  [216, 248],
	  [217, 249],
	  [218, 250],
	  [219, 251],
	  [220, 252],
	  [221, 253],
	  [222, 254],
	  [224, 192],
	  [225, 193],
	  [226, 194],
	  [227, 195],
	  [228, 196],
	  [229, 197],
	  [230, 198],
	  [231, 199],
	  [232, 200],
	  [233, 201],
	  [234, 202],
	  [235, 203],
	  [236, 204],
	  [237, 205],
	  [238, 206],
	  [239, 207],
	  [240, 208],
	  [241, 209],
	  [242, 210],
	  [243, 211],
	  [244, 212],
	  [245, 213],
	  [246, 214],
	  [248, 216],
	  [249, 217],
	  [250, 218],
	  [251, 219],
	  [252, 220],
	  [253, 221],
	  [254, 222],
	  [255, 376],
	  [256, 257],
	  [257, 256],
	  [258, 259],
	  [259, 258],
	  [260, 261],
	  [261, 260],
	  [262, 263],
	  [263, 262],
	  [264, 265],
	  [265, 264],
	  [266, 267],
	  [267, 266],
	  [268, 269],
	  [269, 268],
	  [270, 271],
	  [271, 270],
	  [272, 273],
	  [273, 272],
	  [274, 275],
	  [275, 274],
	  [276, 277],
	  [277, 276],
	  [278, 279],
	  [279, 278],
	  [280, 281],
	  [281, 280],
	  [282, 283],
	  [283, 282],
	  [284, 285],
	  [285, 284],
	  [286, 287],
	  [287, 286],
	  [288, 289],
	  [289, 288],
	  [290, 291],
	  [291, 290],
	  [292, 293],
	  [293, 292],
	  [294, 295],
	  [295, 294],
	  [296, 297],
	  [297, 296],
	  [298, 299],
	  [299, 298],
	  [300, 301],
	  [301, 300],
	  [302, 303],
	  [303, 302],
	  [306, 307],
	  [307, 306],
	  [308, 309],
	  [309, 308],
	  [310, 311],
	  [311, 310],
	  [313, 314],
	  [314, 313],
	  [315, 316],
	  [316, 315],
	  [317, 318],
	  [318, 317],
	  [319, 320],
	  [320, 319],
	  [321, 322],
	  [322, 321],
	  [323, 324],
	  [324, 323],
	  [325, 326],
	  [326, 325],
	  [327, 328],
	  [328, 327],
	  [330, 331],
	  [331, 330],
	  [332, 333],
	  [333, 332],
	  [334, 335],
	  [335, 334],
	  [336, 337],
	  [337, 336],
	  [338, 339],
	  [339, 338],
	  [340, 341],
	  [341, 340],
	  [342, 343],
	  [343, 342],
	  [344, 345],
	  [345, 344],
	  [346, 347],
	  [347, 346],
	  [348, 349],
	  [349, 348],
	  [350, 351],
	  [351, 350],
	  [352, 353],
	  [353, 352],
	  [354, 355],
	  [355, 354],
	  [356, 357],
	  [357, 356],
	  [358, 359],
	  [359, 358],
	  [360, 361],
	  [361, 360],
	  [362, 363],
	  [363, 362],
	  [364, 365],
	  [365, 364],
	  [366, 367],
	  [367, 366],
	  [368, 369],
	  [369, 368],
	  [370, 371],
	  [371, 370],
	  [372, 373],
	  [373, 372],
	  [374, 375],
	  [375, 374],
	  [376, 255],
	  [377, 378],
	  [378, 377],
	  [379, 380],
	  [380, 379],
	  [381, 382],
	  [382, 381],
	  [384, 579],
	  [385, 595],
	  [386, 387],
	  [387, 386],
	  [388, 389],
	  [389, 388],
	  [390, 596],
	  [391, 392],
	  [392, 391],
	  [393, 598],
	  [394, 599],
	  [395, 396],
	  [396, 395],
	  [398, 477],
	  [399, 601],
	  [400, 603],
	  [401, 402],
	  [402, 401],
	  [403, 608],
	  [404, 611],
	  [405, 502],
	  [406, 617],
	  [407, 616],
	  [408, 409],
	  [409, 408],
	  [410, 573],
	  [411, 42972],
	  [412, 623],
	  [413, 626],
	  [414, 544],
	  [415, 629],
	  [416, 417],
	  [417, 416],
	  [418, 419],
	  [419, 418],
	  [420, 421],
	  [421, 420],
	  [422, 640],
	  [423, 424],
	  [424, 423],
	  [425, 643],
	  [428, 429],
	  [429, 428],
	  [430, 648],
	  [431, 432],
	  [432, 431],
	  [433, 650],
	  [434, 651],
	  [435, 436],
	  [436, 435],
	  [437, 438],
	  [438, 437],
	  [439, 658],
	  [440, 441],
	  [441, 440],
	  [444, 445],
	  [445, 444],
	  [447, 503],
	  [452, 454],
	  [453, 454],
	  [454, [
	    452,
	    453
	  ]],
	  [455, 457],
	  [456, 457],
	  [457, [
	    455,
	    456
	  ]],
	  [458, 460],
	  [459, 460],
	  [460, [
	    458,
	    459
	  ]],
	  [461, 462],
	  [462, 461],
	  [463, 464],
	  [464, 463],
	  [465, 466],
	  [466, 465],
	  [467, 468],
	  [468, 467],
	  [469, 470],
	  [470, 469],
	  [471, 472],
	  [472, 471],
	  [473, 474],
	  [474, 473],
	  [475, 476],
	  [476, 475],
	  [477, 398],
	  [478, 479],
	  [479, 478],
	  [480, 481],
	  [481, 480],
	  [482, 483],
	  [483, 482],
	  [484, 485],
	  [485, 484],
	  [486, 487],
	  [487, 486],
	  [488, 489],
	  [489, 488],
	  [490, 491],
	  [491, 490],
	  [492, 493],
	  [493, 492],
	  [494, 495],
	  [495, 494],
	  [497, 499],
	  [498, 499],
	  [499, [
	    497,
	    498
	  ]],
	  [500, 501],
	  [501, 500],
	  [502, 405],
	  [503, 447],
	  [504, 505],
	  [505, 504],
	  [506, 507],
	  [507, 506],
	  [508, 509],
	  [509, 508],
	  [510, 511],
	  [511, 510],
	  [512, 513],
	  [513, 512],
	  [514, 515],
	  [515, 514],
	  [516, 517],
	  [517, 516],
	  [518, 519],
	  [519, 518],
	  [520, 521],
	  [521, 520],
	  [522, 523],
	  [523, 522],
	  [524, 525],
	  [525, 524],
	  [526, 527],
	  [527, 526],
	  [528, 529],
	  [529, 528],
	  [530, 531],
	  [531, 530],
	  [532, 533],
	  [533, 532],
	  [534, 535],
	  [535, 534],
	  [536, 537],
	  [537, 536],
	  [538, 539],
	  [539, 538],
	  [540, 541],
	  [541, 540],
	  [542, 543],
	  [543, 542],
	  [544, 414],
	  [546, 547],
	  [547, 546],
	  [548, 549],
	  [549, 548],
	  [550, 551],
	  [551, 550],
	  [552, 553],
	  [553, 552],
	  [554, 555],
	  [555, 554],
	  [556, 557],
	  [557, 556],
	  [558, 559],
	  [559, 558],
	  [560, 561],
	  [561, 560],
	  [562, 563],
	  [563, 562],
	  [570, 11365],
	  [571, 572],
	  [572, 571],
	  [573, 410],
	  [574, 11366],
	  [575, 11390],
	  [576, 11391],
	  [577, 578],
	  [578, 577],
	  [579, 384],
	  [580, 649],
	  [581, 652],
	  [582, 583],
	  [583, 582],
	  [584, 585],
	  [585, 584],
	  [586, 587],
	  [587, 586],
	  [588, 589],
	  [589, 588],
	  [590, 591],
	  [591, 590],
	  [592, 11375],
	  [593, 11373],
	  [594, 11376],
	  [595, 385],
	  [596, 390],
	  [598, 393],
	  [599, 394],
	  [601, 399],
	  [603, 400],
	  [604, 42923],
	  [608, 403],
	  [609, 42924],
	  [611, 404],
	  [612, 42955],
	  [613, 42893],
	  [614, 42922],
	  [616, 407],
	  [617, 406],
	  [618, 42926],
	  [619, 11362],
	  [620, 42925],
	  [623, 412],
	  [625, 11374],
	  [626, 413],
	  [629, 415],
	  [637, 11364],
	  [640, 422],
	  [642, 42949],
	  [643, 425],
	  [647, 42929],
	  [648, 430],
	  [649, 580],
	  [650, 433],
	  [651, 434],
	  [652, 581],
	  [658, 439],
	  [669, 42930],
	  [670, 42928],
	  [837, 953],
	  [880, 881],
	  [881, 880],
	  [882, 883],
	  [883, 882],
	  [886, 887],
	  [887, 886],
	  [891, 1021],
	  [892, 1022],
	  [893, 1023],
	  [895, 1011],
	  [902, 940],
	  [904, 941],
	  [905, 942],
	  [906, 943],
	  [908, 972],
	  [910, 973],
	  [911, 974],
	  [913, 945],
	  [914, 946],
	  [915, 947],
	  [916, 948],
	  [917, 949],
	  [918, 950],
	  [919, 951],
	  [920, 952],
	  [921, 953],
	  [922, 954],
	  [923, 955],
	  [924, 956],
	  [925, 957],
	  [926, 958],
	  [927, 959],
	  [928, 960],
	  [929, 961],
	  [931, 963],
	  [932, 964],
	  [933, 965],
	  [934, 966],
	  [935, 967],
	  [936, 968],
	  [937, 969],
	  [938, 970],
	  [939, 971],
	  [940, 902],
	  [941, 904],
	  [942, 905],
	  [943, 906],
	  [945, 913],
	  [946, [
	    914,
	    976
	  ]],
	  [947, 915],
	  [948, 916],
	  [949, [
	    917,
	    1013
	  ]],
	  [950, 918],
	  [951, 919],
	  [952, [
	    920,
	    977
	  ]],
	  [953, [
	    837,
	    921,
	    8126
	  ]],
	  [954, [
	    922,
	    1008
	  ]],
	  [955, 923],
	  [956, [
	    181,
	    924
	  ]],
	  [957, 925],
	  [958, 926],
	  [959, 927],
	  [960, [
	    928,
	    982
	  ]],
	  [961, [
	    929,
	    1009
	  ]],
	  [962, 963],
	  [963, [
	    931,
	    962
	  ]],
	  [964, 932],
	  [965, 933],
	  [966, [
	    934,
	    981
	  ]],
	  [967, 935],
	  [968, 936],
	  [969, 937],
	  [970, 938],
	  [971, 939],
	  [972, 908],
	  [973, 910],
	  [974, 911],
	  [975, 983],
	  [976, 946],
	  [977, 952],
	  [981, 966],
	  [982, 960],
	  [983, 975],
	  [984, 985],
	  [985, 984],
	  [986, 987],
	  [987, 986],
	  [988, 989],
	  [989, 988],
	  [990, 991],
	  [991, 990],
	  [992, 993],
	  [993, 992],
	  [994, 995],
	  [995, 994],
	  [996, 997],
	  [997, 996],
	  [998, 999],
	  [999, 998],
	  [1e3, 1001],
	  [1001, 1e3],
	  [1002, 1003],
	  [1003, 1002],
	  [1004, 1005],
	  [1005, 1004],
	  [1006, 1007],
	  [1007, 1006],
	  [1008, 954],
	  [1009, 961],
	  [1010, 1017],
	  [1011, 895],
	  [1013, 949],
	  [1015, 1016],
	  [1016, 1015],
	  [1017, 1010],
	  [1018, 1019],
	  [1019, 1018],
	  [1021, 891],
	  [1022, 892],
	  [1023, 893],
	  [1024, 1104],
	  [1025, 1105],
	  [1026, 1106],
	  [1027, 1107],
	  [1028, 1108],
	  [1029, 1109],
	  [1030, 1110],
	  [1031, 1111],
	  [1032, 1112],
	  [1033, 1113],
	  [1034, 1114],
	  [1035, 1115],
	  [1036, 1116],
	  [1037, 1117],
	  [1038, 1118],
	  [1039, 1119],
	  [1040, 1072],
	  [1041, 1073],
	  [1042, 1074],
	  [1043, 1075],
	  [1044, 1076],
	  [1045, 1077],
	  [1046, 1078],
	  [1047, 1079],
	  [1048, 1080],
	  [1049, 1081],
	  [1050, 1082],
	  [1051, 1083],
	  [1052, 1084],
	  [1053, 1085],
	  [1054, 1086],
	  [1055, 1087],
	  [1056, 1088],
	  [1057, 1089],
	  [1058, 1090],
	  [1059, 1091],
	  [1060, 1092],
	  [1061, 1093],
	  [1062, 1094],
	  [1063, 1095],
	  [1064, 1096],
	  [1065, 1097],
	  [1066, 1098],
	  [1067, 1099],
	  [1068, 1100],
	  [1069, 1101],
	  [1070, 1102],
	  [1071, 1103],
	  [1072, 1040],
	  [1073, 1041],
	  [1074, [
	    1042,
	    7296
	  ]],
	  [1075, 1043],
	  [1076, [
	    1044,
	    7297
	  ]],
	  [1077, 1045],
	  [1078, 1046],
	  [1079, 1047],
	  [1080, 1048],
	  [1081, 1049],
	  [1082, 1050],
	  [1083, 1051],
	  [1084, 1052],
	  [1085, 1053],
	  [1086, [
	    1054,
	    7298
	  ]],
	  [1087, 1055],
	  [1088, 1056],
	  [1089, [
	    1057,
	    7299
	  ]],
	  [1090, [
	    1058,
	    7300,
	    7301
	  ]],
	  [1091, 1059],
	  [1092, 1060],
	  [1093, 1061],
	  [1094, 1062],
	  [1095, 1063],
	  [1096, 1064],
	  [1097, 1065],
	  [1098, [
	    1066,
	    7302
	  ]],
	  [1099, 1067],
	  [1100, 1068],
	  [1101, 1069],
	  [1102, 1070],
	  [1103, 1071],
	  [1104, 1024],
	  [1105, 1025],
	  [1106, 1026],
	  [1107, 1027],
	  [1108, 1028],
	  [1109, 1029],
	  [1110, 1030],
	  [1111, 1031],
	  [1112, 1032],
	  [1113, 1033],
	  [1114, 1034],
	  [1115, 1035],
	  [1116, 1036],
	  [1117, 1037],
	  [1118, 1038],
	  [1119, 1039],
	  [1120, 1121],
	  [1121, 1120],
	  [1122, 1123],
	  [1123, [
	    1122,
	    7303
	  ]],
	  [1124, 1125],
	  [1125, 1124],
	  [1126, 1127],
	  [1127, 1126],
	  [1128, 1129],
	  [1129, 1128],
	  [1130, 1131],
	  [1131, 1130],
	  [1132, 1133],
	  [1133, 1132],
	  [1134, 1135],
	  [1135, 1134],
	  [1136, 1137],
	  [1137, 1136],
	  [1138, 1139],
	  [1139, 1138],
	  [1140, 1141],
	  [1141, 1140],
	  [1142, 1143],
	  [1143, 1142],
	  [1144, 1145],
	  [1145, 1144],
	  [1146, 1147],
	  [1147, 1146],
	  [1148, 1149],
	  [1149, 1148],
	  [1150, 1151],
	  [1151, 1150],
	  [1152, 1153],
	  [1153, 1152],
	  [1162, 1163],
	  [1163, 1162],
	  [1164, 1165],
	  [1165, 1164],
	  [1166, 1167],
	  [1167, 1166],
	  [1168, 1169],
	  [1169, 1168],
	  [1170, 1171],
	  [1171, 1170],
	  [1172, 1173],
	  [1173, 1172],
	  [1174, 1175],
	  [1175, 1174],
	  [1176, 1177],
	  [1177, 1176],
	  [1178, 1179],
	  [1179, 1178],
	  [1180, 1181],
	  [1181, 1180],
	  [1182, 1183],
	  [1183, 1182],
	  [1184, 1185],
	  [1185, 1184],
	  [1186, 1187],
	  [1187, 1186],
	  [1188, 1189],
	  [1189, 1188],
	  [1190, 1191],
	  [1191, 1190],
	  [1192, 1193],
	  [1193, 1192],
	  [1194, 1195],
	  [1195, 1194],
	  [1196, 1197],
	  [1197, 1196],
	  [1198, 1199],
	  [1199, 1198],
	  [1200, 1201],
	  [1201, 1200],
	  [1202, 1203],
	  [1203, 1202],
	  [1204, 1205],
	  [1205, 1204],
	  [1206, 1207],
	  [1207, 1206],
	  [1208, 1209],
	  [1209, 1208],
	  [1210, 1211],
	  [1211, 1210],
	  [1212, 1213],
	  [1213, 1212],
	  [1214, 1215],
	  [1215, 1214],
	  [1216, 1231],
	  [1217, 1218],
	  [1218, 1217],
	  [1219, 1220],
	  [1220, 1219],
	  [1221, 1222],
	  [1222, 1221],
	  [1223, 1224],
	  [1224, 1223],
	  [1225, 1226],
	  [1226, 1225],
	  [1227, 1228],
	  [1228, 1227],
	  [1229, 1230],
	  [1230, 1229],
	  [1231, 1216],
	  [1232, 1233],
	  [1233, 1232],
	  [1234, 1235],
	  [1235, 1234],
	  [1236, 1237],
	  [1237, 1236],
	  [1238, 1239],
	  [1239, 1238],
	  [1240, 1241],
	  [1241, 1240],
	  [1242, 1243],
	  [1243, 1242],
	  [1244, 1245],
	  [1245, 1244],
	  [1246, 1247],
	  [1247, 1246],
	  [1248, 1249],
	  [1249, 1248],
	  [1250, 1251],
	  [1251, 1250],
	  [1252, 1253],
	  [1253, 1252],
	  [1254, 1255],
	  [1255, 1254],
	  [1256, 1257],
	  [1257, 1256],
	  [1258, 1259],
	  [1259, 1258],
	  [1260, 1261],
	  [1261, 1260],
	  [1262, 1263],
	  [1263, 1262],
	  [1264, 1265],
	  [1265, 1264],
	  [1266, 1267],
	  [1267, 1266],
	  [1268, 1269],
	  [1269, 1268],
	  [1270, 1271],
	  [1271, 1270],
	  [1272, 1273],
	  [1273, 1272],
	  [1274, 1275],
	  [1275, 1274],
	  [1276, 1277],
	  [1277, 1276],
	  [1278, 1279],
	  [1279, 1278],
	  [1280, 1281],
	  [1281, 1280],
	  [1282, 1283],
	  [1283, 1282],
	  [1284, 1285],
	  [1285, 1284],
	  [1286, 1287],
	  [1287, 1286],
	  [1288, 1289],
	  [1289, 1288],
	  [1290, 1291],
	  [1291, 1290],
	  [1292, 1293],
	  [1293, 1292],
	  [1294, 1295],
	  [1295, 1294],
	  [1296, 1297],
	  [1297, 1296],
	  [1298, 1299],
	  [1299, 1298],
	  [1300, 1301],
	  [1301, 1300],
	  [1302, 1303],
	  [1303, 1302],
	  [1304, 1305],
	  [1305, 1304],
	  [1306, 1307],
	  [1307, 1306],
	  [1308, 1309],
	  [1309, 1308],
	  [1310, 1311],
	  [1311, 1310],
	  [1312, 1313],
	  [1313, 1312],
	  [1314, 1315],
	  [1315, 1314],
	  [1316, 1317],
	  [1317, 1316],
	  [1318, 1319],
	  [1319, 1318],
	  [1320, 1321],
	  [1321, 1320],
	  [1322, 1323],
	  [1323, 1322],
	  [1324, 1325],
	  [1325, 1324],
	  [1326, 1327],
	  [1327, 1326],
	  [1329, 1377],
	  [1330, 1378],
	  [1331, 1379],
	  [1332, 1380],
	  [1333, 1381],
	  [1334, 1382],
	  [1335, 1383],
	  [1336, 1384],
	  [1337, 1385],
	  [1338, 1386],
	  [1339, 1387],
	  [1340, 1388],
	  [1341, 1389],
	  [1342, 1390],
	  [1343, 1391],
	  [1344, 1392],
	  [1345, 1393],
	  [1346, 1394],
	  [1347, 1395],
	  [1348, 1396],
	  [1349, 1397],
	  [1350, 1398],
	  [1351, 1399],
	  [1352, 1400],
	  [1353, 1401],
	  [1354, 1402],
	  [1355, 1403],
	  [1356, 1404],
	  [1357, 1405],
	  [1358, 1406],
	  [1359, 1407],
	  [1360, 1408],
	  [1361, 1409],
	  [1362, 1410],
	  [1363, 1411],
	  [1364, 1412],
	  [1365, 1413],
	  [1366, 1414],
	  [1377, 1329],
	  [1378, 1330],
	  [1379, 1331],
	  [1380, 1332],
	  [1381, 1333],
	  [1382, 1334],
	  [1383, 1335],
	  [1384, 1336],
	  [1385, 1337],
	  [1386, 1338],
	  [1387, 1339],
	  [1388, 1340],
	  [1389, 1341],
	  [1390, 1342],
	  [1391, 1343],
	  [1392, 1344],
	  [1393, 1345],
	  [1394, 1346],
	  [1395, 1347],
	  [1396, 1348],
	  [1397, 1349],
	  [1398, 1350],
	  [1399, 1351],
	  [1400, 1352],
	  [1401, 1353],
	  [1402, 1354],
	  [1403, 1355],
	  [1404, 1356],
	  [1405, 1357],
	  [1406, 1358],
	  [1407, 1359],
	  [1408, 1360],
	  [1409, 1361],
	  [1410, 1362],
	  [1411, 1363],
	  [1412, 1364],
	  [1413, 1365],
	  [1414, 1366],
	  [4256, 11520],
	  [4257, 11521],
	  [4258, 11522],
	  [4259, 11523],
	  [4260, 11524],
	  [4261, 11525],
	  [4262, 11526],
	  [4263, 11527],
	  [4264, 11528],
	  [4265, 11529],
	  [4266, 11530],
	  [4267, 11531],
	  [4268, 11532],
	  [4269, 11533],
	  [4270, 11534],
	  [4271, 11535],
	  [4272, 11536],
	  [4273, 11537],
	  [4274, 11538],
	  [4275, 11539],
	  [4276, 11540],
	  [4277, 11541],
	  [4278, 11542],
	  [4279, 11543],
	  [4280, 11544],
	  [4281, 11545],
	  [4282, 11546],
	  [4283, 11547],
	  [4284, 11548],
	  [4285, 11549],
	  [4286, 11550],
	  [4287, 11551],
	  [4288, 11552],
	  [4289, 11553],
	  [4290, 11554],
	  [4291, 11555],
	  [4292, 11556],
	  [4293, 11557],
	  [4295, 11559],
	  [4301, 11565],
	  [4304, 7312],
	  [4305, 7313],
	  [4306, 7314],
	  [4307, 7315],
	  [4308, 7316],
	  [4309, 7317],
	  [4310, 7318],
	  [4311, 7319],
	  [4312, 7320],
	  [4313, 7321],
	  [4314, 7322],
	  [4315, 7323],
	  [4316, 7324],
	  [4317, 7325],
	  [4318, 7326],
	  [4319, 7327],
	  [4320, 7328],
	  [4321, 7329],
	  [4322, 7330],
	  [4323, 7331],
	  [4324, 7332],
	  [4325, 7333],
	  [4326, 7334],
	  [4327, 7335],
	  [4328, 7336],
	  [4329, 7337],
	  [4330, 7338],
	  [4331, 7339],
	  [4332, 7340],
	  [4333, 7341],
	  [4334, 7342],
	  [4335, 7343],
	  [4336, 7344],
	  [4337, 7345],
	  [4338, 7346],
	  [4339, 7347],
	  [4340, 7348],
	  [4341, 7349],
	  [4342, 7350],
	  [4343, 7351],
	  [4344, 7352],
	  [4345, 7353],
	  [4346, 7354],
	  [4349, 7357],
	  [4350, 7358],
	  [4351, 7359],
	  [5024, 43888],
	  [5025, 43889],
	  [5026, 43890],
	  [5027, 43891],
	  [5028, 43892],
	  [5029, 43893],
	  [5030, 43894],
	  [5031, 43895],
	  [5032, 43896],
	  [5033, 43897],
	  [5034, 43898],
	  [5035, 43899],
	  [5036, 43900],
	  [5037, 43901],
	  [5038, 43902],
	  [5039, 43903],
	  [5040, 43904],
	  [5041, 43905],
	  [5042, 43906],
	  [5043, 43907],
	  [5044, 43908],
	  [5045, 43909],
	  [5046, 43910],
	  [5047, 43911],
	  [5048, 43912],
	  [5049, 43913],
	  [5050, 43914],
	  [5051, 43915],
	  [5052, 43916],
	  [5053, 43917],
	  [5054, 43918],
	  [5055, 43919],
	  [5056, 43920],
	  [5057, 43921],
	  [5058, 43922],
	  [5059, 43923],
	  [5060, 43924],
	  [5061, 43925],
	  [5062, 43926],
	  [5063, 43927],
	  [5064, 43928],
	  [5065, 43929],
	  [5066, 43930],
	  [5067, 43931],
	  [5068, 43932],
	  [5069, 43933],
	  [5070, 43934],
	  [5071, 43935],
	  [5072, 43936],
	  [5073, 43937],
	  [5074, 43938],
	  [5075, 43939],
	  [5076, 43940],
	  [5077, 43941],
	  [5078, 43942],
	  [5079, 43943],
	  [5080, 43944],
	  [5081, 43945],
	  [5082, 43946],
	  [5083, 43947],
	  [5084, 43948],
	  [5085, 43949],
	  [5086, 43950],
	  [5087, 43951],
	  [5088, 43952],
	  [5089, 43953],
	  [5090, 43954],
	  [5091, 43955],
	  [5092, 43956],
	  [5093, 43957],
	  [5094, 43958],
	  [5095, 43959],
	  [5096, 43960],
	  [5097, 43961],
	  [5098, 43962],
	  [5099, 43963],
	  [5100, 43964],
	  [5101, 43965],
	  [5102, 43966],
	  [5103, 43967],
	  [5104, 5112],
	  [5105, 5113],
	  [5106, 5114],
	  [5107, 5115],
	  [5108, 5116],
	  [5109, 5117],
	  [5112, 5104],
	  [5113, 5105],
	  [5114, 5106],
	  [5115, 5107],
	  [5116, 5108],
	  [5117, 5109],
	  [7296, 1074],
	  [7297, 1076],
	  [7298, 1086],
	  [7299, 1089],
	  [7300, 1090],
	  [7301, 1090],
	  [7302, 1098],
	  [7303, 1123],
	  [7304, 42571],
	  [7305, 7306],
	  [7306, 7305],
	  [7312, 4304],
	  [7313, 4305],
	  [7314, 4306],
	  [7315, 4307],
	  [7316, 4308],
	  [7317, 4309],
	  [7318, 4310],
	  [7319, 4311],
	  [7320, 4312],
	  [7321, 4313],
	  [7322, 4314],
	  [7323, 4315],
	  [7324, 4316],
	  [7325, 4317],
	  [7326, 4318],
	  [7327, 4319],
	  [7328, 4320],
	  [7329, 4321],
	  [7330, 4322],
	  [7331, 4323],
	  [7332, 4324],
	  [7333, 4325],
	  [7334, 4326],
	  [7335, 4327],
	  [7336, 4328],
	  [7337, 4329],
	  [7338, 4330],
	  [7339, 4331],
	  [7340, 4332],
	  [7341, 4333],
	  [7342, 4334],
	  [7343, 4335],
	  [7344, 4336],
	  [7345, 4337],
	  [7346, 4338],
	  [7347, 4339],
	  [7348, 4340],
	  [7349, 4341],
	  [7350, 4342],
	  [7351, 4343],
	  [7352, 4344],
	  [7353, 4345],
	  [7354, 4346],
	  [7357, 4349],
	  [7358, 4350],
	  [7359, 4351],
	  [7545, 42877],
	  [7549, 11363],
	  [7566, 42950],
	  [7680, 7681],
	  [7681, 7680],
	  [7682, 7683],
	  [7683, 7682],
	  [7684, 7685],
	  [7685, 7684],
	  [7686, 7687],
	  [7687, 7686],
	  [7688, 7689],
	  [7689, 7688],
	  [7690, 7691],
	  [7691, 7690],
	  [7692, 7693],
	  [7693, 7692],
	  [7694, 7695],
	  [7695, 7694],
	  [7696, 7697],
	  [7697, 7696],
	  [7698, 7699],
	  [7699, 7698],
	  [7700, 7701],
	  [7701, 7700],
	  [7702, 7703],
	  [7703, 7702],
	  [7704, 7705],
	  [7705, 7704],
	  [7706, 7707],
	  [7707, 7706],
	  [7708, 7709],
	  [7709, 7708],
	  [7710, 7711],
	  [7711, 7710],
	  [7712, 7713],
	  [7713, 7712],
	  [7714, 7715],
	  [7715, 7714],
	  [7716, 7717],
	  [7717, 7716],
	  [7718, 7719],
	  [7719, 7718],
	  [7720, 7721],
	  [7721, 7720],
	  [7722, 7723],
	  [7723, 7722],
	  [7724, 7725],
	  [7725, 7724],
	  [7726, 7727],
	  [7727, 7726],
	  [7728, 7729],
	  [7729, 7728],
	  [7730, 7731],
	  [7731, 7730],
	  [7732, 7733],
	  [7733, 7732],
	  [7734, 7735],
	  [7735, 7734],
	  [7736, 7737],
	  [7737, 7736],
	  [7738, 7739],
	  [7739, 7738],
	  [7740, 7741],
	  [7741, 7740],
	  [7742, 7743],
	  [7743, 7742],
	  [7744, 7745],
	  [7745, 7744],
	  [7746, 7747],
	  [7747, 7746],
	  [7748, 7749],
	  [7749, 7748],
	  [7750, 7751],
	  [7751, 7750],
	  [7752, 7753],
	  [7753, 7752],
	  [7754, 7755],
	  [7755, 7754],
	  [7756, 7757],
	  [7757, 7756],
	  [7758, 7759],
	  [7759, 7758],
	  [7760, 7761],
	  [7761, 7760],
	  [7762, 7763],
	  [7763, 7762],
	  [7764, 7765],
	  [7765, 7764],
	  [7766, 7767],
	  [7767, 7766],
	  [7768, 7769],
	  [7769, 7768],
	  [7770, 7771],
	  [7771, 7770],
	  [7772, 7773],
	  [7773, 7772],
	  [7774, 7775],
	  [7775, 7774],
	  [7776, 7777],
	  [7777, [
	    7776,
	    7835
	  ]],
	  [7778, 7779],
	  [7779, 7778],
	  [7780, 7781],
	  [7781, 7780],
	  [7782, 7783],
	  [7783, 7782],
	  [7784, 7785],
	  [7785, 7784],
	  [7786, 7787],
	  [7787, 7786],
	  [7788, 7789],
	  [7789, 7788],
	  [7790, 7791],
	  [7791, 7790],
	  [7792, 7793],
	  [7793, 7792],
	  [7794, 7795],
	  [7795, 7794],
	  [7796, 7797],
	  [7797, 7796],
	  [7798, 7799],
	  [7799, 7798],
	  [7800, 7801],
	  [7801, 7800],
	  [7802, 7803],
	  [7803, 7802],
	  [7804, 7805],
	  [7805, 7804],
	  [7806, 7807],
	  [7807, 7806],
	  [7808, 7809],
	  [7809, 7808],
	  [7810, 7811],
	  [7811, 7810],
	  [7812, 7813],
	  [7813, 7812],
	  [7814, 7815],
	  [7815, 7814],
	  [7816, 7817],
	  [7817, 7816],
	  [7818, 7819],
	  [7819, 7818],
	  [7820, 7821],
	  [7821, 7820],
	  [7822, 7823],
	  [7823, 7822],
	  [7824, 7825],
	  [7825, 7824],
	  [7826, 7827],
	  [7827, 7826],
	  [7828, 7829],
	  [7829, 7828],
	  [7835, 7777],
	  [7840, 7841],
	  [7841, 7840],
	  [7842, 7843],
	  [7843, 7842],
	  [7844, 7845],
	  [7845, 7844],
	  [7846, 7847],
	  [7847, 7846],
	  [7848, 7849],
	  [7849, 7848],
	  [7850, 7851],
	  [7851, 7850],
	  [7852, 7853],
	  [7853, 7852],
	  [7854, 7855],
	  [7855, 7854],
	  [7856, 7857],
	  [7857, 7856],
	  [7858, 7859],
	  [7859, 7858],
	  [7860, 7861],
	  [7861, 7860],
	  [7862, 7863],
	  [7863, 7862],
	  [7864, 7865],
	  [7865, 7864],
	  [7866, 7867],
	  [7867, 7866],
	  [7868, 7869],
	  [7869, 7868],
	  [7870, 7871],
	  [7871, 7870],
	  [7872, 7873],
	  [7873, 7872],
	  [7874, 7875],
	  [7875, 7874],
	  [7876, 7877],
	  [7877, 7876],
	  [7878, 7879],
	  [7879, 7878],
	  [7880, 7881],
	  [7881, 7880],
	  [7882, 7883],
	  [7883, 7882],
	  [7884, 7885],
	  [7885, 7884],
	  [7886, 7887],
	  [7887, 7886],
	  [7888, 7889],
	  [7889, 7888],
	  [7890, 7891],
	  [7891, 7890],
	  [7892, 7893],
	  [7893, 7892],
	  [7894, 7895],
	  [7895, 7894],
	  [7896, 7897],
	  [7897, 7896],
	  [7898, 7899],
	  [7899, 7898],
	  [7900, 7901],
	  [7901, 7900],
	  [7902, 7903],
	  [7903, 7902],
	  [7904, 7905],
	  [7905, 7904],
	  [7906, 7907],
	  [7907, 7906],
	  [7908, 7909],
	  [7909, 7908],
	  [7910, 7911],
	  [7911, 7910],
	  [7912, 7913],
	  [7913, 7912],
	  [7914, 7915],
	  [7915, 7914],
	  [7916, 7917],
	  [7917, 7916],
	  [7918, 7919],
	  [7919, 7918],
	  [7920, 7921],
	  [7921, 7920],
	  [7922, 7923],
	  [7923, 7922],
	  [7924, 7925],
	  [7925, 7924],
	  [7926, 7927],
	  [7927, 7926],
	  [7928, 7929],
	  [7929, 7928],
	  [7930, 7931],
	  [7931, 7930],
	  [7932, 7933],
	  [7933, 7932],
	  [7934, 7935],
	  [7935, 7934],
	  [7936, 7944],
	  [7937, 7945],
	  [7938, 7946],
	  [7939, 7947],
	  [7940, 7948],
	  [7941, 7949],
	  [7942, 7950],
	  [7943, 7951],
	  [7944, 7936],
	  [7945, 7937],
	  [7946, 7938],
	  [7947, 7939],
	  [7948, 7940],
	  [7949, 7941],
	  [7950, 7942],
	  [7951, 7943],
	  [7952, 7960],
	  [7953, 7961],
	  [7954, 7962],
	  [7955, 7963],
	  [7956, 7964],
	  [7957, 7965],
	  [7960, 7952],
	  [7961, 7953],
	  [7962, 7954],
	  [7963, 7955],
	  [7964, 7956],
	  [7965, 7957],
	  [7968, 7976],
	  [7969, 7977],
	  [7970, 7978],
	  [7971, 7979],
	  [7972, 7980],
	  [7973, 7981],
	  [7974, 7982],
	  [7975, 7983],
	  [7976, 7968],
	  [7977, 7969],
	  [7978, 7970],
	  [7979, 7971],
	  [7980, 7972],
	  [7981, 7973],
	  [7982, 7974],
	  [7983, 7975],
	  [7984, 7992],
	  [7985, 7993],
	  [7986, 7994],
	  [7987, 7995],
	  [7988, 7996],
	  [7989, 7997],
	  [7990, 7998],
	  [7991, 7999],
	  [7992, 7984],
	  [7993, 7985],
	  [7994, 7986],
	  [7995, 7987],
	  [7996, 7988],
	  [7997, 7989],
	  [7998, 7990],
	  [7999, 7991],
	  [8e3, 8008],
	  [8001, 8009],
	  [8002, 8010],
	  [8003, 8011],
	  [8004, 8012],
	  [8005, 8013],
	  [8008, 8e3],
	  [8009, 8001],
	  [8010, 8002],
	  [8011, 8003],
	  [8012, 8004],
	  [8013, 8005],
	  [8017, 8025],
	  [8019, 8027],
	  [8021, 8029],
	  [8023, 8031],
	  [8025, 8017],
	  [8027, 8019],
	  [8029, 8021],
	  [8031, 8023],
	  [8032, 8040],
	  [8033, 8041],
	  [8034, 8042],
	  [8035, 8043],
	  [8036, 8044],
	  [8037, 8045],
	  [8038, 8046],
	  [8039, 8047],
	  [8040, 8032],
	  [8041, 8033],
	  [8042, 8034],
	  [8043, 8035],
	  [8044, 8036],
	  [8045, 8037],
	  [8046, 8038],
	  [8047, 8039],
	  [8048, 8122],
	  [8049, 8123],
	  [8050, 8136],
	  [8051, 8137],
	  [8052, 8138],
	  [8053, 8139],
	  [8054, 8154],
	  [8055, 8155],
	  [8056, 8184],
	  [8057, 8185],
	  [8058, 8170],
	  [8059, 8171],
	  [8060, 8186],
	  [8061, 8187],
	  [8112, 8120],
	  [8113, 8121],
	  [8120, 8112],
	  [8121, 8113],
	  [8122, 8048],
	  [8123, 8049],
	  [8126, 953],
	  [8136, 8050],
	  [8137, 8051],
	  [8138, 8052],
	  [8139, 8053],
	  [8144, 8152],
	  [8145, 8153],
	  [8152, 8144],
	  [8153, 8145],
	  [8154, 8054],
	  [8155, 8055],
	  [8160, 8168],
	  [8161, 8169],
	  [8165, 8172],
	  [8168, 8160],
	  [8169, 8161],
	  [8170, 8058],
	  [8171, 8059],
	  [8172, 8165],
	  [8184, 8056],
	  [8185, 8057],
	  [8186, 8060],
	  [8187, 8061],
	  [8498, 8526],
	  [8526, 8498],
	  [8544, 8560],
	  [8545, 8561],
	  [8546, 8562],
	  [8547, 8563],
	  [8548, 8564],
	  [8549, 8565],
	  [8550, 8566],
	  [8551, 8567],
	  [8552, 8568],
	  [8553, 8569],
	  [8554, 8570],
	  [8555, 8571],
	  [8556, 8572],
	  [8557, 8573],
	  [8558, 8574],
	  [8559, 8575],
	  [8560, 8544],
	  [8561, 8545],
	  [8562, 8546],
	  [8563, 8547],
	  [8564, 8548],
	  [8565, 8549],
	  [8566, 8550],
	  [8567, 8551],
	  [8568, 8552],
	  [8569, 8553],
	  [8570, 8554],
	  [8571, 8555],
	  [8572, 8556],
	  [8573, 8557],
	  [8574, 8558],
	  [8575, 8559],
	  [8579, 8580],
	  [8580, 8579],
	  [9398, 9424],
	  [9399, 9425],
	  [9400, 9426],
	  [9401, 9427],
	  [9402, 9428],
	  [9403, 9429],
	  [9404, 9430],
	  [9405, 9431],
	  [9406, 9432],
	  [9407, 9433],
	  [9408, 9434],
	  [9409, 9435],
	  [9410, 9436],
	  [9411, 9437],
	  [9412, 9438],
	  [9413, 9439],
	  [9414, 9440],
	  [9415, 9441],
	  [9416, 9442],
	  [9417, 9443],
	  [9418, 9444],
	  [9419, 9445],
	  [9420, 9446],
	  [9421, 9447],
	  [9422, 9448],
	  [9423, 9449],
	  [9424, 9398],
	  [9425, 9399],
	  [9426, 9400],
	  [9427, 9401],
	  [9428, 9402],
	  [9429, 9403],
	  [9430, 9404],
	  [9431, 9405],
	  [9432, 9406],
	  [9433, 9407],
	  [9434, 9408],
	  [9435, 9409],
	  [9436, 9410],
	  [9437, 9411],
	  [9438, 9412],
	  [9439, 9413],
	  [9440, 9414],
	  [9441, 9415],
	  [9442, 9416],
	  [9443, 9417],
	  [9444, 9418],
	  [9445, 9419],
	  [9446, 9420],
	  [9447, 9421],
	  [9448, 9422],
	  [9449, 9423],
	  [11264, 11312],
	  [11265, 11313],
	  [11266, 11314],
	  [11267, 11315],
	  [11268, 11316],
	  [11269, 11317],
	  [11270, 11318],
	  [11271, 11319],
	  [11272, 11320],
	  [11273, 11321],
	  [11274, 11322],
	  [11275, 11323],
	  [11276, 11324],
	  [11277, 11325],
	  [11278, 11326],
	  [11279, 11327],
	  [11280, 11328],
	  [11281, 11329],
	  [11282, 11330],
	  [11283, 11331],
	  [11284, 11332],
	  [11285, 11333],
	  [11286, 11334],
	  [11287, 11335],
	  [11288, 11336],
	  [11289, 11337],
	  [11290, 11338],
	  [11291, 11339],
	  [11292, 11340],
	  [11293, 11341],
	  [11294, 11342],
	  [11295, 11343],
	  [11296, 11344],
	  [11297, 11345],
	  [11298, 11346],
	  [11299, 11347],
	  [11300, 11348],
	  [11301, 11349],
	  [11302, 11350],
	  [11303, 11351],
	  [11304, 11352],
	  [11305, 11353],
	  [11306, 11354],
	  [11307, 11355],
	  [11308, 11356],
	  [11309, 11357],
	  [11310, 11358],
	  [11311, 11359],
	  [11312, 11264],
	  [11313, 11265],
	  [11314, 11266],
	  [11315, 11267],
	  [11316, 11268],
	  [11317, 11269],
	  [11318, 11270],
	  [11319, 11271],
	  [11320, 11272],
	  [11321, 11273],
	  [11322, 11274],
	  [11323, 11275],
	  [11324, 11276],
	  [11325, 11277],
	  [11326, 11278],
	  [11327, 11279],
	  [11328, 11280],
	  [11329, 11281],
	  [11330, 11282],
	  [11331, 11283],
	  [11332, 11284],
	  [11333, 11285],
	  [11334, 11286],
	  [11335, 11287],
	  [11336, 11288],
	  [11337, 11289],
	  [11338, 11290],
	  [11339, 11291],
	  [11340, 11292],
	  [11341, 11293],
	  [11342, 11294],
	  [11343, 11295],
	  [11344, 11296],
	  [11345, 11297],
	  [11346, 11298],
	  [11347, 11299],
	  [11348, 11300],
	  [11349, 11301],
	  [11350, 11302],
	  [11351, 11303],
	  [11352, 11304],
	  [11353, 11305],
	  [11354, 11306],
	  [11355, 11307],
	  [11356, 11308],
	  [11357, 11309],
	  [11358, 11310],
	  [11359, 11311],
	  [11360, 11361],
	  [11361, 11360],
	  [11362, 619],
	  [11363, 7549],
	  [11364, 637],
	  [11365, 570],
	  [11366, 574],
	  [11367, 11368],
	  [11368, 11367],
	  [11369, 11370],
	  [11370, 11369],
	  [11371, 11372],
	  [11372, 11371],
	  [11373, 593],
	  [11374, 625],
	  [11375, 592],
	  [11376, 594],
	  [11378, 11379],
	  [11379, 11378],
	  [11381, 11382],
	  [11382, 11381],
	  [11390, 575],
	  [11391, 576],
	  [11392, 11393],
	  [11393, 11392],
	  [11394, 11395],
	  [11395, 11394],
	  [11396, 11397],
	  [11397, 11396],
	  [11398, 11399],
	  [11399, 11398],
	  [11400, 11401],
	  [11401, 11400],
	  [11402, 11403],
	  [11403, 11402],
	  [11404, 11405],
	  [11405, 11404],
	  [11406, 11407],
	  [11407, 11406],
	  [11408, 11409],
	  [11409, 11408],
	  [11410, 11411],
	  [11411, 11410],
	  [11412, 11413],
	  [11413, 11412],
	  [11414, 11415],
	  [11415, 11414],
	  [11416, 11417],
	  [11417, 11416],
	  [11418, 11419],
	  [11419, 11418],
	  [11420, 11421],
	  [11421, 11420],
	  [11422, 11423],
	  [11423, 11422],
	  [11424, 11425],
	  [11425, 11424],
	  [11426, 11427],
	  [11427, 11426],
	  [11428, 11429],
	  [11429, 11428],
	  [11430, 11431],
	  [11431, 11430],
	  [11432, 11433],
	  [11433, 11432],
	  [11434, 11435],
	  [11435, 11434],
	  [11436, 11437],
	  [11437, 11436],
	  [11438, 11439],
	  [11439, 11438],
	  [11440, 11441],
	  [11441, 11440],
	  [11442, 11443],
	  [11443, 11442],
	  [11444, 11445],
	  [11445, 11444],
	  [11446, 11447],
	  [11447, 11446],
	  [11448, 11449],
	  [11449, 11448],
	  [11450, 11451],
	  [11451, 11450],
	  [11452, 11453],
	  [11453, 11452],
	  [11454, 11455],
	  [11455, 11454],
	  [11456, 11457],
	  [11457, 11456],
	  [11458, 11459],
	  [11459, 11458],
	  [11460, 11461],
	  [11461, 11460],
	  [11462, 11463],
	  [11463, 11462],
	  [11464, 11465],
	  [11465, 11464],
	  [11466, 11467],
	  [11467, 11466],
	  [11468, 11469],
	  [11469, 11468],
	  [11470, 11471],
	  [11471, 11470],
	  [11472, 11473],
	  [11473, 11472],
	  [11474, 11475],
	  [11475, 11474],
	  [11476, 11477],
	  [11477, 11476],
	  [11478, 11479],
	  [11479, 11478],
	  [11480, 11481],
	  [11481, 11480],
	  [11482, 11483],
	  [11483, 11482],
	  [11484, 11485],
	  [11485, 11484],
	  [11486, 11487],
	  [11487, 11486],
	  [11488, 11489],
	  [11489, 11488],
	  [11490, 11491],
	  [11491, 11490],
	  [11499, 11500],
	  [11500, 11499],
	  [11501, 11502],
	  [11502, 11501],
	  [11506, 11507],
	  [11507, 11506],
	  [11520, 4256],
	  [11521, 4257],
	  [11522, 4258],
	  [11523, 4259],
	  [11524, 4260],
	  [11525, 4261],
	  [11526, 4262],
	  [11527, 4263],
	  [11528, 4264],
	  [11529, 4265],
	  [11530, 4266],
	  [11531, 4267],
	  [11532, 4268],
	  [11533, 4269],
	  [11534, 4270],
	  [11535, 4271],
	  [11536, 4272],
	  [11537, 4273],
	  [11538, 4274],
	  [11539, 4275],
	  [11540, 4276],
	  [11541, 4277],
	  [11542, 4278],
	  [11543, 4279],
	  [11544, 4280],
	  [11545, 4281],
	  [11546, 4282],
	  [11547, 4283],
	  [11548, 4284],
	  [11549, 4285],
	  [11550, 4286],
	  [11551, 4287],
	  [11552, 4288],
	  [11553, 4289],
	  [11554, 4290],
	  [11555, 4291],
	  [11556, 4292],
	  [11557, 4293],
	  [11559, 4295],
	  [11565, 4301],
	  [42560, 42561],
	  [42561, 42560],
	  [42562, 42563],
	  [42563, 42562],
	  [42564, 42565],
	  [42565, 42564],
	  [42566, 42567],
	  [42567, 42566],
	  [42568, 42569],
	  [42569, 42568],
	  [42570, 42571],
	  [42571, [
	    7304,
	    42570
	  ]],
	  [42572, 42573],
	  [42573, 42572],
	  [42574, 42575],
	  [42575, 42574],
	  [42576, 42577],
	  [42577, 42576],
	  [42578, 42579],
	  [42579, 42578],
	  [42580, 42581],
	  [42581, 42580],
	  [42582, 42583],
	  [42583, 42582],
	  [42584, 42585],
	  [42585, 42584],
	  [42586, 42587],
	  [42587, 42586],
	  [42588, 42589],
	  [42589, 42588],
	  [42590, 42591],
	  [42591, 42590],
	  [42592, 42593],
	  [42593, 42592],
	  [42594, 42595],
	  [42595, 42594],
	  [42596, 42597],
	  [42597, 42596],
	  [42598, 42599],
	  [42599, 42598],
	  [42600, 42601],
	  [42601, 42600],
	  [42602, 42603],
	  [42603, 42602],
	  [42604, 42605],
	  [42605, 42604],
	  [42624, 42625],
	  [42625, 42624],
	  [42626, 42627],
	  [42627, 42626],
	  [42628, 42629],
	  [42629, 42628],
	  [42630, 42631],
	  [42631, 42630],
	  [42632, 42633],
	  [42633, 42632],
	  [42634, 42635],
	  [42635, 42634],
	  [42636, 42637],
	  [42637, 42636],
	  [42638, 42639],
	  [42639, 42638],
	  [42640, 42641],
	  [42641, 42640],
	  [42642, 42643],
	  [42643, 42642],
	  [42644, 42645],
	  [42645, 42644],
	  [42646, 42647],
	  [42647, 42646],
	  [42648, 42649],
	  [42649, 42648],
	  [42650, 42651],
	  [42651, 42650],
	  [42786, 42787],
	  [42787, 42786],
	  [42788, 42789],
	  [42789, 42788],
	  [42790, 42791],
	  [42791, 42790],
	  [42792, 42793],
	  [42793, 42792],
	  [42794, 42795],
	  [42795, 42794],
	  [42796, 42797],
	  [42797, 42796],
	  [42798, 42799],
	  [42799, 42798],
	  [42802, 42803],
	  [42803, 42802],
	  [42804, 42805],
	  [42805, 42804],
	  [42806, 42807],
	  [42807, 42806],
	  [42808, 42809],
	  [42809, 42808],
	  [42810, 42811],
	  [42811, 42810],
	  [42812, 42813],
	  [42813, 42812],
	  [42814, 42815],
	  [42815, 42814],
	  [42816, 42817],
	  [42817, 42816],
	  [42818, 42819],
	  [42819, 42818],
	  [42820, 42821],
	  [42821, 42820],
	  [42822, 42823],
	  [42823, 42822],
	  [42824, 42825],
	  [42825, 42824],
	  [42826, 42827],
	  [42827, 42826],
	  [42828, 42829],
	  [42829, 42828],
	  [42830, 42831],
	  [42831, 42830],
	  [42832, 42833],
	  [42833, 42832],
	  [42834, 42835],
	  [42835, 42834],
	  [42836, 42837],
	  [42837, 42836],
	  [42838, 42839],
	  [42839, 42838],
	  [42840, 42841],
	  [42841, 42840],
	  [42842, 42843],
	  [42843, 42842],
	  [42844, 42845],
	  [42845, 42844],
	  [42846, 42847],
	  [42847, 42846],
	  [42848, 42849],
	  [42849, 42848],
	  [42850, 42851],
	  [42851, 42850],
	  [42852, 42853],
	  [42853, 42852],
	  [42854, 42855],
	  [42855, 42854],
	  [42856, 42857],
	  [42857, 42856],
	  [42858, 42859],
	  [42859, 42858],
	  [42860, 42861],
	  [42861, 42860],
	  [42862, 42863],
	  [42863, 42862],
	  [42873, 42874],
	  [42874, 42873],
	  [42875, 42876],
	  [42876, 42875],
	  [42877, 7545],
	  [42878, 42879],
	  [42879, 42878],
	  [42880, 42881],
	  [42881, 42880],
	  [42882, 42883],
	  [42883, 42882],
	  [42884, 42885],
	  [42885, 42884],
	  [42886, 42887],
	  [42887, 42886],
	  [42891, 42892],
	  [42892, 42891],
	  [42893, 613],
	  [42896, 42897],
	  [42897, 42896],
	  [42898, 42899],
	  [42899, 42898],
	  [42900, 42948],
	  [42902, 42903],
	  [42903, 42902],
	  [42904, 42905],
	  [42905, 42904],
	  [42906, 42907],
	  [42907, 42906],
	  [42908, 42909],
	  [42909, 42908],
	  [42910, 42911],
	  [42911, 42910],
	  [42912, 42913],
	  [42913, 42912],
	  [42914, 42915],
	  [42915, 42914],
	  [42916, 42917],
	  [42917, 42916],
	  [42918, 42919],
	  [42919, 42918],
	  [42920, 42921],
	  [42921, 42920],
	  [42922, 614],
	  [42923, 604],
	  [42924, 609],
	  [42925, 620],
	  [42926, 618],
	  [42928, 670],
	  [42929, 647],
	  [42930, 669],
	  [42931, 43859],
	  [42932, 42933],
	  [42933, 42932],
	  [42934, 42935],
	  [42935, 42934],
	  [42936, 42937],
	  [42937, 42936],
	  [42938, 42939],
	  [42939, 42938],
	  [42940, 42941],
	  [42941, 42940],
	  [42942, 42943],
	  [42943, 42942],
	  [42944, 42945],
	  [42945, 42944],
	  [42946, 42947],
	  [42947, 42946],
	  [42948, 42900],
	  [42949, 642],
	  [42950, 7566],
	  [42951, 42952],
	  [42952, 42951],
	  [42953, 42954],
	  [42954, 42953],
	  [42955, 612],
	  [42956, 42957],
	  [42957, 42956],
	  [42960, 42961],
	  [42961, 42960],
	  [42966, 42967],
	  [42967, 42966],
	  [42968, 42969],
	  [42969, 42968],
	  [42970, 42971],
	  [42971, 42970],
	  [42972, 411],
	  [42997, 42998],
	  [42998, 42997],
	  [43859, 42931],
	  [43888, 5024],
	  [43889, 5025],
	  [43890, 5026],
	  [43891, 5027],
	  [43892, 5028],
	  [43893, 5029],
	  [43894, 5030],
	  [43895, 5031],
	  [43896, 5032],
	  [43897, 5033],
	  [43898, 5034],
	  [43899, 5035],
	  [43900, 5036],
	  [43901, 5037],
	  [43902, 5038],
	  [43903, 5039],
	  [43904, 5040],
	  [43905, 5041],
	  [43906, 5042],
	  [43907, 5043],
	  [43908, 5044],
	  [43909, 5045],
	  [43910, 5046],
	  [43911, 5047],
	  [43912, 5048],
	  [43913, 5049],
	  [43914, 5050],
	  [43915, 5051],
	  [43916, 5052],
	  [43917, 5053],
	  [43918, 5054],
	  [43919, 5055],
	  [43920, 5056],
	  [43921, 5057],
	  [43922, 5058],
	  [43923, 5059],
	  [43924, 5060],
	  [43925, 5061],
	  [43926, 5062],
	  [43927, 5063],
	  [43928, 5064],
	  [43929, 5065],
	  [43930, 5066],
	  [43931, 5067],
	  [43932, 5068],
	  [43933, 5069],
	  [43934, 5070],
	  [43935, 5071],
	  [43936, 5072],
	  [43937, 5073],
	  [43938, 5074],
	  [43939, 5075],
	  [43940, 5076],
	  [43941, 5077],
	  [43942, 5078],
	  [43943, 5079],
	  [43944, 5080],
	  [43945, 5081],
	  [43946, 5082],
	  [43947, 5083],
	  [43948, 5084],
	  [43949, 5085],
	  [43950, 5086],
	  [43951, 5087],
	  [43952, 5088],
	  [43953, 5089],
	  [43954, 5090],
	  [43955, 5091],
	  [43956, 5092],
	  [43957, 5093],
	  [43958, 5094],
	  [43959, 5095],
	  [43960, 5096],
	  [43961, 5097],
	  [43962, 5098],
	  [43963, 5099],
	  [43964, 5100],
	  [43965, 5101],
	  [43966, 5102],
	  [43967, 5103],
	  [65313, 65345],
	  [65314, 65346],
	  [65315, 65347],
	  [65316, 65348],
	  [65317, 65349],
	  [65318, 65350],
	  [65319, 65351],
	  [65320, 65352],
	  [65321, 65353],
	  [65322, 65354],
	  [65323, 65355],
	  [65324, 65356],
	  [65325, 65357],
	  [65326, 65358],
	  [65327, 65359],
	  [65328, 65360],
	  [65329, 65361],
	  [65330, 65362],
	  [65331, 65363],
	  [65332, 65364],
	  [65333, 65365],
	  [65334, 65366],
	  [65335, 65367],
	  [65336, 65368],
	  [65337, 65369],
	  [65338, 65370],
	  [65345, 65313],
	  [65346, 65314],
	  [65347, 65315],
	  [65348, 65316],
	  [65349, 65317],
	  [65350, 65318],
	  [65351, 65319],
	  [65352, 65320],
	  [65353, 65321],
	  [65354, 65322],
	  [65355, 65323],
	  [65356, 65324],
	  [65357, 65325],
	  [65358, 65326],
	  [65359, 65327],
	  [65360, 65328],
	  [65361, 65329],
	  [65362, 65330],
	  [65363, 65331],
	  [65364, 65332],
	  [65365, 65333],
	  [65366, 65334],
	  [65367, 65335],
	  [65368, 65336],
	  [65369, 65337],
	  [65370, 65338]
	]);
	return iBmpMappings;
}

var iuFoldings;
var hasRequiredIuFoldings;

function requireIuFoldings () {
	if (hasRequiredIuFoldings) return iuFoldings;
	hasRequiredIuFoldings = 1;
	iuFoldings = /* @__PURE__ */ new Map([
	  [65, 97],
	  [66, 98],
	  [67, 99],
	  [68, 100],
	  [69, 101],
	  [70, 102],
	  [71, 103],
	  [72, 104],
	  [73, 105],
	  [74, 106],
	  [75, 107],
	  [76, 108],
	  [77, 109],
	  [78, 110],
	  [79, 111],
	  [80, 112],
	  [81, 113],
	  [82, 114],
	  [83, 115],
	  [84, 116],
	  [85, 117],
	  [86, 118],
	  [87, 119],
	  [88, 120],
	  [89, 121],
	  [90, 122],
	  [181, 956],
	  [192, 224],
	  [193, 225],
	  [194, 226],
	  [195, 227],
	  [196, 228],
	  [197, 229],
	  [198, 230],
	  [199, 231],
	  [200, 232],
	  [201, 233],
	  [202, 234],
	  [203, 235],
	  [204, 236],
	  [205, 237],
	  [206, 238],
	  [207, 239],
	  [208, 240],
	  [209, 241],
	  [210, 242],
	  [211, 243],
	  [212, 244],
	  [213, 245],
	  [214, 246],
	  [216, 248],
	  [217, 249],
	  [218, 250],
	  [219, 251],
	  [220, 252],
	  [221, 253],
	  [222, 254],
	  [256, 257],
	  [258, 259],
	  [260, 261],
	  [262, 263],
	  [264, 265],
	  [266, 267],
	  [268, 269],
	  [270, 271],
	  [272, 273],
	  [274, 275],
	  [276, 277],
	  [278, 279],
	  [280, 281],
	  [282, 283],
	  [284, 285],
	  [286, 287],
	  [288, 289],
	  [290, 291],
	  [292, 293],
	  [294, 295],
	  [296, 297],
	  [298, 299],
	  [300, 301],
	  [302, 303],
	  [306, 307],
	  [308, 309],
	  [310, 311],
	  [313, 314],
	  [315, 316],
	  [317, 318],
	  [319, 320],
	  [321, 322],
	  [323, 324],
	  [325, 326],
	  [327, 328],
	  [330, 331],
	  [332, 333],
	  [334, 335],
	  [336, 337],
	  [338, 339],
	  [340, 341],
	  [342, 343],
	  [344, 345],
	  [346, 347],
	  [348, 349],
	  [350, 351],
	  [352, 353],
	  [354, 355],
	  [356, 357],
	  [358, 359],
	  [360, 361],
	  [362, 363],
	  [364, 365],
	  [366, 367],
	  [368, 369],
	  [370, 371],
	  [372, 373],
	  [374, 375],
	  [376, 255],
	  [377, 378],
	  [379, 380],
	  [381, 382],
	  [383, 115],
	  [385, 595],
	  [386, 387],
	  [388, 389],
	  [390, 596],
	  [391, 392],
	  [393, 598],
	  [394, 599],
	  [395, 396],
	  [398, 477],
	  [399, 601],
	  [400, 603],
	  [401, 402],
	  [403, 608],
	  [404, 611],
	  [406, 617],
	  [407, 616],
	  [408, 409],
	  [412, 623],
	  [413, 626],
	  [415, 629],
	  [416, 417],
	  [418, 419],
	  [420, 421],
	  [422, 640],
	  [423, 424],
	  [425, 643],
	  [428, 429],
	  [430, 648],
	  [431, 432],
	  [433, 650],
	  [434, 651],
	  [435, 436],
	  [437, 438],
	  [439, 658],
	  [440, 441],
	  [444, 445],
	  [452, 454],
	  [453, 454],
	  [455, 457],
	  [456, 457],
	  [458, 460],
	  [459, 460],
	  [461, 462],
	  [463, 464],
	  [465, 466],
	  [467, 468],
	  [469, 470],
	  [471, 472],
	  [473, 474],
	  [475, 476],
	  [478, 479],
	  [480, 481],
	  [482, 483],
	  [484, 485],
	  [486, 487],
	  [488, 489],
	  [490, 491],
	  [492, 493],
	  [494, 495],
	  [497, 499],
	  [498, 499],
	  [500, 501],
	  [502, 405],
	  [503, 447],
	  [504, 505],
	  [506, 507],
	  [508, 509],
	  [510, 511],
	  [512, 513],
	  [514, 515],
	  [516, 517],
	  [518, 519],
	  [520, 521],
	  [522, 523],
	  [524, 525],
	  [526, 527],
	  [528, 529],
	  [530, 531],
	  [532, 533],
	  [534, 535],
	  [536, 537],
	  [538, 539],
	  [540, 541],
	  [542, 543],
	  [544, 414],
	  [546, 547],
	  [548, 549],
	  [550, 551],
	  [552, 553],
	  [554, 555],
	  [556, 557],
	  [558, 559],
	  [560, 561],
	  [562, 563],
	  [570, 11365],
	  [571, 572],
	  [573, 410],
	  [574, 11366],
	  [577, 578],
	  [579, 384],
	  [580, 649],
	  [581, 652],
	  [582, 583],
	  [584, 585],
	  [586, 587],
	  [588, 589],
	  [590, 591],
	  [837, 953],
	  [880, 881],
	  [882, 883],
	  [886, 887],
	  [895, 1011],
	  [902, 940],
	  [904, 941],
	  [905, 942],
	  [906, 943],
	  [908, 972],
	  [910, 973],
	  [911, 974],
	  [913, 945],
	  [914, 946],
	  [915, 947],
	  [916, 948],
	  [917, 949],
	  [918, 950],
	  [919, 951],
	  [920, 952],
	  [921, 953],
	  [922, 954],
	  [923, 955],
	  [924, 956],
	  [925, 957],
	  [926, 958],
	  [927, 959],
	  [928, 960],
	  [929, 961],
	  [931, 963],
	  [932, 964],
	  [933, 965],
	  [934, 966],
	  [935, 967],
	  [936, 968],
	  [937, 969],
	  [938, 970],
	  [939, 971],
	  [962, 963],
	  [975, 983],
	  [976, 946],
	  [977, 952],
	  [981, 966],
	  [982, 960],
	  [984, 985],
	  [986, 987],
	  [988, 989],
	  [990, 991],
	  [992, 993],
	  [994, 995],
	  [996, 997],
	  [998, 999],
	  [1e3, 1001],
	  [1002, 1003],
	  [1004, 1005],
	  [1006, 1007],
	  [1008, 954],
	  [1009, 961],
	  [1012, 952],
	  [1013, 949],
	  [1015, 1016],
	  [1017, 1010],
	  [1018, 1019],
	  [1021, 891],
	  [1022, 892],
	  [1023, 893],
	  [1024, 1104],
	  [1025, 1105],
	  [1026, 1106],
	  [1027, 1107],
	  [1028, 1108],
	  [1029, 1109],
	  [1030, 1110],
	  [1031, 1111],
	  [1032, 1112],
	  [1033, 1113],
	  [1034, 1114],
	  [1035, 1115],
	  [1036, 1116],
	  [1037, 1117],
	  [1038, 1118],
	  [1039, 1119],
	  [1040, 1072],
	  [1041, 1073],
	  [1042, 1074],
	  [1043, 1075],
	  [1044, 1076],
	  [1045, 1077],
	  [1046, 1078],
	  [1047, 1079],
	  [1048, 1080],
	  [1049, 1081],
	  [1050, 1082],
	  [1051, 1083],
	  [1052, 1084],
	  [1053, 1085],
	  [1054, 1086],
	  [1055, 1087],
	  [1056, 1088],
	  [1057, 1089],
	  [1058, 1090],
	  [1059, 1091],
	  [1060, 1092],
	  [1061, 1093],
	  [1062, 1094],
	  [1063, 1095],
	  [1064, 1096],
	  [1065, 1097],
	  [1066, 1098],
	  [1067, 1099],
	  [1068, 1100],
	  [1069, 1101],
	  [1070, 1102],
	  [1071, 1103],
	  [1120, 1121],
	  [1122, 1123],
	  [1124, 1125],
	  [1126, 1127],
	  [1128, 1129],
	  [1130, 1131],
	  [1132, 1133],
	  [1134, 1135],
	  [1136, 1137],
	  [1138, 1139],
	  [1140, 1141],
	  [1142, 1143],
	  [1144, 1145],
	  [1146, 1147],
	  [1148, 1149],
	  [1150, 1151],
	  [1152, 1153],
	  [1162, 1163],
	  [1164, 1165],
	  [1166, 1167],
	  [1168, 1169],
	  [1170, 1171],
	  [1172, 1173],
	  [1174, 1175],
	  [1176, 1177],
	  [1178, 1179],
	  [1180, 1181],
	  [1182, 1183],
	  [1184, 1185],
	  [1186, 1187],
	  [1188, 1189],
	  [1190, 1191],
	  [1192, 1193],
	  [1194, 1195],
	  [1196, 1197],
	  [1198, 1199],
	  [1200, 1201],
	  [1202, 1203],
	  [1204, 1205],
	  [1206, 1207],
	  [1208, 1209],
	  [1210, 1211],
	  [1212, 1213],
	  [1214, 1215],
	  [1216, 1231],
	  [1217, 1218],
	  [1219, 1220],
	  [1221, 1222],
	  [1223, 1224],
	  [1225, 1226],
	  [1227, 1228],
	  [1229, 1230],
	  [1232, 1233],
	  [1234, 1235],
	  [1236, 1237],
	  [1238, 1239],
	  [1240, 1241],
	  [1242, 1243],
	  [1244, 1245],
	  [1246, 1247],
	  [1248, 1249],
	  [1250, 1251],
	  [1252, 1253],
	  [1254, 1255],
	  [1256, 1257],
	  [1258, 1259],
	  [1260, 1261],
	  [1262, 1263],
	  [1264, 1265],
	  [1266, 1267],
	  [1268, 1269],
	  [1270, 1271],
	  [1272, 1273],
	  [1274, 1275],
	  [1276, 1277],
	  [1278, 1279],
	  [1280, 1281],
	  [1282, 1283],
	  [1284, 1285],
	  [1286, 1287],
	  [1288, 1289],
	  [1290, 1291],
	  [1292, 1293],
	  [1294, 1295],
	  [1296, 1297],
	  [1298, 1299],
	  [1300, 1301],
	  [1302, 1303],
	  [1304, 1305],
	  [1306, 1307],
	  [1308, 1309],
	  [1310, 1311],
	  [1312, 1313],
	  [1314, 1315],
	  [1316, 1317],
	  [1318, 1319],
	  [1320, 1321],
	  [1322, 1323],
	  [1324, 1325],
	  [1326, 1327],
	  [1329, 1377],
	  [1330, 1378],
	  [1331, 1379],
	  [1332, 1380],
	  [1333, 1381],
	  [1334, 1382],
	  [1335, 1383],
	  [1336, 1384],
	  [1337, 1385],
	  [1338, 1386],
	  [1339, 1387],
	  [1340, 1388],
	  [1341, 1389],
	  [1342, 1390],
	  [1343, 1391],
	  [1344, 1392],
	  [1345, 1393],
	  [1346, 1394],
	  [1347, 1395],
	  [1348, 1396],
	  [1349, 1397],
	  [1350, 1398],
	  [1351, 1399],
	  [1352, 1400],
	  [1353, 1401],
	  [1354, 1402],
	  [1355, 1403],
	  [1356, 1404],
	  [1357, 1405],
	  [1358, 1406],
	  [1359, 1407],
	  [1360, 1408],
	  [1361, 1409],
	  [1362, 1410],
	  [1363, 1411],
	  [1364, 1412],
	  [1365, 1413],
	  [1366, 1414],
	  [4256, 11520],
	  [4257, 11521],
	  [4258, 11522],
	  [4259, 11523],
	  [4260, 11524],
	  [4261, 11525],
	  [4262, 11526],
	  [4263, 11527],
	  [4264, 11528],
	  [4265, 11529],
	  [4266, 11530],
	  [4267, 11531],
	  [4268, 11532],
	  [4269, 11533],
	  [4270, 11534],
	  [4271, 11535],
	  [4272, 11536],
	  [4273, 11537],
	  [4274, 11538],
	  [4275, 11539],
	  [4276, 11540],
	  [4277, 11541],
	  [4278, 11542],
	  [4279, 11543],
	  [4280, 11544],
	  [4281, 11545],
	  [4282, 11546],
	  [4283, 11547],
	  [4284, 11548],
	  [4285, 11549],
	  [4286, 11550],
	  [4287, 11551],
	  [4288, 11552],
	  [4289, 11553],
	  [4290, 11554],
	  [4291, 11555],
	  [4292, 11556],
	  [4293, 11557],
	  [4295, 11559],
	  [4301, 11565],
	  [5112, 5104],
	  [5113, 5105],
	  [5114, 5106],
	  [5115, 5107],
	  [5116, 5108],
	  [5117, 5109],
	  [7296, 1074],
	  [7297, 1076],
	  [7298, 1086],
	  [7299, 1089],
	  [7300, 1090],
	  [7301, 1090],
	  [7302, 1098],
	  [7303, 1123],
	  [7304, 42571],
	  [7305, 7306],
	  [7312, 4304],
	  [7313, 4305],
	  [7314, 4306],
	  [7315, 4307],
	  [7316, 4308],
	  [7317, 4309],
	  [7318, 4310],
	  [7319, 4311],
	  [7320, 4312],
	  [7321, 4313],
	  [7322, 4314],
	  [7323, 4315],
	  [7324, 4316],
	  [7325, 4317],
	  [7326, 4318],
	  [7327, 4319],
	  [7328, 4320],
	  [7329, 4321],
	  [7330, 4322],
	  [7331, 4323],
	  [7332, 4324],
	  [7333, 4325],
	  [7334, 4326],
	  [7335, 4327],
	  [7336, 4328],
	  [7337, 4329],
	  [7338, 4330],
	  [7339, 4331],
	  [7340, 4332],
	  [7341, 4333],
	  [7342, 4334],
	  [7343, 4335],
	  [7344, 4336],
	  [7345, 4337],
	  [7346, 4338],
	  [7347, 4339],
	  [7348, 4340],
	  [7349, 4341],
	  [7350, 4342],
	  [7351, 4343],
	  [7352, 4344],
	  [7353, 4345],
	  [7354, 4346],
	  [7357, 4349],
	  [7358, 4350],
	  [7359, 4351],
	  [7680, 7681],
	  [7682, 7683],
	  [7684, 7685],
	  [7686, 7687],
	  [7688, 7689],
	  [7690, 7691],
	  [7692, 7693],
	  [7694, 7695],
	  [7696, 7697],
	  [7698, 7699],
	  [7700, 7701],
	  [7702, 7703],
	  [7704, 7705],
	  [7706, 7707],
	  [7708, 7709],
	  [7710, 7711],
	  [7712, 7713],
	  [7714, 7715],
	  [7716, 7717],
	  [7718, 7719],
	  [7720, 7721],
	  [7722, 7723],
	  [7724, 7725],
	  [7726, 7727],
	  [7728, 7729],
	  [7730, 7731],
	  [7732, 7733],
	  [7734, 7735],
	  [7736, 7737],
	  [7738, 7739],
	  [7740, 7741],
	  [7742, 7743],
	  [7744, 7745],
	  [7746, 7747],
	  [7748, 7749],
	  [7750, 7751],
	  [7752, 7753],
	  [7754, 7755],
	  [7756, 7757],
	  [7758, 7759],
	  [7760, 7761],
	  [7762, 7763],
	  [7764, 7765],
	  [7766, 7767],
	  [7768, 7769],
	  [7770, 7771],
	  [7772, 7773],
	  [7774, 7775],
	  [7776, 7777],
	  [7778, 7779],
	  [7780, 7781],
	  [7782, 7783],
	  [7784, 7785],
	  [7786, 7787],
	  [7788, 7789],
	  [7790, 7791],
	  [7792, 7793],
	  [7794, 7795],
	  [7796, 7797],
	  [7798, 7799],
	  [7800, 7801],
	  [7802, 7803],
	  [7804, 7805],
	  [7806, 7807],
	  [7808, 7809],
	  [7810, 7811],
	  [7812, 7813],
	  [7814, 7815],
	  [7816, 7817],
	  [7818, 7819],
	  [7820, 7821],
	  [7822, 7823],
	  [7824, 7825],
	  [7826, 7827],
	  [7828, 7829],
	  [7835, 7777],
	  [7838, 223],
	  [7840, 7841],
	  [7842, 7843],
	  [7844, 7845],
	  [7846, 7847],
	  [7848, 7849],
	  [7850, 7851],
	  [7852, 7853],
	  [7854, 7855],
	  [7856, 7857],
	  [7858, 7859],
	  [7860, 7861],
	  [7862, 7863],
	  [7864, 7865],
	  [7866, 7867],
	  [7868, 7869],
	  [7870, 7871],
	  [7872, 7873],
	  [7874, 7875],
	  [7876, 7877],
	  [7878, 7879],
	  [7880, 7881],
	  [7882, 7883],
	  [7884, 7885],
	  [7886, 7887],
	  [7888, 7889],
	  [7890, 7891],
	  [7892, 7893],
	  [7894, 7895],
	  [7896, 7897],
	  [7898, 7899],
	  [7900, 7901],
	  [7902, 7903],
	  [7904, 7905],
	  [7906, 7907],
	  [7908, 7909],
	  [7910, 7911],
	  [7912, 7913],
	  [7914, 7915],
	  [7916, 7917],
	  [7918, 7919],
	  [7920, 7921],
	  [7922, 7923],
	  [7924, 7925],
	  [7926, 7927],
	  [7928, 7929],
	  [7930, 7931],
	  [7932, 7933],
	  [7934, 7935],
	  [7944, 7936],
	  [7945, 7937],
	  [7946, 7938],
	  [7947, 7939],
	  [7948, 7940],
	  [7949, 7941],
	  [7950, 7942],
	  [7951, 7943],
	  [7960, 7952],
	  [7961, 7953],
	  [7962, 7954],
	  [7963, 7955],
	  [7964, 7956],
	  [7965, 7957],
	  [7976, 7968],
	  [7977, 7969],
	  [7978, 7970],
	  [7979, 7971],
	  [7980, 7972],
	  [7981, 7973],
	  [7982, 7974],
	  [7983, 7975],
	  [7992, 7984],
	  [7993, 7985],
	  [7994, 7986],
	  [7995, 7987],
	  [7996, 7988],
	  [7997, 7989],
	  [7998, 7990],
	  [7999, 7991],
	  [8008, 8e3],
	  [8009, 8001],
	  [8010, 8002],
	  [8011, 8003],
	  [8012, 8004],
	  [8013, 8005],
	  [8025, 8017],
	  [8027, 8019],
	  [8029, 8021],
	  [8031, 8023],
	  [8040, 8032],
	  [8041, 8033],
	  [8042, 8034],
	  [8043, 8035],
	  [8044, 8036],
	  [8045, 8037],
	  [8046, 8038],
	  [8047, 8039],
	  [8072, 8064],
	  [8073, 8065],
	  [8074, 8066],
	  [8075, 8067],
	  [8076, 8068],
	  [8077, 8069],
	  [8078, 8070],
	  [8079, 8071],
	  [8088, 8080],
	  [8089, 8081],
	  [8090, 8082],
	  [8091, 8083],
	  [8092, 8084],
	  [8093, 8085],
	  [8094, 8086],
	  [8095, 8087],
	  [8104, 8096],
	  [8105, 8097],
	  [8106, 8098],
	  [8107, 8099],
	  [8108, 8100],
	  [8109, 8101],
	  [8110, 8102],
	  [8111, 8103],
	  [8120, 8112],
	  [8121, 8113],
	  [8122, 8048],
	  [8123, 8049],
	  [8124, 8115],
	  [8126, 953],
	  [8136, 8050],
	  [8137, 8051],
	  [8138, 8052],
	  [8139, 8053],
	  [8140, 8131],
	  [8147, 912],
	  [8152, 8144],
	  [8153, 8145],
	  [8154, 8054],
	  [8155, 8055],
	  [8163, 944],
	  [8168, 8160],
	  [8169, 8161],
	  [8170, 8058],
	  [8171, 8059],
	  [8172, 8165],
	  [8184, 8056],
	  [8185, 8057],
	  [8186, 8060],
	  [8187, 8061],
	  [8188, 8179],
	  [8486, 969],
	  [8490, 107],
	  [8491, 229],
	  [8498, 8526],
	  [8544, 8560],
	  [8545, 8561],
	  [8546, 8562],
	  [8547, 8563],
	  [8548, 8564],
	  [8549, 8565],
	  [8550, 8566],
	  [8551, 8567],
	  [8552, 8568],
	  [8553, 8569],
	  [8554, 8570],
	  [8555, 8571],
	  [8556, 8572],
	  [8557, 8573],
	  [8558, 8574],
	  [8559, 8575],
	  [8579, 8580],
	  [9398, 9424],
	  [9399, 9425],
	  [9400, 9426],
	  [9401, 9427],
	  [9402, 9428],
	  [9403, 9429],
	  [9404, 9430],
	  [9405, 9431],
	  [9406, 9432],
	  [9407, 9433],
	  [9408, 9434],
	  [9409, 9435],
	  [9410, 9436],
	  [9411, 9437],
	  [9412, 9438],
	  [9413, 9439],
	  [9414, 9440],
	  [9415, 9441],
	  [9416, 9442],
	  [9417, 9443],
	  [9418, 9444],
	  [9419, 9445],
	  [9420, 9446],
	  [9421, 9447],
	  [9422, 9448],
	  [9423, 9449],
	  [11264, 11312],
	  [11265, 11313],
	  [11266, 11314],
	  [11267, 11315],
	  [11268, 11316],
	  [11269, 11317],
	  [11270, 11318],
	  [11271, 11319],
	  [11272, 11320],
	  [11273, 11321],
	  [11274, 11322],
	  [11275, 11323],
	  [11276, 11324],
	  [11277, 11325],
	  [11278, 11326],
	  [11279, 11327],
	  [11280, 11328],
	  [11281, 11329],
	  [11282, 11330],
	  [11283, 11331],
	  [11284, 11332],
	  [11285, 11333],
	  [11286, 11334],
	  [11287, 11335],
	  [11288, 11336],
	  [11289, 11337],
	  [11290, 11338],
	  [11291, 11339],
	  [11292, 11340],
	  [11293, 11341],
	  [11294, 11342],
	  [11295, 11343],
	  [11296, 11344],
	  [11297, 11345],
	  [11298, 11346],
	  [11299, 11347],
	  [11300, 11348],
	  [11301, 11349],
	  [11302, 11350],
	  [11303, 11351],
	  [11304, 11352],
	  [11305, 11353],
	  [11306, 11354],
	  [11307, 11355],
	  [11308, 11356],
	  [11309, 11357],
	  [11310, 11358],
	  [11311, 11359],
	  [11360, 11361],
	  [11362, 619],
	  [11363, 7549],
	  [11364, 637],
	  [11367, 11368],
	  [11369, 11370],
	  [11371, 11372],
	  [11373, 593],
	  [11374, 625],
	  [11375, 592],
	  [11376, 594],
	  [11378, 11379],
	  [11381, 11382],
	  [11390, 575],
	  [11391, 576],
	  [11392, 11393],
	  [11394, 11395],
	  [11396, 11397],
	  [11398, 11399],
	  [11400, 11401],
	  [11402, 11403],
	  [11404, 11405],
	  [11406, 11407],
	  [11408, 11409],
	  [11410, 11411],
	  [11412, 11413],
	  [11414, 11415],
	  [11416, 11417],
	  [11418, 11419],
	  [11420, 11421],
	  [11422, 11423],
	  [11424, 11425],
	  [11426, 11427],
	  [11428, 11429],
	  [11430, 11431],
	  [11432, 11433],
	  [11434, 11435],
	  [11436, 11437],
	  [11438, 11439],
	  [11440, 11441],
	  [11442, 11443],
	  [11444, 11445],
	  [11446, 11447],
	  [11448, 11449],
	  [11450, 11451],
	  [11452, 11453],
	  [11454, 11455],
	  [11456, 11457],
	  [11458, 11459],
	  [11460, 11461],
	  [11462, 11463],
	  [11464, 11465],
	  [11466, 11467],
	  [11468, 11469],
	  [11470, 11471],
	  [11472, 11473],
	  [11474, 11475],
	  [11476, 11477],
	  [11478, 11479],
	  [11480, 11481],
	  [11482, 11483],
	  [11484, 11485],
	  [11486, 11487],
	  [11488, 11489],
	  [11490, 11491],
	  [11499, 11500],
	  [11501, 11502],
	  [11506, 11507],
	  [42560, 42561],
	  [42562, 42563],
	  [42564, 42565],
	  [42566, 42567],
	  [42568, 42569],
	  [42570, 42571],
	  [42572, 42573],
	  [42574, 42575],
	  [42576, 42577],
	  [42578, 42579],
	  [42580, 42581],
	  [42582, 42583],
	  [42584, 42585],
	  [42586, 42587],
	  [42588, 42589],
	  [42590, 42591],
	  [42592, 42593],
	  [42594, 42595],
	  [42596, 42597],
	  [42598, 42599],
	  [42600, 42601],
	  [42602, 42603],
	  [42604, 42605],
	  [42624, 42625],
	  [42626, 42627],
	  [42628, 42629],
	  [42630, 42631],
	  [42632, 42633],
	  [42634, 42635],
	  [42636, 42637],
	  [42638, 42639],
	  [42640, 42641],
	  [42642, 42643],
	  [42644, 42645],
	  [42646, 42647],
	  [42648, 42649],
	  [42650, 42651],
	  [42786, 42787],
	  [42788, 42789],
	  [42790, 42791],
	  [42792, 42793],
	  [42794, 42795],
	  [42796, 42797],
	  [42798, 42799],
	  [42802, 42803],
	  [42804, 42805],
	  [42806, 42807],
	  [42808, 42809],
	  [42810, 42811],
	  [42812, 42813],
	  [42814, 42815],
	  [42816, 42817],
	  [42818, 42819],
	  [42820, 42821],
	  [42822, 42823],
	  [42824, 42825],
	  [42826, 42827],
	  [42828, 42829],
	  [42830, 42831],
	  [42832, 42833],
	  [42834, 42835],
	  [42836, 42837],
	  [42838, 42839],
	  [42840, 42841],
	  [42842, 42843],
	  [42844, 42845],
	  [42846, 42847],
	  [42848, 42849],
	  [42850, 42851],
	  [42852, 42853],
	  [42854, 42855],
	  [42856, 42857],
	  [42858, 42859],
	  [42860, 42861],
	  [42862, 42863],
	  [42873, 42874],
	  [42875, 42876],
	  [42877, 7545],
	  [42878, 42879],
	  [42880, 42881],
	  [42882, 42883],
	  [42884, 42885],
	  [42886, 42887],
	  [42891, 42892],
	  [42893, 613],
	  [42896, 42897],
	  [42898, 42899],
	  [42902, 42903],
	  [42904, 42905],
	  [42906, 42907],
	  [42908, 42909],
	  [42910, 42911],
	  [42912, 42913],
	  [42914, 42915],
	  [42916, 42917],
	  [42918, 42919],
	  [42920, 42921],
	  [42922, 614],
	  [42923, 604],
	  [42924, 609],
	  [42925, 620],
	  [42926, 618],
	  [42928, 670],
	  [42929, 647],
	  [42930, 669],
	  [42931, 43859],
	  [42932, 42933],
	  [42934, 42935],
	  [42936, 42937],
	  [42938, 42939],
	  [42940, 42941],
	  [42942, 42943],
	  [42944, 42945],
	  [42946, 42947],
	  [42948, 42900],
	  [42949, 642],
	  [42950, 7566],
	  [42951, 42952],
	  [42953, 42954],
	  [42955, 612],
	  [42956, 42957],
	  [42960, 42961],
	  [42966, 42967],
	  [42968, 42969],
	  [42970, 42971],
	  [42972, 411],
	  [42997, 42998],
	  [43888, 5024],
	  [43889, 5025],
	  [43890, 5026],
	  [43891, 5027],
	  [43892, 5028],
	  [43893, 5029],
	  [43894, 5030],
	  [43895, 5031],
	  [43896, 5032],
	  [43897, 5033],
	  [43898, 5034],
	  [43899, 5035],
	  [43900, 5036],
	  [43901, 5037],
	  [43902, 5038],
	  [43903, 5039],
	  [43904, 5040],
	  [43905, 5041],
	  [43906, 5042],
	  [43907, 5043],
	  [43908, 5044],
	  [43909, 5045],
	  [43910, 5046],
	  [43911, 5047],
	  [43912, 5048],
	  [43913, 5049],
	  [43914, 5050],
	  [43915, 5051],
	  [43916, 5052],
	  [43917, 5053],
	  [43918, 5054],
	  [43919, 5055],
	  [43920, 5056],
	  [43921, 5057],
	  [43922, 5058],
	  [43923, 5059],
	  [43924, 5060],
	  [43925, 5061],
	  [43926, 5062],
	  [43927, 5063],
	  [43928, 5064],
	  [43929, 5065],
	  [43930, 5066],
	  [43931, 5067],
	  [43932, 5068],
	  [43933, 5069],
	  [43934, 5070],
	  [43935, 5071],
	  [43936, 5072],
	  [43937, 5073],
	  [43938, 5074],
	  [43939, 5075],
	  [43940, 5076],
	  [43941, 5077],
	  [43942, 5078],
	  [43943, 5079],
	  [43944, 5080],
	  [43945, 5081],
	  [43946, 5082],
	  [43947, 5083],
	  [43948, 5084],
	  [43949, 5085],
	  [43950, 5086],
	  [43951, 5087],
	  [43952, 5088],
	  [43953, 5089],
	  [43954, 5090],
	  [43955, 5091],
	  [43956, 5092],
	  [43957, 5093],
	  [43958, 5094],
	  [43959, 5095],
	  [43960, 5096],
	  [43961, 5097],
	  [43962, 5098],
	  [43963, 5099],
	  [43964, 5100],
	  [43965, 5101],
	  [43966, 5102],
	  [43967, 5103],
	  [64261, 64262],
	  [65313, 65345],
	  [65314, 65346],
	  [65315, 65347],
	  [65316, 65348],
	  [65317, 65349],
	  [65318, 65350],
	  [65319, 65351],
	  [65320, 65352],
	  [65321, 65353],
	  [65322, 65354],
	  [65323, 65355],
	  [65324, 65356],
	  [65325, 65357],
	  [65326, 65358],
	  [65327, 65359],
	  [65328, 65360],
	  [65329, 65361],
	  [65330, 65362],
	  [65331, 65363],
	  [65332, 65364],
	  [65333, 65365],
	  [65334, 65366],
	  [65335, 65367],
	  [65336, 65368],
	  [65337, 65369],
	  [65338, 65370],
	  [66560, 66600],
	  [66561, 66601],
	  [66562, 66602],
	  [66563, 66603],
	  [66564, 66604],
	  [66565, 66605],
	  [66566, 66606],
	  [66567, 66607],
	  [66568, 66608],
	  [66569, 66609],
	  [66570, 66610],
	  [66571, 66611],
	  [66572, 66612],
	  [66573, 66613],
	  [66574, 66614],
	  [66575, 66615],
	  [66576, 66616],
	  [66577, 66617],
	  [66578, 66618],
	  [66579, 66619],
	  [66580, 66620],
	  [66581, 66621],
	  [66582, 66622],
	  [66583, 66623],
	  [66584, 66624],
	  [66585, 66625],
	  [66586, 66626],
	  [66587, 66627],
	  [66588, 66628],
	  [66589, 66629],
	  [66590, 66630],
	  [66591, 66631],
	  [66592, 66632],
	  [66593, 66633],
	  [66594, 66634],
	  [66595, 66635],
	  [66596, 66636],
	  [66597, 66637],
	  [66598, 66638],
	  [66599, 66639],
	  [66736, 66776],
	  [66737, 66777],
	  [66738, 66778],
	  [66739, 66779],
	  [66740, 66780],
	  [66741, 66781],
	  [66742, 66782],
	  [66743, 66783],
	  [66744, 66784],
	  [66745, 66785],
	  [66746, 66786],
	  [66747, 66787],
	  [66748, 66788],
	  [66749, 66789],
	  [66750, 66790],
	  [66751, 66791],
	  [66752, 66792],
	  [66753, 66793],
	  [66754, 66794],
	  [66755, 66795],
	  [66756, 66796],
	  [66757, 66797],
	  [66758, 66798],
	  [66759, 66799],
	  [66760, 66800],
	  [66761, 66801],
	  [66762, 66802],
	  [66763, 66803],
	  [66764, 66804],
	  [66765, 66805],
	  [66766, 66806],
	  [66767, 66807],
	  [66768, 66808],
	  [66769, 66809],
	  [66770, 66810],
	  [66771, 66811],
	  [66928, 66967],
	  [66929, 66968],
	  [66930, 66969],
	  [66931, 66970],
	  [66932, 66971],
	  [66933, 66972],
	  [66934, 66973],
	  [66935, 66974],
	  [66936, 66975],
	  [66937, 66976],
	  [66938, 66977],
	  [66940, 66979],
	  [66941, 66980],
	  [66942, 66981],
	  [66943, 66982],
	  [66944, 66983],
	  [66945, 66984],
	  [66946, 66985],
	  [66947, 66986],
	  [66948, 66987],
	  [66949, 66988],
	  [66950, 66989],
	  [66951, 66990],
	  [66952, 66991],
	  [66953, 66992],
	  [66954, 66993],
	  [66956, 66995],
	  [66957, 66996],
	  [66958, 66997],
	  [66959, 66998],
	  [66960, 66999],
	  [66961, 67e3],
	  [66962, 67001],
	  [66964, 67003],
	  [66965, 67004],
	  [68736, 68800],
	  [68737, 68801],
	  [68738, 68802],
	  [68739, 68803],
	  [68740, 68804],
	  [68741, 68805],
	  [68742, 68806],
	  [68743, 68807],
	  [68744, 68808],
	  [68745, 68809],
	  [68746, 68810],
	  [68747, 68811],
	  [68748, 68812],
	  [68749, 68813],
	  [68750, 68814],
	  [68751, 68815],
	  [68752, 68816],
	  [68753, 68817],
	  [68754, 68818],
	  [68755, 68819],
	  [68756, 68820],
	  [68757, 68821],
	  [68758, 68822],
	  [68759, 68823],
	  [68760, 68824],
	  [68761, 68825],
	  [68762, 68826],
	  [68763, 68827],
	  [68764, 68828],
	  [68765, 68829],
	  [68766, 68830],
	  [68767, 68831],
	  [68768, 68832],
	  [68769, 68833],
	  [68770, 68834],
	  [68771, 68835],
	  [68772, 68836],
	  [68773, 68837],
	  [68774, 68838],
	  [68775, 68839],
	  [68776, 68840],
	  [68777, 68841],
	  [68778, 68842],
	  [68779, 68843],
	  [68780, 68844],
	  [68781, 68845],
	  [68782, 68846],
	  [68783, 68847],
	  [68784, 68848],
	  [68785, 68849],
	  [68786, 68850],
	  [68944, 68976],
	  [68945, 68977],
	  [68946, 68978],
	  [68947, 68979],
	  [68948, 68980],
	  [68949, 68981],
	  [68950, 68982],
	  [68951, 68983],
	  [68952, 68984],
	  [68953, 68985],
	  [68954, 68986],
	  [68955, 68987],
	  [68956, 68988],
	  [68957, 68989],
	  [68958, 68990],
	  [68959, 68991],
	  [68960, 68992],
	  [68961, 68993],
	  [68962, 68994],
	  [68963, 68995],
	  [68964, 68996],
	  [68965, 68997],
	  [71840, 71872],
	  [71841, 71873],
	  [71842, 71874],
	  [71843, 71875],
	  [71844, 71876],
	  [71845, 71877],
	  [71846, 71878],
	  [71847, 71879],
	  [71848, 71880],
	  [71849, 71881],
	  [71850, 71882],
	  [71851, 71883],
	  [71852, 71884],
	  [71853, 71885],
	  [71854, 71886],
	  [71855, 71887],
	  [71856, 71888],
	  [71857, 71889],
	  [71858, 71890],
	  [71859, 71891],
	  [71860, 71892],
	  [71861, 71893],
	  [71862, 71894],
	  [71863, 71895],
	  [71864, 71896],
	  [71865, 71897],
	  [71866, 71898],
	  [71867, 71899],
	  [71868, 71900],
	  [71869, 71901],
	  [71870, 71902],
	  [71871, 71903],
	  [93760, 93792],
	  [93761, 93793],
	  [93762, 93794],
	  [93763, 93795],
	  [93764, 93796],
	  [93765, 93797],
	  [93766, 93798],
	  [93767, 93799],
	  [93768, 93800],
	  [93769, 93801],
	  [93770, 93802],
	  [93771, 93803],
	  [93772, 93804],
	  [93773, 93805],
	  [93774, 93806],
	  [93775, 93807],
	  [93776, 93808],
	  [93777, 93809],
	  [93778, 93810],
	  [93779, 93811],
	  [93780, 93812],
	  [93781, 93813],
	  [93782, 93814],
	  [93783, 93815],
	  [93784, 93816],
	  [93785, 93817],
	  [93786, 93818],
	  [93787, 93819],
	  [93788, 93820],
	  [93789, 93821],
	  [93790, 93822],
	  [93791, 93823],
	  [125184, 125218],
	  [125185, 125219],
	  [125186, 125220],
	  [125187, 125221],
	  [125188, 125222],
	  [125189, 125223],
	  [125190, 125224],
	  [125191, 125225],
	  [125192, 125226],
	  [125193, 125227],
	  [125194, 125228],
	  [125195, 125229],
	  [125196, 125230],
	  [125197, 125231],
	  [125198, 125232],
	  [125199, 125233],
	  [125200, 125234],
	  [125201, 125235],
	  [125202, 125236],
	  [125203, 125237],
	  [125204, 125238],
	  [125205, 125239],
	  [125206, 125240],
	  [125207, 125241],
	  [125208, 125242],
	  [125209, 125243],
	  [125210, 125244],
	  [125211, 125245],
	  [125212, 125246],
	  [125213, 125247],
	  [125214, 125248],
	  [125215, 125249],
	  [125216, 125250],
	  [125217, 125251]
	]);
	return iuFoldings;
}

var characterClassEscapeSets = {};

var allCharacters = {};

var hasRequiredAllCharacters;

function requireAllCharacters () {
	if (hasRequiredAllCharacters) return allCharacters;
	hasRequiredAllCharacters = 1;
	const regenerate = requireRegenerate();
	allCharacters.UNICODE_SET = regenerate().addRange(0, 1114111);
	allCharacters.UNICODE_IV_SET = regenerate(215, 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 307, 309, 314, 316, 318, 320, 322, 324, 326, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, 382, 384, 387, 389, 392, 402, 405, 414, 417, 419, 421, 424, 429, 432, 436, 438, 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, 479, 481, 483, 485, 487, 489, 491, 493, 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, 572, 578, 583, 585, 587, 589, 881, 903, 907, 909, 912, 930, 983, 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, 1007, 1014, 1016, 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 4294, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, 8026, 8028, 8030, 8125, 11361, 11368, 11370, 11372, 11377, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11500, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42787, 42789, 42791, 42793, 42795, 42797, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42874, 42876, 42879, 42881, 42883, 42885, 42892, 42897, 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42967, 42969, 42971, 66939, 66955, 66963).addRange(0, 64).addRange(91, 180).addRange(182, 191).addRange(223, 255).addRange(303, 305).addRange(311, 312).addRange(328, 329).addRange(396, 397).addRange(409, 411).addRange(426, 427).addRange(441, 443).addRange(445, 451).addRange(476, 477).addRange(495, 496).addRange(563, 569).addRange(575, 576).addRange(591, 836).addRange(838, 879).addRange(883, 885).addRange(887, 894).addRange(896, 901).addRange(940, 961).addRange(963, 974).addRange(978, 980).addRange(1010, 1011).addRange(1019, 1020).addRange(1072, 1119).addRange(1153, 1161).addRange(1230, 1231).addRange(1327, 1328).addRange(1367, 4255).addRange(4296, 4300).addRange(4302, 5111).addRange(5118, 7295).addRange(7306, 7311).addRange(7355, 7356).addRange(7360, 7679).addRange(7829, 7834).addRange(7836, 7837).addRange(7935, 7943).addRange(7952, 7959).addRange(7966, 7975).addRange(7984, 7991).addRange(8e3, 8007).addRange(8014, 8024).addRange(8032, 8039).addRange(8048, 8071).addRange(8080, 8087).addRange(8096, 8103).addRange(8112, 8119).addRange(8127, 8135).addRange(8141, 8146).addRange(8148, 8151).addRange(8156, 8162).addRange(8164, 8167).addRange(8173, 8183).addRange(8189, 8485).addRange(8487, 8489).addRange(8492, 8497).addRange(8499, 8543).addRange(8560, 8578).addRange(8580, 9397).addRange(9424, 11263).addRange(11312, 11359).addRange(11365, 11366).addRange(11379, 11380).addRange(11382, 11389).addRange(11491, 11498).addRange(11502, 11505).addRange(11507, 42559).addRange(42605, 42623).addRange(42651, 42785).addRange(42799, 42801).addRange(42863, 42872).addRange(42887, 42890).addRange(42894, 42895).addRange(42899, 42901).addRange(42957, 42959).addRange(42961, 42965).addRange(42973, 42996).addRange(42998, 43887).addRange(43968, 64260).addRange(64262, 65312).addRange(65339, 66559).addRange(66600, 66735).addRange(66772, 66927).addRange(66966, 68735).addRange(68787, 68943).addRange(68966, 71839).addRange(71872, 93759).addRange(93792, 125183).addRange(125218, 1114111);
	return allCharacters;
}

var hasRequiredCharacterClassEscapeSets;

function requireCharacterClassEscapeSets () {
	if (hasRequiredCharacterClassEscapeSets) return characterClassEscapeSets;
	hasRequiredCharacterClassEscapeSets = 1;
	const regenerate = requireRegenerate();
	const UNICODE_IV_SET = requireAllCharacters().UNICODE_IV_SET;
	characterClassEscapeSets.REGULAR = /* @__PURE__ */ new Map([
	  ["d", regenerate().addRange(48, 57)],
	  ["D", regenerate().addRange(0, 47).addRange(58, 65535)],
	  ["s", regenerate(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)],
	  ["S", regenerate().addRange(0, 8).addRange(14, 31).addRange(33, 159).addRange(161, 5759).addRange(5761, 8191).addRange(8203, 8231).addRange(8234, 8238).addRange(8240, 8286).addRange(8288, 12287).addRange(12289, 65278).addRange(65280, 65535)],
	  ["w", regenerate(95).addRange(48, 57).addRange(65, 90).addRange(97, 122)],
	  ["W", regenerate(96).addRange(0, 47).addRange(58, 64).addRange(91, 94).addRange(123, 65535)]
	]);
	characterClassEscapeSets.UNICODE = /* @__PURE__ */ new Map([
	  ["d", regenerate().addRange(48, 57)],
	  ["D", regenerate().addRange(0, 47).addRange(58, 1114111)],
	  ["s", regenerate(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)],
	  ["S", regenerate().addRange(0, 8).addRange(14, 31).addRange(33, 159).addRange(161, 5759).addRange(5761, 8191).addRange(8203, 8231).addRange(8234, 8238).addRange(8240, 8286).addRange(8288, 12287).addRange(12289, 65278).addRange(65280, 1114111)],
	  ["w", regenerate(95).addRange(48, 57).addRange(65, 90).addRange(97, 122)],
	  ["W", regenerate(96).addRange(0, 47).addRange(58, 64).addRange(91, 94).addRange(123, 1114111)]
	]);
	characterClassEscapeSets.UNICODE_IGNORE_CASE = /* @__PURE__ */ new Map([
	  ["d", regenerate().addRange(48, 57)],
	  ["D", regenerate().addRange(0, 47).addRange(58, 1114111)],
	  ["s", regenerate(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)],
	  ["S", regenerate().addRange(0, 8).addRange(14, 31).addRange(33, 159).addRange(161, 5759).addRange(5761, 8191).addRange(8203, 8231).addRange(8234, 8238).addRange(8240, 8286).addRange(8288, 12287).addRange(12289, 65278).addRange(65280, 1114111)],
	  ["w", regenerate(95, 383, 8490).addRange(48, 57).addRange(65, 90).addRange(97, 122)],
	  ["W", regenerate(96).addRange(0, 47).addRange(58, 64).addRange(91, 94).addRange(123, 382).addRange(384, 8489).addRange(8491, 1114111)]
	]);
	characterClassEscapeSets.UNICODESET_IGNORE_CASE = /* @__PURE__ */ new Map([
	  ["d", regenerate().addRange(48, 57)],
	  ["D", UNICODE_IV_SET.clone().remove(regenerate().addRange(48, 57))],
	  ["s", regenerate(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233)],
	  ["S", UNICODE_IV_SET.clone().remove(regenerate(32, 160, 5760, 8239, 8287, 12288, 65279).addRange(9, 13).addRange(8192, 8202).addRange(8232, 8233))],
	  ["w", regenerate(95).addRange(48, 57).addRange(97, 122)],
	  ["W", UNICODE_IV_SET.clone().remove(regenerate(95).addRange(48, 57).addRange(97, 122))]
	]);
	return characterClassEscapeSets;
}

var rewritePattern_1;
var hasRequiredRewritePattern;

function requireRewritePattern () {
	if (hasRequiredRewritePattern) return rewritePattern_1;
	hasRequiredRewritePattern = 1;
	const generate = requireRegjsgen().generate;
	const parse = requireParser().parse;
	const regenerate = requireRegenerate();
	const unicodeMatchProperty = requireUnicodeMatchPropertyEcmascript();
	const unicodeMatchPropertyValue = requireUnicodeMatchPropertyValueEcmascript();
	const iuMappings = requireIuMappings();
	const iBMPMappings = requireIBmpMappings();
	const iuFoldings = requireIuFoldings();
	const ESCAPE_SETS = requireCharacterClassEscapeSets();
	const { UNICODE_SET, UNICODE_IV_SET } = requireAllCharacters();
	function flatMap(array, callback) {
	  const result = [];
	  array.forEach((item) => {
	    const res = callback(item);
	    if (Array.isArray(res)) {
	      result.push.apply(result, res);
	    } else {
	      result.push(res);
	    }
	  });
	  return result;
	}
	function regenerateContainsAstral(regenerateData) {
	  const data = regenerateData.data;
	  return data.length >= 1 && data[data.length - 1] >= 65536;
	}
	const SYNTAX_CHARS = /[\\^$.*+?()[\]{}|]/g;
	const ASTRAL_SET = regenerate().addRange(65536, 1114111);
	const NEWLINE_SET = regenerate().add(
	  // `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
	  10,
	  // Line Feed <LF>
	  13,
	  // Carriage Return <CR>
	  8232,
	  // Line Separator <LS>
	  8233
	  // Paragraph Separator <PS>
	);
	const DOT_SET_UNICODE = UNICODE_SET.clone().remove(NEWLINE_SET);
	const getCharacterClassEscapeSet = (character, unicode, ignoreCase, shouldApplySCF) => {
	  if (unicode) {
	    if (ignoreCase) {
	      const result = ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);
	      if (shouldApplySCF) {
	        return ESCAPE_SETS.UNICODESET_IGNORE_CASE.get(character);
	      } else {
	        return result;
	      }
	    }
	    return ESCAPE_SETS.UNICODE.get(character);
	  }
	  return ESCAPE_SETS.REGULAR.get(character);
	};
	const getUnicodeDotSet = (dotAll) => {
	  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
	};
	const getUnicodePropertyValueSet = (property, value) => {
	  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;
	  try {
	    return require(`regenerate-unicode-properties/${path}.js`);
	  } catch (exception) {
	    throw new Error(
	      `Failed to recognize value \`${value}\` for property \`${property}\`.`
	    );
	  }
	};
	const handleLoneUnicodePropertyNameOrValue = (value) => {
	  try {
	    const property2 = "General_Category";
	    const category = unicodeMatchPropertyValue(property2, value);
	    return getUnicodePropertyValueSet(property2, category);
	  } catch (exception) {
	  }
	  try {
	    return getUnicodePropertyValueSet("Property_of_Strings", value);
	  } catch (exception) {
	  }
	  const property = unicodeMatchProperty(value);
	  return getUnicodePropertyValueSet(property);
	};
	const getUnicodePropertyEscapeSet = (value, isNegative, isUnicodeSetIgnoreCase) => {
	  const parts = value.split("=");
	  const firstPart = parts[0];
	  let set;
	  if (parts.length == 1) {
	    set = handleLoneUnicodePropertyNameOrValue(firstPart);
	  } else {
	    const property = unicodeMatchProperty(firstPart);
	    const value2 = unicodeMatchPropertyValue(property, parts[1]);
	    set = getUnicodePropertyValueSet(property, value2);
	  }
	  if (isNegative) {
	    if (set.strings) {
	      throw new Error("Cannot negate Unicode property of strings");
	    }
	    return {
	      characters: (isUnicodeSetIgnoreCase ? UNICODE_IV_SET : UNICODE_SET).clone().remove(set.characters),
	      strings: /* @__PURE__ */ new Set()
	    };
	  }
	  return {
	    characters: set.characters.clone(),
	    strings: set.strings ? new Set(set.strings.map((str) => str.replace(SYNTAX_CHARS, "\\$&"))) : /* @__PURE__ */ new Set()
	  };
	};
	const getUnicodePropertyEscapeCharacterClassData = (property, isNegative, isUnicodeSetIgnoreCase, shouldApplySCF) => {
	  const set = getUnicodePropertyEscapeSet(property, isNegative, isUnicodeSetIgnoreCase);
	  const data = getCharacterClassEmptyData();
	  const singleChars = shouldApplySCF ? regenerate(set.characters.toArray().map((ch) => simpleCaseFolding(ch))) : set.characters;
	  const caseEqFlags = configGetCaseEqFlags();
	  if (caseEqFlags) {
	    for (const codepoint of singleChars.toArray()) {
	      const list = getCaseEquivalents(codepoint, caseEqFlags);
	      if (list) {
	        singleChars.add(list);
	      }
	    }
	  }
	  data.singleChars = singleChars;
	  if (set.strings.size > 0) {
	    data.longStrings = set.strings;
	    data.maybeIncludesStrings = true;
	  }
	  return data;
	};
	const CASE_EQ_FLAG_NONE = 0;
	const CASE_EQ_FLAG_BMP = 1;
	const CASE_EQ_FLAG_UNICODE = 2;
	function configGetCaseEqFlags() {
	  let flags = CASE_EQ_FLAG_NONE;
	  if (config.modifiersData.i === true) {
	    if (config.transform.modifiers) {
	      flags |= CASE_EQ_FLAG_BMP;
	      if (config.flags.unicode || config.flags.unicodeSets) {
	        flags |= CASE_EQ_FLAG_UNICODE;
	      }
	    }
	  } else if (config.modifiersData.i === void 0) {
	    if (config.transform.unicodeFlag && config.flags.ignoreCase) {
	      flags |= CASE_EQ_FLAG_UNICODE;
	    }
	  }
	  return flags;
	}
	regenerate.prototype.iuAddRange = function(min, max, caseEqFlags) {
	  const $this = this;
	  do {
	    const list = getCaseEquivalents(min, caseEqFlags);
	    if (list) {
	      $this.add(list);
	    }
	  } while (++min <= max);
	  return $this;
	};
	regenerate.prototype.iuRemoveRange = function(min, max, caseEqFlags) {
	  const $this = this;
	  do {
	    const list = getCaseEquivalents(min, caseEqFlags);
	    if (list) {
	      $this.remove(list);
	    }
	  } while (++min <= max);
	  return $this;
	};
	const update = (item, pattern) => {
	  let tree = parse(pattern, config.useUnicodeFlag ? "u" : "", {
	    lookbehind: true,
	    namedGroups: true,
	    unicodePropertyEscape: true,
	    unicodeSet: true,
	    modifiers: true
	  });
	  switch (tree.type) {
	    case "characterClass":
	    case "group":
	    case "value":
	      break;
	    default:
	      tree = wrap(tree, pattern);
	  }
	  Object.assign(item, tree);
	};
	const wrap = (tree, pattern) => {
	  return {
	    "type": "group",
	    "behavior": "ignore",
	    "body": [tree],
	    "raw": `(?:${pattern})`
	  };
	};
	const getCaseEquivalents = (codePoint, flags) => {
	  if (flags === CASE_EQ_FLAG_NONE) {
	    return false;
	  }
	  let result = (flags & CASE_EQ_FLAG_UNICODE ? iuMappings.get(codePoint) : void 0) || [];
	  if (typeof result === "number") result = [result];
	  if (flags & CASE_EQ_FLAG_BMP) {
	    for (const cp of [codePoint].concat(result)) {
	      if (cp >= 65 && cp <= 90) {
	        result.push(cp + 32);
	      } else if (cp >= 97 && cp <= 122) {
	        result.push(cp - 32);
	      } else {
	        result = result.concat(iBMPMappings.get(cp) || []);
	      }
	    }
	  }
	  return result.length == 0 ? false : result;
	};
	const simpleCaseFolding = (codePoint) => {
	  if (codePoint <= 127) {
	    if (codePoint >= 65 && codePoint <= 90) {
	      return codePoint + 32;
	    }
	    return codePoint;
	  }
	  return iuFoldings.get(codePoint) || codePoint;
	};
	const buildHandler = (action) => {
	  switch (action) {
	    case "union":
	      return {
	        single: (data, cp) => {
	          data.singleChars.add(cp);
	        },
	        regSet: (data, set2) => {
	          data.singleChars.add(set2);
	        },
	        range: (data, start, end) => {
	          data.singleChars.addRange(start, end);
	        },
	        iuRange: (data, start, end, caseEqFlags) => {
	          data.singleChars.iuAddRange(start, end, caseEqFlags);
	        },
	        nested: (data, nestedData) => {
	          data.singleChars.add(nestedData.singleChars);
	          for (const str of nestedData.longStrings) data.longStrings.add(str);
	          if (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;
	        }
	      };
	    case "union-negative": {
	      const regSet = (data, set2) => {
	        data.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);
	      };
	      return {
	        single: (data, cp) => {
	          const unicode = UNICODE_SET.clone();
	          data.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);
	        },
	        regSet,
	        range: (data, start, end) => {
	          data.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);
	        },
	        iuRange: (data, start, end, caseEqFlags) => {
	          data.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end, caseEqFlags).add(data.singleChars);
	        },
	        nested: (data, nestedData) => {
	          regSet(data, nestedData.singleChars);
	          if (nestedData.maybeIncludesStrings) throw new Error("ASSERTION ERROR");
	        }
	      };
	    }
	    case "intersection": {
	      const regSet = (data, set2) => {
	        if (data.first) data.singleChars = set2;
	        else data.singleChars.intersection(set2);
	      };
	      return {
	        single: (data, cp) => {
	          data.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();
	          data.longStrings.clear();
	          data.maybeIncludesStrings = false;
	        },
	        regSet: (data, set) => {
	          regSet(data, set);
	          data.longStrings.clear();
	          data.maybeIncludesStrings = false;
	        },
	        range: (data, start, end) => {
	          if (data.first) data.singleChars.addRange(start, end);
	          else data.singleChars.intersection(regenerate().addRange(start, end));
	          data.longStrings.clear();
	          data.maybeIncludesStrings = false;
	        },
	        iuRange: (data, start, end, caseEqFlags) => {
	          if (data.first) data.singleChars.iuAddRange(start, end, caseEqFlags);
	          else data.singleChars.intersection(regenerate().iuAddRange(start, end, caseEqFlags));
	          data.longStrings.clear();
	          data.maybeIncludesStrings = false;
	        },
	        nested: (data, nestedData) => {
	          regSet(data, nestedData.singleChars);
	          if (data.first) {
	            data.longStrings = nestedData.longStrings;
	            data.maybeIncludesStrings = nestedData.maybeIncludesStrings;
	          } else {
	            for (const str of data.longStrings) {
	              if (!nestedData.longStrings.has(str)) data.longStrings.delete(str);
	            }
	            if (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;
	          }
	        }
	      };
	    }
	    case "subtraction": {
	      const regSet = (data, set2) => {
	        if (data.first) data.singleChars.add(set2);
	        else data.singleChars.remove(set2);
	      };
	      return {
	        single: (data, cp) => {
	          if (data.first) data.singleChars.add(cp);
	          else data.singleChars.remove(cp);
	        },
	        regSet,
	        range: (data, start, end) => {
	          if (data.first) data.singleChars.addRange(start, end);
	          else data.singleChars.removeRange(start, end);
	        },
	        iuRange: (data, start, end, caseEqFlags) => {
	          if (data.first) data.singleChars.iuAddRange(start, end, caseEqFlags);
	          else data.singleChars.iuRemoveRange(start, end, caseEqFlags);
	        },
	        nested: (data, nestedData) => {
	          regSet(data, nestedData.singleChars);
	          if (data.first) {
	            data.longStrings = nestedData.longStrings;
	            data.maybeIncludesStrings = nestedData.maybeIncludesStrings;
	          } else {
	            for (const str of data.longStrings) {
	              if (nestedData.longStrings.has(str)) data.longStrings.delete(str);
	            }
	          }
	        }
	      };
	    }
	    // The `default` clause is only here as a safeguard; it should never be
	    // reached. Code coverage tools should ignore it.
	    /* node:coverage ignore next */
	    default:
	      throw new Error(`Unknown set action: ${characterClassItem.kind}`);
	  }
	};
	const getCharacterClassEmptyData = () => ({
	  transformed: config.transform.unicodeFlag,
	  singleChars: regenerate(),
	  longStrings: /* @__PURE__ */ new Set(),
	  hasEmptyString: false,
	  first: true,
	  maybeIncludesStrings: false
	});
	const concatCaseEquivalents = (codePoint, caseEqFlags) => {
	  const caseEquivalents = getCaseEquivalents(codePoint, caseEqFlags);
	  if (caseEquivalents) {
	    return [codePoint, ...caseEquivalents];
	  }
	  return [codePoint];
	};
	const computeClassStrings = (classStrings, regenerateOptions, caseEqFlags, shouldApplySCF) => {
	  let data = getCharacterClassEmptyData();
	  for (const string of classStrings.strings) {
	    if (string.characters.length === 1) {
	      const codePoint = shouldApplySCF ? simpleCaseFolding(string.characters[0].codePoint) : string.characters[0].codePoint;
	      concatCaseEquivalents(codePoint, caseEqFlags).forEach((cp) => {
	        data.singleChars.add(cp);
	      });
	    } else {
	      let stringifiedString = "";
	      if (caseEqFlags) {
	        for (const ch of string.characters) {
	          const codePoint = shouldApplySCF ? simpleCaseFolding(ch.codePoint) : ch.codePoint;
	          const set = regenerate(concatCaseEquivalents(codePoint, caseEqFlags));
	          stringifiedString += set.toString(regenerateOptions);
	        }
	      } else {
	        for (const ch of string.characters) {
	          const codePoint = shouldApplySCF ? simpleCaseFolding(ch.codePoint) : ch.codePoint;
	          if (codePoint !== ch.codePoint) {
	            stringifiedString += regenerate(codePoint).toString(regenerateOptions);
	          } else {
	            stringifiedString += generate(ch);
	          }
	        }
	      }
	      data.longStrings.add(stringifiedString);
	      data.maybeIncludesStrings = true;
	    }
	  }
	  return data;
	};
	const computeCharacterClass = (characterClassItem2, regenerateOptions, shouldApplySCF) => {
	  let data = getCharacterClassEmptyData();
	  let handlePositive;
	  let handleNegative;
	  let caseEqFlags = configGetCaseEqFlags();
	  switch (characterClassItem2.kind) {
	    case "union":
	      handlePositive = buildHandler("union");
	      handleNegative = buildHandler("union-negative");
	      break;
	    case "intersection":
	      handlePositive = buildHandler("intersection");
	      handleNegative = buildHandler("subtraction");
	      if (config.transform.unicodeSetsFlag) data.transformed = true;
	      if (config.isIgnoreCaseMode) {
	        shouldApplySCF = true;
	      }
	      break;
	    case "subtraction":
	      handlePositive = buildHandler("subtraction");
	      handleNegative = buildHandler("intersection");
	      if (config.transform.unicodeSetsFlag) data.transformed = true;
	      if (config.isIgnoreCaseMode) {
	        shouldApplySCF = true;
	      }
	      break;
	    // The `default` clause is only here as a safeguard; it should never be
	    // reached. Code coverage tools should ignore it.
	    /* node:coverage ignore next */
	    default:
	      throw new Error(`Unknown character class kind: ${characterClassItem2.kind}`);
	  }
	  for (const item of characterClassItem2.body) {
	    switch (item.type) {
	      case "value":
	        const codePoint = shouldApplySCF ? simpleCaseFolding(item.codePoint) : item.codePoint;
	        const list = concatCaseEquivalents(codePoint, caseEqFlags);
	        handlePositive.regSet(data, regenerate(list));
	        if (list.length > 1) {
	          data.transformed = true;
	        }
	        break;
	      case "characterClassRange":
	        const min = item.min.codePoint;
	        const max = item.max.codePoint;
	        if (shouldApplySCF) {
	          let list2 = [];
	          for (let cp = min; cp <= max; cp++) {
	            list2.push(simpleCaseFolding(cp));
	          }
	          handlePositive.regSet(data, regenerate(list2));
	        } else {
	          handlePositive.range(data, min, max);
	        }
	        if (caseEqFlags) {
	          handlePositive.iuRange(data, min, max, caseEqFlags);
	          data.transformed = true;
	        }
	        break;
	      case "characterClassEscape":
	        handlePositive.regSet(data, getCharacterClassEscapeSet(
	          item.value,
	          config.flags.unicode || config.flags.unicodeSets,
	          config.flags.ignoreCase,
	          shouldApplySCF
	        ));
	        break;
	      case "unicodePropertyEscape":
	        const nestedData = getUnicodePropertyEscapeCharacterClassData(
	          item.value,
	          item.negative,
	          config.flags.unicodeSets && config.isIgnoreCaseMode,
	          shouldApplySCF
	        );
	        handlePositive.nested(data, nestedData);
	        data.transformed = data.transformed || config.transform.unicodePropertyEscapes || config.transform.unicodeSetsFlag && (nestedData.maybeIncludesStrings || characterClassItem2.kind !== "union" || item.negative);
	        break;
	      case "characterClass":
	        const handler = item.negative ? handleNegative : handlePositive;
	        const res = computeCharacterClass(item, regenerateOptions, shouldApplySCF);
	        handler.nested(data, res);
	        data.transformed = true;
	        break;
	      case "classStrings":
	        handlePositive.nested(data, computeClassStrings(item, regenerateOptions, caseEqFlags, shouldApplySCF));
	        data.transformed = true;
	        break;
	      // The `default` clause is only here as a safeguard; it should never be
	      // reached. Code coverage tools should ignore it.
	      /* node:coverage ignore next */
	      default:
	        throw new Error(`Unknown term type: ${item.type}`);
	    }
	    data.first = false;
	  }
	  if (characterClassItem2.negative && data.maybeIncludesStrings) {
	    throw new SyntaxError("Cannot negate set containing strings");
	  }
	  return data;
	};
	const processCharacterClass = (characterClassItem2, regenerateOptions, computed = computeCharacterClass(characterClassItem2, regenerateOptions)) => {
	  const negative = characterClassItem2.negative;
	  const { singleChars, transformed, longStrings } = computed;
	  if (transformed) {
	    const bmpOnly = regenerateContainsAstral(singleChars);
	    const setStr = singleChars.toString(Object.assign({}, regenerateOptions, { bmpOnly }));
	    if (negative) {
	      if (config.useUnicodeFlag) {
	        update(characterClassItem2, `[^${setStr[0] === "[" ? setStr.slice(1, -1) : setStr}]`);
	      } else {
	        if (config.flags.unicode || config.flags.unicodeSets) {
	          if (config.flags.ignoreCase) {
	            const astralCharsSet = singleChars.clone().intersection(ASTRAL_SET);
	            const surrogateOrBMPSetStr = singleChars.clone().remove(astralCharsSet).addRange(55296, 57343).toString({ bmpOnly: true });
	            const astralNegativeSetStr = ASTRAL_SET.clone().remove(astralCharsSet).toString(regenerateOptions);
	            update(
	              characterClassItem2,
	              `(?!${surrogateOrBMPSetStr})[^]|${astralNegativeSetStr}`
	            );
	          } else {
	            const negativeSet = UNICODE_SET.clone().remove(singleChars);
	            update(characterClassItem2, negativeSet.toString(regenerateOptions));
	          }
	        } else {
	          update(characterClassItem2, `(?!${setStr})[^]`);
	        }
	      }
	    } else {
	      const hasEmptyString = longStrings.has("");
	      const pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);
	      if (setStr !== "[]" || longStrings.size === 0) {
	        pieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);
	      }
	      update(characterClassItem2, pieces.join("|"));
	    }
	  }
	  return characterClassItem2;
	};
	const assertNoUnmatchedReferences = (groups) => {
	  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);
	  if (unmatchedReferencesNames.length > 0) {
	    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);
	  }
	};
	const processModifiers = (item, regenerateOptions, groups) => {
	  const enabling = item.modifierFlags.enabling;
	  const disabling = item.modifierFlags.disabling;
	  const oldData = Object.assign({}, config.modifiersData);
	  for (const flag of enabling) {
	    config.modifiersData[flag] = true;
	  }
	  for (const flag of disabling) {
	    config.modifiersData[flag] = false;
	  }
	  if (config.transform.modifiers) {
	    delete item.modifierFlags;
	    item.behavior = "ignore";
	  }
	  item.body = item.body.map((term) => {
	    return processTerm(term, regenerateOptions, groups);
	  });
	  config.modifiersData = oldData;
	  return item;
	};
	const processTerm = (item, regenerateOptions, groups) => {
	  switch (item.type) {
	    case "dot":
	      if (config.transform.unicodeFlag) {
	        update(
	          item,
	          getUnicodeDotSet(config.isDotAllMode).toString(regenerateOptions)
	        );
	      } else if (config.modifiersData.s != null ? config.modifiersData.s && config.transform.modifiers : config.transform.dotAllFlag) {
	        update(item, "[^]");
	      }
	      break;
	    case "characterClass":
	      item = processCharacterClass(item, regenerateOptions);
	      break;
	    case "unicodePropertyEscape":
	      const data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative, config.flags.unicodeSets && config.isIgnoreCaseMode);
	      if (data.maybeIncludesStrings) {
	        if (!config.flags.unicodeSets) {
	          throw new Error(
	            "Properties of strings are only supported when using the unicodeSets (v) flag."
	          );
	        }
	        if (config.transform.unicodeSetsFlag) {
	          data.transformed = true;
	          item = processCharacterClass(item, regenerateOptions, data);
	        }
	      } else if (config.transform.unicodePropertyEscapes || configGetCaseEqFlags()) {
	        update(
	          item,
	          data.singleChars.toString(regenerateOptions)
	        );
	      }
	      break;
	    case "characterClassEscape":
	      if (config.transform.unicodeFlag) {
	        update(
	          item,
	          getCharacterClassEscapeSet(
	            item.value,
	            /* config.transform.unicodeFlag implies config.flags.unicode */
	            true,
	            config.flags.ignoreCase
	          ).toString(regenerateOptions)
	        );
	      }
	      break;
	    case "group":
	      if (item.behavior == "normal") {
	        groups.lastIndex++;
	      }
	      if (item.name) {
	        const name = item.name.value;
	        if (groups.namesConflicts[name]) {
	          throw new Error(
	            `Group '${name}' has already been defined in this context.`
	          );
	        }
	        groups.namesConflicts[name] = true;
	        if (config.transform.namedGroups) {
	          delete item.name;
	        }
	        const index = groups.lastIndex;
	        if (!groups.names[name]) {
	          groups.names[name] = [];
	        }
	        groups.names[name].push(index);
	        if (groups.onNamedGroup) {
	          groups.onNamedGroup.call(null, name, index);
	        }
	        if (groups.unmatchedReferences[name]) {
	          delete groups.unmatchedReferences[name];
	        }
	      }
	      if (item.modifierFlags) {
	        return processModifiers(item, regenerateOptions, groups);
	      }
	    /* falls through */
	    case "quantifier":
	      item.body = item.body.map((term) => {
	        return processTerm(term, regenerateOptions, groups);
	      });
	      break;
	    case "disjunction":
	      const outerNamesConflicts = groups.namesConflicts;
	      item.body = item.body.map((term) => {
	        groups.namesConflicts = Object.create(outerNamesConflicts);
	        return processTerm(term, regenerateOptions, groups);
	      });
	      break;
	    case "alternative":
	      item.body = flatMap(item.body, (term) => {
	        const res = processTerm(term, regenerateOptions, groups);
	        return res.type === "alternative" ? res.body : res;
	      });
	      break;
	    case "value":
	      const codePoint = item.codePoint;
	      const caseEqFlags = configGetCaseEqFlags();
	      const list = concatCaseEquivalents(codePoint, caseEqFlags);
	      if (list.length === 1 && item.kind === "symbol" && codePoint >= 32 && codePoint <= 126) {
	        break;
	      }
	      const set = regenerate(list);
	      update(item, set.toString(regenerateOptions));
	      break;
	    case "reference":
	      if (item.name) {
	        const name = item.name.value;
	        const indexes = groups.names[name];
	        if (!indexes) {
	          groups.unmatchedReferences[name] = true;
	        }
	        if (config.transform.namedGroups) {
	          if (indexes) {
	            const body = indexes.map((index) => ({
	              "type": "reference",
	              "matchIndex": index,
	              "raw": "\\" + index
	            }));
	            if (body.length === 1) {
	              return body[0];
	            }
	            return {
	              "type": "alternative",
	              "body": body,
	              "raw": body.map((term) => term.raw).join("")
	            };
	          }
	          return {
	            "type": "group",
	            "behavior": "ignore",
	            "body": [],
	            "raw": "(?:)"
	          };
	        }
	      }
	      break;
	    case "anchor":
	      if (config.modifiersData.m && config.transform.modifiers) {
	        if (item.kind == "start") {
	          update(item, `(?:^|(?<=${NEWLINE_SET.toString()}))`);
	        } else if (item.kind == "end") {
	          update(item, `(?:$|(?=${NEWLINE_SET.toString()}))`);
	        }
	      }
	    case "empty":
	      break;
	    // The `default` clause is only here as a safeguard; it should never be
	    // reached. Code coverage tools should ignore it.
	    /* node:coverage ignore next */
	    default:
	      throw new Error(`Unknown term type: ${item.type}`);
	  }
	  return item;
	};
	const config = {
	  "flags": {
	    "ignoreCase": false,
	    "unicode": false,
	    "unicodeSets": false,
	    "dotAll": false,
	    "multiline": false
	  },
	  "transform": {
	    "dotAllFlag": false,
	    "unicodeFlag": false,
	    "unicodeSetsFlag": false,
	    "unicodePropertyEscapes": false,
	    "namedGroups": false,
	    "modifiers": false
	  },
	  "modifiersData": {
	    "i": void 0,
	    "s": void 0,
	    "m": void 0
	  },
	  get useUnicodeFlag() {
	    return (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;
	  },
	  get isDotAllMode() {
	    return this.modifiersData.s !== void 0 ? this.modifiersData.s : this.flags.dotAll;
	  },
	  get isIgnoreCaseMode() {
	    return this.modifiersData.i !== void 0 ? this.modifiersData.i : this.flags.ignoreCase;
	  }
	};
	const validateOptions = (options) => {
	  if (!options) return;
	  for (const key of Object.keys(options)) {
	    const value = options[key];
	    switch (key) {
	      case "dotAllFlag":
	      case "unicodeFlag":
	      case "unicodePropertyEscapes":
	      case "unicodeSetsFlag":
	      case "namedGroups":
	        if (value != null && value !== false && value !== "transform") {
	          throw new Error(`.${key} must be false (default) or 'transform'.`);
	        }
	        break;
	      // todo: remove modifiers: 'parse' in regexpu-core v7
	      case "modifiers":
	        if (value != null && value !== false && value !== "parse" && value !== "transform") {
	          throw new Error(`.${key} must be false (default), 'parse' or 'transform'.`);
	        }
	        break;
	      case "onNamedGroup":
	      case "onNewFlags":
	        if (value != null && typeof value !== "function") {
	          throw new Error(`.${key} must be a function.`);
	        }
	        break;
	      default:
	        throw new Error(`.${key} is not a valid regexpu-core option.`);
	    }
	  }
	};
	const hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;
	const transform = (options, name) => options ? options[name] === "transform" : false;
	const rewritePattern = (pattern, flags, options) => {
	  validateOptions(options);
	  config.flags.unicode = hasFlag(flags, "u");
	  config.flags.unicodeSets = hasFlag(flags, "v");
	  config.flags.ignoreCase = hasFlag(flags, "i");
	  config.flags.dotAll = hasFlag(flags, "s");
	  config.flags.multiline = hasFlag(flags, "m");
	  config.transform.dotAllFlag = config.flags.dotAll && transform(options, "dotAllFlag");
	  config.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, "unicodeFlag");
	  config.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, "unicodeSetsFlag");
	  config.transform.unicodePropertyEscapes = (config.flags.unicode || config.flags.unicodeSets) && (transform(options, "unicodeFlag") || transform(options, "unicodePropertyEscapes"));
	  config.transform.namedGroups = transform(options, "namedGroups");
	  config.transform.modifiers = transform(options, "modifiers");
	  config.modifiersData.i = void 0;
	  config.modifiersData.s = void 0;
	  config.modifiersData.m = void 0;
	  const regjsparserFeatures = {
	    // Enable every stable RegExp feature by default
	    "modifiers": true,
	    "unicodePropertyEscape": true,
	    "unicodeSet": true,
	    "namedGroups": true,
	    "lookbehind": true
	  };
	  const regenerateOptions = {
	    "hasUnicodeFlag": config.useUnicodeFlag,
	    "bmpOnly": !config.flags.unicode && !config.flags.unicodeSets
	  };
	  const groups = {
	    "onNamedGroup": options && options.onNamedGroup,
	    "lastIndex": 0,
	    "names": /* @__PURE__ */ Object.create(null),
	    // { [name]: Array<index> }
	    "namesConflicts": /* @__PURE__ */ Object.create(null),
	    // { [name]: true }
	    "unmatchedReferences": /* @__PURE__ */ Object.create(null)
	    // { [name]: true }
	  };
	  const tree = parse(pattern, flags, regjsparserFeatures);
	  if (config.transform.modifiers) {
	    if (/\(\?[a-z]*-[a-z]+:/.test(pattern)) {
	      const allDisabledModifiers = /* @__PURE__ */ Object.create(null);
	      const itemStack = [tree];
	      let node;
	      while (node = itemStack.pop(), node != void 0) {
	        if (Array.isArray(node)) {
	          Array.prototype.push.apply(itemStack, node);
	        } else if (typeof node == "object" && node != null) {
	          for (const key of Object.keys(node)) {
	            const value = node[key];
	            if (key == "modifierFlags") {
	              for (const flag of value.disabling) {
	                allDisabledModifiers[flag] = true;
	              }
	            } else if (typeof value == "object" && value != null) {
	              itemStack.push(value);
	            }
	          }
	        }
	      }
	      if (allDisabledModifiers.i) {
	        config.modifiersData.i = config.flags.ignoreCase;
	      }
	      if (allDisabledModifiers.m) {
	        config.modifiersData.m = config.flags.multiline;
	      }
	      if (allDisabledModifiers.s) {
	        config.modifiersData.s = config.flags.dotAll;
	      }
	    }
	  }
	  processTerm(tree, regenerateOptions, groups);
	  assertNoUnmatchedReferences(groups);
	  const onNewFlags = options && options.onNewFlags;
	  if (onNewFlags) {
	    let newFlags = flags.split("").filter((flag) => !config.modifiersData[flag]).join("");
	    if (config.transform.unicodeSetsFlag) {
	      newFlags = newFlags.replace("v", "u");
	    }
	    if (config.transform.unicodeFlag) {
	      newFlags = newFlags.replace("u", "");
	    }
	    if (config.transform.dotAllFlag) {
	      newFlags = newFlags.replace("s", "");
	    }
	    onNewFlags(newFlags);
	  }
	  return generate(tree);
	};
	rewritePattern_1 = rewritePattern;
	return rewritePattern_1;
}

var features = {};

var hasRequiredFeatures;

function requireFeatures () {
	if (hasRequiredFeatures) return features;
	hasRequiredFeatures = 1;
	Object.defineProperty(features, "__esModule", {
	  value: true
	});
	features.FEATURES = void 0;
	features.enableFeature = enableFeature;
	features.featuresKey = void 0;
	features.hasFeature = hasFeature;
	features.runtimeKey = void 0;
	features.FEATURES = Object.freeze({
	  unicodeFlag: 1 << 0,
	  dotAllFlag: 1 << 1,
	  unicodePropertyEscape: 1 << 2,
	  namedCaptureGroups: 1 << 3,
	  unicodeSetsFlag_syntax: 1 << 4,
	  unicodeSetsFlag: 1 << 5,
	  duplicateNamedCaptureGroups: 1 << 6,
	  modifiers: 1 << 7
	});
	features.featuresKey = "@babel/plugin-regexp-features/featuresKey";
	features.runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
	function enableFeature(features, feature) {
	  return features | feature;
	}
	function hasFeature(features, feature) {
	  return !!(features & feature);
	}
	return features;
}

var util$3 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$3;
	hasRequiredUtil$1 = 1;
	Object.defineProperty(util$3, "__esModule", {
	  value: true
	});
	util$3.canSkipRegexpu = canSkipRegexpu;
	util$3.generateRegexpuOptions = generateRegexpuOptions;
	util$3.transformFlags = transformFlags;
	var _features = requireFeatures();
	function generateRegexpuOptions(pattern, toTransform) {
	  const feat = (name) => {
	    return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? "transform" : false;
	  };
	  const featDuplicateNamedGroups = () => {
	    if (!feat("duplicateNamedCaptureGroups")) return false;
	    const regex = /\(\?<([^>]+)(>|$)/g;
	    const seen = /* @__PURE__ */ new Set();
	    for (let match; (match = regex.exec(pattern)) && match[2]; seen.add(match[1])) {
	      if (seen.has(match[1])) return "transform";
	    }
	    return false;
	  };
	  return {
	    unicodeFlag: feat("unicodeFlag"),
	    unicodeSetsFlag: feat("unicodeSetsFlag"),
	    dotAllFlag: feat("dotAllFlag"),
	    unicodePropertyEscapes: feat("unicodePropertyEscape"),
	    namedGroups: feat("namedCaptureGroups") || featDuplicateNamedGroups(),
	    onNamedGroup: () => {
	    },
	    modifiers: feat("modifiers")
	  };
	}
	function canSkipRegexpu(node, options) {
	  const {
	    flags,
	    pattern
	  } = node;
	  if (flags.includes("v")) {
	    if (options.unicodeSetsFlag === "transform") return false;
	  }
	  if (flags.includes("u")) {
	    if (options.unicodeFlag === "transform") return false;
	    if (options.unicodePropertyEscapes === "transform" && /\\p\{/i.test(pattern)) {
	      return false;
	    }
	  }
	  if (flags.includes("s")) {
	    if (options.dotAllFlag === "transform") return false;
	  }
	  if (options.namedGroups === "transform" && /\(\?<(?![=!])/.test(pattern)) {
	    return false;
	  }
	  if (options.modifiers === "transform" && /\(\?[\w-]+:/.test(pattern)) {
	    return false;
	  }
	  return true;
	}
	function transformFlags(regexpuOptions, flags) {
	  if (regexpuOptions.unicodeSetsFlag === "transform") {
	    flags = flags.replace("v", "u");
	  }
	  if (regexpuOptions.unicodeFlag === "transform") {
	    flags = flags.replace("u", "");
	  }
	  if (regexpuOptions.dotAllFlag === "transform") {
	    flags = flags.replace("s", "");
	  }
	  return flags;
	}
	return util$3;
}

var hasRequiredLib$R;

function requireLib$R () {
	if (hasRequiredLib$R) return lib$P;
	hasRequiredLib$R = 1;
	Object.defineProperty(lib$P, "__esModule", {
	  value: true
	});
	lib$P.createRegExpFeaturePlugin = createRegExpFeaturePlugin;
	var _regexpuCore = requireRewritePattern();
	var _core = require$$0$b;
	var _helperAnnotateAsPure = requireLib$17();
	var _semver = requireSemver();
	var _features = requireFeatures();
	var _util = requireUtil$1();
	const versionKey = "@babel/plugin-regexp-features/version";
	function createRegExpFeaturePlugin({
	  name,
	  feature,
	  options = {},
	  manipulateOptions = () => {
	  }
	}) {
	  return {
	    name,
	    manipulateOptions,
	    pre() {
	      var _file$get;
	      const {
	        file
	      } = this;
	      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;
	      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
	      const {
	        useUnicodeFlag,
	        runtime
	      } = options;
	      if (useUnicodeFlag === false) {
	        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);
	      }
	      if (newFeatures !== features) {
	        file.set(_features.featuresKey, newFeatures);
	      }
	      if (runtime !== void 0) {
	        if (file.has(_features.runtimeKey) && file.get(_features.runtimeKey) !== runtime && (0, _features.hasFeature)(newFeatures, _features.FEATURES.duplicateNamedCaptureGroups)) {
	          throw new Error(`The 'runtime' option must be the same for '@babel/plugin-transform-named-capturing-groups-regex' and '@babel/plugin-transform-duplicate-named-capturing-groups-regex'.`);
	        }
	        if (feature === "namedCaptureGroups") {
	          if (!runtime || !file.has(_features.runtimeKey)) file.set(_features.runtimeKey, runtime);
	        } else {
	          file.set(_features.runtimeKey, runtime);
	        }
	      }
	      {
	        if (typeof file.get(versionKey) === "number") {
	          file.set(versionKey, "7.27.1");
	          return;
	        }
	      }
	      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.27.1")) {
	        file.set(versionKey, "7.27.1");
	      }
	    },
	    visitor: {
	      RegExpLiteral(path) {
	        var _file$get2;
	        const {
	          node
	        } = path;
	        const {
	          file
	        } = this;
	        const features = file.get(_features.featuresKey);
	        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;
	        const regexpuOptions = (0, _util.generateRegexpuOptions)(node.pattern, features);
	        if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) {
	          return;
	        }
	        const namedCaptureGroups = {
	          __proto__: null
	        };
	        if (regexpuOptions.namedGroups === "transform") {
	          regexpuOptions.onNamedGroup = (name2, index) => {
	            const prev = namedCaptureGroups[name2];
	            if (typeof prev === "number") {
	              namedCaptureGroups[name2] = [prev, index];
	            } else if (Array.isArray(prev)) {
	              prev.push(index);
	            } else {
	              namedCaptureGroups[name2] = index;
	            }
	          };
	        }
	        let newFlags;
	        if (regexpuOptions.modifiers === "transform") {
	          regexpuOptions.onNewFlags = (flags) => {
	            newFlags = flags;
	          };
	        }
	        node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);
	        if (regexpuOptions.namedGroups === "transform" && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
	          const call = _core.types.callExpression(this.addHelper("wrapRegExp"), [node, _core.types.valueToNode(namedCaptureGroups)]);
	          (0, _helperAnnotateAsPure.default)(call);
	          path.replaceWith(call);
	        }
	        node.flags = (0, _util.transformFlags)(regexpuOptions, newFlags != null ? newFlags : node.flags);
	      }
	    }
	  };
	}
	function isRegExpTest(path) {
	  return path.parentPath.isMemberExpression({
	    object: path.node,
	    computed: false
	  }) && path.parentPath.get("property").isIdentifier({
	    name: "test"
	  });
	}
	return lib$P;
}

var hasRequiredLib$Q;

function requireLib$Q () {
	if (hasRequiredLib$Q) return lib$Q;
	hasRequiredLib$Q = 1;
	Object.defineProperty(lib$Q, "__esModule", {
	  value: true
	});
	lib$Q.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$Q.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-dotall-regex",
	    feature: "dotAllFlag"
	  });
	});
	return lib$Q;
}

var lib$O = {};

var hasRequiredLib$P;

function requireLib$P () {
	if (hasRequiredLib$P) return lib$O;
	hasRequiredLib$P = 1;
	Object.defineProperty(lib$O, "__esModule", {
	  value: true
	});
	lib$O.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	function getName(key) {
	  if (_core.types.isIdentifier(key)) {
	    return key.name;
	  }
	  return key.value.toString();
	}
	lib$O.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-duplicate-keys",
	    visitor: {
	      ObjectExpression(path) {
	        const {
	          node
	        } = path;
	        const plainProps = node.properties.filter((prop) => !_core.types.isSpreadElement(prop) && !prop.computed);
	        const alreadySeenData = /* @__PURE__ */ Object.create(null);
	        const alreadySeenGetters = /* @__PURE__ */ Object.create(null);
	        const alreadySeenSetters = /* @__PURE__ */ Object.create(null);
	        for (const prop of plainProps) {
	          const name = getName(prop.key);
	          let isDuplicate = false;
	          switch (prop.kind) {
	            case "get":
	              if (alreadySeenData[name] || alreadySeenGetters[name]) {
	                isDuplicate = true;
	              }
	              alreadySeenGetters[name] = true;
	              break;
	            case "set":
	              if (alreadySeenData[name] || alreadySeenSetters[name]) {
	                isDuplicate = true;
	              }
	              alreadySeenSetters[name] = true;
	              break;
	            default:
	              if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
	                isDuplicate = true;
	              }
	              alreadySeenData[name] = true;
	          }
	          if (isDuplicate) {
	            prop.computed = true;
	            prop.key = _core.types.stringLiteral(name);
	          }
	        }
	      }
	    }
	  };
	});
	return lib$O;
}

var lib$N = {};

var hasRequiredLib$O;

function requireLib$O () {
	if (hasRequiredLib$O) return lib$N;
	hasRequiredLib$O = 1;
	Object.defineProperty(lib$N, "__esModule", {
	  value: true
	});
	lib$N.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$N.default = (0, _helperPluginUtils.declare)((api, options) => {
	  api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    runtime
	  } = options;
	  if (runtime !== void 0 && typeof runtime !== "boolean") {
	    throw new Error("The 'runtime' option must be boolean");
	  }
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-duplicate-named-capturing-groups-regex",
	    feature: "duplicateNamedCaptureGroups",
	    options: {
	      runtime
	    }
	  });
	});
	return lib$N;
}

var lib$M = {};

var hasRequiredLib$N;

function requireLib$N () {
	if (hasRequiredLib$N) return lib$M;
	hasRequiredLib$N = 1;
	Object.defineProperty(lib$M, "__esModule", {
	  value: true
	});
	lib$M.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	const SUPPORTED_MODULES = /* @__PURE__ */ new Set(["commonjs", "amd", "systemjs"]);
	const MODULES_NOT_FOUND = `@babel/plugin-transform-dynamic-import depends on a modules
transform plugin. Supported plugins are:
 - @babel/plugin-transform-modules-commonjs ^7.4.0
 - @babel/plugin-transform-modules-amd ^7.4.0
 - @babel/plugin-transform-modules-systemjs ^7.4.0

If you are using Webpack or Rollup and thus don't want
Babel to transpile your imports and exports, you can use
the @babel/plugin-syntax-dynamic-import plugin and let your
bundler handle dynamic imports.
`;
	lib$M.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-dynamic-import",
	    manipulateOptions: (_, parser) => parser.plugins.push("dynamicImport"),
	    pre() {
	      this.file.set("@babel/plugin-proposal-dynamic-import", "7.27.1");
	    },
	    visitor: {
	      Program() {
	        const modules = this.file.get("@babel/plugin-transform-modules-*");
	        if (!SUPPORTED_MODULES.has(modules)) {
	          throw new Error(MODULES_NOT_FOUND);
	        }
	      }
	    }
	  };
	});
	return lib$M;
}

var lib$L = {};

var hasRequiredLib$M;

function requireLib$M () {
	if (hasRequiredLib$M) return lib$L;
	hasRequiredLib$M = 1;
	Object.defineProperty(lib$L, "__esModule", {
	  value: true
	});
	lib$L.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$L.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    types: t,
	    template
	  } = api;
	  function build(left, right) {
	    return t.callExpression(t.memberExpression(t.identifier("Math"), t.identifier("pow")), [left, right]);
	  }
	  function maybeMemoize(node, scope) {
	    if (scope.isStatic(node)) {
	      return {
	        assign: node,
	        ref: t.cloneNode(node)
	      };
	    }
	    if (scope.path.isPattern()) {
	      return null;
	    }
	    const id = scope.generateUidIdentifierBasedOnNode(node);
	    scope.push({
	      id
	    });
	    return {
	      assign: t.assignmentExpression("=", t.cloneNode(id), node),
	      ref: t.cloneNode(id)
	    };
	  }
	  return {
	    name: "transform-exponentiation-operator",
	    visitor: {
	      AssignmentExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        if (node.operator !== "**=") return;
	        if (t.isMemberExpression(node.left)) {
	          let member1;
	          let member2;
	          const object = maybeMemoize(node.left.object, scope);
	          if (!object) {
	            path.replaceWith(template.expression.ast`(() => ${path.node})()`);
	            return;
	          }
	          const {
	            property,
	            computed
	          } = node.left;
	          if (computed) {
	            const prop = maybeMemoize(property, scope);
	            member1 = t.memberExpression(object.assign, prop.assign, true);
	            member2 = t.memberExpression(object.ref, prop.ref, true);
	          } else {
	            member1 = t.memberExpression(object.assign, property, false);
	            member2 = t.memberExpression(object.ref, t.cloneNode(property), false);
	          }
	          path.replaceWith(t.assignmentExpression("=", member1, build(member2, node.right)));
	        } else {
	          path.replaceWith(t.assignmentExpression("=", node.left, build(t.cloneNode(node.left), node.right)));
	        }
	      },
	      BinaryExpression(path) {
	        const {
	          node
	        } = path;
	        if (node.operator === "**") {
	          path.replaceWith(build(node.left, node.right));
	        }
	      }
	    }
	  };
	});
	return lib$L;
}

var lib$K = {};

var hasRequiredLib$L;

function requireLib$L () {
	if (hasRequiredLib$L) return lib$K;
	hasRequiredLib$L = 1;
	Object.defineProperty(lib$K, "__esModule", {
	  value: true
	});
	lib$K.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$K.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-export-namespace-from",
	    manipulateOptions: (_, parser) => parser.plugins.push("exportNamespaceFrom"),
	    visitor: {
	      ExportNamedDeclaration(path) {
	        var _exported$name;
	        const {
	          node,
	          scope
	        } = path;
	        const {
	          specifiers
	        } = node;
	        const index = _core.types.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
	        if (!_core.types.isExportNamespaceSpecifier(specifiers[index])) return;
	        const nodes = [];
	        if (index === 1) {
	          nodes.push(_core.types.exportNamedDeclaration(null, [specifiers.shift()], node.source));
	        }
	        const specifier = specifiers.shift();
	        const {
	          exported
	        } = specifier;
	        const uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
	        nodes.push(_core.types.importDeclaration([_core.types.importNamespaceSpecifier(uid)], _core.types.cloneNode(node.source)), _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(uid), exported)]));
	        if (node.specifiers.length >= 1) {
	          nodes.push(node);
	        }
	        const [importDeclaration] = path.replaceWithMultiple(nodes);
	        path.scope.registerDeclaration(importDeclaration);
	      }
	    }
	  };
	});
	return lib$K;
}

var lib$J = {};

var noHelperImplementation = {};

var hasRequiredNoHelperImplementation;

function requireNoHelperImplementation () {
	if (hasRequiredNoHelperImplementation) return noHelperImplementation;
	hasRequiredNoHelperImplementation = 1;
	Object.defineProperty(noHelperImplementation, "__esModule", {
	  value: true
	});
	noHelperImplementation.default = transformWithoutHelper;
	var _core = require$$0$b;
	function transformWithoutHelper(loose, path, state) {
	  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
	  const {
	    node
	  } = path;
	  const build = pushComputedProps(path, state);
	  const declar = build.declar;
	  const loop = build.loop;
	  const block = loop.body;
	  path.ensureBlock();
	  if (declar) {
	    block.body.push(declar);
	  }
	  block.body.push(...node.body.body);
	  _core.types.inherits(loop, node);
	  _core.types.inherits(loop.body, node.body);
	  if (build.replaceParent) {
	    path.parentPath.replaceWithMultiple(build.node);
	    path.remove();
	  } else {
	    path.replaceWithMultiple(build.node);
	  }
	}
	const buildForOfLoose = _core.template.statement(`
  for (var LOOP_OBJECT = OBJECT,
          IS_ARRAY = Array.isArray(LOOP_OBJECT),
          INDEX = 0,
          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {
    INTERMEDIATE;
    if (IS_ARRAY) {
      if (INDEX >= LOOP_OBJECT.length) break;
      ID = LOOP_OBJECT[INDEX++];
    } else {
      INDEX = LOOP_OBJECT.next();
      if (INDEX.done) break;
      ID = INDEX.value;
    }
  }
`);
	const buildForOf = _core.template.statements(`
  var ITERATOR_COMPLETION = true;
  var ITERATOR_HAD_ERROR_KEY = false;
  var ITERATOR_ERROR_KEY = undefined;
  try {
    for (
      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;
      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);
      ITERATOR_COMPLETION = true
    ) {}
  } catch (err) {
    ITERATOR_HAD_ERROR_KEY = true;
    ITERATOR_ERROR_KEY = err;
  } finally {
    try {
      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {
        ITERATOR_KEY.return();
      }
    } finally {
      if (ITERATOR_HAD_ERROR_KEY) {
        throw ITERATOR_ERROR_KEY;
      }
    }
  }
`);
	function pushComputedPropsLoose(path, state) {
	  const {
	    node,
	    scope,
	    parent
	  } = path;
	  const {
	    left
	  } = node;
	  let declar, id, intermediate;
	  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
	    id = left;
	    intermediate = null;
	  } else if (_core.types.isVariableDeclaration(left)) {
	    id = scope.generateUidIdentifier("ref");
	    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name))]);
	    intermediate = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(id.name))]);
	  } else {
	    throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
	  }
	  const iteratorKey = scope.generateUidIdentifier("iterator");
	  const isArrayKey = scope.generateUidIdentifier("isArray");
	  const loop = buildForOfLoose({
	    LOOP_OBJECT: iteratorKey,
	    IS_ARRAY: isArrayKey,
	    OBJECT: node.right,
	    INDEX: scope.generateUidIdentifier("i"),
	    ID: id,
	    INTERMEDIATE: intermediate
	  });
	  const isLabeledParent = _core.types.isLabeledStatement(parent);
	  let labeled;
	  if (isLabeledParent) {
	    labeled = _core.types.labeledStatement(parent.label, loop);
	  }
	  return {
	    replaceParent: isLabeledParent,
	    declar,
	    node: labeled || loop,
	    loop
	  };
	}
	function pushComputedPropsSpec(path, state) {
	  const {
	    node,
	    scope,
	    parent
	  } = path;
	  const left = node.left;
	  let declar;
	  const stepKey = scope.generateUid("step");
	  const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
	  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
	    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
	  } else if (_core.types.isVariableDeclaration(left)) {
	    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
	  } else {
	    throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
	  }
	  const template = buildForOf({
	    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
	    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
	    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
	    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
	    STEP_KEY: _core.types.identifier(stepKey),
	    OBJECT: node.right
	  });
	  const isLabeledParent = _core.types.isLabeledStatement(parent);
	  const tryBody = template[3].block.body;
	  const loop = tryBody[0];
	  if (isLabeledParent) {
	    tryBody[0] = _core.types.labeledStatement(parent.label, loop);
	  }
	  return {
	    replaceParent: isLabeledParent,
	    declar,
	    loop,
	    node: template
	  };
	}
	return noHelperImplementation;
}

var hasRequiredLib$K;

function requireLib$K () {
	if (hasRequiredLib$K) return lib$J;
	hasRequiredLib$K = 1;
	Object.defineProperty(lib$J, "__esModule", {
	  value: true
	});
	lib$J.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	var _noHelperImplementation = requireNoHelperImplementation();
	var _helperSkipTransparentExpressionWrappers = requireLib$X();
	function buildLoopBody(path, declar, newBody) {
	  let block;
	  const bodyPath = path.get("body");
	  const body = newBody != null ? newBody : bodyPath.node;
	  if (_core.types.isBlockStatement(body) && Object.keys(path.getBindingIdentifiers()).some((id) => bodyPath.scope.hasOwnBinding(id))) {
	    block = _core.types.blockStatement([declar, body]);
	  } else {
	    block = _core.types.toBlock(body);
	    block.body.unshift(declar);
	  }
	  return block;
	}
	lib$J.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _options$assumeArray, _options$allowArrayLi, _api$assumption;
	  api.assertVersion(7);
	  {
	    const {
	      assumeArray,
	      allowArrayLike,
	      loose
	    } = options;
	    if (loose === true && assumeArray === true) {
	      throw new Error(`The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`);
	    }
	    if (assumeArray === true && allowArrayLike === true) {
	      throw new Error(`The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of`);
	    }
	    {
	      if (allowArrayLike && /^7\.\d\./.test(api.version)) {
	        throw new Error(`The allowArrayLike is only supported when using @babel/core@^7.10.0`);
	      }
	    }
	  }
	  const iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
	  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
	  const skipIteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;
	  if (iterableIsArray && arrayLikeIsIterable) {
	    throw new Error(`The "iterableIsArray" and "arrayLikeIsIterable" assumptions are not compatible.`);
	  }
	  if (iterableIsArray) {
	    return {
	      name: "transform-for-of",
	      visitor: {
	        ForOfStatement(path) {
	          const {
	            scope
	          } = path;
	          const {
	            left,
	            await: isAwait
	          } = path.node;
	          if (isAwait) {
	            return;
	          }
	          const right = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(path.node.right);
	          const i = scope.generateUidIdentifier("i");
	          let array = scope.maybeGenerateMemoised(right, true);
	          if (!array && _core.types.isIdentifier(right) && path.get("body").scope.hasOwnBinding(right.name)) {
	            array = scope.generateUidIdentifier("arr");
	          }
	          const inits = [_core.types.variableDeclarator(i, _core.types.numericLiteral(0))];
	          if (array) {
	            inits.push(_core.types.variableDeclarator(array, right));
	          } else {
	            array = right;
	          }
	          const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), true);
	          let assignment;
	          if (_core.types.isVariableDeclaration(left)) {
	            assignment = left;
	            assignment.declarations[0].init = item;
	          } else {
	            assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
	          }
	          path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), buildLoopBody(path, assignment)));
	        }
	      }
	    };
	  }
	  const buildForOfArray = (0, _core.template)`
    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;
  `;
	  const buildForOfNoIteratorClosing = _core.template.statements`
    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;
  `;
	  const buildForOf = _core.template.statements`
    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
    try {
      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;
    } catch (err) {
      ITERATOR_HELPER.e(err);
    } finally {
      ITERATOR_HELPER.f();
    }
  `;
	  const builder = skipIteratorClosing ? {
	    build: buildForOfNoIteratorClosing,
	    helper: "createForOfIteratorHelperLoose",
	    getContainer: (nodes) => nodes
	  } : {
	    build: buildForOf,
	    helper: "createForOfIteratorHelper",
	    getContainer: (nodes) => nodes[1].block.body
	  };
	  function _ForOfStatementArray(path) {
	    const {
	      node,
	      scope
	    } = path;
	    const right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
	    const iterationKey = scope.generateUidIdentifier("i");
	    const loop = buildForOfArray({
	      BODY: node.body,
	      KEY: iterationKey,
	      NAME: right,
	      ARR: node.right
	    });
	    _core.types.inherits(loop, node);
	    const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), true);
	    let declar;
	    const left = node.left;
	    if (_core.types.isVariableDeclaration(left)) {
	      left.declarations[0].init = iterationValue;
	      declar = left;
	    } else {
	      declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue));
	    }
	    loop.body = buildLoopBody(path, declar, loop.body);
	    return loop;
	  }
	  return {
	    name: "transform-for-of",
	    visitor: {
	      ForOfStatement(path, state) {
	        const right = path.get("right");
	        if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) {
	          path.replaceWith(_ForOfStatementArray(path));
	          return;
	        }
	        {
	          if (!state.availableHelper(builder.helper)) {
	            (0, _noHelperImplementation.default)(skipIteratorClosing, path, state);
	            return;
	          }
	        }
	        const {
	          node,
	          parent,
	          scope
	        } = path;
	        const left = node.left;
	        let declar;
	        const stepKey = scope.generateUid("step");
	        const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
	        if (_core.types.isVariableDeclaration(left)) {
	          declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);
	        } else {
	          declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
	        }
	        const nodes = builder.build({
	          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
	          ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
	          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? _core.types.booleanLiteral(true) : null,
	          STEP_KEY: _core.types.identifier(stepKey),
	          OBJECT: node.right,
	          BODY: buildLoopBody(path, declar)
	        });
	        const container = builder.getContainer(nodes);
	        _core.types.inherits(container[0], node);
	        _core.types.inherits(container[0].body, node.body);
	        if (_core.types.isLabeledStatement(parent)) {
	          container[0] = _core.types.labeledStatement(parent.label, container[0]);
	          path.parentPath.replaceWithMultiple(nodes);
	          path.skip();
	        } else {
	          path.replaceWithMultiple(nodes);
	        }
	      }
	    }
	  };
	});
	return lib$J;
}

var lib$I = {};

var hasRequiredLib$J;

function requireLib$J () {
	if (hasRequiredLib$J) return lib$I;
	hasRequiredLib$J = 1;
	Object.defineProperty(lib$I, "__esModule", {
	  value: true
	});
	lib$I.default = void 0;
	var _helperCompilationTargets = requireLib$1g();
	var _helperPluginUtils = requireLib$1f();
	lib$I.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
	  return {
	    name: "transform-function-name",
	    visitor: {
	      FunctionExpression: {
	        exit(path) {
	          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
	            {
	              var _path$ensureFunctionN;
	              (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	            }
	            path.ensureFunctionName(supportUnicodeId);
	          }
	        }
	      },
	      ObjectProperty(path) {
	        const value = path.get("value");
	        if (value.isFunction()) {
	          {
	            var _value$ensureFunction;
	            (_value$ensureFunction = value.ensureFunctionName) != null ? _value$ensureFunction : value.ensureFunctionName = require$$2$2.NodePath.prototype.ensureFunctionName;
	          }
	          value.ensureFunctionName(supportUnicodeId);
	        }
	      }
	    }
	  };
	});
	return lib$I;
}

var lib$H = {};

var hasRequiredLib$I;

function requireLib$I () {
	if (hasRequiredLib$I) return lib$H;
	hasRequiredLib$I = 1;
	Object.defineProperty(lib$H, "__esModule", {
	  value: true
	});
	lib$H.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$H.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const regex = /(\\*)([\u2028\u2029])/g;
	  function replace(match, escapes, separator) {
	    const isEscaped = escapes.length % 2 === 1;
	    if (isEscaped) return match;
	    return `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
	  }
	  return {
	    name: "transform-json-strings",
	    manipulateOptions: (_, parser) => parser.plugins.push("jsonStrings"),
	    visitor: {
	      "DirectiveLiteral|StringLiteral"({
	        node
	      }) {
	        const {
	          extra
	        } = node;
	        if (!(extra != null && extra.raw)) return;
	        extra.raw = extra.raw.replace(regex, replace);
	      }
	    }
	  };
	});
	return lib$H;
}

var lib$G = {};

var hasRequiredLib$H;

function requireLib$H () {
	if (hasRequiredLib$H) return lib$G;
	hasRequiredLib$H = 1;
	Object.defineProperty(lib$G, "__esModule", {
	  value: true
	});
	lib$G.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$G.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-literals",
	    visitor: {
	      NumericLiteral({
	        node
	      }) {
	        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
	          node.extra = void 0;
	        }
	      },
	      StringLiteral({
	        node
	      }) {
	        if (node.extra && /\\u/i.test(node.extra.raw)) {
	          node.extra = void 0;
	        }
	      }
	    }
	  };
	});
	return lib$G;
}

var lib$F = {};

var hasRequiredLib$G;

function requireLib$G () {
	if (hasRequiredLib$G) return lib$F;
	hasRequiredLib$G = 1;
	Object.defineProperty(lib$F, "__esModule", {
	  value: true
	});
	lib$F.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$F.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return {
	    name: "transform-logical-assignment-operators",
	    manipulateOptions: (_, parser) => parser.plugins.push("logicalAssignment"),
	    visitor: {
	      AssignmentExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        const {
	          operator,
	          left,
	          right
	        } = node;
	        const operatorTrunc = operator.slice(0, -1);
	        if (!_core.types.LOGICAL_OPERATORS.includes(operatorTrunc)) {
	          return;
	        }
	        const lhs = _core.types.cloneNode(left);
	        if (_core.types.isMemberExpression(left)) {
	          const {
	            object,
	            property,
	            computed
	          } = left;
	          const memo = scope.maybeGenerateMemoised(object);
	          if (memo) {
	            left.object = memo;
	            lhs.object = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), object);
	          }
	          if (computed) {
	            const memo2 = scope.maybeGenerateMemoised(property);
	            if (memo2) {
	              left.property = memo2;
	              lhs.property = _core.types.assignmentExpression("=", _core.types.cloneNode(memo2), property);
	            }
	          }
	        }
	        path.replaceWith(_core.types.logicalExpression(operatorTrunc, lhs, _core.types.assignmentExpression("=", left, right)));
	      }
	    }
	  };
	});
	return lib$F;
}

var lib$E = {};

var hasRequiredLib$F;

function requireLib$F () {
	if (hasRequiredLib$F) return lib$E;
	hasRequiredLib$F = 1;
	Object.defineProperty(lib$E, "__esModule", {
	  value: true
	});
	lib$E.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$E.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-member-expression-literals",
	    visitor: {
	      MemberExpression: {
	        exit({
	          node
	        }) {
	          const prop = node.property;
	          if (!node.computed && _core.types.isIdentifier(prop) && !_core.types.isValidES3Identifier(prop.name)) {
	            node.property = _core.types.stringLiteral(prop.name);
	            node.computed = true;
	          }
	        }
	      }
	    }
	  };
	});
	return lib$E;
}

var lib$D = {};

var lib$C = {};

var rewriteThis = {};

var hasRequiredRewriteThis;

function requireRewriteThis () {
	if (hasRequiredRewriteThis) return rewriteThis;
	hasRequiredRewriteThis = 1;
	Object.defineProperty(rewriteThis, "__esModule", {
	  value: true
	});
	rewriteThis.default = rewriteThis$1;
	var _core = require$$0$b;
	var _traverse = require$$2$2;
	let rewriteThisVisitor;
	function rewriteThis$1(programPath) {
	  if (!rewriteThisVisitor) {
	    rewriteThisVisitor = _traverse.visitors.environmentVisitor({
	      ThisExpression(path) {
	        path.replaceWith(_core.types.unaryExpression("void", _core.types.numericLiteral(0), true));
	      }
	    });
	    rewriteThisVisitor.noScope = true;
	  }
	  (0, _traverse.default)(programPath.node, rewriteThisVisitor);
	}
	return rewriteThis;
}

var rewriteLiveReferences = {};

var hasRequiredRewriteLiveReferences;

function requireRewriteLiveReferences () {
	if (hasRequiredRewriteLiveReferences) return rewriteLiveReferences;
	hasRequiredRewriteLiveReferences = 1;
	Object.defineProperty(rewriteLiveReferences, "__esModule", {
	  value: true
	});
	rewriteLiveReferences.default = rewriteLiveReferences$1;
	var _core = require$$0$b;
	function isInType(path) {
	  do {
	    switch (path.parent.type) {
	      case "TSTypeAnnotation":
	      case "TSTypeAliasDeclaration":
	      case "TSTypeReference":
	      case "TypeAnnotation":
	      case "TypeAlias":
	        return true;
	      case "ExportSpecifier":
	        return path.parentPath.parent.exportKind === "type";
	      default:
	        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {
	          return false;
	        }
	    }
	  } while (path = path.parentPath);
	}
	function rewriteLiveReferences$1(programPath, metadata, wrapReference) {
	  const imported = /* @__PURE__ */ new Map();
	  const exported = /* @__PURE__ */ new Map();
	  const requeueInParent = (path) => {
	    programPath.requeue(path);
	  };
	  for (const [source, data] of metadata.source) {
	    for (const [localName, importName] of data.imports) {
	      imported.set(localName, [source, importName, null]);
	    }
	    for (const localName of data.importsNamespace) {
	      imported.set(localName, [source, null, localName]);
	    }
	  }
	  for (const [local, data] of metadata.local) {
	    let exportMeta = exported.get(local);
	    if (!exportMeta) {
	      exportMeta = [];
	      exported.set(local, exportMeta);
	    }
	    exportMeta.push(...data.names);
	  }
	  const rewriteBindingInitVisitorState = {
	    metadata,
	    requeueInParent,
	    scope: programPath.scope,
	    exported
	  };
	  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
	  const rewriteReferencesVisitorState = {
	    seen: /* @__PURE__ */ new WeakSet(),
	    metadata,
	    requeueInParent,
	    scope: programPath.scope,
	    imported,
	    exported,
	    buildImportReference([source, importName, localName], identNode) {
	      const meta = metadata.source.get(source);
	      meta.referenced = true;
	      if (localName) {
	        if (meta.wrap) {
	          var _wrapReference;
	          identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
	        }
	        return identNode;
	      }
	      let namespace = _core.types.identifier(meta.name);
	      if (meta.wrap) {
	        var _wrapReference2;
	        namespace = (_wrapReference2 = wrapReference(namespace, meta.wrap)) != null ? _wrapReference2 : namespace;
	      }
	      if (importName === "default" && meta.interop === "node-default") {
	        return namespace;
	      }
	      const computed = metadata.stringSpecifiers.has(importName);
	      return _core.types.memberExpression(namespace, computed ? _core.types.stringLiteral(importName) : _core.types.identifier(importName), computed);
	    }
	  };
	  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
	}
	const rewriteBindingInitVisitor = {
	  Scope(path) {
	    path.skip();
	  },
	  ClassDeclaration(path) {
	    const {
	      requeueInParent,
	      exported,
	      metadata
	    } = this;
	    const {
	      id
	    } = path.node;
	    if (!id) throw new Error("Expected class to have a name");
	    const localName = id.name;
	    const exportNames = exported.get(localName) || [];
	    if (exportNames.length > 0) {
	      const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, _core.types.identifier(localName), path.scope));
	      statement._blockHoist = path.node._blockHoist;
	      requeueInParent(path.insertAfter(statement)[0]);
	    }
	  },
	  VariableDeclaration(path) {
	    const {
	      requeueInParent,
	      exported,
	      metadata
	    } = this;
	    const isVar = path.node.kind === "var";
	    for (const decl of path.get("declarations")) {
	      const {
	        id
	      } = decl.node;
	      let {
	        init
	      } = decl.node;
	      if (_core.types.isIdentifier(id) && exported.has(id.name) && !_core.types.isArrowFunctionExpression(init) && (!_core.types.isFunctionExpression(init) || init.id) && (!_core.types.isClassExpression(init) || init.id)) {
	        if (!init) {
	          if (isVar) {
	            continue;
	          } else {
	            init = path.scope.buildUndefinedNode();
	          }
	        }
	        decl.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id.name), init, path.scope);
	        requeueInParent(decl.get("init"));
	      } else {
	        for (const localName of Object.keys(decl.getOuterBindingIdentifiers())) {
	          if (exported.has(localName)) {
	            const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), _core.types.identifier(localName), path.scope));
	            statement._blockHoist = path.node._blockHoist;
	            requeueInParent(path.insertAfter(statement)[0]);
	          }
	        }
	      }
	    }
	  }
	};
	const buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
	  const exportsObjectName = metadata.exportName;
	  for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent) {
	    if (currentScope.hasOwnBinding(exportsObjectName)) {
	      currentScope.rename(exportsObjectName);
	    }
	  }
	  return (exportNames || []).reduce((expr, exportName) => {
	    const {
	      stringSpecifiers
	    } = metadata;
	    const computed = stringSpecifiers.has(exportName);
	    return _core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportsObjectName), computed ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), computed), expr);
	  }, localExpr);
	};
	const buildImportThrow = (localName) => {
	  return _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `;
	};
	const rewriteReferencesVisitor = {
	  ReferencedIdentifier(path) {
	    const {
	      seen,
	      buildImportReference,
	      scope,
	      imported,
	      requeueInParent
	    } = this;
	    if (seen.has(path.node)) return;
	    seen.add(path.node);
	    const localName = path.node.name;
	    const importData = imported.get(localName);
	    if (importData) {
	      if (isInType(path)) {
	        throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
	      }
	      const localBinding = path.scope.getBinding(localName);
	      const rootBinding = scope.getBinding(localName);
	      if (rootBinding !== localBinding) return;
	      const ref = buildImportReference(importData, path.node);
	      ref.loc = path.node.loc;
	      if ((path.parentPath.isCallExpression({
	        callee: path.node
	      }) || path.parentPath.isOptionalCallExpression({
	        callee: path.node
	      }) || path.parentPath.isTaggedTemplateExpression({
	        tag: path.node
	      })) && _core.types.isMemberExpression(ref)) {
	        path.replaceWith(_core.types.sequenceExpression([_core.types.numericLiteral(0), ref]));
	      } else if (path.isJSXIdentifier() && _core.types.isMemberExpression(ref)) {
	        const {
	          object,
	          property
	        } = ref;
	        path.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object.name), _core.types.jsxIdentifier(property.name)));
	      } else {
	        path.replaceWith(ref);
	      }
	      requeueInParent(path);
	      path.skip();
	    }
	  },
	  UpdateExpression(path) {
	    const {
	      scope,
	      seen,
	      imported,
	      exported,
	      requeueInParent,
	      buildImportReference
	    } = this;
	    if (seen.has(path.node)) return;
	    seen.add(path.node);
	    const arg = path.get("argument");
	    if (arg.isMemberExpression()) return;
	    const update = path.node;
	    if (arg.isIdentifier()) {
	      const localName = arg.node.name;
	      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
	        return;
	      }
	      const exportedNames = exported.get(localName);
	      const importData = imported.get(localName);
	      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
	        if (importData) {
	          path.replaceWith(_core.types.assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
	        } else if (update.prefix) {
	          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.cloneNode(update), path.scope));
	        } else {
	          const ref = scope.generateDeclaredUidIdentifier(localName);
	          path.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(ref), _core.types.cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope), _core.types.cloneNode(ref)]));
	        }
	      }
	    }
	    requeueInParent(path);
	    path.skip();
	  },
	  AssignmentExpression: {
	    exit(path) {
	      const {
	        scope,
	        seen,
	        imported,
	        exported,
	        requeueInParent,
	        buildImportReference
	      } = this;
	      if (seen.has(path.node)) return;
	      seen.add(path.node);
	      const left = path.get("left");
	      if (left.isMemberExpression()) return;
	      if (left.isIdentifier()) {
	        const localName = left.node.name;
	        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
	          return;
	        }
	        const exportedNames = exported.get(localName);
	        const importData = imported.get(localName);
	        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
	          const assignment = path.node;
	          if (importData) {
	            assignment.left = buildImportReference(importData, left.node);
	            assignment.right = _core.types.sequenceExpression([assignment.right, buildImportThrow(localName)]);
	          }
	          const {
	            operator
	          } = assignment;
	          let newExpr;
	          if (operator === "=") {
	            newExpr = assignment;
	          } else if (operator === "&&=" || operator === "||=" || operator === "??=") {
	            newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.logicalExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
	          } else {
	            newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.binaryExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
	          }
	          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, newExpr, path.scope));
	          requeueInParent(path);
	          path.skip();
	        }
	      } else {
	        const ids = left.getOuterBindingIdentifiers();
	        const programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path.scope.getBinding(localName));
	        const id = programScopeIds.find((localName) => imported.has(localName));
	        if (id) {
	          path.node.right = _core.types.sequenceExpression([path.node.right, buildImportThrow(id)]);
	        }
	        const items = [];
	        programScopeIds.forEach((localName) => {
	          const exportedNames = exported.get(localName) || [];
	          if (exportedNames.length > 0) {
	            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope));
	          }
	        });
	        if (items.length > 0) {
	          let node = _core.types.sequenceExpression(items);
	          if (path.parentPath.isExpressionStatement()) {
	            node = _core.types.expressionStatement(node);
	            node._blockHoist = path.parentPath.node._blockHoist;
	          }
	          const statement = path.insertAfter(node)[0];
	          requeueInParent(statement);
	        }
	      }
	    }
	  },
	  ForXStatement(path) {
	    const {
	      scope,
	      node
	    } = path;
	    const {
	      left
	    } = node;
	    const {
	      exported,
	      imported,
	      scope: programScope
	    } = this;
	    if (!_core.types.isVariableDeclaration(left)) {
	      let didTransformExport = false, importConstViolationName;
	      const loopBodyScope = path.get("body").scope;
	      for (const name of Object.keys(_core.types.getOuterBindingIdentifiers(left))) {
	        if (programScope.getBinding(name) === scope.getBinding(name)) {
	          if (exported.has(name)) {
	            didTransformExport = true;
	            if (loopBodyScope.hasOwnBinding(name)) {
	              loopBodyScope.rename(name);
	            }
	          }
	          if (imported.has(name) && !importConstViolationName) {
	            importConstViolationName = name;
	          }
	        }
	      }
	      if (!didTransformExport && !importConstViolationName) {
	        return;
	      }
	      path.ensureBlock();
	      const bodyPath = path.get("body");
	      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);
	      path.get("left").replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(newLoopId))]));
	      scope.registerDeclaration(path.get("left"));
	      if (didTransformExport) {
	        bodyPath.unshiftContainer("body", _core.types.expressionStatement(_core.types.assignmentExpression("=", left, newLoopId)));
	      }
	      if (importConstViolationName) {
	        bodyPath.unshiftContainer("body", _core.types.expressionStatement(buildImportThrow(importConstViolationName)));
	      }
	    }
	  }
	};
	return rewriteLiveReferences;
}

var normalizeAndLoadMetadata = {};

var hasRequiredNormalizeAndLoadMetadata;

function requireNormalizeAndLoadMetadata () {
	if (hasRequiredNormalizeAndLoadMetadata) return normalizeAndLoadMetadata;
	hasRequiredNormalizeAndLoadMetadata = 1;
	Object.defineProperty(normalizeAndLoadMetadata, "__esModule", {
	  value: true
	});
	normalizeAndLoadMetadata.default = normalizeModuleAndLoadMetadata;
	normalizeAndLoadMetadata.hasExports = hasExports;
	normalizeAndLoadMetadata.isSideEffectImport = isSideEffectImport;
	normalizeAndLoadMetadata.validateImportInteropOption = validateImportInteropOption;
	var _path = require$$0$9;
	var _helperValidatorIdentifier = requireLib$1b();
	function hasExports(metadata) {
	  return metadata.hasExports;
	}
	function isSideEffectImport(source) {
	  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
	}
	function validateImportInteropOption(importInterop) {
	  if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
	    throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
	  }
	  return importInterop;
	}
	function resolveImportInterop(importInterop, source, filename) {
	  if (typeof importInterop === "function") {
	    return validateImportInteropOption(importInterop(source, filename));
	  }
	  return importInterop;
	}
	function normalizeModuleAndLoadMetadata(programPath, exportName, {
	  importInterop,
	  initializeReexports = false,
	  getWrapperPayload,
	  esNamespaceOnly = false,
	  filename
	}) {
	  if (!exportName) {
	    exportName = programPath.scope.generateUidIdentifier("exports").name;
	  }
	  const stringSpecifiers = /* @__PURE__ */ new Set();
	  nameAnonymousExports(programPath);
	  const {
	    local,
	    sources,
	    hasExports: hasExports2
	  } = getModuleMetadata(programPath, {
	    initializeReexports,
	    getWrapperPayload
	  }, stringSpecifiers);
	  removeImportExportDeclarations(programPath);
	  for (const [source, metadata] of sources) {
	    const {
	      importsNamespace,
	      imports
	    } = metadata;
	    if (importsNamespace.size > 0 && imports.size === 0) {
	      const [nameOfnamespace] = importsNamespace;
	      metadata.name = nameOfnamespace;
	    }
	    const resolvedInterop = resolveImportInterop(importInterop, source, filename);
	    if (resolvedInterop === "none") {
	      metadata.interop = "none";
	    } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
	      metadata.interop = "node-namespace";
	    } else if (resolvedInterop === "node" && metadata.interop === "default") {
	      metadata.interop = "node-default";
	    } else if (esNamespaceOnly && metadata.interop === "namespace") {
	      metadata.interop = "default";
	    }
	  }
	  return {
	    exportName,
	    exportNameListName: null,
	    hasExports: hasExports2,
	    local,
	    source: sources,
	    stringSpecifiers
	  };
	}
	function getExportSpecifierName(path, stringSpecifiers) {
	  if (path.isIdentifier()) {
	    return path.node.name;
	  } else if (path.isStringLiteral()) {
	    const stringValue = path.node.value;
	    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
	      stringSpecifiers.add(stringValue);
	    }
	    return stringValue;
	  } else {
	    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
	  }
	}
	function assertExportSpecifier(path) {
	  if (path.isExportSpecifier()) {
	    return;
	  } else if (path.isExportNamespaceSpecifier()) {
	    throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
	  } else {
	    throw path.buildCodeFrameError("Unexpected export specifier type");
	  }
	}
	function getModuleMetadata(programPath, {
	  getWrapperPayload,
	  initializeReexports
	}, stringSpecifiers) {
	  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
	  const importNodes = /* @__PURE__ */ new Map();
	  const sourceData = /* @__PURE__ */ new Map();
	  const getData = (sourceNode, node) => {
	    const source = sourceNode.value;
	    let data = sourceData.get(source);
	    if (!data) {
	      data = {
	        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
	        interop: "none",
	        loc: null,
	        imports: /* @__PURE__ */ new Map(),
	        importsNamespace: /* @__PURE__ */ new Set(),
	        reexports: /* @__PURE__ */ new Map(),
	        reexportNamespace: /* @__PURE__ */ new Set(),
	        reexportAll: null,
	        wrap: null,
	        get lazy() {
	          return this.wrap === "lazy";
	        },
	        referenced: false
	      };
	      sourceData.set(source, data);
	      importNodes.set(source, [node]);
	    } else {
	      importNodes.get(source).push(node);
	    }
	    return data;
	  };
	  let hasExports2 = false;
	  programPath.get("body").forEach((child) => {
	    if (child.isImportDeclaration()) {
	      const data = getData(child.node.source, child.node);
	      if (!data.loc) data.loc = child.node.loc;
	      child.get("specifiers").forEach((spec) => {
	        if (spec.isImportDefaultSpecifier()) {
	          const localName = spec.get("local").node.name;
	          data.imports.set(localName, "default");
	          const reexport = localData.get(localName);
	          if (reexport) {
	            localData.delete(localName);
	            reexport.names.forEach((name) => {
	              data.reexports.set(name, "default");
	            });
	            data.referenced = true;
	          }
	        } else if (spec.isImportNamespaceSpecifier()) {
	          const localName = spec.get("local").node.name;
	          data.importsNamespace.add(localName);
	          const reexport = localData.get(localName);
	          if (reexport) {
	            localData.delete(localName);
	            reexport.names.forEach((name) => {
	              data.reexportNamespace.add(name);
	            });
	            data.referenced = true;
	          }
	        } else if (spec.isImportSpecifier()) {
	          const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
	          const localName = spec.get("local").node.name;
	          data.imports.set(localName, importName);
	          const reexport = localData.get(localName);
	          if (reexport) {
	            localData.delete(localName);
	            reexport.names.forEach((name) => {
	              data.reexports.set(name, importName);
	            });
	            data.referenced = true;
	          }
	        }
	      });
	    } else if (child.isExportAllDeclaration()) {
	      hasExports2 = true;
	      const data = getData(child.node.source, child.node);
	      if (!data.loc) data.loc = child.node.loc;
	      data.reexportAll = {
	        loc: child.node.loc
	      };
	      data.referenced = true;
	    } else if (child.isExportNamedDeclaration() && child.node.source) {
	      hasExports2 = true;
	      const data = getData(child.node.source, child.node);
	      if (!data.loc) data.loc = child.node.loc;
	      child.get("specifiers").forEach((spec) => {
	        assertExportSpecifier(spec);
	        const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
	        const exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
	        data.reexports.set(exportName, importName);
	        data.referenced = true;
	        if (exportName === "__esModule") {
	          throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
	        }
	      });
	    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
	      hasExports2 = true;
	    }
	  });
	  for (const metadata of sourceData.values()) {
	    let needsDefault = false;
	    let needsNamed = false;
	    if (metadata.importsNamespace.size > 0) {
	      needsDefault = true;
	      needsNamed = true;
	    }
	    if (metadata.reexportAll) {
	      needsNamed = true;
	    }
	    for (const importName of metadata.imports.values()) {
	      if (importName === "default") needsDefault = true;
	      else needsNamed = true;
	    }
	    for (const importName of metadata.reexports.values()) {
	      if (importName === "default") needsDefault = true;
	      else needsNamed = true;
	    }
	    if (needsDefault && needsNamed) {
	      metadata.interop = "namespace";
	    } else if (needsDefault) {
	      metadata.interop = "default";
	    }
	  }
	  if (getWrapperPayload) {
	    for (const [source, metadata] of sourceData) {
	      metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
	    }
	  }
	  return {
	    hasExports: hasExports2,
	    local: localData,
	    sources: sourceData
	  };
	}
	function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
	  const bindingKindLookup = /* @__PURE__ */ new Map();
	  const programScope = programPath.scope;
	  const programChildren = programPath.get("body");
	  programChildren.forEach((child) => {
	    let kind;
	    if (child.isImportDeclaration()) {
	      kind = "import";
	    } else {
	      if (child.isExportDefaultDeclaration()) {
	        child = child.get("declaration");
	      }
	      if (child.isExportNamedDeclaration()) {
	        if (child.node.declaration) {
	          child = child.get("declaration");
	        } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
	          child.get("specifiers").forEach((spec) => {
	            assertExportSpecifier(spec);
	            bindingKindLookup.set(spec.get("local").node.name, "block");
	          });
	          return;
	        }
	      }
	      if (child.isFunctionDeclaration()) {
	        kind = "hoisted";
	      } else if (child.isClassDeclaration()) {
	        kind = "block";
	      } else if (child.isVariableDeclaration({
	        kind: "var"
	      })) {
	        kind = "var";
	      } else if (child.isVariableDeclaration()) {
	        kind = "block";
	      } else {
	        return;
	      }
	    }
	    Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
	      bindingKindLookup.set(name, kind);
	    });
	  });
	  const localMetadata = /* @__PURE__ */ new Map();
	  const getLocalMetadata = (idPath) => {
	    const localName = idPath.node.name;
	    let metadata = localMetadata.get(localName);
	    if (!metadata) {
	      var _bindingKindLookup$ge, _programScope$getBind;
	      const kind = (_bindingKindLookup$ge = bindingKindLookup.get(localName)) != null ? _bindingKindLookup$ge : (_programScope$getBind = programScope.getBinding(localName)) == null ? void 0 : _programScope$getBind.kind;
	      if (kind === void 0) {
	        throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
	      }
	      metadata = {
	        names: [],
	        kind
	      };
	      localMetadata.set(localName, metadata);
	    }
	    return metadata;
	  };
	  programChildren.forEach((child) => {
	    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
	      if (child.node.declaration) {
	        const declaration = child.get("declaration");
	        const ids = declaration.getOuterBindingIdentifierPaths();
	        Object.keys(ids).forEach((name) => {
	          if (name === "__esModule") {
	            throw declaration.buildCodeFrameError('Illegal export "__esModule".');
	          }
	          getLocalMetadata(ids[name]).names.push(name);
	        });
	      } else {
	        child.get("specifiers").forEach((spec) => {
	          const local = spec.get("local");
	          const exported = spec.get("exported");
	          const localMetadata2 = getLocalMetadata(local);
	          const exportName = getExportSpecifierName(exported, stringSpecifiers);
	          if (exportName === "__esModule") {
	            throw exported.buildCodeFrameError('Illegal export "__esModule".');
	          }
	          localMetadata2.names.push(exportName);
	        });
	      }
	    } else if (child.isExportDefaultDeclaration()) {
	      const declaration = child.get("declaration");
	      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
	        getLocalMetadata(declaration.get("id")).names.push("default");
	      } else {
	        throw declaration.buildCodeFrameError("Unexpected default expression export.");
	      }
	    }
	  });
	  return localMetadata;
	}
	function nameAnonymousExports(programPath) {
	  programPath.get("body").forEach((child) => {
	    if (!child.isExportDefaultDeclaration()) return;
	    {
	      var _child$splitExportDec;
	      (_child$splitExportDec = child.splitExportDeclaration) != null ? _child$splitExportDec : child.splitExportDeclaration = require$$2$2.NodePath.prototype.splitExportDeclaration;
	    }
	    child.splitExportDeclaration();
	  });
	}
	function removeImportExportDeclarations(programPath) {
	  programPath.get("body").forEach((child) => {
	    if (child.isImportDeclaration()) {
	      child.remove();
	    } else if (child.isExportNamedDeclaration()) {
	      if (child.node.declaration) {
	        child.node.declaration._blockHoist = child.node._blockHoist;
	        child.replaceWith(child.node.declaration);
	      } else {
	        child.remove();
	      }
	    } else if (child.isExportDefaultDeclaration()) {
	      const declaration = child.get("declaration");
	      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
	        declaration._blockHoist = child.node._blockHoist;
	        child.replaceWith(declaration);
	      } else {
	        throw declaration.buildCodeFrameError("Unexpected default expression export.");
	      }
	    } else if (child.isExportAllDeclaration()) {
	      child.remove();
	    }
	  });
	}
	return normalizeAndLoadMetadata;
}

var lazyModules = {};

var hasRequiredLazyModules;

function requireLazyModules () {
	if (hasRequiredLazyModules) return lazyModules;
	hasRequiredLazyModules = 1;
	Object.defineProperty(lazyModules, "__esModule", {
	  value: true
	});
	lazyModules.toGetWrapperPayload = toGetWrapperPayload;
	lazyModules.wrapReference = wrapReference;
	var _core = require$$0$b;
	var _normalizeAndLoadMetadata = requireNormalizeAndLoadMetadata();
	function toGetWrapperPayload(lazy) {
	  return (source, metadata) => {
	    if (lazy === false) return null;
	    if ((0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) || metadata.reexportAll) return null;
	    if (lazy === true) {
	      return source.includes(".") ? null : "lazy";
	    }
	    if (Array.isArray(lazy)) {
	      return !lazy.includes(source) ? null : "lazy";
	    }
	    if (typeof lazy === "function") {
	      return lazy(source) ? "lazy" : null;
	    }
	    throw new Error(`.lazy must be a boolean, string array, or function`);
	  };
	}
	function wrapReference(ref, payload) {
	  if (payload === "lazy") return _core.types.callExpression(ref, []);
	  return null;
	}
	return lazyModules;
}

var dynamicImport$1 = {};

var hasRequiredDynamicImport$1;

function requireDynamicImport$1 () {
	if (hasRequiredDynamicImport$1) return dynamicImport$1;
	hasRequiredDynamicImport$1 = 1;
	Object.defineProperty(dynamicImport$1, "__esModule", {
	  value: true
	});
	dynamicImport$1.buildDynamicImport = buildDynamicImport;
	var _core = require$$0$b;
	{
	  dynamicImport$1.getDynamicImportSource = function getDynamicImportSource(node) {
	    const [source] = node.arguments;
	    return _core.types.isStringLiteral(source) || _core.types.isTemplateLiteral(source) ? source : _core.template.expression.ast`\`\${${source}}\``;
	  };
	}
	function buildDynamicImport(node, deferToThen, wrapWithPromise, builder) {
	  const specifier = _core.types.isCallExpression(node) ? node.arguments[0] : node.source;
	  if (_core.types.isStringLiteral(specifier) || _core.types.isTemplateLiteral(specifier) && specifier.quasis.length === 0) {
	    if (deferToThen) {
	      return _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `;
	    } else return builder(specifier);
	  }
	  const specifierToString = _core.types.isTemplateLiteral(specifier) ? _core.types.identifier("specifier") : _core.types.templateLiteral([_core.types.templateElement({
	    raw: ""
	  }), _core.types.templateElement({
	    raw: ""
	  })], [_core.types.identifier("specifier")]);
	  if (deferToThen) {
	    return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    `;
	  } else if (wrapWithPromise) {
	    return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `;
	  } else {
	    return _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
	  }
	}
	return dynamicImport$1;
}

var getModuleName = {};

var hasRequiredGetModuleName;

function requireGetModuleName () {
	if (hasRequiredGetModuleName) return getModuleName;
	hasRequiredGetModuleName = 1;
	Object.defineProperty(getModuleName, "__esModule", {
	  value: true
	});
	getModuleName.default = getModuleName$1;
	{
	  const originalGetModuleName = getModuleName$1;
	  getModuleName.default = getModuleName$1 = function getModuleName2(rootOpts, pluginOpts) {
	    var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
	    return originalGetModuleName(rootOpts, {
	      moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
	      moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
	      getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
	      moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
	    });
	  };
	}
	function getModuleName$1(rootOpts, pluginOpts) {
	  const {
	    filename,
	    filenameRelative = filename,
	    sourceRoot = pluginOpts.moduleRoot
	  } = rootOpts;
	  const {
	    moduleId,
	    moduleIds = !!moduleId,
	    getModuleId,
	    moduleRoot = sourceRoot
	  } = pluginOpts;
	  if (!moduleIds) return null;
	  if (moduleId != null && !getModuleId) {
	    return moduleId;
	  }
	  let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
	  if (filenameRelative) {
	    const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
	    moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.\w*$/, "");
	  }
	  moduleName = moduleName.replace(/\\/g, "/");
	  if (getModuleId) {
	    return getModuleId(moduleName) || moduleName;
	  } else {
	    return moduleName;
	  }
	}
	return getModuleName;
}

var hasRequiredLib$E;

function requireLib$E () {
	if (hasRequiredLib$E) return lib$C;
	hasRequiredLib$E = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "buildDynamicImport", {
		  enumerable: true,
		  get: function() {
		    return _dynamicImport.buildDynamicImport;
		  }
		});
		exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
		exports.ensureStatementsHoisted = ensureStatementsHoisted;
		Object.defineProperty(exports, "getModuleName", {
		  enumerable: true,
		  get: function() {
		    return _getModuleName.default;
		  }
		});
		Object.defineProperty(exports, "hasExports", {
		  enumerable: true,
		  get: function() {
		    return _normalizeAndLoadMetadata.hasExports;
		  }
		});
		Object.defineProperty(exports, "isModule", {
		  enumerable: true,
		  get: function() {
		    return _helperModuleImports.isModule;
		  }
		});
		Object.defineProperty(exports, "isSideEffectImport", {
		  enumerable: true,
		  get: function() {
		    return _normalizeAndLoadMetadata.isSideEffectImport;
		  }
		});
		exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
		Object.defineProperty(exports, "rewriteThis", {
		  enumerable: true,
		  get: function() {
		    return _rewriteThis.default;
		  }
		});
		exports.wrapInterop = wrapInterop;
		var _assert = require$$0$c;
		var _core = require$$0$b;
		var _helperModuleImports = requireLib$14();
		var _rewriteThis = requireRewriteThis();
		var _rewriteLiveReferences = requireRewriteLiveReferences();
		var _normalizeAndLoadMetadata = requireNormalizeAndLoadMetadata();
		var Lazy = requireLazyModules();
		var _dynamicImport = requireDynamicImport$1();
		var _getModuleName = requireGetModuleName();
		{
		  exports.getDynamicImportSource = requireDynamicImport$1().getDynamicImportSource;
		}
		function rewriteModuleStatementsAndPrepareHeader(path, {
		  exportName,
		  strict,
		  allowTopLevelThis,
		  strictMode,
		  noInterop,
		  importInterop = noInterop ? "none" : "babel",
		  lazy,
		  getWrapperPayload = Lazy.toGetWrapperPayload(lazy != null ? lazy : false),
		  wrapReference = Lazy.wrapReference,
		  esNamespaceOnly,
		  filename,
		  constantReexports = arguments[1].loose,
		  enumerableModuleMeta = arguments[1].loose,
		  noIncompleteNsImportDetection
		}) {
		  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);
		  _assert((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script");
		  path.node.sourceType = "script";
		  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
		    importInterop,
		    initializeReexports: constantReexports,
		    getWrapperPayload,
		    esNamespaceOnly,
		    filename
		  });
		  if (!allowTopLevelThis) {
		    (0, _rewriteThis.default)(path);
		  }
		  (0, _rewriteLiveReferences.default)(path, meta, wrapReference);
		  if (strictMode !== false) {
		    const hasStrict = path.node.directives.some((directive) => {
		      return directive.value.value === "use strict";
		    });
		    if (!hasStrict) {
		      path.unshiftContainer("directives", _core.types.directive(_core.types.directiveLiteral("use strict")));
		    }
		  }
		  const headers = [];
		  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
		    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
		  }
		  const nameList = buildExportNameListDeclaration(path, meta);
		  if (nameList) {
		    meta.exportNameListName = nameList.name;
		    headers.push(nameList.statement);
		  }
		  headers.push(...buildExportInitializationStatements(path, meta, wrapReference, constantReexports, noIncompleteNsImportDetection));
		  return {
		    meta,
		    headers
		  };
		}
		function ensureStatementsHoisted(statements) {
		  statements.forEach((header) => {
		    header._blockHoist = 3;
		  });
		}
		function wrapInterop(programPath, expr, type) {
		  if (type === "none") {
		    return null;
		  }
		  if (type === "node-namespace") {
		    return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, _core.types.booleanLiteral(true)]);
		  } else if (type === "node-default") {
		    return null;
		  }
		  let helper;
		  if (type === "default") {
		    helper = "interopRequireDefault";
		  } else if (type === "namespace") {
		    helper = "interopRequireWildcard";
		  } else {
		    throw new Error(`Unknown interop: ${type}`);
		  }
		  return _core.types.callExpression(programPath.hub.addHelper(helper), [expr]);
		}
		function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false, wrapReference = Lazy.wrapReference) {
		  var _wrapReference;
		  const statements = [];
		  const srcNamespaceId = _core.types.identifier(sourceMetadata.name);
		  for (const localName of sourceMetadata.importsNamespace) {
		    if (localName === sourceMetadata.name) continue;
		    statements.push(_core.template.statement`var NAME = SOURCE;`({
		      NAME: localName,
		      SOURCE: _core.types.cloneNode(srcNamespaceId)
		    }));
		  }
		  const srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
		  if (constantReexports) {
		    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference));
		  }
		  for (const exportName of sourceMetadata.reexportNamespace) {
		    statements.push((!_core.types.isIdentifier(srcNamespace) ? _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _core.template.statement`EXPORTS.NAME = NAMESPACE;`)({
		      EXPORTS: metadata.exportName,
		      NAME: exportName,
		      NAMESPACE: _core.types.cloneNode(srcNamespace)
		    }));
		  }
		  if (sourceMetadata.reexportAll) {
		    const statement = buildNamespaceReexport(metadata, _core.types.cloneNode(srcNamespace), constantReexports);
		    statement.loc = sourceMetadata.reexportAll.loc;
		    statements.push(statement);
		  }
		  return statements;
		}
		const ReexportTemplate = {
		  constant: ({
		    exports: exports2,
		    exportName,
		    namespaceImport
		  }) => _core.template.statement.ast`
      ${exports2}.${exportName} = ${namespaceImport};
    `,
		  constantComputed: ({
		    exports: exports2,
		    exportName,
		    namespaceImport
		  }) => _core.template.statement.ast`
      ${exports2}["${exportName}"] = ${namespaceImport};
    `,
		  spec: ({
		    exports: exports2,
		    exportName,
		    namespaceImport
		  }) => _core.template.statement.ast`
      Object.defineProperty(${exports2}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `
		};
		function buildReexportsFromMeta(meta, metadata, constantReexports, wrapReference) {
		  var _wrapReference2;
		  let namespace = _core.types.identifier(metadata.name);
		  namespace = (_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null ? _wrapReference2 : namespace;
		  const {
		    stringSpecifiers
		  } = meta;
		  return Array.from(metadata.reexports, ([exportName, importName]) => {
		    let namespaceImport = _core.types.cloneNode(namespace);
		    if (importName === "default" && metadata.interop === "node-default") ; else if (stringSpecifiers.has(importName)) {
		      namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.stringLiteral(importName), true);
		    } else {
		      namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.identifier(importName));
		    }
		    const astNodes = {
		      exports: meta.exportName,
		      exportName,
		      namespaceImport
		    };
		    if (constantReexports || _core.types.isIdentifier(namespaceImport)) {
		      if (stringSpecifiers.has(exportName)) {
		        return ReexportTemplate.constantComputed(astNodes);
		      } else {
		        return ReexportTemplate.constant(astNodes);
		      }
		    } else {
		      return ReexportTemplate.spec(astNodes);
		    }
		  });
		}
		function buildESModuleHeader(metadata, enumerableModuleMeta = false) {
		  return (enumerableModuleMeta ? _core.template.statement`
        EXPORTS.__esModule = true;
      ` : _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
		    EXPORTS: metadata.exportName
		  });
		}
		function buildNamespaceReexport(metadata, namespace, constantReexports) {
		  return (constantReexports ? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
		    NAMESPACE: namespace,
		    EXPORTS: metadata.exportName,
		    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
		      EXPORTS_LIST: metadata.exportNameListName
		    }) : null
		  });
		}
		function buildExportNameListDeclaration(programPath, metadata) {
		  const exportedVars = /* @__PURE__ */ Object.create(null);
		  for (const data of metadata.local.values()) {
		    for (const name2 of data.names) {
		      exportedVars[name2] = true;
		    }
		  }
		  let hasReexport = false;
		  for (const data of metadata.source.values()) {
		    for (const exportName of data.reexports.keys()) {
		      exportedVars[exportName] = true;
		    }
		    for (const exportName of data.reexportNamespace) {
		      exportedVars[exportName] = true;
		    }
		    hasReexport = hasReexport || !!data.reexportAll;
		  }
		  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
		  const name = programPath.scope.generateUidIdentifier("exportNames");
		  delete exportedVars.default;
		  return {
		    name: name.name,
		    statement: _core.types.variableDeclaration("var", [_core.types.variableDeclarator(name, _core.types.valueToNode(exportedVars))])
		  };
		}
		function buildExportInitializationStatements(programPath, metadata, wrapReference, constantReexports = false, noIncompleteNsImportDetection = false) {
		  const initStatements = [];
		  for (const [localName, data] of metadata.local) {
		    if (data.kind === "import") ; else if (data.kind === "hoisted") {
		      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, _core.types.identifier(localName))]);
		    } else if (!noIncompleteNsImportDetection) {
		      for (const exportName of data.names) {
		        initStatements.push([exportName, null]);
		      }
		    }
		  }
		  for (const data of metadata.source.values()) {
		    if (!constantReexports) {
		      const reexportsStatements = buildReexportsFromMeta(metadata, data, false, wrapReference);
		      const reexports = [...data.reexports.keys()];
		      for (let i = 0; i < reexportsStatements.length; i++) {
		        initStatements.push([reexports[i], reexportsStatements[i]]);
		      }
		    }
		    if (!noIncompleteNsImportDetection) {
		      for (const exportName of data.reexportNamespace) {
		        initStatements.push([exportName, null]);
		      }
		    }
		  }
		  initStatements.sort(([a], [b]) => {
		    if (a < b) return -1;
		    if (b < a) return 1;
		    return 0;
		  });
		  const results = [];
		  if (noIncompleteNsImportDetection) {
		    for (const [, initStatement] of initStatements) {
		      results.push(initStatement);
		    }
		  } else {
		    const chunkSize = 100;
		    for (let i = 0; i < initStatements.length; i += chunkSize) {
		      let uninitializedExportNames = [];
		      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
		        const [exportName, initStatement] = initStatements[i + j];
		        if (initStatement !== null) {
		          if (uninitializedExportNames.length > 0) {
		            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
		            uninitializedExportNames = [];
		          }
		          results.push(initStatement);
		        } else {
		          uninitializedExportNames.push(exportName);
		        }
		      }
		      if (uninitializedExportNames.length > 0) {
		        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
		      }
		    }
		  }
		  return results;
		}
		const InitTemplate = {
		  computed: ({
		    exports: exports2,
		    name,
		    value
		  }) => _core.template.expression.ast`${exports2}["${name}"] = ${value}`,
		  default: ({
		    exports: exports2,
		    name,
		    value
		  }) => _core.template.expression.ast`${exports2}.${name} = ${value}`,
		  define: ({
		    exports: exports2,
		    name,
		    value
		  }) => _core.template.expression.ast`
      Object.defineProperty(${exports2}, "${name}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name}"] = ${value}`
		};
		function buildInitStatement(metadata, exportNames, initExpr) {
		  const {
		    stringSpecifiers,
		    exportName: exports2
		  } = metadata;
		  return _core.types.expressionStatement(exportNames.reduce((value, name) => {
		    const params = {
		      exports: exports2,
		      name,
		      value
		    };
		    if (name === "__proto__") {
		      return InitTemplate.define(params);
		    }
		    if (stringSpecifiers.has(name)) {
		      return InitTemplate.computed(params);
		    }
		    return InitTemplate.default(params);
		  }, initExpr));
		} 
	} (lib$C));
	return lib$C;
}

var hasRequiredLib$D;

function requireLib$D () {
	if (hasRequiredLib$D) return lib$D;
	hasRequiredLib$D = 1;
	Object.defineProperty(lib$D, "__esModule", {
	  value: true
	});
	lib$D.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperModuleTransforms = requireLib$E();
	var _core = require$$0$b;
	const buildWrapper = _core.template.statement(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);
	const buildAnonymousWrapper = _core.template.statement(`
  define(["require"], function(REQUIRE) {
  })
`);
	function injectWrapper(path, wrapper) {
	  const {
	    body,
	    directives
	  } = path.node;
	  path.node.directives = [];
	  path.node.body = [];
	  const amdFactoryCall = path.pushContainer("body", wrapper)[0].get("expression");
	  const amdFactoryCallArgs = amdFactoryCall.get("arguments");
	  const amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get("body");
	  amdFactory.pushContainer("directives", directives);
	  amdFactory.pushContainer("body", body);
	}
	lib$D.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion(7);
	  const {
	    allowTopLevelThis,
	    strict,
	    strictMode,
	    importInterop,
	    noInterop
	  } = options;
	  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
	  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
	  return {
	    name: "transform-modules-amd",
	    pre() {
	      this.file.set("@babel/plugin-transform-modules-*", "amd");
	    },
	    visitor: {
	      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path, state) {
	        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
	        if (path.isCallExpression() && !path.get("callee").isImport()) return;
	        let {
	          requireId,
	          resolveId,
	          rejectId
	        } = state;
	        if (!requireId) {
	          requireId = path.scope.generateUidIdentifier("require");
	          state.requireId = requireId;
	        }
	        if (!resolveId || !rejectId) {
	          resolveId = path.scope.generateUidIdentifier("resolve");
	          rejectId = path.scope.generateUidIdentifier("reject");
	          state.resolveId = resolveId;
	          state.rejectId = rejectId;
	        }
	        let result = _core.types.identifier("imported");
	        if (!noInterop) {
	          result = (0, _helperModuleTransforms.wrapInterop)(this.file.path, result, "namespace");
	        }
	        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, false, (specifier) => _core.template.expression.ast`
              new Promise((${resolveId}, ${rejectId}) =>
                ${requireId}(
                  [${specifier}],
                  imported => ${_core.types.cloneNode(resolveId)}(${result}),
                  ${_core.types.cloneNode(rejectId)}
                )
              )
            `));
	      },
	      Program: {
	        exit(path, {
	          requireId
	        }) {
	          if (!(0, _helperModuleTransforms.isModule)(path)) {
	            if (requireId) {
	              injectWrapper(path, buildAnonymousWrapper({
	                REQUIRE: _core.types.cloneNode(requireId)
	              }));
	            }
	            return;
	          }
	          const amdArgs = [];
	          const importNames = [];
	          if (requireId) {
	            amdArgs.push(_core.types.stringLiteral("require"));
	            importNames.push(_core.types.cloneNode(requireId));
	          }
	          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
	          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
	          const {
	            meta,
	            headers
	          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
	            enumerableModuleMeta,
	            constantReexports,
	            strict,
	            strictMode,
	            allowTopLevelThis,
	            importInterop,
	            noInterop,
	            filename: this.file.opts.filename
	          });
	          if ((0, _helperModuleTransforms.hasExports)(meta)) {
	            amdArgs.push(_core.types.stringLiteral("exports"));
	            importNames.push(_core.types.identifier(meta.exportName));
	          }
	          for (const [source, metadata] of meta.source) {
	            amdArgs.push(_core.types.stringLiteral(source));
	            importNames.push(_core.types.identifier(metadata.name));
	            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
	              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
	              if (interop) {
	                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
	                header.loc = metadata.loc;
	                headers.push(header);
	              }
	            }
	            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
	          }
	          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
	          path.unshiftContainer("body", headers);
	          injectWrapper(path, buildWrapper({
	            MODULE_NAME: moduleName,
	            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
	            IMPORT_NAMES: importNames
	          }));
	        }
	      }
	    }
	  };
	});
	return lib$D;
}

var lib$B = {};

var dynamicImport = {};

var hasRequiredDynamicImport;

function requireDynamicImport () {
	if (hasRequiredDynamicImport) return dynamicImport;
	hasRequiredDynamicImport = 1;
	Object.defineProperty(dynamicImport, "__esModule", {
	  value: true
	});
	dynamicImport.transformDynamicImport = transformDynamicImport;
	var _core = require$$0$b;
	var _helperModuleTransforms = requireLib$E();
	const requireNoInterop = (source) => _core.template.expression.ast`require(${source})`;
	const requireInterop = (source, file) => _core.types.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
	function transformDynamicImport(path, noInterop, file) {
	  const buildRequire = noInterop ? requireNoInterop : requireInterop;
	  path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, true, false, (specifier) => buildRequire(specifier, file)));
	}
	return dynamicImport;
}

var lazy = {};

var hasRequiredLazy;

function requireLazy () {
	if (hasRequiredLazy) return lazy;
	hasRequiredLazy = 1;
	Object.defineProperty(lazy, "__esModule", {
	  value: true
	});
	lazy.lazyImportsHook = void 0;
	var _core = require$$0$b;
	var _helperModuleTransforms = requireLib$E();
	const lazyImportsHook = (lazy) => ({
	  name: `${"@babel/plugin-transform-modules-commonjs"}/lazy`,
	  version: "7.27.1",
	  getWrapperPayload(source, metadata) {
	    if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll) {
	      return null;
	    }
	    if (lazy === true) {
	      return source.includes(".") ? null : "lazy/function";
	    }
	    if (Array.isArray(lazy)) {
	      return !lazy.includes(source) ? null : "lazy/function";
	    }
	    if (typeof lazy === "function") {
	      return lazy(source) ? "lazy/function" : null;
	    }
	  },
	  buildRequireWrapper(name, init, payload, referenced) {
	    if (payload === "lazy/function") {
	      if (!referenced) return false;
	      return _core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `;
	    }
	  },
	  wrapReference(ref, payload) {
	    if (payload === "lazy/function") return _core.types.callExpression(ref, []);
	  }
	});
	lazy.lazyImportsHook = lazyImportsHook;
	return lazy;
}

var hooks = {};

var hasRequiredHooks;

function requireHooks () {
	if (hasRequiredHooks) return hooks;
	hasRequiredHooks = 1;
	Object.defineProperty(hooks, "__esModule", {
	  value: true
	});
	hooks.defineCommonJSHook = defineCommonJSHook;
	hooks.makeInvokers = makeInvokers;
	const commonJSHooksKey = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
	function defineCommonJSHook(file, hook) {
	  let hooks = file.get(commonJSHooksKey);
	  if (!hooks) file.set(commonJSHooksKey, hooks = []);
	  hooks.push(hook);
	}
	function findMap(arr, cb) {
	  if (arr) {
	    for (const el of arr) {
	      const res = cb(el);
	      if (res != null) return res;
	    }
	  }
	}
	function makeInvokers(file) {
	  const hooks = file.get(commonJSHooksKey);
	  return {
	    getWrapperPayload(...args) {
	      return findMap(hooks, (hook) => hook.getWrapperPayload == null ? void 0 : hook.getWrapperPayload(...args));
	    },
	    wrapReference(...args) {
	      return findMap(hooks, (hook) => hook.wrapReference == null ? void 0 : hook.wrapReference(...args));
	    },
	    buildRequireWrapper(...args) {
	      return findMap(hooks, (hook) => hook.buildRequireWrapper == null ? void 0 : hook.buildRequireWrapper(...args));
	    }
	  };
	}
	return hooks;
}

var hasRequiredLib$C;

function requireLib$C () {
	if (hasRequiredLib$C) return lib$B;
	hasRequiredLib$C = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;
		Object.defineProperty(exports, "defineCommonJSHook", {
		  enumerable: true,
		  get: function() {
		    return _hooks.defineCommonJSHook;
		  }
		});
		var _helperPluginUtils = requireLib$1f();
		var _helperModuleTransforms = requireLib$E();
		var _core = require$$0$b;
		var _dynamicImport = requireDynamicImport();
		var _lazy = requireLazy();
		var _hooks = requireHooks();
		exports.default = (0, _helperPluginUtils.declare)((api, options) => {
		  var _api$assumption, _api$assumption2, _api$assumption3;
		  api.assertVersion(7);
		  const {
		    strictNamespace = false,
		    mjsStrictNamespace = strictNamespace,
		    allowTopLevelThis,
		    strict,
		    strictMode,
		    noInterop,
		    importInterop,
		    lazy = false,
		    allowCommonJSExports = true,
		    loose = false
		  } = options;
		  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose;
		  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose;
		  const noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : false;
		  if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every((item) => typeof item === "string"))) {
		    throw new Error(`.lazy must be a boolean, array of strings, or a function`);
		  }
		  if (typeof strictNamespace !== "boolean") {
		    throw new Error(`.strictNamespace must be a boolean, or undefined`);
		  }
		  if (typeof mjsStrictNamespace !== "boolean") {
		    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
		  }
		  const getAssertion = (localName) => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
		  const moduleExportsVisitor = {
		    ReferencedIdentifier(path) {
		      const localName = path.node.name;
		      if (localName !== "module" && localName !== "exports") return;
		      const localBinding = path.scope.getBinding(localName);
		      const rootBinding = this.scope.getBinding(localName);
		      if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
		        value: path.node
		      }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
		        left: path.node
		      }) || path.isAssignmentExpression({
		        left: path.node
		      })) {
		        return;
		      }
		      path.replaceWith(getAssertion(localName));
		    },
		    UpdateExpression(path) {
		      const arg = path.get("argument");
		      if (!arg.isIdentifier()) return;
		      const localName = arg.node.name;
		      if (localName !== "module" && localName !== "exports") return;
		      const localBinding = path.scope.getBinding(localName);
		      const rootBinding = this.scope.getBinding(localName);
		      if (rootBinding !== localBinding) return;
		      path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
		    },
		    AssignmentExpression(path) {
		      const left = path.get("left");
		      if (left.isIdentifier()) {
		        const localName = left.node.name;
		        if (localName !== "module" && localName !== "exports") return;
		        const localBinding = path.scope.getBinding(localName);
		        const rootBinding = this.scope.getBinding(localName);
		        if (rootBinding !== localBinding) return;
		        const right = path.get("right");
		        right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
		      } else if (left.isPattern()) {
		        const ids = left.getOuterBindingIdentifiers();
		        const localName = Object.keys(ids).find((localName2) => {
		          if (localName2 !== "module" && localName2 !== "exports") return false;
		          return this.scope.getBinding(localName2) === path.scope.getBinding(localName2);
		        });
		        if (localName) {
		          const right = path.get("right");
		          right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
		        }
		      }
		    }
		  };
		  return {
		    name: "transform-modules-commonjs",
		    pre() {
		      this.file.set("@babel/plugin-transform-modules-*", "commonjs");
		      if (lazy) (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));
		    },
		    visitor: {
		      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path) {
		        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
		        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
		        let {
		          scope
		        } = path;
		        do {
		          scope.rename("require");
		        } while (scope = scope.parent);
		        (0, _dynamicImport.transformDynamicImport)(path, noInterop, this.file);
		      },
		      Program: {
		        exit(path, state) {
		          if (!(0, _helperModuleTransforms.isModule)(path)) return;
		          path.scope.rename("exports");
		          path.scope.rename("module");
		          path.scope.rename("require");
		          path.scope.rename("__filename");
		          path.scope.rename("__dirname");
		          if (!allowCommonJSExports) {
		            path.traverse(moduleExportsVisitor, {
		              scope: path.scope
		            });
		          }
		          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
		          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
		          const hooks = (0, _hooks.makeInvokers)(this.file);
		          const {
		            meta,
		            headers
		          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
		            exportName: "exports",
		            constantReexports,
		            enumerableModuleMeta,
		            strict,
		            strictMode,
		            allowTopLevelThis,
		            noInterop,
		            importInterop,
		            wrapReference: hooks.wrapReference,
		            getWrapperPayload: hooks.getWrapperPayload,
		            esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
		            noIncompleteNsImportDetection,
		            filename: this.file.opts.filename
		          });
		          for (const [source, metadata] of meta.source) {
		            const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);
		            let header;
		            if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
		              if (lazy && metadata.wrap === "function") {
		                throw new Error("Assertion failure");
		              }
		              header = _core.types.expressionStatement(loadExpr);
		            } else {
		              const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
		              if (metadata.wrap) {
		                const res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);
		                if (res === false) continue;
		                else header = res;
		              }
		              header != null ? header : header = _core.template.statement.ast`
                var ${metadata.name} = ${init};
              `;
		            }
		            header.loc = metadata.loc;
		            headers.push(header);
		            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));
		          }
		          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
		          path.unshiftContainer("body", headers);
		          path.get("body").forEach((path2) => {
		            if (!headers.includes(path2.node)) return;
		            if (path2.isVariableDeclaration()) {
		              path2.scope.registerDeclaration(path2);
		            }
		          });
		        }
		      }
		    }
		  };
		}); 
	} (lib$B));
	return lib$B;
}

var lib$A = {};

var hasRequiredLib$B;

function requireLib$B () {
	if (hasRequiredLib$B) return lib$A;
	hasRequiredLib$B = 1;
	Object.defineProperty(lib$A, "__esModule", {
	  value: true
	});
	lib$A.default = void 0;
	lib$A.getExportSpecifierName = getExportSpecifierName;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	var _helperModuleTransforms = requireLib$E();
	var _helperValidatorIdentifier = requireLib$1b();
	const buildTemplate = _core.template.statement(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: EXECUTE,
    };
  });
`);
	const buildExportAll = _core.template.statement(`
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
	const MISSING_PLUGIN_WARNING = `WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-transform-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;
	const MISSING_PLUGIN_ERROR = `ERROR: Dynamic import() transformation must be enabled using the
       @babel/plugin-transform-dynamic-import plugin. Babel 8
       no longer transforms import() without using that plugin.
`;
	function getExportSpecifierName(node, stringSpecifiers) {
	  if (node.type === "Identifier") {
	    return node.name;
	  } else if (node.type === "StringLiteral") {
	    const stringValue = node.value;
	    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
	      stringSpecifiers.add(stringValue);
	    }
	    return stringValue;
	  } else {
	    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);
	  }
	}
	function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
	  const statements = [];
	  if (!exportStarTarget) {
	    if (exportNames.length === 1) {
	      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
	    } else {
	      const objectProperties = [];
	      for (let i = 0; i < exportNames.length; i++) {
	        const exportName = exportNames[i];
	        const exportValue = exportValues[i];
	        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));
	      }
	      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
	    }
	  } else {
	    const exportObj = path.scope.generateUid("exportObj");
	    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
	    statements.push(buildExportAll({
	      KEY: path.scope.generateUidIdentifier("key"),
	      EXPORT_OBJ: _core.types.identifier(exportObj),
	      TARGET: exportStarTarget
	    }));
	    for (let i = 0; i < exportNames.length; i++) {
	      const exportName = exportNames[i];
	      const exportValue = exportValues[i];
	      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
	    }
	    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
	  }
	  return statements;
	}
	lib$A.default = (0, _helperPluginUtils.declare)((api, options) => {
	  api.assertVersion(7);
	  const {
	    systemGlobal = "System",
	    allowTopLevelThis = false
	  } = options;
	  const reassignmentVisited = /* @__PURE__ */ new WeakSet();
	  const reassignmentVisitor = {
	    "AssignmentExpression|UpdateExpression"(path) {
	      if (reassignmentVisited.has(path.node)) return;
	      reassignmentVisited.add(path.node);
	      const arg = path.isAssignmentExpression() ? path.get("left") : path.get("argument");
	      if (arg.isObjectPattern() || arg.isArrayPattern()) {
	        const exprs = [path.node];
	        for (const name2 of Object.keys(arg.getBindingIdentifiers())) {
	          if (this.scope.getBinding(name2) !== path.scope.getBinding(name2)) {
	            return;
	          }
	          const exportedNames2 = this.exports[name2];
	          if (!exportedNames2) continue;
	          for (const exportedName of exportedNames2) {
	            exprs.push(this.buildCall(exportedName, _core.types.identifier(name2)).expression);
	          }
	        }
	        path.replaceWith(_core.types.sequenceExpression(exprs));
	        return;
	      }
	      if (!arg.isIdentifier()) return;
	      const name = arg.node.name;
	      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
	      const exportedNames = this.exports[name];
	      if (!exportedNames) return;
	      let node = path.node;
	      const isPostUpdateExpression = _core.types.isUpdateExpression(node, {
	        prefix: false
	      });
	      if (isPostUpdateExpression) {
	        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
	      }
	      for (const exportedName of exportedNames) {
	        node = this.buildCall(exportedName, node).expression;
	      }
	      if (isPostUpdateExpression) {
	        node = _core.types.sequenceExpression([node, path.node]);
	      }
	      path.replaceWith(node);
	    }
	  };
	  return {
	    name: "transform-modules-systemjs",
	    pre() {
	      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
	    },
	    visitor: {
	      ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path, state) {
	        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
	        if (path.isCallExpression()) {
	          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
	            {
	              console.warn(MISSING_PLUGIN_WARNING);
	            }
	          }
	        } else {
	          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
	            throw new Error(MISSING_PLUGIN_ERROR);
	          }
	        }
	        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, true, (specifier) => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [specifier])));
	      },
	      MetaProperty(path, state) {
	        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
	          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
	        }
	      },
	      ReferencedIdentifier(path, state) {
	        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
	          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
	        }
	      },
	      Program: {
	        enter(path, state) {
	          state.contextIdent = path.scope.generateUid("context");
	          state.stringSpecifiers = /* @__PURE__ */ new Set();
	          if (!allowTopLevelThis) {
	            (0, _helperModuleTransforms.rewriteThis)(path);
	          }
	        },
	        exit(path, state) {
	          const scope = path.scope;
	          const exportIdent = scope.generateUid("export");
	          const {
	            contextIdent,
	            stringSpecifiers
	          } = state;
	          const exportMap = /* @__PURE__ */ Object.create(null);
	          const modules = [];
	          const beforeBody = [];
	          const setters = [];
	          const sources = [];
	          const variableIds = [];
	          const removedPaths = [];
	          function addExportName(key, val) {
	            exportMap[key] = exportMap[key] || [];
	            exportMap[key].push(val);
	          }
	          function pushModule(source, key, specifiers) {
	            let module;
	            modules.forEach(function(m) {
	              if (m.key === source) {
	                module = m;
	              }
	            });
	            if (!module) {
	              modules.push(module = {
	                key: source,
	                imports: [],
	                exports: []
	              });
	            }
	            module[key] = module[key].concat(specifiers);
	          }
	          function buildExportCall(name, val) {
	            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
	          }
	          const exportNames = [];
	          const exportValues = [];
	          const body = path.get("body");
	          for (const path2 of body) {
	            if (path2.isFunctionDeclaration()) {
	              beforeBody.push(path2.node);
	              removedPaths.push(path2);
	            } else if (path2.isClassDeclaration()) {
	              variableIds.push(_core.types.cloneNode(path2.node.id));
	              path2.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path2.node.id), _core.types.toExpression(path2.node))));
	            } else if (path2.isVariableDeclaration()) {
	              path2.node.kind = "var";
	            } else if (path2.isImportDeclaration()) {
	              const source = path2.node.source.value;
	              pushModule(source, "imports", path2.node.specifiers);
	              for (const name of Object.keys(path2.getBindingIdentifiers())) {
	                scope.removeBinding(name);
	                variableIds.push(_core.types.identifier(name));
	              }
	              path2.remove();
	            } else if (path2.isExportAllDeclaration()) {
	              pushModule(path2.node.source.value, "exports", path2.node);
	              path2.remove();
	            } else if (path2.isExportDefaultDeclaration()) {
	              const declar = path2.node.declaration;
	              if (_core.types.isClassDeclaration(declar)) {
	                const id = declar.id;
	                if (id) {
	                  exportNames.push("default");
	                  exportValues.push(scope.buildUndefinedNode());
	                  variableIds.push(_core.types.cloneNode(id));
	                  addExportName(id.name, "default");
	                  path2.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar))));
	                } else {
	                  exportNames.push("default");
	                  exportValues.push(_core.types.toExpression(declar));
	                  removedPaths.push(path2);
	                }
	              } else if (_core.types.isFunctionDeclaration(declar)) {
	                const id = declar.id;
	                if (id) {
	                  beforeBody.push(declar);
	                  exportNames.push("default");
	                  exportValues.push(_core.types.cloneNode(id));
	                  addExportName(id.name, "default");
	                } else {
	                  exportNames.push("default");
	                  exportValues.push(_core.types.toExpression(declar));
	                }
	                removedPaths.push(path2);
	              } else {
	                path2.replaceWith(buildExportCall("default", declar));
	              }
	            } else if (path2.isExportNamedDeclaration()) {
	              const declar = path2.node.declaration;
	              if (declar) {
	                path2.replaceWith(declar);
	                if (_core.types.isFunction(declar)) {
	                  const name = declar.id.name;
	                  addExportName(name, name);
	                  beforeBody.push(declar);
	                  exportNames.push(name);
	                  exportValues.push(_core.types.cloneNode(declar.id));
	                  removedPaths.push(path2);
	                } else if (_core.types.isClass(declar)) {
	                  const name = declar.id.name;
	                  exportNames.push(name);
	                  exportValues.push(scope.buildUndefinedNode());
	                  variableIds.push(_core.types.cloneNode(declar.id));
	                  path2.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));
	                  addExportName(name, name);
	                } else {
	                  if (_core.types.isVariableDeclaration(declar)) {
	                    declar.kind = "var";
	                  }
	                  for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))) {
	                    addExportName(name, name);
	                  }
	                }
	              } else {
	                const specifiers = path2.node.specifiers;
	                if (specifiers != null && specifiers.length) {
	                  if (path2.node.source) {
	                    pushModule(path2.node.source.value, "exports", specifiers);
	                    path2.remove();
	                  } else {
	                    const nodes = [];
	                    for (const specifier of specifiers) {
	                      const {
	                        local,
	                        exported
	                      } = specifier;
	                      const binding = scope.getBinding(local.name);
	                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);
	                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
	                        exportNames.push(exportedName);
	                        exportValues.push(_core.types.cloneNode(local));
	                      } else if (!binding) {
	                        nodes.push(buildExportCall(exportedName, local));
	                      }
	                      addExportName(local.name, exportedName);
	                    }
	                    path2.replaceWithMultiple(nodes);
	                  }
	                } else {
	                  path2.remove();
	                }
	              }
	            }
	          }
	          modules.forEach(function(specifiers) {
	            const setterBody = [];
	            const target = scope.generateUid(specifiers.key);
	            for (let specifier of specifiers.imports) {
	              if (_core.types.isImportNamespaceSpecifier(specifier)) {
	                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
	              } else if (_core.types.isImportDefaultSpecifier(specifier)) {
	                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
	              }
	              if (_core.types.isImportSpecifier(specifier)) {
	                const {
	                  imported
	                } = specifier;
	                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === "StringLiteral"))));
	              }
	            }
	            if (specifiers.exports.length) {
	              const exportNames2 = [];
	              const exportValues2 = [];
	              let hasExportStar = false;
	              for (const node of specifiers.exports) {
	                if (_core.types.isExportAllDeclaration(node)) {
	                  hasExportStar = true;
	                } else if (_core.types.isExportSpecifier(node)) {
	                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);
	                  exportNames2.push(exportedName);
	                  exportValues2.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));
	                } else ;
	              }
	              setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames2, exportValues2, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));
	            }
	            sources.push(_core.types.stringLiteral(specifiers.key));
	            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));
	          });
	          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
	          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
	          {
	            var _path$scope, _path$scope$hoistVari;
	            (_path$scope$hoistVari = (_path$scope = path.scope).hoistVariables) != null ? _path$scope$hoistVari : _path$scope.hoistVariables = require$$2$2.Scope.prototype.hoistVariables;
	          }
	          path.scope.hoistVariables((id, hasInit) => {
	            variableIds.push(id);
	            if (!hasInit && id.name in exportMap) {
	              for (const exported of exportMap[id.name]) {
	                exportNames.push(exported);
	                exportValues.push(_core.types.buildUndefinedNode());
	              }
	            }
	          });
	          if (variableIds.length) {
	            beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map((id) => _core.types.variableDeclarator(id))));
	          }
	          if (exportNames.length) {
	            beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
	          }
	          path.traverse(reassignmentVisitor, {
	            exports: exportMap,
	            buildCall: buildExportCall,
	            scope
	          });
	          for (const path2 of removedPaths) {
	            path2.remove();
	          }
	          let hasTLA = false;
	          path.traverse({
	            AwaitExpression(path2) {
	              hasTLA = true;
	              path2.stop();
	            },
	            Function(path2) {
	              path2.skip();
	            },
	            noScope: true
	          });
	          path.node.body = [buildTemplate({
	            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
	            BEFORE_BODY: beforeBody,
	            MODULE_NAME: moduleName,
	            SETTERS: _core.types.arrayExpression(setters),
	            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),
	            SOURCES: _core.types.arrayExpression(sources),
	            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
	            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
	          })];
	          path.requeue(path.get("body.0"));
	        }
	      }
	    }
	  };
	});
	return lib$A;
}

var lib$z = {};

var hasRequiredLib$A;

function requireLib$A () {
	if (hasRequiredLib$A) return lib$z;
	hasRequiredLib$A = 1;
	Object.defineProperty(lib$z, "__esModule", {
	  value: true
	});
	lib$z.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _path = require$$0$9;
	var _helperModuleTransforms = requireLib$E();
	var _core = require$$0$b;
	const buildPrerequisiteAssignment = (0, _core.template)(`
  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}
`);
	const buildWrapper = (0, _core.template)(`
  (function (global, factory) {
    if (typeof define === "function" && define.amd) {
      define(MODULE_NAME, AMD_ARGUMENTS, factory);
    } else if (typeof exports !== "undefined") {
      factory(COMMONJS_ARGUMENTS);
    } else {
      var mod = { exports: {} };
      factory(BROWSER_ARGUMENTS);

      GLOBAL_TO_ASSIGN;
    }
  })(
    typeof globalThis !== "undefined" ? globalThis
      : typeof self !== "undefined" ? self
      : this,
    function(IMPORT_NAMES) {
  })
`);
	lib$z.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion(7);
	  const {
	    globals,
	    exactGlobals,
	    allowTopLevelThis,
	    strict,
	    strictMode,
	    noInterop,
	    importInterop
	  } = options;
	  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
	  const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
	  function buildBrowserInit(browserGlobals, exactGlobals2, filename, moduleName) {
	    const moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, _path.extname)(filename));
	    let globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename)));
	    let initAssignments = [];
	    if (exactGlobals2) {
	      const globalName = browserGlobals[moduleNameOrBasename];
	      if (globalName) {
	        initAssignments = [];
	        const members = globalName.split(".");
	        globalToAssign = members.slice(1).reduce((accum, curr) => {
	          initAssignments.push(buildPrerequisiteAssignment({
	            GLOBAL_REFERENCE: _core.types.cloneNode(accum)
	          }));
	          return _core.types.memberExpression(accum, _core.types.identifier(curr));
	        }, _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
	      }
	    }
	    initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")))));
	    return initAssignments;
	  }
	  function buildBrowserArg(browserGlobals, exactGlobals2, source) {
	    let memberExpression;
	    if (exactGlobals2) {
	      const globalRef = browserGlobals[source];
	      if (globalRef) {
	        memberExpression = globalRef.split(".").reduce((accum, curr) => _core.types.memberExpression(accum, _core.types.identifier(curr)), _core.types.identifier("global"));
	      } else {
	        memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
	      }
	    } else {
	      const requireName = (0, _path.basename)(source, (0, _path.extname)(source));
	      const globalName = browserGlobals[requireName] || requireName;
	      memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
	    }
	    return memberExpression;
	  }
	  return {
	    name: "transform-modules-umd",
	    visitor: {
	      Program: {
	        exit(path) {
	          if (!(0, _helperModuleTransforms.isModule)(path)) return;
	          const browserGlobals = globals || {};
	          const moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
	          let moduleNameLiteral;
	          if (moduleName) moduleNameLiteral = _core.types.stringLiteral(moduleName);
	          const {
	            meta,
	            headers
	          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
	            constantReexports,
	            enumerableModuleMeta,
	            strict,
	            strictMode,
	            allowTopLevelThis,
	            noInterop,
	            importInterop,
	            filename: this.file.opts.filename
	          });
	          const amdArgs = [];
	          const commonjsArgs = [];
	          const browserArgs = [];
	          const importNames = [];
	          if ((0, _helperModuleTransforms.hasExports)(meta)) {
	            amdArgs.push(_core.types.stringLiteral("exports"));
	            commonjsArgs.push(_core.types.identifier("exports"));
	            browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")));
	            importNames.push(_core.types.identifier(meta.exportName));
	          }
	          for (const [source, metadata] of meta.source) {
	            amdArgs.push(_core.types.stringLiteral(source));
	            commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]));
	            browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
	            importNames.push(_core.types.identifier(metadata.name));
	            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
	              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
	              if (interop) {
	                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
	                header.loc = meta.loc;
	                headers.push(header);
	              }
	            }
	            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
	          }
	          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
	          path.unshiftContainer("body", headers);
	          const {
	            body,
	            directives
	          } = path.node;
	          path.node.directives = [];
	          path.node.body = [];
	          const umdWrapper = path.pushContainer("body", [buildWrapper({
	            MODULE_NAME: moduleNameLiteral,
	            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
	            COMMONJS_ARGUMENTS: commonjsArgs,
	            BROWSER_ARGUMENTS: browserArgs,
	            IMPORT_NAMES: importNames,
	            GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleNameLiteral)
	          })])[0];
	          const umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
	          umdFactory.pushContainer("directives", directives);
	          umdFactory.pushContainer("body", body);
	        }
	      }
	    }
	  };
	});
	return lib$z;
}

var lib$y = {};

var hasRequiredLib$z;

function requireLib$z () {
	if (hasRequiredLib$z) return lib$y;
	hasRequiredLib$z = 1;
	Object.defineProperty(lib$y, "__esModule", {
	  value: true
	});
	lib$y.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$y.default = (0, _helperPluginUtils.declare)((api, options) => {
	  const {
	    runtime
	  } = options;
	  if (runtime !== void 0 && typeof runtime !== "boolean") {
	    throw new Error("The 'runtime' option must be boolean");
	  }
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-named-capturing-groups-regex",
	    feature: "namedCaptureGroups",
	    options: {
	      runtime
	    }
	  });
	});
	return lib$y;
}

var lib$x = {};

var hasRequiredLib$y;

function requireLib$y () {
	if (hasRequiredLib$y) return lib$x;
	hasRequiredLib$y = 1;
	Object.defineProperty(lib$x, "__esModule", {
	  value: true
	});
	lib$x.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$x.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-new-target",
	    visitor: {
	      MetaProperty(path) {
	        const meta = path.get("meta");
	        const property = path.get("property");
	        const {
	          scope
	        } = path;
	        if (meta.isIdentifier({
	          name: "new"
	        }) && property.isIdentifier({
	          name: "target"
	        })) {
	          const func = path.findParent((path2) => {
	            if (path2.isClass()) return true;
	            if (path2.isFunction() && !path2.isArrowFunctionExpression()) {
	              if (path2.isClassMethod({
	                kind: "constructor"
	              })) {
	                return false;
	              }
	              return true;
	            }
	            return false;
	          });
	          if (!func) {
	            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
	          }
	          const {
	            node
	          } = func;
	          if (_core.types.isMethod(node)) {
	            path.replaceWith(scope.buildUndefinedNode());
	            return;
	          }
	          const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
	          if (func.isClass()) {
	            path.replaceWith(constructor);
	            return;
	          }
	          if (!node.id) {
	            node.id = scope.generateUidIdentifier("target");
	          } else {
	            let scope2 = path.scope;
	            const name = node.id.name;
	            while (scope2 !== func.parentPath.scope) {
	              if (scope2.hasOwnBinding(name) && !scope2.bindingIdentifierEquals(name, node.id)) {
	                scope2.rename(name);
	              }
	              scope2 = scope2.parent;
	            }
	          }
	          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
	        }
	      }
	    }
	  };
	});
	return lib$x;
}

var lib$w = {};

var hasRequiredLib$x;

function requireLib$x () {
	if (hasRequiredLib$x) return lib$w;
	hasRequiredLib$x = 1;
	Object.defineProperty(lib$w, "__esModule", {
	  value: true
	});
	lib$w.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$w.default = (0, _helperPluginUtils.declare)((api, {
	  loose = false
	}) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
	  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : false;
	  return {
	    name: "transform-nullish-coalescing-operator",
	    manipulateOptions: (_, parser) => parser.plugins.push("nullishCoalescingOperator"),
	    visitor: {
	      LogicalExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        if (node.operator !== "??") {
	          return;
	        }
	        let ref;
	        let assignment;
	        if (pureGetters && scope.path.isPattern() && _core.types.isMemberExpression(node.left) && !node.left.computed && _core.types.isIdentifier(node.left.object) && _core.types.isIdentifier(node.left.property) || _core.types.isIdentifier(node.left) && (pureGetters || scope.hasBinding(node.left.name))) {
	          ref = node.left;
	          assignment = _core.types.cloneNode(node.left);
	        } else if (scope.path.isPattern()) {
	          path.replaceWith(_core.template.statement.ast`(() => ${path.node})()`);
	          return;
	        } else {
	          ref = scope.generateUidIdentifierBasedOnNode(node.left);
	          scope.push({
	            id: _core.types.cloneNode(ref)
	          });
	          assignment = _core.types.assignmentExpression("=", ref, node.left);
	        }
	        path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
	      }
	    }
	  };
	});
	return lib$w;
}

var lib$v = {};

var hasRequiredLib$w;

function requireLib$w () {
	if (hasRequiredLib$w) return lib$v;
	hasRequiredLib$w = 1;
	Object.defineProperty(lib$v, "__esModule", {
	  value: true
	});
	lib$v.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	function remover({
	  node
	}) {
	  var _extra$raw;
	  const {
	    extra
	  } = node;
	  if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_")) {
	    extra.raw = extra.raw.replace(/_/g, "");
	  }
	}
	lib$v.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return {
	    name: "transform-numeric-separator",
	    manipulateOptions: (_, parser) => parser.plugins.push("numericSeparator"),
	    visitor: {
	      NumericLiteral: remover,
	      BigIntLiteral: remover
	    }
	  };
	});
	return lib$v;
}

var lib$u = {};

var lib$t = {};

var params = {};

var shadowUtils = {};

var hasRequiredShadowUtils;

function requireShadowUtils () {
	if (hasRequiredShadowUtils) return shadowUtils;
	hasRequiredShadowUtils = 1;
	Object.defineProperty(shadowUtils, "__esModule", {
	  value: true
	});
	shadowUtils.buildScopeIIFE = buildScopeIIFE;
	shadowUtils.collectShadowedParamsNames = collectShadowedParamsNames;
	shadowUtils.iifeVisitor = void 0;
	var _core = require$$0$b;
	shadowUtils.iifeVisitor = {
	  "ReferencedIdentifier|BindingIdentifier"(path, state) {
	    const {
	      scope,
	      node
	    } = path;
	    const {
	      name
	    } = node;
	    if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
	      state.needsOuterBinding = true;
	      path.stop();
	    }
	  },
	  "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": (path) => path.skip()
	};
	function collectShadowedParamsNames(param, functionScope, shadowedParams) {
	  for (const name of Object.keys(param.getBindingIdentifiers())) {
	    var _functionScope$bindin;
	    const constantViolations = (_functionScope$bindin = functionScope.bindings[name]) == null ? void 0 : _functionScope$bindin.constantViolations;
	    if (constantViolations) {
	      for (const redeclarator of constantViolations) {
	        const node = redeclarator.node;
	        switch (node.type) {
	          case "VariableDeclarator": {
	            if (node.init === null) {
	              const declaration = redeclarator.parentPath;
	              if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
	                redeclarator.remove();
	                break;
	              }
	            }
	            shadowedParams.add(name);
	            break;
	          }
	          case "FunctionDeclaration":
	            shadowedParams.add(name);
	            break;
	        }
	      }
	    }
	  }
	}
	function buildScopeIIFE(shadowedParams, body) {
	  const args = [];
	  const params = [];
	  for (const name of shadowedParams) {
	    args.push(_core.types.identifier(name));
	    params.push(_core.types.identifier(name));
	  }
	  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));
	}
	return shadowUtils;
}

var hasRequiredParams;

function requireParams () {
	if (hasRequiredParams) return params;
	hasRequiredParams = 1;
	Object.defineProperty(params, "__esModule", {
	  value: true
	});
	params.default = convertFunctionParams;
	var _core = require$$0$b;
	var _shadowUtils = requireShadowUtils();
	const buildDefaultParam = _core.template.statement(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?
      arguments[ARGUMENT_KEY]
    :
      DEFAULT_VALUE;
`);
	const buildLooseDefaultParam = _core.template.statement(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {
    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
  }
`);
	const buildLooseDestructuredDefaultParam = _core.template.statement(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;
`);
	const buildSafeArgumentsAccess = _core.template.statement(`
  let $0 = arguments.length > $1 ? arguments[$1] : undefined;
`);
	function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
	  const params = path.get("params");
	  const isSimpleParameterList = params.every((param) => param.isIdentifier());
	  if (isSimpleParameterList) return false;
	  const {
	    node,
	    scope
	  } = path;
	  const body = [];
	  const shadowedParams = /* @__PURE__ */ new Set();
	  for (const param of params) {
	    (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);
	  }
	  const state = {
	    needsOuterBinding: false,
	    scope
	  };
	  if (shadowedParams.size === 0) {
	    for (const param of params) {
	      if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);
	      if (state.needsOuterBinding) break;
	    }
	  }
	  let firstOptionalIndex = null;
	  for (let i = 0; i < params.length; i++) {
	    const param = params[i];
	    if (shouldTransformParam && !shouldTransformParam(i)) {
	      continue;
	    }
	    const transformedRestNodes = [];
	    if (replaceRestElement) {
	      replaceRestElement(path, param, transformedRestNodes);
	    }
	    const paramIsAssignmentPattern = param.isAssignmentPattern();
	    if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {
	      kind: "set"
	    }))) {
	      const left = param.get("left");
	      const right = param.get("right");
	      const undefinedNode = scope.buildUndefinedNode();
	      if (left.isIdentifier()) {
	        body.push(buildLooseDefaultParam({
	          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
	          DEFAULT_VALUE: right.node,
	          UNDEFINED: undefinedNode
	        }));
	        param.replaceWith(left.node);
	      } else if (left.isObjectPattern() || left.isArrayPattern()) {
	        const paramName = scope.generateUidIdentifier();
	        body.push(buildLooseDestructuredDefaultParam({
	          ASSIGNMENT_IDENTIFIER: left.node,
	          DEFAULT_VALUE: right.node,
	          PARAMETER_NAME: _core.types.cloneNode(paramName),
	          UNDEFINED: undefinedNode
	        }));
	        param.replaceWith(paramName);
	      }
	    } else if (paramIsAssignmentPattern) {
	      if (firstOptionalIndex === null) firstOptionalIndex = i;
	      const left = param.get("left");
	      const right = param.get("right");
	      const defNode = buildDefaultParam({
	        VARIABLE_NAME: left.node,
	        DEFAULT_VALUE: right.node,
	        ARGUMENT_KEY: _core.types.numericLiteral(i)
	      });
	      body.push(defNode);
	    } else if (firstOptionalIndex !== null) {
	      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);
	      body.push(defNode);
	    } else if (param.isObjectPattern() || param.isArrayPattern()) {
	      const uid = path.scope.generateUidIdentifier("ref");
	      uid.typeAnnotation = param.node.typeAnnotation;
	      const defNode = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(param.node, uid)]);
	      body.push(defNode);
	      param.replaceWith(_core.types.cloneNode(uid));
	    }
	    if (transformedRestNodes) {
	      for (const transformedNode of transformedRestNodes) {
	        body.push(transformedNode);
	      }
	    }
	  }
	  if (firstOptionalIndex !== null) {
	    node.params = node.params.slice(0, firstOptionalIndex);
	  }
	  path.ensureBlock();
	  const path2 = path;
	  const {
	    async,
	    generator
	  } = node;
	  if (generator || state.needsOuterBinding || shadowedParams.size > 0) {
	    body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path2.node.body));
	    path.set("body", _core.types.blockStatement(body));
	    const bodyPath = path2.get("body.body");
	    const arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
	    arrowPath.arrowFunctionToExpression();
	    arrowPath.node.generator = generator;
	    arrowPath.node.async = async;
	    node.generator = false;
	    node.async = false;
	    if (async) {
	      path2.node.body = _core.template.statement.ast`{
        try {
          ${path2.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`;
	    }
	  } else {
	    path2.get("body").unshiftContainer("body", body);
	  }
	  return true;
	}
	return params;
}

var rest = {};

var hasRequiredRest;

function requireRest () {
	if (hasRequiredRest) return rest;
	hasRequiredRest = 1;
	Object.defineProperty(rest, "__esModule", {
	  value: true
	});
	rest.default = convertFunctionRest;
	var _core = require$$0$b;
	var _shadowUtils = requireShadowUtils();
	const buildRest = _core.template.statement(`
  for (var LEN = ARGUMENTS.length,
           ARRAY = new Array(ARRAY_LEN),
           KEY = START;
       KEY < LEN;
       KEY++) {
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
  }
`);
	const restIndex = _core.template.expression(`
  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]
`);
	const restIndexImpure = _core.template.expression(`
  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]
`);
	const restLength = _core.template.expression(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`);
	function referencesRest(path, state) {
	  if (path.node.name === state.name) {
	    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
	  }
	  return false;
	}
	const memberExpressionOptimisationVisitor = {
	  Scope(path, state) {
	    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
	      path.skip();
	    }
	  },
	  Flow(path) {
	    if (path.isTypeCastExpression()) return;
	    path.skip();
	  },
	  Function(path, state) {
	    const oldNoOptimise = state.noOptimise;
	    state.noOptimise = true;
	    path.traverse(memberExpressionOptimisationVisitor, state);
	    state.noOptimise = oldNoOptimise;
	    path.skip();
	  },
	  ReferencedIdentifier(path, state) {
	    const {
	      node
	    } = path;
	    if (node.name === "arguments") {
	      state.deopted = true;
	    }
	    if (!referencesRest(path, state)) return;
	    if (state.noOptimise) {
	      state.deopted = true;
	    } else {
	      const {
	        parentPath
	      } = path;
	      if (parentPath.listKey === "params" && parentPath.key < state.offset) {
	        return;
	      }
	      if (parentPath.isMemberExpression({
	        object: node
	      })) {
	        const grandparentPath = parentPath.parentPath;
	        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
	          operator: "delete"
	        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);
	        if (argsOptEligible) {
	          if (parentPath.node.computed) {
	            if (parentPath.get("property").isBaseType("number")) {
	              state.candidates.push({
	                cause: "indexGetter",
	                path
	              });
	              return;
	            }
	          } else if (parentPath.node.property.name === "length") {
	            state.candidates.push({
	              cause: "lengthGetter",
	              path
	            });
	            return;
	          }
	        }
	      }
	      if (state.offset === 0 && parentPath.isSpreadElement()) {
	        const call = parentPath.parentPath;
	        if (call.isCallExpression() && call.node.arguments.length === 1) {
	          state.candidates.push({
	            cause: "argSpread",
	            path
	          });
	          return;
	        }
	      }
	      state.references.push(path);
	    }
	  },
	  BindingIdentifier(path, state) {
	    if (referencesRest(path, state)) {
	      state.deopted = true;
	    }
	  }
	};
	function getParamsCount(node) {
	  let count = node.params.length;
	  if (count > 0 && _core.types.isIdentifier(node.params[0], {
	    name: "this"
	  })) {
	    count -= 1;
	  }
	  return count;
	}
	function hasRest(node) {
	  const length = node.params.length;
	  return length > 0 && _core.types.isRestElement(node.params[length - 1]);
	}
	function optimiseIndexGetter(path, argsId, offset) {
	  const offsetLiteral = _core.types.numericLiteral(offset);
	  let index;
	  const parent = path.parent;
	  if (_core.types.isNumericLiteral(parent.property)) {
	    index = _core.types.numericLiteral(parent.property.value + offset);
	  } else if (offset === 0) {
	    index = parent.property;
	  } else {
	    index = _core.types.binaryExpression("+", parent.property, _core.types.cloneNode(offsetLiteral));
	  }
	  const {
	    scope,
	    parentPath
	  } = path;
	  if (!scope.isPure(index)) {
	    const temp = scope.generateUidIdentifierBasedOnNode(index);
	    scope.push({
	      id: temp,
	      kind: "var"
	    });
	    parentPath.replaceWith(restIndexImpure({
	      ARGUMENTS: argsId,
	      OFFSET: offsetLiteral,
	      INDEX: index,
	      REF: _core.types.cloneNode(temp)
	    }));
	  } else {
	    parentPath.replaceWith(restIndex({
	      ARGUMENTS: argsId,
	      OFFSET: offsetLiteral,
	      INDEX: index
	    }));
	    const replacedParentPath = parentPath;
	    const offsetTestPath = replacedParentPath.get("test");
	    const valRes = offsetTestPath.get("left").evaluate();
	    if (valRes.confident) {
	      if (valRes.value === true) {
	        replacedParentPath.replaceWith(scope.buildUndefinedNode());
	      } else {
	        offsetTestPath.replaceWith(offsetTestPath.get("right"));
	      }
	    }
	  }
	}
	function optimiseLengthGetter(path, argsId, offset) {
	  if (offset) {
	    path.parentPath.replaceWith(restLength({
	      ARGUMENTS: argsId,
	      OFFSET: _core.types.numericLiteral(offset)
	    }));
	  } else {
	    path.replaceWith(argsId);
	  }
	}
	function convertFunctionRest(path) {
	  const {
	    node,
	    scope
	  } = path;
	  if (!hasRest(node)) return false;
	  const restPath = path.get(`params.${node.params.length - 1}.argument`);
	  if (!restPath.isIdentifier()) {
	    const shadowedParams = /* @__PURE__ */ new Set();
	    (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);
	    let needsIIFE = shadowedParams.size > 0;
	    if (!needsIIFE) {
	      const state2 = {
	        needsOuterBinding: false,
	        scope
	      };
	      restPath.traverse(_shadowUtils.iifeVisitor, state2);
	      needsIIFE = state2.needsOuterBinding;
	    }
	    if (needsIIFE) {
	      path.ensureBlock();
	      path.set("body", _core.types.blockStatement([(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)]));
	    }
	  }
	  let rest = restPath.node;
	  node.params.pop();
	  if (_core.types.isPattern(rest)) {
	    const pattern = rest;
	    rest = scope.generateUidIdentifier("ref");
	    const declar = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(pattern, rest)]);
	    path.ensureBlock();
	    node.body.body.unshift(declar);
	  } else if (rest.name === "arguments") {
	    scope.rename(rest.name);
	  }
	  const argsId = _core.types.identifier("arguments");
	  const paramsCount = getParamsCount(node);
	  const state = {
	    references: [],
	    offset: paramsCount,
	    argumentsNode: argsId,
	    outerBinding: scope.getBindingIdentifier(rest.name),
	    candidates: [],
	    name: rest.name,
	    deopted: false
	  };
	  path.traverse(memberExpressionOptimisationVisitor, state);
	  if (!state.deopted && !state.references.length) {
	    for (const {
	      path: path2,
	      cause
	    } of state.candidates) {
	      const clonedArgsId = _core.types.cloneNode(argsId);
	      switch (cause) {
	        case "indexGetter":
	          optimiseIndexGetter(path2, clonedArgsId, state.offset);
	          break;
	        case "lengthGetter":
	          optimiseLengthGetter(path2, clonedArgsId, state.offset);
	          break;
	        default:
	          path2.replaceWith(clonedArgsId);
	      }
	    }
	    return true;
	  }
	  state.references.push(...state.candidates.map(({
	    path: path2
	  }) => path2));
	  const start = _core.types.numericLiteral(paramsCount);
	  const key = scope.generateUidIdentifier("key");
	  const len = scope.generateUidIdentifier("len");
	  let arrKey, arrLen;
	  if (paramsCount) {
	    arrKey = _core.types.binaryExpression("-", _core.types.cloneNode(key), _core.types.cloneNode(start));
	    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(">", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression("-", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));
	  } else {
	    arrKey = _core.types.identifier(key.name);
	    arrLen = _core.types.identifier(len.name);
	  }
	  const loop = buildRest({
	    ARGUMENTS: argsId,
	    ARRAY_KEY: arrKey,
	    ARRAY_LEN: arrLen,
	    START: start,
	    ARRAY: rest,
	    KEY: key,
	    LEN: len
	  });
	  if (state.deopted) {
	    node.body.body.unshift(loop);
	  } else {
	    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
	    target.findParent((path2) => {
	      if (path2.isLoop()) {
	        target = path2;
	      } else {
	        return path2.isFunction();
	      }
	    });
	    target.insertBefore(loop);
	  }
	  return true;
	}
	return rest;
}

var hasRequiredLib$v;

function requireLib$v () {
	if (hasRequiredLib$v) return lib$t;
	hasRequiredLib$v = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "convertFunctionParams", {
		  enumerable: true,
		  get: function() {
		    return _params.default;
		  }
		});
		exports.default = void 0;
		var _helperPluginUtils = requireLib$1f();
		var _params = requireParams();
		var _rest = requireRest();
		exports.default = (0, _helperPluginUtils.declare)((api, options) => {
		  var _api$assumption, _api$assumption2;
		  api.assertVersion(7);
		  const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose;
		  const noNewArrows = (_api$assumption2 = api.assumption("noNewArrows")) != null ? _api$assumption2 : true;
		  return {
		    name: "transform-parameters",
		    visitor: {
		      Function(path) {
		        if (path.isArrowFunctionExpression() && path.get("params").some((param) => param.isRestElement() || param.isAssignmentPattern())) {
		          path.arrowFunctionToExpression({
		            allowInsertArrowWithRest: false,
		            noNewArrows
		          });
		          if (!path.isFunctionExpression()) return;
		        }
		        const convertedRest = (0, _rest.default)(path);
		        const convertedParams = (0, _params.default)(path, ignoreFunctionLength);
		        if (convertedRest || convertedParams) {
		          path.scope.crawl();
		        }
		      }
		    }
		  };
		}); 
	} (lib$t));
	return lib$t;
}

var hasRequiredLib$u;

function requireLib$u () {
	if (hasRequiredLib$u) return lib$u;
	hasRequiredLib$u = 1;
	Object.defineProperty(lib$u, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	var core = require$$0$b;
	var pluginTransformParameters = requireLib$v();
	var helperCompilationTargets = requireLib$1g();
	var pluginTransformDestructuring = requireLib$S();
	function shouldStoreRHSInTemporaryVariable(node) {
	  if (!node) return false;
	  if (node.type === "ArrayPattern") {
	    const nonNullElements = node.elements.filter((element) => element !== null);
	    if (nonNullElements.length > 1) return true;
	    else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
	  } else if (node.type === "ObjectPattern") {
	    const {
	      properties
	    } = node;
	    if (properties.length > 1) return true;
	    else if (properties.length === 0) return false;
	    else {
	      const firstProperty = properties[0];
	      if (firstProperty.type === "ObjectProperty") {
	        return shouldStoreRHSInTemporaryVariable(firstProperty.value);
	      } else {
	        return shouldStoreRHSInTemporaryVariable(firstProperty);
	      }
	    }
	  } else if (node.type === "AssignmentPattern") {
	    return shouldStoreRHSInTemporaryVariable(node.left);
	  } else if (node.type === "RestElement") {
	    if (node.argument.type === "Identifier") return true;
	    return shouldStoreRHSInTemporaryVariable(node.argument);
	  } else {
	    return false;
	  }
	}
	var compatData = {
	  "Object.assign": {
	    chrome: "49",
	    opera: "36",
	    edge: "13",
	    firefox: "36",
	    safari: "10",
	    node: "6",
	    deno: "1",
	    ios: "10",
	    samsung: "5",
	    opera_mobile: "36",
	    electron: "0.37"
	  }
	};
	{
	  const node = core.types.identifier("a");
	  const property = core.types.objectProperty(core.types.identifier("key"), node);
	  const pattern = core.types.objectPattern([property]);
	  var ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;
	}
	var index = helperPluginUtils.declare((api, opts) => {
	  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const targets = api.targets();
	  const supportsObjectAssign = !helperCompilationTargets.isRequired("Object.assign", targets, {
	    compatData
	  });
	  const {
	    useBuiltIns = supportsObjectAssign,
	    loose = false
	  } = opts;
	  if (typeof loose !== "boolean") {
	    throw new Error(".loose must be a boolean, or undefined");
	  }
	  const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose;
	  const objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose;
	  const pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose;
	  const setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;
	  function getExtendsHelper(file) {
	    return useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : file.addHelper("extends");
	  }
	  function* iterateObjectRestElement(path) {
	    switch (path.type) {
	      case "ArrayPattern":
	        for (const elementPath of path.get("elements")) {
	          if (elementPath.isRestElement()) {
	            yield* iterateObjectRestElement(elementPath.get("argument"));
	          } else {
	            yield* iterateObjectRestElement(elementPath);
	          }
	        }
	        break;
	      case "ObjectPattern":
	        for (const propertyPath of path.get("properties")) {
	          if (propertyPath.isRestElement()) {
	            yield propertyPath;
	          } else {
	            yield* iterateObjectRestElement(propertyPath.get("value"));
	          }
	        }
	        break;
	      case "AssignmentPattern":
	        yield* iterateObjectRestElement(path.get("left"));
	        break;
	    }
	  }
	  function hasObjectRestElement(path) {
	    const objectRestPatternIterator = iterateObjectRestElement(path);
	    return !objectRestPatternIterator.next().done;
	  }
	  function visitObjectRestElements(path, visitor) {
	    for (const restElementPath of iterateObjectRestElement(path)) {
	      visitor(restElementPath);
	    }
	  }
	  function hasSpread(node) {
	    for (const prop of node.properties) {
	      if (core.types.isSpreadElement(prop)) {
	        return true;
	      }
	    }
	    return false;
	  }
	  function extractNormalizedKeys(node) {
	    const props = node.properties;
	    const keys = [];
	    let allPrimitives = true;
	    let hasTemplateLiteral = false;
	    for (const prop of props) {
	      const {
	        key
	      } = prop;
	      if (core.types.isIdentifier(key) && !prop.computed) {
	        keys.push(core.types.stringLiteral(key.name));
	      } else if (core.types.isTemplateLiteral(key)) {
	        keys.push(core.types.cloneNode(key));
	        hasTemplateLiteral = true;
	      } else if (core.types.isLiteral(key)) {
	        keys.push(core.types.stringLiteral(String(key.value)));
	      } else {
	        keys.push(core.types.cloneNode(key));
	        if (core.types.isMemberExpression(key, {
	          computed: false
	        }) && core.types.isIdentifier(key.object, {
	          name: "Symbol"
	        }) || core.types.isCallExpression(key) && core.types.matchesPattern(key.callee, "Symbol.for")) ;
	        else {
	          allPrimitives = false;
	        }
	      }
	    }
	    return {
	      keys,
	      allPrimitives,
	      hasTemplateLiteral
	    };
	  }
	  function replaceImpureComputedKeys(properties, scope) {
	    const impureComputedPropertyDeclarators = [];
	    for (const propPath of properties) {
	      const key = propPath.get("key");
	      if (propPath.node.computed && !key.isPure()) {
	        const name = scope.generateUidBasedOnNode(key.node);
	        const declarator = core.types.variableDeclarator(core.types.identifier(name), key.node);
	        impureComputedPropertyDeclarators.push(declarator);
	        key.replaceWith(core.types.identifier(name));
	      }
	    }
	    return impureComputedPropertyDeclarators;
	  }
	  function removeUnusedExcludedKeys(path) {
	    const bindings = path.getOuterBindingIdentifierPaths();
	    Object.keys(bindings).forEach((bindingName) => {
	      const bindingParentPath = bindings[bindingName].parentPath;
	      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
	        return;
	      }
	      bindingParentPath.remove();
	    });
	  }
	  function createObjectRest(path, file, objRef) {
	    const props = path.get("properties");
	    const last = props[props.length - 1];
	    core.types.assertRestElement(last.node);
	    const restElement = core.types.cloneNode(last.node);
	    last.remove();
	    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);
	    const {
	      keys,
	      allPrimitives,
	      hasTemplateLiteral
	    } = extractNormalizedKeys(path.node);
	    if (keys.length === 0) {
	      return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(getExtendsHelper(file), [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(file.addHelper("objectDestructuringEmpty"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])])];
	    }
	    let keyExpression;
	    if (!allPrimitives) {
	      keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier("map")), [file.addHelper("toPropertyKey")]);
	    } else {
	      keyExpression = core.types.arrayExpression(keys);
	      if (!hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {
	        const program = path.findParent((path2) => path2.isProgram());
	        const id = path.scope.generateUidIdentifier("excluded");
	        program.scope.push({
	          id,
	          init: keyExpression,
	          kind: "const"
	        });
	        keyExpression = core.types.cloneNode(id);
	      }
	    }
	    return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [core.types.cloneNode(objRef), keyExpression])];
	  }
	  function replaceRestElement(parentPath, paramPath, container) {
	    if (paramPath.isAssignmentPattern()) {
	      replaceRestElement(parentPath, paramPath.get("left"), container);
	      return;
	    }
	    if (paramPath.isArrayPattern() && hasObjectRestElement(paramPath)) {
	      const elements = paramPath.get("elements");
	      for (let i = 0; i < elements.length; i++) {
	        replaceRestElement(parentPath, elements[i], container);
	      }
	    }
	    if (paramPath.isObjectPattern() && hasObjectRestElement(paramPath)) {
	      const uid = parentPath.scope.generateUidIdentifier("ref");
	      const declar = core.types.variableDeclaration("let", [core.types.variableDeclarator(paramPath.node, uid)]);
	      if (container) {
	        container.push(declar);
	      } else {
	        parentPath.ensureBlock();
	        parentPath.get("body").unshiftContainer("body", declar);
	      }
	      paramPath.replaceWith(core.types.cloneNode(uid));
	    }
	  }
	  return {
	    name: "transform-object-rest-spread",
	    manipulateOptions: (_, parser) => parser.plugins.push("objectRestSpread"),
	    visitor: {
	      Function(path) {
	        const params = path.get("params");
	        const paramsWithRestElement = /* @__PURE__ */ new Set();
	        const idsInRestParams = /* @__PURE__ */ new Set();
	        for (let i2 = 0; i2 < params.length; ++i2) {
	          const param = params[i2];
	          if (hasObjectRestElement(param)) {
	            paramsWithRestElement.add(i2);
	            for (const name of Object.keys(param.getBindingIdentifiers())) {
	              idsInRestParams.add(name);
	            }
	          }
	        }
	        let idInRest = false;
	        const IdentifierHandler = function(path2, functionScope) {
	          const name = path2.node.name;
	          if (path2.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
	            idInRest = true;
	            path2.stop();
	          }
	        };
	        let i;
	        for (i = 0; i < params.length && !idInRest; ++i) {
	          const param = params[i];
	          if (!paramsWithRestElement.has(i)) {
	            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {
	              IdentifierHandler(param, path.scope);
	            } else {
	              param.traverse({
	                "Scope|TypeAnnotation|TSTypeAnnotation": (path2) => path2.skip(),
	                "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
	              }, path.scope);
	            }
	          }
	        }
	        if (!idInRest) {
	          for (let i2 = 0; i2 < params.length; ++i2) {
	            const param = params[i2];
	            if (paramsWithRestElement.has(i2)) {
	              replaceRestElement(path, param);
	            }
	          }
	        } else {
	          const shouldTransformParam = (idx) => idx >= i - 1 || paramsWithRestElement.has(idx);
	          pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
	        }
	      },
	      VariableDeclarator(path, file) {
	        if (!path.get("id").isObjectPattern()) {
	          return;
	        }
	        let insertionPath = path;
	        const originalPath = path;
	        visitObjectRestElements(path.get("id"), (path2) => {
	          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {
	            const initRef = path2.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
	            originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init));
	            originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));
	            return;
	          }
	          let ref = originalPath.node.init;
	          const refPropertyPath = [];
	          let kind;
	          path2.findParent((path3) => {
	            if (path3.isObjectProperty()) {
	              refPropertyPath.unshift(path3);
	            } else if (path3.isVariableDeclarator()) {
	              kind = path3.parentPath.node.kind;
	              return true;
	            }
	          });
	          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path2.scope);
	          refPropertyPath.forEach((prop) => {
	            const {
	              node
	            } = prop;
	            ref = core.types.memberExpression(ref, core.types.cloneNode(node.key), node.computed || core.types.isLiteral(node.key));
	          });
	          const objectPatternPath = path2.parentPath;
	          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);
	          if (pureGetters) {
	            removeUnusedExcludedKeys(objectPatternPath);
	          }
	          core.types.assertIdentifier(argument);
	          insertionPath.insertBefore(impureComputedPropertyDeclarators);
	          insertionPath.insertBefore(impureObjRefComputedDeclarators);
	          insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0];
	          path2.scope.registerBinding(kind, insertionPath);
	          if (objectPatternPath.node.properties.length === 0) {
	            objectPatternPath.findParent((path3) => path3.isObjectProperty() || path3.isVariableDeclarator()).remove();
	          }
	        });
	      },
	      ExportNamedDeclaration(path) {
	        const declaration = path.get("declaration");
	        if (!declaration.isVariableDeclaration()) return;
	        const hasRest = declaration.get("declarations").some((path2) => hasObjectRestElement(path2.get("id")));
	        if (!hasRest) return;
	        const specifiers = [];
	        for (const name of Object.keys(path.getOuterBindingIdentifiers(true))) {
	          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
	        }
	        path.replaceWith(declaration.node);
	        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
	      },
	      CatchClause(path) {
	        const paramPath = path.get("param");
	        replaceRestElement(path, paramPath);
	      },
	      AssignmentExpression(path, file) {
	        const leftPath = path.get("left");
	        if (leftPath.isObjectPattern() && hasObjectRestElement(leftPath)) {
	          const nodes = [];
	          const refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
	          nodes.push(core.types.variableDeclaration("var", [core.types.variableDeclarator(core.types.identifier(refName), path.node.right)]));
	          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));
	          if (impureComputedPropertyDeclarators.length > 0) {
	            nodes.push(core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
	          }
	          const nodeWithoutSpread = core.types.cloneNode(path.node);
	          nodeWithoutSpread.right = core.types.identifier(refName);
	          nodes.push(core.types.expressionStatement(nodeWithoutSpread));
	          nodes.push(core.types.expressionStatement(core.types.assignmentExpression("=", argument, callExpression)));
	          nodes.push(core.types.expressionStatement(core.types.identifier(refName)));
	          path.replaceWithMultiple(nodes);
	        }
	      },
	      ForXStatement(path) {
	        const {
	          node,
	          scope
	        } = path;
	        const leftPath = path.get("left");
	        if (!leftPath.isVariableDeclaration()) {
	          if (!hasObjectRestElement(leftPath)) {
	            return;
	          }
	          const temp = scope.generateUidIdentifier("ref");
	          node.left = core.types.variableDeclaration("var", [core.types.variableDeclarator(temp)]);
	          path.ensureBlock();
	          const statementBody = path.node.body.body;
	          const nodes = [];
	          if (statementBody.length === 0 && path.isCompletionRecord()) {
	            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
	          }
	          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", leftPath.node, core.types.cloneNode(temp))));
	          pluginTransformDestructuring.unshiftForXStatementBody(path, nodes);
	          scope.crawl();
	          return;
	        } else {
	          const patternPath = leftPath.get("declarations")[0].get("id");
	          if (!hasObjectRestElement(patternPath)) {
	            return;
	          }
	          const left = leftPath.node;
	          const pattern = patternPath.node;
	          const key = scope.generateUidIdentifier("ref");
	          node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);
	          path.ensureBlock();
	          pluginTransformDestructuring.unshiftForXStatementBody(path, [core.types.variableDeclaration(node.left.kind, [core.types.variableDeclarator(pattern, core.types.cloneNode(key))])]);
	          scope.crawl();
	          return;
	        }
	      },
	      ArrayPattern(path) {
	        const objectPatterns = [];
	        const {
	          scope
	        } = path;
	        const uidIdentifiers = [];
	        visitObjectRestElements(path, (path2) => {
	          const objectPattern = path2.parentPath;
	          const uid = scope.generateUidIdentifier("ref");
	          objectPatterns.push({
	            left: objectPattern.node,
	            right: uid
	          });
	          uidIdentifiers.push(uid);
	          objectPattern.replaceWith(core.types.cloneNode(uid));
	          path2.skip();
	        });
	        if (objectPatterns.length > 0) {
	          const patternParentPath = path.findParent((path2) => !(path2.isPattern() || path2.isObjectProperty()));
	          const patternParent = patternParentPath.node;
	          switch (patternParent.type) {
	            case "VariableDeclarator":
	              patternParentPath.insertAfter(objectPatterns.map(({
	                left,
	                right
	              }) => core.types.variableDeclarator(left, right)));
	              break;
	            case "AssignmentExpression":
	              {
	                for (const uidIdentifier of uidIdentifiers) {
	                  scope.push({
	                    id: core.types.cloneNode(uidIdentifier)
	                  });
	                }
	                patternParentPath.insertAfter(objectPatterns.map(({
	                  left,
	                  right
	                }) => core.types.assignmentExpression("=", left, right)));
	              }
	              break;
	            default:
	              throw new Error(`Unexpected pattern parent type: ${patternParent.type}`);
	          }
	        }
	      },
	      ObjectExpression(path, file) {
	        if (!hasSpread(path.node)) return;
	        let helper;
	        if (setSpreadProperties) {
	          helper = getExtendsHelper(file);
	        } else {
	          {
	            try {
	              helper = file.addHelper("objectSpread2");
	            } catch (_unused) {
	              this.file.declarations.objectSpread2 = null;
	              helper = file.addHelper("objectSpread");
	            }
	          }
	        }
	        let exp = null;
	        let props = [];
	        function make() {
	          const hadProps = props.length > 0;
	          const obj = core.types.objectExpression(props);
	          props = [];
	          if (!exp) {
	            exp = core.types.callExpression(helper, [obj]);
	            return;
	          }
	          if (pureGetters) {
	            if (hadProps) {
	              exp.arguments.push(obj);
	            }
	            return;
	          }
	          exp = core.types.callExpression(core.types.cloneNode(helper), [exp, ...hadProps ? [core.types.objectExpression([]), obj] : []]);
	        }
	        for (const prop of path.node.properties) {
	          if (core.types.isSpreadElement(prop)) {
	            make();
	            exp.arguments.push(prop.argument);
	          } else {
	            props.push(prop);
	          }
	        }
	        if (props.length) make();
	        path.replaceWith(exp);
	      }
	    }
	  };
	});
	lib$u.default = index;
	return lib$u;
}

var lib$s = {};

var hasRequiredLib$t;

function requireLib$t () {
	if (hasRequiredLib$t) return lib$s;
	hasRequiredLib$t = 1;
	Object.defineProperty(lib$s, "__esModule", {
	  value: true
	});
	lib$s.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperReplaceSupers = requireLib$Z();
	var _core = require$$0$b;
	function replacePropertySuper(path, getObjectRef, file) {
	  const replaceSupers = new _helperReplaceSupers.default({
	    getObjectRef,
	    methodPath: path,
	    file
	  });
	  replaceSupers.replace();
	}
	lib$s.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  const newLets = /* @__PURE__ */ new Set();
	  return {
	    name: "transform-object-super",
	    visitor: {
	      Loop: {
	        exit(path) {
	          newLets.forEach((v) => {
	            if (v.scopePath === path) {
	              path.scope.push({
	                id: v.id,
	                kind: "let"
	              });
	              path.scope.crawl();
	              path.requeue();
	              newLets.delete(v);
	            }
	          });
	        }
	      },
	      ObjectExpression(path, state) {
	        let objectRef;
	        const getObjectRef = () => objectRef = objectRef || path.scope.generateUidIdentifier("obj");
	        path.get("properties").forEach((propPath) => {
	          if (!propPath.isMethod()) return;
	          replacePropertySuper(propPath, getObjectRef, state.file);
	        });
	        if (objectRef) {
	          const scopePath = path.findParent((p) => p.isFunction() || p.isProgram() || p.isLoop());
	          const useLet = scopePath.isLoop();
	          if (useLet) {
	            newLets.add({
	              scopePath,
	              id: _core.types.cloneNode(objectRef)
	            });
	          } else {
	            path.scope.push({
	              id: _core.types.cloneNode(objectRef),
	              kind: "var"
	            });
	          }
	          path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(objectRef), path.node));
	        }
	      }
	    }
	  };
	});
	return lib$s;
}

var lib$r = {};

var hasRequiredLib$s;

function requireLib$s () {
	if (hasRequiredLib$s) return lib$r;
	hasRequiredLib$s = 1;
	Object.defineProperty(lib$r, "__esModule", {
	  value: true
	});
	lib$r.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	lib$r.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return {
	    name: "transform-optional-catch-binding",
	    manipulateOptions: (_, parser) => parser.plugins.push("optionalCatchBinding"),
	    visitor: {
	      CatchClause(path) {
	        if (!path.node.param) {
	          const uid = path.scope.generateUidIdentifier("unused");
	          const paramPath = path.get("param");
	          paramPath.replaceWith(uid);
	        }
	      }
	    }
	  };
	});
	return lib$r;
}

var lib$q = {};

var hasRequiredLib$r;

function requireLib$r () {
	if (hasRequiredLib$r) return lib$q;
	hasRequiredLib$r = 1;
	Object.defineProperty(lib$q, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	var core = require$$0$b;
	var helperSkipTransparentExpressionWrappers = requireLib$X();
	function willPathCastToBoolean(path) {
	  const maybeWrapped = findOutermostTransparentParent(path);
	  const {
	    node,
	    parentPath
	  } = maybeWrapped;
	  if (parentPath.isLogicalExpression()) {
	    const {
	      operator,
	      right
	    } = parentPath.node;
	    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
	      return willPathCastToBoolean(parentPath);
	    }
	  }
	  if (parentPath.isSequenceExpression()) {
	    const {
	      expressions
	    } = parentPath.node;
	    if (expressions[expressions.length - 1] === node) {
	      return willPathCastToBoolean(parentPath);
	    } else {
	      return true;
	    }
	  }
	  return parentPath.isConditional({
	    test: node
	  }) || parentPath.isUnaryExpression({
	    operator: "!"
	  }) || parentPath.isLoop({
	    test: node
	  });
	}
	function findOutermostTransparentParent(path) {
	  let maybeWrapped = path;
	  path.findParent((p) => {
	    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;
	    maybeWrapped = p;
	  });
	  return maybeWrapped;
	}
	const last = (arr) => arr[arr.length - 1];
	function isSimpleMemberExpression(expression) {
	  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);
	  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
	}
	function needsMemoize(path) {
	  let optionalPath = path;
	  const {
	    scope
	  } = path;
	  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
	    const {
	      node
	    } = optionalPath;
	    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get("object") : optionalPath.get("callee"));
	    if (node.optional) {
	      return !scope.isStatic(childPath.node);
	    }
	    optionalPath = childPath;
	  }
	}
	const NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);
	const NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);
	const NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);
	const NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);
	function transformOptionalChain(path, {
	  pureGetters,
	  noDocumentAll
	}, replacementPath, ifNullish, wrapLast) {
	  const {
	    scope
	  } = path;
	  if (scope.path.isPattern() && needsMemoize(path)) {
	    replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node})()`);
	    return;
	  }
	  const optionals = [];
	  let optionalPath = path;
	  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
	    const {
	      node
	    } = optionalPath;
	    if (node.optional) {
	      optionals.push(node);
	    }
	    if (optionalPath.isOptionalMemberExpression()) {
	      optionalPath.node.type = "MemberExpression";
	      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
	    } else if (optionalPath.isOptionalCallExpression()) {
	      optionalPath.node.type = "CallExpression";
	      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
	    }
	  }
	  if (optionals.length === 0) {
	    return;
	  }
	  const checks = [];
	  let tmpVar;
	  for (let i = optionals.length - 1; i >= 0; i--) {
	    const node = optionals[i];
	    const isCall = core.types.isCallExpression(node);
	    const chainWithTypes = isCall ? node.callee : node.object;
	    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
	    let ref;
	    let check2;
	    if (isCall && core.types.isIdentifier(chain, {
	      name: "eval"
	    })) {
	      check2 = ref = chain;
	      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);
	    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
	      check2 = ref = node.callee;
	    } else if (scope.isStatic(chain)) {
	      check2 = ref = chainWithTypes;
	    } else {
	      if (!tmpVar || isCall) {
	        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);
	        scope.push({
	          id: core.types.cloneNode(tmpVar)
	        });
	      }
	      ref = tmpVar;
	      check2 = core.types.assignmentExpression("=", core.types.cloneNode(tmpVar), chainWithTypes);
	      if (isCall) {
	        node.callee = ref;
	      } else {
	        node.object = ref;
	      }
	    }
	    if (isCall && core.types.isMemberExpression(chain)) {
	      if (pureGetters && isSimpleMemberExpression(chain)) {
	        node.callee = chainWithTypes;
	      } else {
	        const {
	          object
	        } = chain;
	        let context;
	        if (core.types.isSuper(object)) {
	          context = core.types.thisExpression();
	        } else {
	          const memoized = scope.maybeGenerateMemoised(object);
	          if (memoized) {
	            context = memoized;
	            chain.object = core.types.assignmentExpression("=", memoized, object);
	          } else {
	            context = object;
	          }
	        }
	        node.arguments.unshift(core.types.cloneNode(context));
	        node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
	      }
	    }
	    const data = {
	      check: core.types.cloneNode(check2),
	      ref: core.types.cloneNode(ref)
	    };
	    Object.defineProperty(data, "ref", {
	      enumerable: false
	    });
	    checks.push(data);
	  }
	  let result = replacementPath.node;
	  if (wrapLast) result = wrapLast(result);
	  const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);
	  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;
	  const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {
	    operator: "void"
	  });
	  const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;
	  const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;
	  const logicalOp = ifNullishFalse ? "&&" : "||";
	  const check = checks.map(tpl).reduce((expr, check2) => core.types.logicalExpression(logicalOp, expr, check2));
	  replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));
	}
	function transform(path, assumptions) {
	  const {
	    scope
	  } = path;
	  const maybeWrapped = findOutermostTransparentParent(path);
	  const {
	    parentPath
	  } = maybeWrapped;
	  if (parentPath.isUnaryExpression({
	    operator: "delete"
	  })) {
	    transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));
	  } else {
	    let wrapLast;
	    if (parentPath.isCallExpression({
	      callee: maybeWrapped.node
	    }) && path.isOptionalMemberExpression()) {
	      wrapLast = (replacement) => {
	        const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
	        let baseRef;
	        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {
	          baseRef = scope.maybeGenerateMemoised(object);
	          if (baseRef) {
	            replacement.object = core.types.assignmentExpression("=", baseRef, object);
	          }
	        }
	        return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [core.types.cloneNode(baseRef != null ? baseRef : object)]);
	      };
	    }
	    transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);
	  }
	}
	var index = helperPluginUtils.declare((api, options) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    loose = false
	  } = options;
	  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
	  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
	  return {
	    name: "transform-optional-chaining",
	    manipulateOptions: (_, parser) => parser.plugins.push("optionalChaining"),
	    visitor: {
	      "OptionalCallExpression|OptionalMemberExpression"(path) {
	        transform(path, {
	          noDocumentAll,
	          pureGetters
	        });
	      }
	    }
	  };
	});
	lib$q.default = index;
	lib$q.transform = transform;
	lib$q.transformOptionalChain = transformOptionalChain;
	return lib$q;
}

var lib$p = {};

var hasRequiredLib$q;

function requireLib$q () {
	if (hasRequiredLib$q) return lib$p;
	hasRequiredLib$q = 1;
	Object.defineProperty(lib$p, "__esModule", {
	  value: true
	});
	lib$p.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperCreateClassFeaturesPlugin = requireLib$W();
	lib$p.default = (0, _helperPluginUtils.declare)((api, options) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
	    name: "transform-private-methods",
	    api,
	    feature: _helperCreateClassFeaturesPlugin.FEATURES.privateMethods,
	    loose: options.loose,
	    manipulateOptions(opts, parserOpts) {
	      {
	        parserOpts.plugins.push("classPrivateMethods");
	      }
	    }
	  });
	});
	return lib$p;
}

var lib$o = {};

var hasRequiredLib$p;

function requireLib$p () {
	if (hasRequiredLib$p) return lib$o;
	hasRequiredLib$p = 1;
	Object.defineProperty(lib$o, "__esModule", {
	  value: true
	});
	lib$o.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperCreateClassFeaturesPlugin = requireLib$W();
	var _helperAnnotateAsPure = requireLib$17();
	lib$o.default = (0, _helperPluginUtils.declare)((api, opt) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    types: t,
	    template
	  } = api;
	  const {
	    loose
	  } = opt;
	  const classWeakSets = /* @__PURE__ */ new WeakMap();
	  const fieldsWeakSets = /* @__PURE__ */ new WeakMap();
	  function unshadow(name, targetScope, scope) {
	    while (scope !== targetScope) {
	      if (scope.hasOwnBinding(name)) scope.rename(name);
	      scope = scope.parent;
	    }
	  }
	  function injectToFieldInit(fieldPath, expr, before = false) {
	    if (fieldPath.node.value) {
	      const value = fieldPath.get("value");
	      if (before) {
	        value.insertBefore(expr);
	      } else {
	        value.insertAfter(expr);
	      }
	    } else {
	      fieldPath.set("value", t.unaryExpression("void", expr));
	    }
	  }
	  function injectInitialization(classPath, init) {
	    let firstFieldPath;
	    let constructorPath;
	    for (const el of classPath.get("body.body")) {
	      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {
	        firstFieldPath = el;
	        break;
	      }
	      if (!constructorPath && el.isClassMethod({
	        kind: "constructor"
	      })) {
	        constructorPath = el;
	      }
	    }
	    if (firstFieldPath) {
	      injectToFieldInit(firstFieldPath, init, true);
	    } else {
	      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);
	    }
	  }
	  function getWeakSetId(weakSets, outerClass, reference, name = "", inject) {
	    let id = weakSets.get(reference.node);
	    if (!id) {
	      id = outerClass.scope.generateUidIdentifier(`${name || ""} brandCheck`);
	      weakSets.set(reference.node, id);
	      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);
	      const newExpr = t.newExpression(t.identifier("WeakSet"), []);
	      (0, _helperAnnotateAsPure.default)(newExpr);
	      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);
	    }
	    return t.cloneNode(id);
	  }
	  return {
	    name: "transform-private-property-in-object",
	    manipulateOptions: (_, parser) => parser.plugins.push("privateIn"),
	    pre() {
	      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);
	    },
	    visitor: {
	      BinaryExpression(path, state) {
	        const {
	          node
	        } = path;
	        const {
	          file
	        } = state;
	        if (node.operator !== "in") return;
	        if (!t.isPrivateName(node.left)) return;
	        const {
	          name
	        } = node.left.id;
	        let privateElement;
	        const outerClass = path.findParent((path2) => {
	          if (!path2.isClass()) return false;
	          privateElement = path2.get("body.body").find(({
	            node: node2
	          }) => t.isPrivate(node2) && node2.key.id.name === name);
	          return !!privateElement;
	        });
	        if (outerClass.parentPath.scope.path.isPattern()) {
	          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);
	          return;
	        }
	        if (privateElement.node.type === "ClassPrivateMethod") {
	          if (privateElement.node.static) {
	            if (outerClass.node.id) {
	              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);
	            } else {
	              outerClass.set("id", path.scope.generateUidIdentifier("class"));
	            }
	            path.replaceWith(template.expression.ast`
                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}
              `);
	          } else {
	            var _outerClass$node$id;
	            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);
	            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
	          }
	        } else {
	          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);
	          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
	        }
	      }
	    }
	  };
	});
	return lib$o;
}

var lib$n = {};

var hasRequiredLib$o;

function requireLib$o () {
	if (hasRequiredLib$o) return lib$n;
	hasRequiredLib$o = 1;
	Object.defineProperty(lib$n, "__esModule", {
	  value: true
	});
	lib$n.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$n.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-property-literals",
	    visitor: {
	      ObjectProperty: {
	        exit({
	          node
	        }) {
	          const key = node.key;
	          if (!node.computed && _core.types.isIdentifier(key) && !_core.types.isValidES3Identifier(key.name)) {
	            node.key = _core.types.stringLiteral(key.name);
	          }
	        }
	      }
	    }
	  };
	});
	return lib$n;
}

var lib$m = {};

var visit = {};

var hoist = {};

var util$2 = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util$2;
	hasRequiredUtil = 1;
	Object.defineProperty(util$2, "__esModule", {
	  value: true
	});
	util$2.getTypes = getTypes;
	util$2.isReference = isReference;
	util$2.newHelpersAvailable = void 0;
	util$2.replaceWithOrRemove = replaceWithOrRemove;
	util$2.runtimeProperty = void 0;
	util$2.wrapWithTypes = wrapWithTypes;
	let currentTypes = null;
	function wrapWithTypes(types, fn) {
	  return function(...args) {
	    const oldTypes = currentTypes;
	    currentTypes = types;
	    try {
	      return fn.apply(this, args);
	    } finally {
	      currentTypes = oldTypes;
	    }
	  };
	}
	function getTypes() {
	  return currentTypes;
	}
	util$2.newHelpersAvailable = void 0;
	{
	  util$2.newHelpersAvailable = (file) => {
	    return file.availableHelper("regenerator") && !getTypes().isIdentifier(file.addHelper("regenerator"), {
	      name: "__interal_marker_fallback_regenerator__"
	    });
	  };
	}
	util$2.runtimeProperty = void 0;
	{
	  util$2.runtimeProperty = function(file, name) {
	    const t = getTypes();
	    const helper = file.addHelper("regeneratorRuntime");
	    return t.memberExpression(t.isArrowFunctionExpression(helper) && t.isIdentifier(helper.body) ? helper.body : t.callExpression(helper, []), t.identifier(name), false);
	  };
	}
	function isReference(path) {
	  return path.isReferenced() || path.parentPath.isAssignmentExpression({
	    left: path.node
	  });
	}
	function replaceWithOrRemove(path, replacement) {
	  if (replacement) {
	    path.replaceWith(replacement);
	  } else {
	    path.remove();
	  }
	}
	return util$2;
}

var hasRequiredHoist;

function requireHoist () {
	if (hasRequiredHoist) return hoist;
	hasRequiredHoist = 1;
	Object.defineProperty(hoist, "__esModule", {
	  value: true
	});
	hoist.hoist = hoist$1;
	var util = requireUtil();
	const hasOwn = Object.prototype.hasOwnProperty;
	function hoist$1(funPath) {
	  const t = util.getTypes();
	  t.assertFunction(funPath.node);
	  const vars = {};
	  function varDeclToExpr({
	    node: vdec,
	    scope
	  }, includeIdentifiers) {
	    t.assertVariableDeclaration(vdec);
	    const exprs = [];
	    vdec.declarations.forEach(function(dec) {
	      vars[dec.id.name] = t.identifier(dec.id.name);
	      scope.removeBinding(dec.id.name);
	      if (dec.init) {
	        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
	      } else if (includeIdentifiers) {
	        exprs.push(dec.id);
	      }
	    });
	    if (exprs.length === 0) return null;
	    if (exprs.length === 1) return exprs[0];
	    return t.sequenceExpression(exprs);
	  }
	  funPath.get("body").traverse({
	    VariableDeclaration: {
	      exit: function(path) {
	        const expr = varDeclToExpr(path, false);
	        if (expr === null) {
	          path.remove();
	        } else {
	          util.replaceWithOrRemove(path, t.expressionStatement(expr));
	        }
	        path.skip();
	      }
	    },
	    ForStatement: function(path) {
	      const init = path.get("init");
	      if (init.isVariableDeclaration()) {
	        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
	      }
	    },
	    ForXStatement: function(path) {
	      const left = path.get("left");
	      if (left.isVariableDeclaration()) {
	        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
	      }
	    },
	    FunctionDeclaration: function(path) {
	      const node = path.node;
	      vars[node.id.name] = node.id;
	      const assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
	      if (path.parentPath.isBlockStatement()) {
	        path.parentPath.unshiftContainer("body", assignment);
	        path.remove();
	      } else {
	        util.replaceWithOrRemove(path, assignment);
	      }
	      path.scope.removeBinding(node.id.name);
	      path.skip();
	    },
	    FunctionExpression: function(path) {
	      path.skip();
	    },
	    ArrowFunctionExpression: function(path) {
	      path.skip();
	    }
	  });
	  const paramNames = {};
	  funPath.get("params").forEach(function(paramPath) {
	    const param = paramPath.node;
	    if (t.isIdentifier(param)) {
	      paramNames[param.name] = param;
	    }
	  });
	  const declarations = [];
	  Object.keys(vars).forEach(function(name) {
	    if (!hasOwn.call(paramNames, name)) {
	      declarations.push(t.variableDeclarator(vars[name], null));
	    }
	  });
	  return declarations;
	}
	return hoist;
}

var emit = {};

var leap = {};

var hasRequiredLeap;

function requireLeap () {
	if (hasRequiredLeap) return leap;
	hasRequiredLeap = 1;
	Object.defineProperty(leap, "__esModule", {
	  value: true
	});
	leap.TryEntry = leap.SwitchEntry = leap.LoopEntry = leap.LeapManager = leap.LabeledEntry = leap.FunctionEntry = leap.FinallyEntry = leap.Entry = leap.CatchEntry = void 0;
	var _assert = require$$0$c;
	class Entry {
	}
	leap.Entry = Entry;
	class FunctionEntry extends Entry {
	  constructor(returnLoc) {
	    super();
	    this.returnLoc = void 0;
	    this.returnLoc = returnLoc;
	  }
	}
	leap.FunctionEntry = FunctionEntry;
	class LoopEntry extends Entry {
	  constructor(breakLoc, continueLoc, label = null) {
	    super();
	    this.breakLoc = void 0;
	    this.continueLoc = void 0;
	    this.label = void 0;
	    this.breakLoc = breakLoc;
	    this.continueLoc = continueLoc;
	    this.label = label;
	  }
	}
	leap.LoopEntry = LoopEntry;
	class SwitchEntry extends Entry {
	  constructor(breakLoc) {
	    super();
	    this.breakLoc = void 0;
	    this.breakLoc = breakLoc;
	  }
	}
	leap.SwitchEntry = SwitchEntry;
	class TryEntry extends Entry {
	  constructor(firstLoc, catchEntry = null, finallyEntry = null) {
	    super();
	    this.firstLoc = void 0;
	    this.catchEntry = void 0;
	    this.finallyEntry = void 0;
	    _assert.ok(catchEntry || finallyEntry);
	    this.firstLoc = firstLoc;
	    this.catchEntry = catchEntry;
	    this.finallyEntry = finallyEntry;
	  }
	}
	leap.TryEntry = TryEntry;
	class CatchEntry extends Entry {
	  constructor(firstLoc, paramId) {
	    super();
	    this.firstLoc = void 0;
	    this.paramId = void 0;
	    this.firstLoc = firstLoc;
	    this.paramId = paramId;
	  }
	}
	leap.CatchEntry = CatchEntry;
	class FinallyEntry extends Entry {
	  constructor(firstLoc, afterLoc) {
	    super();
	    this.firstLoc = void 0;
	    this.afterLoc = void 0;
	    this.firstLoc = firstLoc;
	    this.afterLoc = afterLoc;
	  }
	}
	leap.FinallyEntry = FinallyEntry;
	class LabeledEntry extends Entry {
	  constructor(breakLoc, label) {
	    super();
	    this.breakLoc = void 0;
	    this.label = void 0;
	    this.breakLoc = breakLoc;
	    this.label = label;
	  }
	}
	leap.LabeledEntry = LabeledEntry;
	class LeapManager {
	  constructor(emitter) {
	    this.emitter = void 0;
	    this.entryStack = void 0;
	    this.emitter = emitter;
	    this.entryStack = [new FunctionEntry(emitter.finalLoc)];
	  }
	  withEntry(entry, callback) {
	    this.entryStack.push(entry);
	    try {
	      callback.call(this.emitter);
	    } finally {
	      const popped = this.entryStack.pop();
	      _assert.strictEqual(popped, entry);
	    }
	  }
	  _findLeapLocation(property, label) {
	    for (let i = this.entryStack.length - 1; i >= 0; --i) {
	      const entry = this.entryStack[i];
	      const loc = entry[property];
	      if (loc) {
	        if (label) {
	          if (entry.label && entry.label.name === label.name) {
	            return loc;
	          }
	        } else if (entry instanceof LabeledEntry) ; else {
	          return loc;
	        }
	      }
	    }
	    return null;
	  }
	  getBreakLoc(label) {
	    return this._findLeapLocation("breakLoc", label);
	  }
	  getContinueLoc(label) {
	    return this._findLeapLocation("continueLoc", label);
	  }
	}
	leap.LeapManager = LeapManager;
	return leap;
}

var meta = {};

var hasRequiredMeta;

function requireMeta () {
	if (hasRequiredMeta) return meta;
	hasRequiredMeta = 1;
	Object.defineProperty(meta, "__esModule", {
	  value: true
	});
	meta.hasSideEffects = meta.containsLeap = void 0;
	var _assert = require$$0$c;
	var _util = requireUtil();
	const mMap = /* @__PURE__ */ new WeakMap();
	function m(node) {
	  if (!mMap.has(node)) {
	    mMap.set(node, {});
	  }
	  return mMap.get(node);
	}
	const hasOwn = Object.prototype.hasOwnProperty;
	function makePredicate(propertyName, knownTypes) {
	  function onlyChildren(node) {
	    const t = (0, _util.getTypes)();
	    t.assertNode(node);
	    let result = false;
	    function check(child) {
	      if (result) ; else if (Array.isArray(child)) {
	        child.some(check);
	      } else if (t.isNode(child)) {
	        _assert.strictEqual(result, false);
	        result = predicate(child);
	      }
	      return result;
	    }
	    const keys = t.VISITOR_KEYS[node.type];
	    if (keys) {
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        const child = node[key];
	        check(child);
	      }
	    }
	    return result;
	  }
	  function predicate(node) {
	    (0, _util.getTypes)().assertNode(node);
	    const meta = m(node);
	    if (hasOwn.call(meta, propertyName)) return meta[propertyName];
	    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;
	    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;
	    return meta[propertyName] = onlyChildren(node);
	  }
	  predicate.onlyChildren = onlyChildren;
	  return predicate;
	}
	const opaqueTypes = {
	  FunctionExpression: true,
	  ArrowFunctionExpression: true
	};
	const sideEffectTypes = {
	  CallExpression: true,
	  ForInStatement: true,
	  UnaryExpression: true,
	  BinaryExpression: true,
	  AssignmentExpression: true,
	  UpdateExpression: true,
	  NewExpression: true
	};
	const leapTypes = {
	  YieldExpression: true,
	  BreakStatement: true,
	  ContinueStatement: true,
	  ReturnStatement: true,
	  ThrowStatement: true
	};
	for (const type in leapTypes) {
	  if (hasOwn.call(leapTypes, type)) {
	    sideEffectTypes[type] = leapTypes[type];
	  }
	}
	meta.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
	meta.containsLeap = makePredicate("containsLeap", leapTypes);
	return meta;
}

var hasRequiredEmit;

function requireEmit () {
	if (hasRequiredEmit) return emit;
	hasRequiredEmit = 1;
	Object.defineProperty(emit, "__esModule", {
	  value: true
	});
	emit.Emitter = void 0;
	var _assert = require$$0$c;
	var leap = requireLeap();
	var meta = requireMeta();
	var util = requireUtil();
	var _core = require$$0$b;
	const PENDING_LOCATION = Number.MAX_VALUE;
	function getDeclError(node) {
	  return new Error("all declarations should have been transformed into assignments before the Exploder began its work: " + JSON.stringify(node));
	}
	const catchParamVisitor = {
	  Identifier: function(path, state) {
	    if (path.node.name === state.catchParamName && util.isReference(path)) {
	      util.replaceWithOrRemove(path, state.getSafeParam());
	    }
	  },
	  Scope: function(path, state) {
	    if (path.scope.hasOwnBinding(state.catchParamName)) {
	      path.skip();
	    }
	  }
	};
	class Emitter {
	  constructor(contextId, scope, vars, pluginPass) {
	    this.nextTempId = void 0;
	    this.contextId = void 0;
	    this.index = void 0;
	    this.indexMap = void 0;
	    this.listing = void 0;
	    this.returns = void 0;
	    this.lastDefaultIndex = void 0;
	    this.marked = void 0;
	    this.insertedLocs = void 0;
	    this.finalLoc = void 0;
	    this.tryEntries = void 0;
	    this.leapManager = void 0;
	    this.scope = void 0;
	    this.vars = void 0;
	    this.pluginPass = void 0;
	    this.pluginPass = pluginPass;
	    this.scope = scope;
	    this.vars = vars;
	    this.nextTempId = 0;
	    this.contextId = contextId;
	    this.listing = [];
	    this.index = 0;
	    this.indexMap = /* @__PURE__ */ new Map([[0, 0]]);
	    this.returns = /* @__PURE__ */ new Set();
	    this.marked = [true];
	    this.insertedLocs = /* @__PURE__ */ new Set();
	    this.finalLoc = this.loc();
	    this.tryEntries = [];
	    this.leapManager = new leap.LeapManager(this);
	  }
	  loc() {
	    const l = _core.types.numericLiteral(PENDING_LOCATION);
	    this.insertedLocs.add(l);
	    return l;
	  }
	  getInsertedLocs() {
	    return this.insertedLocs;
	  }
	  getContextId() {
	    return _core.types.cloneNode(this.contextId);
	  }
	  getIndex() {
	    if (!this.indexMap.has(this.listing.length)) {
	      this.indexMap.set(this.listing.length, ++this.index);
	    }
	    return this.index;
	  }
	  mark(loc) {
	    if (loc.value === PENDING_LOCATION) {
	      loc.value = this.getIndex();
	    } else {
	      _assert.strictEqual(loc.value, this.index);
	    }
	    this.marked[this.listing.length] = true;
	    return loc;
	  }
	  emit(node) {
	    if (_core.types.isExpression(node)) {
	      node = _core.types.expressionStatement(node);
	    }
	    _core.types.assertStatement(node);
	    this.listing.push(node);
	  }
	  emitAssign(lhs, rhs) {
	    this.emit(this.assign(lhs, rhs));
	    return lhs;
	  }
	  assign(lhs, rhs) {
	    return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(lhs), rhs));
	  }
	  contextProperty(name) {
	    const computed = name === "catch";
	    return _core.types.memberExpression(this.getContextId(), computed ? _core.types.stringLiteral(name) : _core.types.identifier(name), !!computed);
	  }
	  clearPendingException(tryLoc, assignee) {
	    const catchCall = _core.types.callExpression(this.contextProperty("catch"), [_core.types.cloneNode(tryLoc)]);
	    if (assignee) {
	      this.emitAssign(assignee, catchCall);
	    } else {
	      this.emit(catchCall);
	    }
	  }
	  jump(toLoc) {
	    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc);
	    this.emit(_core.types.breakStatement());
	  }
	  jumpIf(test, toLoc) {
	    this.emit(_core.types.ifStatement(test, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
	  }
	  jumpIfNot(test, toLoc) {
	    let negatedTest;
	    if (_core.types.isUnaryExpression(test) && test.operator === "!") {
	      negatedTest = test.argument;
	    } else {
	      negatedTest = _core.types.unaryExpression("!", test);
	    }
	    this.emit(_core.types.ifStatement(negatedTest, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
	  }
	  makeContextTempVar() {
	    return this.contextProperty("t" + this.nextTempId++);
	  }
	  makeTempVar() {
	    const id = this.scope.generateUidIdentifier("t");
	    this.vars.push(_core.types.variableDeclarator(id));
	    return _core.types.cloneNode(id);
	  }
	  getContextFunction() {
	    return _core.types.functionExpression(null, [this.getContextId()], _core.types.blockStatement([this.getDispatchLoop()]), false, false);
	  }
	  getDispatchLoop() {
	    const self = this;
	    const cases = [];
	    let current;
	    let alreadyEnded = false;
	    self.listing.forEach(function(stmt, i) {
	      if (self.marked[i]) {
	        cases.push(_core.types.switchCase(_core.types.numericLiteral(self.indexMap.get(i)), current = []));
	        alreadyEnded = false;
	      }
	      if (!alreadyEnded) {
	        current.push(stmt);
	        if (_core.types.isCompletionStatement(stmt)) alreadyEnded = true;
	      }
	    });
	    this.finalLoc.value = this.getIndex();
	    if (util.newHelpersAvailable(this.pluginPass)) {
	      if (this.lastDefaultIndex === this.index || !this.returns.has(this.listing.length)) {
	        cases.push(_core.types.switchCase(this.finalLoc, [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("a"), [_core.types.numericLiteral(2)]))]));
	      }
	    } else {
	      cases.push(_core.types.switchCase(this.finalLoc, []), _core.types.switchCase(_core.types.stringLiteral("end"), [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("stop"), []))]));
	    }
	    return _core.types.whileStatement(_core.types.numericLiteral(1), _core.types.switchStatement(util.newHelpersAvailable(this.pluginPass) ? this.contextProperty("n") : _core.types.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
	  }
	  getTryLocsList() {
	    if (this.tryEntries.length === 0) {
	      return null;
	    }
	    let lastLocValue = 0;
	    const arrayExpression = _core.types.arrayExpression(this.tryEntries.map(function(tryEntry) {
	      const thisLocValue = tryEntry.firstLoc.value;
	      _assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
	      lastLocValue = thisLocValue;
	      const ce = tryEntry.catchEntry;
	      const fe = tryEntry.finallyEntry;
	      const locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];
	      if (fe) {
	        locs[2] = fe.firstLoc;
	        locs[3] = fe.afterLoc;
	      }
	      return _core.types.arrayExpression(locs.map((loc) => loc && _core.types.cloneNode(loc)));
	    }));
	    if (util.newHelpersAvailable(this.pluginPass)) {
	      arrayExpression.elements.reverse();
	    }
	    return arrayExpression;
	  }
	  explode(path, ignoreResult) {
	    const node = path.node;
	    const self = this;
	    if (_core.types.isDeclaration(node)) throw getDeclError(node);
	    if (path.isStatement()) return self.explodeStatement(path);
	    if (path.isExpression()) return self.explodeExpression(path, ignoreResult);
	    switch (node.type) {
	      case "VariableDeclarator":
	        throw getDeclError(node);
	      case "ObjectProperty":
	      case "SwitchCase":
	      case "CatchClause":
	        throw new Error(node.type + " nodes should be handled by their parents");
	      default:
	        throw new Error("unknown Node of type " + JSON.stringify(node.type));
	    }
	  }
	  explodeStatement(path, labelId = null) {
	    const stmt = path.node;
	    const self = this;
	    let before, after, head;
	    if (path.isBlockStatement()) {
	      path.get("body").forEach(function(path2) {
	        self.explodeStatement(path2);
	      });
	      return;
	    }
	    if (!meta.containsLeap(stmt)) {
	      self.emit(stmt);
	      return;
	    }
	    switch (path.type) {
	      case "ExpressionStatement":
	        self.explodeExpression(path.get("expression"), true);
	        break;
	      case "LabeledStatement":
	        after = this.loc();
	        self.leapManager.withEntry(new leap.LabeledEntry(after, path.node.label), function() {
	          self.explodeStatement(path.get("body"), path.node.label);
	        });
	        self.mark(after);
	        break;
	      case "WhileStatement":
	        before = this.loc();
	        after = this.loc();
	        self.mark(before);
	        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
	        self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function() {
	          self.explodeStatement(path.get("body"));
	        });
	        self.jump(before);
	        self.mark(after);
	        break;
	      case "DoWhileStatement":
	        const first = this.loc();
	        const test = this.loc();
	        after = this.loc();
	        self.mark(first);
	        self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function() {
	          self.explode(path.get("body"));
	        });
	        self.mark(test);
	        self.jumpIf(self.explodeExpression(path.get("test")), first);
	        self.mark(after);
	        break;
	      case "ForStatement":
	        head = this.loc();
	        const update = this.loc();
	        after = this.loc();
	        if (path.node.init) {
	          self.explode(path.get("init"), true);
	        }
	        self.mark(head);
	        if (path.node.test) {
	          self.jumpIfNot(self.explodeExpression(path.get("test")), after);
	        }
	        self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function() {
	          self.explodeStatement(path.get("body"));
	        });
	        self.mark(update);
	        if (path.node.update) {
	          self.explode(path.get("update"), true);
	        }
	        self.jump(head);
	        self.mark(after);
	        break;
	      case "TypeCastExpression":
	        return self.explodeExpression(path.get("expression"));
	      case "ForInStatement":
	        head = this.loc();
	        after = this.loc();
	        const keyIterNextFn = self.makeTempVar();
	        const helper = util.newHelpersAvailable(this.pluginPass) ? this.pluginPass.addHelper("regeneratorKeys") : util.runtimeProperty(this.pluginPass, "keys");
	        self.emitAssign(keyIterNextFn, _core.types.callExpression(helper, [self.explodeExpression(path.get("right"))]));
	        self.mark(head);
	        const keyInfoTmpVar = self.makeTempVar();
	        self.jumpIf(_core.types.memberExpression(_core.types.assignmentExpression("=", keyInfoTmpVar, _core.types.callExpression(_core.types.cloneNode(keyIterNextFn), [])), _core.types.identifier("done"), false), after);
	        self.emitAssign(path.node.left, _core.types.memberExpression(_core.types.cloneNode(keyInfoTmpVar), _core.types.identifier("value"), false));
	        self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function() {
	          self.explodeStatement(path.get("body"));
	        });
	        self.jump(head);
	        self.mark(after);
	        break;
	      case "BreakStatement":
	        self.emitAbruptCompletion({
	          type: 3,
	          target: self.leapManager.getBreakLoc(path.node.label)
	        });
	        break;
	      case "ContinueStatement":
	        self.emitAbruptCompletion({
	          type: 3,
	          target: self.leapManager.getContinueLoc(path.node.label)
	        });
	        break;
	      case "SwitchStatement":
	        const disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
	        after = this.loc();
	        const defaultLoc = this.loc();
	        let condition = defaultLoc;
	        const caseLocs = [];
	        const cases = path.node.cases || [];
	        for (let i = cases.length - 1; i >= 0; --i) {
	          const c = cases[i];
	          if (c.test) {
	            condition = _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.cloneNode(disc), c.test), caseLocs[i] = this.loc(), condition);
	          } else {
	            caseLocs[i] = defaultLoc;
	          }
	        }
	        const discriminant = path.get("discriminant");
	        util.replaceWithOrRemove(discriminant, condition);
	        self.jump(self.explodeExpression(discriminant));
	        self.leapManager.withEntry(new leap.SwitchEntry(after), function() {
	          path.get("cases").forEach(function(casePath) {
	            const i = casePath.key;
	            self.mark(caseLocs[i]);
	            casePath.get("consequent").forEach(function(path2) {
	              self.explodeStatement(path2);
	            });
	          });
	        });
	        self.mark(after);
	        if (defaultLoc.value === PENDING_LOCATION) {
	          self.mark(defaultLoc);
	          _assert.strictEqual(after.value, defaultLoc.value);
	          this.lastDefaultIndex = this.index;
	        }
	        break;
	      case "IfStatement":
	        const elseLoc = path.node.alternate && this.loc();
	        after = this.loc();
	        self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
	        self.explodeStatement(path.get("consequent"));
	        if (elseLoc) {
	          self.jump(after);
	          self.mark(elseLoc);
	          self.explodeStatement(path.get("alternate"));
	        }
	        self.mark(after);
	        break;
	      case "ReturnStatement":
	        self.emitAbruptCompletion({
	          type: 2,
	          value: self.explodeExpression(path.get("argument"))
	        });
	        break;
	      case "WithStatement":
	        throw new Error("WithStatement not supported in generator functions.");
	      case "TryStatement":
	        after = this.loc();
	        const handler = path.node.handler;
	        const catchLoc = handler && this.loc();
	        const catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
	        const finallyLoc = path.node.finalizer && this.loc();
	        const finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
	        const tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
	        self.tryEntries.push(tryEntry);
	        self.updateContextPrevLoc(tryEntry.firstLoc);
	        self.leapManager.withEntry(tryEntry, () => {
	          self.explodeStatement(path.get("block"));
	          if (catchLoc) {
	            if (finallyLoc) {
	              self.jump(finallyLoc);
	            } else {
	              self.jump(after);
	            }
	            self.updateContextPrevLoc(self.mark(catchLoc));
	            const bodyPath = path.get("handler.body");
	            const safeParam = self.makeTempVar();
	            if (util.newHelpersAvailable(this.pluginPass)) {
	              this.emitAssign(safeParam, self.contextProperty("v"));
	            } else {
	              self.clearPendingException(tryEntry.firstLoc, safeParam);
	            }
	            bodyPath.traverse(catchParamVisitor, {
	              getSafeParam: () => _core.types.cloneNode(safeParam),
	              catchParamName: handler.param.name
	            });
	            self.leapManager.withEntry(catchEntry, function() {
	              self.explodeStatement(bodyPath);
	            });
	          }
	          if (finallyLoc) {
	            self.updateContextPrevLoc(self.mark(finallyLoc));
	            self.leapManager.withEntry(finallyEntry, function() {
	              self.explodeStatement(path.get("finalizer"));
	            });
	            self.emit(_core.types.returnStatement(_core.types.callExpression(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "f" : "finish"), [finallyEntry.firstLoc])));
	          }
	        });
	        self.mark(after);
	        break;
	      case "ThrowStatement":
	        self.emit(_core.types.throwStatement(self.explodeExpression(path.get("argument"))));
	        break;
	      case "ClassDeclaration":
	        self.emit(self.explodeClass(path));
	        break;
	      default:
	        throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
	    }
	  }
	  emitAbruptCompletion(record) {
	    const abruptArgs = [util.newHelpersAvailable(this.pluginPass) ? _core.types.numericLiteral(record.type) : _core.types.stringLiteral(record.type === 3 ? "continue" : "return")];
	    if (record.type === 3) {
	      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : _core.types.cloneNode(record.target);
	    } else if (record.type === 2) {
	      if (record.value) {
	        abruptArgs[1] = _core.types.cloneNode(record.value);
	      }
	    }
	    this.emit(_core.types.returnStatement(_core.types.callExpression(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "a" : "abrupt"), abruptArgs)));
	    if (record.type === 2) {
	      this.returns.add(this.listing.length);
	    }
	  }
	  getUnmarkedCurrentLoc() {
	    return _core.types.numericLiteral(this.getIndex());
	  }
	  updateContextPrevLoc(loc) {
	    if (loc) {
	      if (loc.value === PENDING_LOCATION) {
	        loc.value = this.getIndex();
	      } else {
	        _assert.strictEqual(loc.value, this.index);
	      }
	    } else {
	      loc = this.getUnmarkedCurrentLoc();
	    }
	    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "p" : "prev"), loc);
	  }
	  explodeViaTempVar(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
	    _assert.ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to be assigned to a temporary variable?");
	    let result = this.explodeExpression(childPath, ignoreChildResult);
	    if (ignoreChildResult) ; else if (tempVar || hasLeapingChildren && !_core.types.isLiteral(result)) {
	      result = this.emitAssign(tempVar || this.makeTempVar(), result);
	    }
	    return result;
	  }
	  explodeExpression(path, ignoreResult) {
	    const expr = path.node;
	    if (!expr) {
	      return expr;
	    }
	    const self = this;
	    let result;
	    let after;
	    function finish(expr2) {
	      if (ignoreResult) {
	        self.emit(expr2);
	      }
	      return expr2;
	    }
	    if (!meta.containsLeap(expr)) {
	      return finish(expr);
	    }
	    const hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
	    switch (path.type) {
	      case "MemberExpression":
	        return finish(_core.types.memberExpression(self.explodeExpression(path.get("object")), path.node.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : path.node.property, path.node.computed));
	      case "CallExpression":
	        const calleePath = path.get("callee");
	        const argsPath = path.get("arguments");
	        let newCallee;
	        let newArgs;
	        const hasLeapingArgs = argsPath.some((argPath) => meta.containsLeap(argPath.node));
	        let injectFirstArg = null;
	        if (_core.types.isMemberExpression(calleePath.node)) {
	          if (hasLeapingArgs) {
	            const newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get("object"), hasLeapingChildren);
	            const newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren) : calleePath.node.property;
	            injectFirstArg = newObject;
	            newCallee = _core.types.memberExpression(_core.types.memberExpression(_core.types.cloneNode(newObject), newProperty, calleePath.node.computed), _core.types.identifier("call"), false);
	          } else {
	            newCallee = self.explodeExpression(calleePath);
	          }
	        } else {
	          newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);
	          if (_core.types.isMemberExpression(newCallee)) {
	            newCallee = _core.types.sequenceExpression([_core.types.numericLiteral(0), _core.types.cloneNode(newCallee)]);
	          }
	        }
	        if (hasLeapingArgs) {
	          newArgs = argsPath.map((argPath) => self.explodeViaTempVar(null, argPath, hasLeapingChildren));
	          if (injectFirstArg) newArgs.unshift(injectFirstArg);
	          newArgs = newArgs.map((arg2) => _core.types.cloneNode(arg2));
	        } else {
	          newArgs = path.node.arguments;
	        }
	        return finish(_core.types.callExpression(newCallee, newArgs));
	      case "NewExpression":
	        return finish(_core.types.newExpression(self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren), path.get("arguments").map(function(argPath) {
	          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
	        })));
	      case "ObjectExpression":
	        return finish(_core.types.objectExpression(path.get("properties").map(function(propPath) {
	          if (propPath.isObjectProperty()) {
	            return _core.types.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed);
	          } else {
	            return propPath.node;
	          }
	        })));
	      case "ArrayExpression":
	        return finish(_core.types.arrayExpression(path.get("elements").map(function(elemPath) {
	          if (!elemPath.node) {
	            return null;
	          }
	          if (elemPath.isSpreadElement()) {
	            return _core.types.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren));
	          } else {
	            return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
	          }
	        })));
	      case "SequenceExpression":
	        const lastIndex = path.node.expressions.length - 1;
	        path.get("expressions").forEach(function(exprPath) {
	          if (exprPath.key === lastIndex) {
	            result = self.explodeExpression(exprPath, ignoreResult);
	          } else {
	            self.explodeExpression(exprPath, true);
	          }
	        });
	        return result;
	      case "LogicalExpression":
	        after = this.loc();
	        if (!ignoreResult) {
	          result = self.makeTempVar();
	        }
	        const left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren);
	        if (path.node.operator === "&&") {
	          self.jumpIfNot(left, after);
	        } else {
	          _assert.strictEqual(path.node.operator, "||");
	          self.jumpIf(left, after);
	        }
	        self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult);
	        self.mark(after);
	        return result;
	      case "ConditionalExpression":
	        const elseLoc = this.loc();
	        after = this.loc();
	        const test = self.explodeExpression(path.get("test"));
	        self.jumpIfNot(test, elseLoc);
	        if (!ignoreResult) {
	          result = self.makeTempVar();
	        }
	        self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult);
	        self.jump(after);
	        self.mark(elseLoc);
	        self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult);
	        self.mark(after);
	        return result;
	      case "UnaryExpression":
	        return finish(_core.types.unaryExpression(path.node.operator, self.explodeExpression(path.get("argument")), !!path.node.prefix));
	      case "BinaryExpression":
	        return finish(_core.types.binaryExpression(path.node.operator, self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren), self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)));
	      case "AssignmentExpression":
	        if (path.node.operator === "=") {
	          return finish(_core.types.assignmentExpression(path.node.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
	        }
	        const lhs = self.explodeExpression(path.get("left"));
	        const temp = self.emitAssign(self.makeTempVar(), lhs);
	        return finish(_core.types.assignmentExpression("=", _core.types.cloneNode(lhs), _core.types.assignmentExpression(path.node.operator, _core.types.cloneNode(temp), self.explodeExpression(path.get("right")))));
	      case "UpdateExpression":
	        return finish(_core.types.updateExpression(path.node.operator, self.explodeExpression(path.get("argument")), path.node.prefix));
	      case "YieldExpression":
	        after = this.loc();
	        const arg = path.node.argument && self.explodeExpression(path.get("argument"));
	        if (arg && path.node.delegate) {
	          if (util.newHelpersAvailable(this.pluginPass)) {
	            const ret2 = _core.types.returnStatement(_core.types.callExpression(self.contextProperty("d"), [_core.types.callExpression(this.pluginPass.addHelper("regeneratorValues"), [arg]), after]));
	            ret2.loc = expr.loc;
	            self.emit(ret2);
	            self.mark(after);
	            return self.contextProperty("v");
	          } else {
	            const result2 = self.makeContextTempVar();
	            const ret2 = _core.types.returnStatement(_core.types.callExpression(self.contextProperty("delegateYield"), [arg, _core.types.stringLiteral(result2.property.name), after]));
	            ret2.loc = expr.loc;
	            self.emit(ret2);
	            self.mark(after);
	            return result2;
	          }
	        }
	        self.emitAssign(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), after);
	        const ret = _core.types.returnStatement(_core.types.cloneNode(arg) || null);
	        ret.loc = expr.loc;
	        self.emit(ret);
	        self.mark(after);
	        return self.contextProperty(util.newHelpersAvailable(self.pluginPass) ? "v" : "sent");
	      case "ClassExpression":
	        return finish(self.explodeClass(path));
	      default:
	        throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
	    }
	  }
	  explodeClass(path) {
	    const explodingChildren = [];
	    if (path.node.superClass) {
	      explodingChildren.push(path.get("superClass"));
	    }
	    path.get("body.body").forEach((member) => {
	      if (member.node.computed) {
	        explodingChildren.push(member.get("key"));
	      }
	    });
	    const hasLeapingChildren = explodingChildren.some((child) => meta.containsLeap(child));
	    for (let i = 0; i < explodingChildren.length; i++) {
	      const child = explodingChildren[i];
	      const isLast = i === explodingChildren.length - 1;
	      if (isLast) {
	        child.replaceWith(this.explodeExpression(child));
	      } else {
	        child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
	      }
	    }
	    return path.node;
	  }
	}
	emit.Emitter = Emitter;
	return emit;
}

var replaceShorthandObjectMethod = {};

var hasRequiredReplaceShorthandObjectMethod;

function requireReplaceShorthandObjectMethod () {
	if (hasRequiredReplaceShorthandObjectMethod) return replaceShorthandObjectMethod;
	hasRequiredReplaceShorthandObjectMethod = 1;
	Object.defineProperty(replaceShorthandObjectMethod, "__esModule", {
	  value: true
	});
	replaceShorthandObjectMethod.default = replaceShorthandObjectMethod$1;
	var util = requireUtil();
	function replaceShorthandObjectMethod$1(path) {
	  const t = util.getTypes();
	  if (!path.node || !t.isFunction(path.node)) {
	    throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
	  }
	  if (!t.isObjectMethod(path.node)) {
	    return path;
	  }
	  if (!path.node.generator) {
	    return path;
	  }
	  const parameters = path.node.params.map(function(param) {
	    return t.cloneDeep(param);
	  });
	  const functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
	  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
	  return path.get("value");
	}
	return replaceShorthandObjectMethod;
}

var hasRequiredVisit;

function requireVisit () {
	if (hasRequiredVisit) return visit;
	hasRequiredVisit = 1;
	Object.defineProperty(visit, "__esModule", {
	  value: true
	});
	visit.getVisitor = void 0;
	var _assert = require$$0$c;
	var _hoist = requireHoist();
	var _emit = requireEmit();
	var _replaceShorthandObjectMethod = requireReplaceShorthandObjectMethod();
	var util = requireUtil();
	const getVisitor = (t) => ({
	  Method(path, state) {
	    const node = path.node;
	    if (!shouldRegenerate(node, state)) return;
	    const container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
	    path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
	    node.async = false;
	    node.generator = false;
	    path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
	  },
	  Function: {
	    exit: util.wrapWithTypes(t, function(path, state) {
	      let node = path.node;
	      if (!shouldRegenerate(node, state)) return;
	      path = (0, _replaceShorthandObjectMethod.default)(path);
	      node = path.node;
	      const contextId = path.scope.generateUidIdentifier("context");
	      const argsId = path.scope.generateUidIdentifier("args");
	      path.ensureBlock();
	      const bodyBlockPath = path.get("body");
	      if (node.async) {
	        bodyBlockPath.traverse(awaitVisitor, this);
	      }
	      bodyBlockPath.traverse(functionSentVisitor, {
	        context: contextId,
	        pluginPass: this
	      });
	      const outerBody = [];
	      const innerBody = [];
	      bodyBlockPath.get("body").forEach(function(childPath) {
	        const node2 = childPath.node;
	        if (t.isExpressionStatement(node2) && t.isStringLiteral(node2.expression)) {
	          outerBody.push(node2);
	        } else if ((node2 == null ? void 0 : node2._blockHoist) != null) {
	          outerBody.push(node2);
	        } else {
	          innerBody.push(node2);
	        }
	      });
	      if (outerBody.length > 0) {
	        bodyBlockPath.node.body = innerBody;
	      }
	      const outerFnExpr = getOuterFnExpr(this, path);
	      t.assertIdentifier(node.id);
	      const vars = (0, _hoist.hoist)(path);
	      const context = {
	        usesThis: false,
	        usesArguments: false,
	        getArgsId: () => t.clone(argsId)
	      };
	      path.traverse(argumentsThisVisitor, context);
	      if (context.usesArguments) {
	        vars.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
	      }
	      const emitter = new _emit.Emitter(contextId, path.scope, vars, this);
	      emitter.explode(path.get("body"));
	      if (vars.length > 0) {
	        outerBody.push(t.variableDeclaration("var", vars));
	      }
	      const wrapArgs = [emitter.getContextFunction()];
	      const tryLocsList = emitter.getTryLocsList();
	      if (node.generator) {
	        wrapArgs.push(outerFnExpr);
	      } else if (context.usesThis || tryLocsList || node.async) {
	        wrapArgs.push(t.nullLiteral());
	      }
	      if (context.usesThis) {
	        wrapArgs.push(t.thisExpression());
	      } else if (tryLocsList || node.async) {
	        wrapArgs.push(t.nullLiteral());
	      }
	      if (tryLocsList) {
	        wrapArgs.push(tryLocsList);
	      } else if (node.async) {
	        wrapArgs.push(t.nullLiteral());
	      }
	      if (node.async) {
	        let currentScope = path.scope;
	        do {
	          if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
	        } while (currentScope = currentScope.parent);
	        wrapArgs.push(t.identifier("Promise"));
	      }
	      const wrapCall = t.callExpression(util.newHelpersAvailable(this) ? !node.async ? t.memberExpression(t.callExpression(this.addHelper("regenerator"), []), t.identifier("w")) : node.generator ? this.addHelper("regeneratorAsyncGen") : this.addHelper("regeneratorAsync") : util.runtimeProperty(this, node.async ? "async" : "wrap"), wrapArgs);
	      outerBody.push(t.returnStatement(wrapCall));
	      node.body = t.blockStatement(outerBody);
	      path.get("body.body").forEach((p) => p.scope.registerDeclaration(p));
	      const oldDirectives = bodyBlockPath.node.directives;
	      if (oldDirectives) {
	        node.body.directives = oldDirectives;
	      }
	      const wasGeneratorFunction = node.generator;
	      if (wasGeneratorFunction) {
	        node.generator = false;
	      }
	      if (node.async) {
	        node.async = false;
	      }
	      if (wasGeneratorFunction && t.isExpression(node)) {
	        util.replaceWithOrRemove(path, t.callExpression(util.newHelpersAvailable(this) ? t.memberExpression(t.callExpression(this.addHelper("regenerator"), []), t.identifier("m")) : util.runtimeProperty(this, "mark"), [node]));
	        path.addComment("leading", "#__PURE__");
	      }
	      const insertedLocs = emitter.getInsertedLocs();
	      path.traverse({
	        NumericLiteral(path2) {
	          if (!insertedLocs.has(path2.node)) {
	            return;
	          }
	          path2.replaceWith(t.numericLiteral(path2.node.value));
	        }
	      });
	      path.requeue();
	    })
	  }
	});
	visit.getVisitor = getVisitor;
	function shouldRegenerate(node, state) {
	  if (node.generator) {
	    if (node.async) {
	      return state.opts.asyncGenerators !== false;
	    } else {
	      return state.opts.generators !== false;
	    }
	  } else if (node.async) {
	    return state.opts.async !== false;
	  } else {
	    return false;
	  }
	}
	function getOuterFnExpr(state, funPath) {
	  const t = util.getTypes();
	  const node = funPath.node;
	  t.assertFunction(node);
	  if (!node.id) {
	    node.id = funPath.scope.parent.generateUidIdentifier("callee");
	  }
	  if (node.generator && t.isFunctionDeclaration(node)) {
	    return getMarkedFunctionId(state, funPath);
	  }
	  return t.clone(node.id);
	}
	const markInfo = /* @__PURE__ */ new WeakMap();
	function getMarkInfo(node) {
	  if (!markInfo.has(node)) {
	    markInfo.set(node, {});
	  }
	  return markInfo.get(node);
	}
	function getMarkedFunctionId(state, funPath) {
	  const t = util.getTypes();
	  const node = funPath.node;
	  t.assertIdentifier(node.id);
	  const blockPath = funPath.findParent(function(path) {
	    return path.isProgram() || path.isBlockStatement();
	  });
	  if (!blockPath) {
	    return node.id;
	  }
	  const block = blockPath.node;
	  _assert.ok(Array.isArray(block.body));
	  const info = getMarkInfo(block);
	  if (!info.decl) {
	    info.decl = t.variableDeclaration("var", []);
	    blockPath.unshiftContainer("body", info.decl);
	    info.declPath = blockPath.get("body.0");
	  }
	  _assert.strictEqual(info.declPath.node, info.decl);
	  const markedId = blockPath.scope.generateUidIdentifier("marked");
	  const markCallExp = t.callExpression(util.newHelpersAvailable(state) ? t.memberExpression(t.callExpression(state.addHelper("regenerator"), []), t.identifier("m")) : util.runtimeProperty(state, "mark"), [t.clone(node.id)]);
	  const index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
	  const markCallExpPath = info.declPath.get("declarations." + index + ".init");
	  _assert.strictEqual(markCallExpPath.node, markCallExp);
	  markCallExpPath.addComment("leading", "#__PURE__");
	  return t.clone(markedId);
	}
	const argumentsThisVisitor = {
	  "FunctionExpression|FunctionDeclaration|Method": function(path) {
	    path.skip();
	  },
	  Identifier: function(path, state) {
	    if (path.node.name === "arguments" && util.isReference(path)) {
	      util.replaceWithOrRemove(path, state.getArgsId());
	      state.usesArguments = true;
	    }
	  },
	  ThisExpression: function(path, state) {
	    state.usesThis = true;
	  }
	};
	const functionSentVisitor = {
	  MetaProperty(path, state) {
	    const {
	      node
	    } = path;
	    if (node.meta.name === "function" && node.property.name === "sent") {
	      const t = util.getTypes();
	      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(util.newHelpersAvailable(state.pluginPass) ? "v" : "_sent")));
	    }
	  }
	};
	const awaitVisitor = {
	  Function: function(path) {
	    path.skip();
	  },
	  AwaitExpression: function(path) {
	    const t = util.getTypes();
	    const argument = path.node.argument;
	    const helper = util.newHelpersAvailable(this) ? this.addHelper("awaitAsyncGenerator") : util.runtimeProperty(this, "awrap");
	    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(helper, [argument]), false));
	  }
	};
	return visit;
}

var hasRequiredLib$n;

function requireLib$n () {
	if (hasRequiredLib$n) return lib$m;
	hasRequiredLib$n = 1;
	Object.defineProperty(lib$m, "__esModule", {
	  value: true
	});
	lib$m.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _visit = requireVisit();
	lib$m.default = (0, _helperPluginUtils.declare)(({
	  types: t,
	  traverse,
	  assertVersion
	}) => {
	  assertVersion(7);
	  return {
	    name: "transform-regenerator",
	    visitor: traverse.visitors.merge([(0, _visit.getVisitor)(t), {
	      CallExpression(path) {
	        var _this$availableHelper;
	        if (!((_this$availableHelper = this.availableHelper) != null && _this$availableHelper.call(this, "regeneratorRuntime"))) {
	          return;
	        }
	        const callee = path.get("callee");
	        if (!callee.isMemberExpression()) return;
	        const obj = callee.get("object");
	        if (obj.isIdentifier({
	          name: "regeneratorRuntime"
	        })) {
	          const helper = this.addHelper("regeneratorRuntime");
	          if (t.isArrowFunctionExpression(helper)) {
	            obj.replaceWith(helper.body);
	            return;
	          }
	          obj.replaceWith(t.callExpression(helper, []));
	        }
	      }
	    }])
	  };
	});
	return lib$m;
}

var lib$l = {};

var hasRequiredLib$m;

function requireLib$m () {
	if (hasRequiredLib$m) return lib$l;
	hasRequiredLib$m = 1;
	Object.defineProperty(lib$l, "__esModule", {
	  value: true
	});
	lib$l.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$l.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-regexp-modifiers",
	    feature: "modifiers"
	  });
	});
	return lib$l;
}

var lib$k = {};

var hasRequiredLib$l;

function requireLib$l () {
	if (hasRequiredLib$l) return lib$k;
	hasRequiredLib$l = 1;
	Object.defineProperty(lib$k, "__esModule", {
	  value: true
	});
	lib$k.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$k.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-reserved-words",
	    visitor: {
	      "BindingIdentifier|ReferencedIdentifier"(path) {
	        if (!_core.types.isValidES3Identifier(path.node.name)) {
	          path.scope.rename(path.node.name);
	        }
	      }
	    }
	  };
	});
	return lib$k;
}

var lib$j = {};

var hasRequiredLib$k;

function requireLib$k () {
	if (hasRequiredLib$k) return lib$j;
	hasRequiredLib$k = 1;
	Object.defineProperty(lib$j, "__esModule", {
	  value: true
	});
	lib$j.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$j.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-shorthand-properties",
	    visitor: {
	      ObjectMethod(path) {
	        const {
	          node
	        } = path;
	        if (node.kind === "method") {
	          const func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
	          func.returnType = node.returnType;
	          const computedKey = _core.types.toComputedKey(node);
	          if (_core.types.isStringLiteral(computedKey, {
	            value: "__proto__"
	          })) {
	            path.replaceWith(_core.types.objectProperty(computedKey, func, true));
	          } else {
	            path.replaceWith(_core.types.objectProperty(node.key, func, node.computed));
	          }
	        }
	      },
	      ObjectProperty(path) {
	        const {
	          node
	        } = path;
	        if (node.shorthand) {
	          const computedKey = _core.types.toComputedKey(node);
	          if (_core.types.isStringLiteral(computedKey, {
	            value: "__proto__"
	          })) {
	            path.replaceWith(_core.types.objectProperty(computedKey, node.value, true));
	          } else {
	            node.shorthand = false;
	          }
	        }
	      }
	    }
	  };
	});
	return lib$j;
}

var lib$i = {};

var hasRequiredLib$j;

function requireLib$j () {
	if (hasRequiredLib$j) return lib$i;
	hasRequiredLib$j = 1;
	Object.defineProperty(lib$i, "__esModule", {
	  value: true
	});
	lib$i.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperSkipTransparentExpressionWrappers = requireLib$X();
	var _core = require$$0$b;
	lib$i.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _options$allowArrayLi;
	  api.assertVersion(7);
	  const iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
	  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
	  function getSpreadLiteral(spread, scope) {
	    if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {
	      name: "arguments"
	    })) {
	      return spread.argument;
	    } else {
	      const node = spread.argument;
	      if (_core.types.isIdentifier(node)) {
	        const binding = scope.getBinding(node.name);
	        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
	          return node;
	        }
	      }
	      if (_core.types.isArrayExpression(node)) {
	        return node;
	      }
	      if (_core.types.isIdentifier(node, {
	        name: "arguments"
	      })) {
	        return _core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
	      }
	      const args = [node];
	      let helperName = "toConsumableArray";
	      if (arrayLikeIsIterable) {
	        args.unshift(scope.path.hub.addHelper(helperName));
	        helperName = "maybeArrayLike";
	      }
	      return _core.types.callExpression(scope.path.hub.addHelper(helperName), args);
	    }
	  }
	  function hasHole(spread) {
	    return spread.elements.includes(null);
	  }
	  function hasSpread(nodes) {
	    for (let i = 0; i < nodes.length; i++) {
	      if (_core.types.isSpreadElement(nodes[i])) {
	        return true;
	      }
	    }
	    return false;
	  }
	  function push(_props, nodes) {
	    if (!_props.length) return _props;
	    nodes.push(_core.types.arrayExpression(_props));
	    return [];
	  }
	  function build(props, scope, file) {
	    const nodes = [];
	    let _props = [];
	    for (const prop of props) {
	      if (_core.types.isSpreadElement(prop)) {
	        _props = push(_props, nodes);
	        let spreadLiteral = getSpreadLiteral(prop, scope);
	        if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {
	          spreadLiteral = _core.types.callExpression(file.addHelper("arrayWithoutHoles"), [spreadLiteral]);
	        }
	        nodes.push(spreadLiteral);
	      } else {
	        _props.push(prop);
	      }
	    }
	    push(_props, nodes);
	    return nodes;
	  }
	  return {
	    name: "transform-spread",
	    visitor: {
	      ArrayExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        const elements = node.elements;
	        if (!hasSpread(elements)) return;
	        const nodes = build(elements, scope, this.file);
	        let first = nodes[0];
	        if (nodes.length === 1 && first !== elements[0].argument) {
	          path.replaceWith(first);
	          return;
	        }
	        if (!_core.types.isArrayExpression(first)) {
	          first = _core.types.arrayExpression([]);
	        } else {
	          nodes.shift();
	        }
	        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
	      },
	      CallExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        const args = node.arguments;
	        if (!hasSpread(args)) return;
	        const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("callee"));
	        if (calleePath.isSuper()) {
	          throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
	        }
	        let contextLiteral = scope.buildUndefinedNode();
	        node.arguments = [];
	        let nodes;
	        if (args.length === 1 && _core.types.isIdentifier(args[0].argument, {
	          name: "arguments"
	        })) {
	          nodes = [args[0].argument];
	        } else {
	          nodes = build(args, scope, this.file);
	        }
	        const first = nodes.shift();
	        if (nodes.length) {
	          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
	        } else {
	          node.arguments.push(first);
	        }
	        const callee = calleePath.node;
	        if (_core.types.isMemberExpression(callee)) {
	          const temp = scope.maybeGenerateMemoised(callee.object);
	          if (temp) {
	            callee.object = _core.types.assignmentExpression("=", temp, callee.object);
	            contextLiteral = temp;
	          } else {
	            contextLiteral = _core.types.cloneNode(callee.object);
	          }
	        }
	        node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("apply"));
	        if (_core.types.isSuper(contextLiteral)) {
	          contextLiteral = _core.types.thisExpression();
	        }
	        node.arguments.unshift(_core.types.cloneNode(contextLiteral));
	      },
	      NewExpression(path) {
	        const {
	          node,
	          scope
	        } = path;
	        if (!hasSpread(node.arguments)) return;
	        const nodes = build(node.arguments, scope, this.file);
	        const first = nodes.shift();
	        let args;
	        if (nodes.length) {
	          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes);
	        } else {
	          args = first;
	        }
	        path.replaceWith(_core.types.callExpression(path.hub.addHelper("construct"), [node.callee, args]));
	      }
	    }
	  };
	});
	return lib$i;
}

var lib$h = {};

var hasRequiredLib$i;

function requireLib$i () {
	if (hasRequiredLib$i) return lib$h;
	hasRequiredLib$i = 1;
	Object.defineProperty(lib$h, "__esModule", {
	  value: true
	});
	lib$h.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$h.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-sticky-regex",
	    visitor: {
	      RegExpLiteral(path) {
	        const {
	          node
	        } = path;
	        if (!node.flags.includes("y")) return;
	        path.replaceWith(_core.types.newExpression(_core.types.identifier("RegExp"), [_core.types.stringLiteral(node.pattern), _core.types.stringLiteral(node.flags)]));
	      }
	    }
	  };
	});
	return lib$h;
}

var lib$g = {};

var hasRequiredLib$h;

function requireLib$h () {
	if (hasRequiredLib$h) return lib$g;
	hasRequiredLib$h = 1;
	Object.defineProperty(lib$g, "__esModule", {
	  value: true
	});
	lib$g.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$g.default = (0, _helperPluginUtils.declare)((api, options) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion(7);
	  const ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
	  const mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
	  let helperName = "taggedTemplateLiteral";
	  if (mutableTemplateObject) helperName += "Loose";
	  function buildConcatCallExpressions(items) {
	    let avail = true;
	    return items.reduce(function(left, right) {
	      let canBeInserted = _core.types.isLiteral(right);
	      if (!canBeInserted && avail) {
	        canBeInserted = true;
	        avail = false;
	      }
	      if (canBeInserted && _core.types.isCallExpression(left)) {
	        left.arguments.push(right);
	        return left;
	      }
	      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
	    });
	  }
	  return {
	    name: "transform-template-literals",
	    visitor: {
	      TaggedTemplateExpression(path) {
	        const {
	          node
	        } = path;
	        const {
	          quasi
	        } = node;
	        const strings = [];
	        const raws = [];
	        let isStringsRawEqual = true;
	        for (const elem of quasi.quasis) {
	          const {
	            raw,
	            cooked
	          } = elem.value;
	          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
	          strings.push(value);
	          raws.push(_core.types.stringLiteral(raw));
	          if (raw !== cooked) {
	            isStringsRawEqual = false;
	          }
	        }
	        const helperArgs = [_core.types.arrayExpression(strings)];
	        if (!isStringsRawEqual) {
	          helperArgs.push(_core.types.arrayExpression(raws));
	        }
	        const tmp = path.scope.generateUidIdentifier("templateObject");
	        path.scope.getProgramParent().push({
	          id: _core.types.cloneNode(tmp)
	        });
	        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`
              ${_core.types.cloneNode(tmp)} || (
                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})
              )
            `, ...quasi.expressions]));
	      },
	      TemplateLiteral(path) {
	        if (path.parent.type === "TSLiteralType") {
	          return;
	        }
	        const nodes = [];
	        const expressions = path.get("expressions");
	        let index = 0;
	        for (const elem of path.node.quasis) {
	          if (elem.value.cooked) {
	            nodes.push(_core.types.stringLiteral(elem.value.cooked));
	          }
	          if (index < expressions.length) {
	            const expr = expressions[index++];
	            const node = expr.node;
	            if (!_core.types.isStringLiteral(node, {
	              value: ""
	            })) {
	              nodes.push(node);
	            }
	          }
	        }
	        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {
	          nodes.unshift(_core.types.stringLiteral(""));
	        }
	        let root = nodes[0];
	        if (ignoreToPrimitiveHint) {
	          for (let i = 1; i < nodes.length; i++) {
	            root = _core.types.binaryExpression("+", root, nodes[i]);
	          }
	        } else if (nodes.length > 1) {
	          root = buildConcatCallExpressions(nodes);
	        }
	        path.replaceWith(root);
	      }
	    }
	  };
	});
	return lib$g;
}

var lib$f = {};

var hasRequiredLib$g;

function requireLib$g () {
	if (hasRequiredLib$g) return lib$f;
	hasRequiredLib$g = 1;
	Object.defineProperty(lib$f, "__esModule", {
	  value: true
	});
	lib$f.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$f.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return {
	    name: "transform-typeof-symbol",
	    visitor: {
	      Scope({
	        scope
	      }) {
	        if (!scope.getBinding("Symbol")) {
	          return;
	        }
	        scope.rename("Symbol");
	      },
	      UnaryExpression(path) {
	        const {
	          node,
	          parent
	        } = path;
	        if (node.operator !== "typeof") return;
	        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.includes(parent.operator)) {
	          const opposite = path.getOpposite();
	          if (opposite.isStringLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
	            return;
	          }
	        }
	        let isUnderHelper = path.findParent((path2) => {
	          if (path2.isFunctionDeclaration()) {
	            var _path$get;
	            return ((_path$get = path2.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
	          }
	        });
	        if (isUnderHelper) return;
	        const helper = this.addHelper("typeof");
	        {
	          isUnderHelper = path.findParent((path2) => {
	            return path2.isVariableDeclarator() && path2.node.id === helper || path2.isFunctionDeclaration() && path2.node.id && path2.node.id.name === helper.name;
	          });
	          if (isUnderHelper) {
	            return;
	          }
	        }
	        const call = _core.types.callExpression(helper, [node.argument]);
	        const arg = path.get("argument");
	        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
	          const unary = _core.types.unaryExpression("typeof", _core.types.cloneNode(node.argument));
	          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("===", unary, _core.types.stringLiteral("undefined")), _core.types.stringLiteral("undefined"), call));
	        } else {
	          path.replaceWith(call);
	        }
	      }
	    }
	  };
	});
	return lib$f;
}

var lib$e = {};

var hasRequiredLib$f;

function requireLib$f () {
	if (hasRequiredLib$f) return lib$e;
	hasRequiredLib$f = 1;
	Object.defineProperty(lib$e, "__esModule", {
	  value: true
	});
	lib$e.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _core = require$$0$b;
	lib$e.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  const surrogate = /[\ud800-\udfff]/g;
	  const unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
	  function escape(code) {
	    {
	      let str = code.toString(16);
	      while (str.length < 4) str = "0" + str;
	      return "\\u" + str;
	    }
	  }
	  function replacer(match, backslashes, code) {
	    if (backslashes.length % 2 === 0) {
	      return match;
	    }
	    const char = String.fromCodePoint(parseInt(code, 16));
	    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
	    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));
	  }
	  function replaceUnicodeEscapes(str) {
	    return str.replace(unicodeEscape, replacer);
	  }
	  function getUnicodeEscape(str) {
	    let match;
	    while (match = unicodeEscape.exec(str)) {
	      if (match[1].length % 2 === 0) continue;
	      unicodeEscape.lastIndex = 0;
	      return match[0];
	    }
	    return null;
	  }
	  return {
	    name: "transform-unicode-escapes",
	    manipulateOptions({
	      generatorOpts
	    }) {
	      var _generatorOpts$jsescO, _generatorOpts$jsescO2;
	      if (!generatorOpts.jsescOption) {
	        generatorOpts.jsescOption = {};
	      }
	      (_generatorOpts$jsescO2 = (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal) != null ? _generatorOpts$jsescO2 : _generatorOpts$jsescO.minimal = false;
	    },
	    visitor: {
	      Identifier(path) {
	        const {
	          node,
	          key
	        } = path;
	        const {
	          name
	        } = node;
	        const replaced = name.replace(surrogate, (c) => {
	          return `_u${c.charCodeAt(0).toString(16)}`;
	        });
	        if (name === replaced) return;
	        const str = _core.types.inherits(_core.types.stringLiteral(name), node);
	        if (key === "key") {
	          path.replaceWith(str);
	          return;
	        }
	        const {
	          parentPath,
	          scope
	        } = path;
	        if (parentPath.isMemberExpression({
	          property: node
	        }) || parentPath.isOptionalMemberExpression({
	          property: node
	        })) {
	          parentPath.node.computed = true;
	          path.replaceWith(str);
	          return;
	        }
	        const binding = scope.getBinding(name);
	        if (binding) {
	          scope.rename(name, scope.generateUid(replaced));
	          return;
	        }
	        throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);
	      },
	      "StringLiteral|DirectiveLiteral"(path) {
	        const {
	          node
	        } = path;
	        const {
	          extra
	        } = node;
	        if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
	      },
	      TemplateElement(path) {
	        const {
	          node,
	          parentPath
	        } = path;
	        const {
	          value
	        } = node;
	        const firstEscape = getUnicodeEscape(value.raw);
	        if (!firstEscape) return;
	        const grandParent = parentPath.parentPath;
	        if (grandParent.isTaggedTemplateExpression()) {
	          throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);
	        }
	        value.raw = replaceUnicodeEscapes(value.raw);
	      }
	    }
	  };
	});
	return lib$e;
}

var lib$d = {};

var hasRequiredLib$e;

function requireLib$e () {
	if (hasRequiredLib$e) return lib$d;
	hasRequiredLib$e = 1;
	Object.defineProperty(lib$d, "__esModule", {
	  value: true
	});
	lib$d.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$d.default = (0, _helperPluginUtils.declare)((api, options) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const {
	    useUnicodeFlag = true
	  } = options;
	  if (typeof useUnicodeFlag !== "boolean") {
	    throw new Error(".useUnicodeFlag must be a boolean, or undefined");
	  }
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-unicode-property-regex",
	    feature: "unicodePropertyEscape",
	    options: {
	      useUnicodeFlag
	    }
	  });
	});
	return lib$d;
}

var lib$c = {};

var hasRequiredLib$d;

function requireLib$d () {
	if (hasRequiredLib$d) return lib$c;
	hasRequiredLib$d = 1;
	Object.defineProperty(lib$c, "__esModule", {
	  value: true
	});
	lib$c.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$c.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-unicode-regex",
	    feature: "unicodeFlag"
	  });
	});
	return lib$c;
}

var lib$b = {};

var hasRequiredLib$c;

function requireLib$c () {
	if (hasRequiredLib$c) return lib$b;
	hasRequiredLib$c = 1;
	Object.defineProperty(lib$b, "__esModule", {
	  value: true
	});
	lib$b.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	lib$b.default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "transform-unicode-sets-regex",
	    feature: "unicodeSetsFlag",
	    manipulateOptions(opts, parserOpts) {
	      {
	        parserOpts.plugins.push("regexpUnicodeSets");
	      }
	    }
	  });
	});
	return lib$b;
}

var transformAsyncArrowsInClass = {exports: {}};

var hasRequiredTransformAsyncArrowsInClass;

function requireTransformAsyncArrowsInClass () {
	if (hasRequiredTransformAsyncArrowsInClass) return transformAsyncArrowsInClass.exports;
	hasRequiredTransformAsyncArrowsInClass = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = void 0;
		const OPTS = {
		  allowInsertArrow: false,
		  specCompliant: false
		};
		var _default = ({
		  types: t
		}) => ({
		  name: "transform-async-arrows-in-class",
		  visitor: {
		    ArrowFunctionExpression(path) {
		      if (path.node.async && path.findParent(t.isClassMethod)) {
		        path.arrowFunctionToExpression(OPTS);
		      }
		    }
		  }
		});
		exports.default = _default;
		module.exports = exports.default; 
	} (transformAsyncArrowsInClass, transformAsyncArrowsInClass.exports));
	return transformAsyncArrowsInClass.exports;
}

var transformEdgeDefaultParameters = {exports: {}};

var hasRequiredTransformEdgeDefaultParameters;

function requireTransformEdgeDefaultParameters () {
	if (hasRequiredTransformEdgeDefaultParameters) return transformEdgeDefaultParameters.exports;
	hasRequiredTransformEdgeDefaultParameters = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = void 0;
		var _default = ({
		  types: t
		}) => {
		  const isArrowParent = (p) => p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
		  return {
		    name: "transform-edge-default-parameters",
		    visitor: {
		      AssignmentPattern(path) {
		        const arrowArgParent = path.find(isArrowParent);
		        if (arrowArgParent && path.parent.shorthand) {
		          path.parent.shorthand = false;
		          (path.parent.extra || {}).shorthand = false;
		          path.scope.rename(path.parent.key.name);
		        }
		      }
		    }
		  };
		};
		exports.default = _default;
		module.exports = exports.default; 
	} (transformEdgeDefaultParameters, transformEdgeDefaultParameters.exports));
	return transformEdgeDefaultParameters.exports;
}

var transformEdgeFunctionName = {exports: {}};

var hasRequiredTransformEdgeFunctionName;

function requireTransformEdgeFunctionName () {
	if (hasRequiredTransformEdgeFunctionName) return transformEdgeFunctionName.exports;
	hasRequiredTransformEdgeFunctionName = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = void 0;
		var _default = ({
		  types: t
		}) => ({
		  name: "transform-edge-function-name",
		  visitor: {
		    FunctionExpression: {
		      exit(path) {
		        if (!path.node.id && t.isIdentifier(path.parent.id)) {
		          const id = t.cloneNode(path.parent.id);
		          const binding = path.scope.getBinding(id.name);
		          if (binding == null ? void 0 : binding.constantViolations.length) {
		            path.scope.rename(id.name);
		          }
		          path.node.id = id;
		        }
		      }
		    }
		  }
		});
		exports.default = _default;
		module.exports = exports.default; 
	} (transformEdgeFunctionName, transformEdgeFunctionName.exports));
	return transformEdgeFunctionName.exports;
}

var lib$a = {};

var hasRequiredLib$b;

function requireLib$b () {
	if (hasRequiredLib$b) return lib$a;
	hasRequiredLib$b = 1;
	Object.defineProperty(lib$a, "__esModule", {
	  value: true
	});
	lib$a.default = void 0;
	var _traverse = require$$2$2;
	var _helperPluginUtils = requireLib$1f();
	lib$a.default = (0, _helperPluginUtils.declare)(({
	  types: t,
	  assertVersion
	}) => {
	  assertVersion(7);
	  const containsClassExpressionVisitor = {
	    ClassExpression(path, state) {
	      state.found = true;
	      path.stop();
	    },
	    Function(path) {
	      path.skip();
	    }
	  };
	  const containsYieldOrAwaitVisitor = _traverse.visitors.environmentVisitor({
	    YieldExpression(path, state) {
	      state.yield = true;
	      if (state.await) path.stop();
	    },
	    AwaitExpression(path, state) {
	      state.await = true;
	      if (state.yield) path.stop();
	    }
	  });
	  function containsClassExpression(path) {
	    if (t.isClassExpression(path.node)) return true;
	    if (t.isFunction(path.node)) return false;
	    const state = {
	      found: false
	    };
	    path.traverse(containsClassExpressionVisitor, state);
	    return state.found;
	  }
	  function wrap(path) {
	    const context = {
	      yield: t.isYieldExpression(path.node),
	      await: t.isAwaitExpression(path.node)
	    };
	    path.traverse(containsYieldOrAwaitVisitor, context);
	    let replacement;
	    if (context.yield) {
	      const fn = t.functionExpression(null, [], t.blockStatement([t.returnStatement(path.node)]), true, context.await);
	      replacement = t.yieldExpression(t.callExpression(t.memberExpression(fn, t.identifier("call")), [t.thisExpression(), t.identifier("arguments")]), true);
	    } else {
	      const fn = t.arrowFunctionExpression([], path.node, context.await);
	      replacement = t.callExpression(fn, []);
	      if (context.await) replacement = t.awaitExpression(replacement);
	    }
	    path.replaceWith(replacement);
	  }
	  return {
	    name: "bugfix-firefox-class-in-computed-class-key",
	    visitor: {
	      Class(path) {
	        const hasPrivateElement = path.node.body.body.some((node) => t.isPrivate(node));
	        if (!hasPrivateElement) return;
	        for (const elem of path.get("body.body")) {
	          if ("computed" in elem.node && elem.node.computed && containsClassExpression(elem.get("key"))) {
	            wrap(elem.get("key"));
	          }
	        }
	      }
	    }
	  };
	});
	return lib$a;
}

var transformTaggedTemplateCaching = {exports: {}};

var hasRequiredTransformTaggedTemplateCaching;

function requireTransformTaggedTemplateCaching () {
	if (hasRequiredTransformTaggedTemplateCaching) return transformTaggedTemplateCaching.exports;
	hasRequiredTransformTaggedTemplateCaching = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = void 0;
		var _default = ({
		  types: t
		}) => ({
		  name: "transform-tagged-template-caching",
		  visitor: {
		    TaggedTemplateExpression(path, state) {
		      let processed = state.get("processed");
		      if (!processed) {
		        processed = /* @__PURE__ */ new WeakSet();
		        state.set("processed", processed);
		      }
		      if (processed.has(path.node)) return path.skip();
		      const expressions = path.node.quasi.expressions;
		      let identity = state.get("identity");
		      if (!identity) {
		        identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
		        state.set("identity", identity);
		        const binding = path.scope.getBinding(identity.name);
		        binding.path.get("init").replaceWith(t.arrowFunctionExpression(
		          // re-use the helper identifier for compressability
		          [t.identifier("t")],
		          t.identifier("t")
		        ));
		      }
		      const template = t.taggedTemplateExpression(t.cloneNode(identity), t.templateLiteral(path.node.quasi.quasis, expressions.map(() => t.numericLiteral(0))));
		      processed.add(template);
		      const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
		      path.scope.getBinding(ident.name).path.parent.kind = "let";
		      const inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", t.cloneNode(ident), template));
		      const node = t.callExpression(path.node.tag, [inlineCache, ...expressions]);
		      path.replaceWith(node);
		    }
		  }
		});
		exports.default = _default;
		module.exports = exports.default; 
	} (transformTaggedTemplateCaching, transformTaggedTemplateCaching.exports));
	return transformTaggedTemplateCaching.exports;
}

var transformSafariBlockShadowing = {exports: {}};

var hasRequiredTransformSafariBlockShadowing;

function requireTransformSafariBlockShadowing () {
	if (hasRequiredTransformSafariBlockShadowing) return transformSafariBlockShadowing.exports;
	hasRequiredTransformSafariBlockShadowing = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = _default;
		function _default({
		  types: t
		}) {
		  return {
		    name: "transform-safari-block-shadowing",
		    visitor: {
		      VariableDeclarator(path) {
		        const kind = path.parent.kind;
		        if (kind !== "let" && kind !== "const") return;
		        const block = path.scope.block;
		        if (t.isFunction(block) || t.isProgram(block)) return;
		        const bindings = t.getOuterBindingIdentifiers(path.node.id);
		        for (const name of Object.keys(bindings)) {
		          let scope = path.scope;
		          if (!scope.hasOwnBinding(name)) continue;
		          while (scope = scope.parent) {
		            if (scope.hasOwnBinding(name)) {
		              path.scope.rename(name);
		              break;
		            }
		            if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
		              break;
		            }
		          }
		        }
		      }
		    }
		  };
		}
		module.exports = exports.default; 
	} (transformSafariBlockShadowing, transformSafariBlockShadowing.exports));
	return transformSafariBlockShadowing.exports;
}

var transformSafariForShadowing = {exports: {}};

var hasRequiredTransformSafariForShadowing;

function requireTransformSafariForShadowing () {
	if (hasRequiredTransformSafariForShadowing) return transformSafariForShadowing.exports;
	hasRequiredTransformSafariForShadowing = 1;
	(function (module, exports) {
		exports.__esModule = true;
		exports.default = void 0;
		function handle(declaration) {
		  if (!declaration.isVariableDeclaration()) return;
		  const fn = declaration.getFunctionParent();
		  const {
		    name
		  } = declaration.node.declarations[0].id;
		  if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
		    declaration.scope.rename(name);
		  }
		}
		var _default = () => ({
		  name: "transform-safari-for-shadowing",
		  visitor: {
		    ForXStatement(path) {
		      handle(path.get("left"));
		    },
		    ForStatement(path) {
		      handle(path.get("init"));
		    }
		  }
		});
		exports.default = _default;
		module.exports = exports.default; 
	} (transformSafariForShadowing, transformSafariForShadowing.exports));
	return transformSafariForShadowing.exports;
}

var lib$9 = {};

var hasRequiredLib$a;

function requireLib$a () {
	if (hasRequiredLib$a) return lib$9;
	hasRequiredLib$a = 1;
	Object.defineProperty(lib$9, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	function shouldTransform(path) {
	  const {
	    node
	  } = path;
	  const functionId = node.id;
	  if (!functionId) return false;
	  const name = functionId.name;
	  const paramNameBinding = path.scope.getOwnBinding(name);
	  if (paramNameBinding === void 0) {
	    return false;
	  }
	  if (paramNameBinding.kind !== "param") {
	    return false;
	  }
	  if (paramNameBinding.identifier === paramNameBinding.path.node) {
	    return false;
	  }
	  return name;
	}
	var index = helperPluginUtils.declare((api) => {
	  api.assertVersion("^7.16.0");
	  return {
	    name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
	    visitor: {
	      FunctionExpression(path) {
	        const name = shouldTransform(path);
	        if (name) {
	          const {
	            scope
	          } = path;
	          const newParamName = scope.generateUid(name);
	          scope.rename(name, newParamName);
	        }
	      }
	    }
	  };
	});
	lib$9.default = index;
	return lib$9;
}

var lib$8 = {};

var hasRequiredLib$9;

function requireLib$9 () {
	if (hasRequiredLib$9) return lib$8;
	hasRequiredLib$9 = 1;
	Object.defineProperty(lib$8, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	var core = require$$0$b;
	function needsWrapping(node) {
	  if (core.types.isLiteral(node) && !core.types.isTemplateLiteral(node)) {
	    return false;
	  }
	  if (core.types.isCallExpression(node) || core.types.isOptionalCallExpression(node) || core.types.isNewExpression(node)) {
	    return needsWrapping(node.callee) || node.arguments.some(needsWrapping);
	  }
	  if (core.types.isTemplateLiteral(node)) {
	    return node.expressions.some(needsWrapping);
	  }
	  if (core.types.isTaggedTemplateExpression(node)) {
	    return needsWrapping(node.tag) || needsWrapping(node.quasi);
	  }
	  if (core.types.isArrayExpression(node)) {
	    return node.elements.some(needsWrapping);
	  }
	  if (core.types.isObjectExpression(node)) {
	    return node.properties.some((prop) => {
	      if (core.types.isObjectProperty(prop)) {
	        return needsWrapping(prop.value) || prop.computed && needsWrapping(prop.key);
	      }
	      if (core.types.isObjectMethod(prop)) {
	        return false;
	      }
	      return false;
	    });
	  }
	  if (core.types.isMemberExpression(node) || core.types.isOptionalMemberExpression(node)) {
	    return needsWrapping(node.object) || node.computed && needsWrapping(node.property);
	  }
	  if (core.types.isFunctionExpression(node) || core.types.isArrowFunctionExpression(node) || core.types.isClassExpression(node)) {
	    return false;
	  }
	  if (core.types.isThisExpression(node)) {
	    return false;
	  }
	  if (core.types.isSequenceExpression(node)) {
	    return node.expressions.some(needsWrapping);
	  }
	  return true;
	}
	function wrapInitializer(path) {
	  const {
	    value
	  } = path.node;
	  if (value && needsWrapping(value)) {
	    path.node.value = core.types.callExpression(core.types.arrowFunctionExpression([], value), []);
	  }
	}
	var index = helperPluginUtils.declare((api) => {
	  api.assertVersion("^7.16.0");
	  return {
	    name: "plugin-bugfix-safari-class-field-initializer-scope",
	    visitor: {
	      ClassProperty(path) {
	        wrapInitializer(path);
	      },
	      ClassPrivateProperty(path) {
	        wrapInitializer(path);
	      }
	    }
	  };
	});
	lib$8.default = index;
	return lib$8;
}

var lib$7 = {};

var hasRequiredLib$8;

function requireLib$8 () {
	if (hasRequiredLib$8) return lib$7;
	hasRequiredLib$8 = 1;
	Object.defineProperty(lib$7, "__esModule", { value: true });
	var helperPluginUtils = requireLib$1f();
	var pluginTransformOptionalChaining = requireLib$r();
	var helperSkipTransparentExpressionWrappers = requireLib$X();
	var core = require$$0$b;
	function matchAffectedArguments(argumentNodes) {
	  const spreadIndex = argumentNodes.findIndex((node) => core.types.isSpreadElement(node));
	  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
	}
	function shouldTransform(path) {
	  let optionalPath = path;
	  const chains = [];
	  for (; ; ) {
	    if (optionalPath.isOptionalMemberExpression()) {
	      chains.push(optionalPath.node);
	      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
	    } else if (optionalPath.isOptionalCallExpression()) {
	      chains.push(optionalPath.node);
	      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
	    } else {
	      break;
	    }
	  }
	  for (let i = 0; i < chains.length; i++) {
	    const node = chains[i];
	    if (core.types.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {
	      if (node.optional) {
	        return true;
	      }
	      const callee = chains[i + 1];
	      if (core.types.isOptionalMemberExpression(callee, {
	        optional: true
	      })) {
	        return true;
	      }
	    }
	  }
	  return false;
	}
	var index = helperPluginUtils.declare((api) => {
	  var _api$assumption, _api$assumption2;
	  api.assertVersion(7);
	  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : false;
	  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : false;
	  return {
	    name: "bugfix-v8-spread-parameters-in-optional-chaining",
	    visitor: {
	      "OptionalCallExpression|OptionalMemberExpression"(path) {
	        if (shouldTransform(path)) {
	          pluginTransformOptionalChaining.transform(path, {
	            noDocumentAll,
	            pureGetters
	          });
	        }
	      }
	    }
	  };
	});
	lib$7.default = index;
	return lib$7;
}

var lib$6 = {};

var hasRequiredLib$7;

function requireLib$7 () {
	if (hasRequiredLib$7) return lib$6;
	hasRequiredLib$7 = 1;
	Object.defineProperty(lib$6, "__esModule", { value: true });
	var core = require$$0$b;
	var helperPluginUtils = requireLib$1f();
	function isNameOrLength(key) {
	  if (core.types.isIdentifier(key)) {
	    return key.name === "name" || key.name === "length";
	  }
	  if (core.types.isStringLiteral(key)) {
	    return key.value === "name" || key.value === "length";
	  }
	  return false;
	}
	function isStaticFieldWithValue(node) {
	  return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;
	}
	const hasReferenceVisitor = {
	  ReferencedIdentifier(path, state) {
	    if (path.node.name === state.name) {
	      state.ref();
	      path.stop();
	    }
	  },
	  Scope(path, {
	    name
	  }) {
	    if (path.scope.hasOwnBinding(name)) {
	      path.skip();
	    }
	  }
	};
	function isReferenceOrThis(node, name) {
	  return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {
	    name
	  });
	}
	const hasReferenceOrThisVisitor = {
	  "ThisExpression|ReferencedIdentifier"(path, state) {
	    if (isReferenceOrThis(path.node, state.name)) {
	      state.ref();
	      path.stop();
	    }
	  },
	  FunctionParent(path, state) {
	    if (path.isArrowFunctionExpression()) return;
	    if (state.name && !path.scope.hasOwnBinding(state.name)) {
	      path.traverse(hasReferenceVisitor, state);
	    }
	    path.skip();
	    if (path.isMethod()) {
	      if (path.requeueComputedKeyAndDecorators) {
	        path.requeueComputedKeyAndDecorators();
	      } else {
	        require$$2$2.NodePath.prototype.requeueComputedKeyAndDecorators.call(path);
	      }
	    }
	  }
	};
	function getPotentiallyBuggyFieldsIndexes(path) {
	  var _path$node$id;
	  const buggyPublicStaticFieldsIndexes = [];
	  let classReferenced = false;
	  const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
	  const hasReferenceState = {
	    name: className,
	    ref: () => classReferenced = true
	  };
	  if (className) {
	    for (const el of path.get("body.body")) {
	      if (el.node.computed) {
	        el.get("key").traverse(hasReferenceVisitor, hasReferenceState);
	        if (classReferenced) break;
	      }
	    }
	  }
	  let nextPotentiallyBuggy = false;
	  const {
	    body
	  } = path.node.body;
	  for (let i = 0; i < body.length; i++) {
	    const node = body[i];
	    if (!nextPotentiallyBuggy) {
	      if (core.types.isStaticBlock(node)) {
	        classReferenced = true;
	        nextPotentiallyBuggy = true;
	      } else if (isStaticFieldWithValue(node)) {
	        if (!classReferenced) {
	          if (isReferenceOrThis(node.value, className)) {
	            classReferenced = true;
	          } else {
	            path.get(`body.body.${i}.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);
	          }
	        }
	        if (classReferenced) {
	          nextPotentiallyBuggy = !path.scope.isPure(node.value);
	        }
	      }
	    }
	    if (core.types.isClassProperty(node, {
	      static: true
	    }) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {
	      buggyPublicStaticFieldsIndexes.push(i);
	    }
	  }
	  return buggyPublicStaticFieldsIndexes;
	}
	function getNameOrLengthStaticFieldsIndexes(path) {
	  const indexes = [];
	  const {
	    body
	  } = path.node.body;
	  for (let i = 0; i < body.length; i++) {
	    const node = body[i];
	    if (core.types.isClassProperty(node, {
	      static: true,
	      computed: false
	    }) && isNameOrLength(node.key)) {
	      indexes.push(i);
	    }
	  }
	  return indexes;
	}
	function toRanges(nums) {
	  const ranges = [];
	  if (nums.length === 0) return ranges;
	  let start = nums[0];
	  let end = start + 1;
	  for (let i = 1; i < nums.length; i++) {
	    if (nums[i] <= nums[i - 1]) {
	      throw new Error("Internal Babel error: nums must be in ascending order");
	    }
	    if (nums[i] === end) {
	      end++;
	    } else {
	      ranges.push([start, end]);
	      start = nums[i];
	      end = start + 1;
	    }
	  }
	  ranges.push([start, end]);
	  return ranges;
	}
	function buildFieldsReplacement(fields, scope, file) {
	  return core.types.staticBlock(fields.map((field) => {
	    const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);
	    return core.types.expressionStatement(core.types.callExpression(file.addHelper("defineProperty"), [core.types.thisExpression(), key, field.value || scope.buildUndefinedNode()]));
	  }));
	}
	var index = helperPluginUtils.declare((api) => {
	  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
	  const setPublicClassFields = api.assumption("setPublicClassFields");
	  return {
	    name: "bugfix-v8-static-class-fields-redefine-readonly",
	    visitor: {
	      Class(path) {
	        const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));
	        for (let i = ranges.length - 1; i >= 0; i--) {
	          const [start, end] = ranges[i];
	          const startPath = path.get("body.body")[start];
	          startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));
	          for (let j = end - 1; j > start; j--) {
	            path.get("body.body")[j].remove();
	          }
	        }
	      }
	    }
	  };
	});
	lib$6.default = index;
	return lib$6;
}

var lib$5 = {};

var hasRequiredLib$6;

function requireLib$6 () {
	if (hasRequiredLib$6) return lib$5;
	hasRequiredLib$6 = 1;
	Object.defineProperty(lib$5, "__esModule", {
	  value: true
	});
	lib$5.default = void 0;
	var _helperCreateRegexpFeaturesPlugin = requireLib$R();
	var _helperPluginUtils = requireLib$1f();
	var _default = (0, _helperPluginUtils.declare)((api) => {
	  api.assertVersion(7);
	  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
	    name: "syntax-unicode-sets-regex",
	    feature: "unicodeSetsFlag_syntax",
	    manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("regexpUnicodeSets");
	    }
	  });
	});
	lib$5.default = _default;
	return lib$5;
}

var hasRequiredAvailablePlugins;

function requireAvailablePlugins () {
	if (hasRequiredAvailablePlugins) return availablePlugins;
	hasRequiredAvailablePlugins = 1;
	Object.defineProperty(availablePlugins, "__esModule", {
	  value: true
	});
	availablePlugins.minVersions = availablePlugins.legacyBabel7SyntaxPlugins = availablePlugins.default = void 0;
	var _pluginSyntaxImportAssertions = requireLib$1e();
	var _pluginSyntaxImportAttributes = requireLib$1d();
	var _pluginTransformAsyncGeneratorFunctions = requireLib$15();
	var _pluginTransformAsyncToGenerator = requireLib$13();
	var _pluginTransformArrowFunctions = requireLib$12();
	var _pluginTransformBlockScopedFunctions = requireLib$11();
	var _pluginTransformBlockScoping = requireLib$10();
	var _pluginTransformClasses = requireLib$Y();
	var _pluginTransformClassProperties = requireLib$V();
	var _pluginTransformClassStaticBlock = requireLib$U();
	var _pluginTransformComputedProperties = requireLib$T();
	var _pluginTransformDestructuring = requireLib$S();
	var _pluginTransformDotallRegex = requireLib$Q();
	var _pluginTransformDuplicateKeys = requireLib$P();
	var _pluginTransformDuplicateNamedCapturingGroupsRegex = requireLib$O();
	var _pluginTransformDynamicImport = requireLib$N();
	var _pluginTransformExponentiationOperator = requireLib$M();
	var _pluginTransformExportNamespaceFrom = requireLib$L();
	var _pluginTransformForOf = requireLib$K();
	var _pluginTransformFunctionName = requireLib$J();
	var _pluginTransformJsonStrings = requireLib$I();
	var _pluginTransformLiterals = requireLib$H();
	var _pluginTransformLogicalAssignmentOperators = requireLib$G();
	var _pluginTransformMemberExpressionLiterals = requireLib$F();
	var _pluginTransformModulesAmd = requireLib$D();
	var _pluginTransformModulesCommonjs = requireLib$C();
	var _pluginTransformModulesSystemjs = requireLib$B();
	var _pluginTransformModulesUmd = requireLib$A();
	var _pluginTransformNamedCapturingGroupsRegex = requireLib$z();
	var _pluginTransformNewTarget = requireLib$y();
	var _pluginTransformNullishCoalescingOperator = requireLib$x();
	var _pluginTransformNumericSeparator = requireLib$w();
	var _pluginTransformObjectRestSpread = requireLib$u();
	var _pluginTransformObjectSuper = requireLib$t();
	var _pluginTransformOptionalCatchBinding = requireLib$s();
	var _pluginTransformOptionalChaining = requireLib$r();
	var _pluginTransformParameters = requireLib$v();
	var _pluginTransformPrivateMethods = requireLib$q();
	var _pluginTransformPrivatePropertyInObject = requireLib$p();
	var _pluginTransformPropertyLiterals = requireLib$o();
	var _pluginTransformRegenerator = requireLib$n();
	var _pluginTransformRegexpModifiers = requireLib$m();
	var _pluginTransformReservedWords = requireLib$l();
	var _pluginTransformShorthandProperties = requireLib$k();
	var _pluginTransformSpread = requireLib$j();
	var _pluginTransformStickyRegex = requireLib$i();
	var _pluginTransformTemplateLiterals = requireLib$h();
	var _pluginTransformTypeofSymbol = requireLib$g();
	var _pluginTransformUnicodeEscapes = requireLib$f();
	var _pluginTransformUnicodePropertyRegex = requireLib$e();
	var _pluginTransformUnicodeRegex = requireLib$d();
	var _pluginTransformUnicodeSetsRegex = requireLib$c();
	var _index = requireTransformAsyncArrowsInClass();
	var _index2 = requireTransformEdgeDefaultParameters();
	var _index3 = requireTransformEdgeFunctionName();
	var _pluginBugfixFirefoxClassInComputedClassKey = requireLib$b();
	var _index4 = requireTransformTaggedTemplateCaching();
	var _index5 = requireTransformSafariBlockShadowing();
	var _index6 = requireTransformSafariForShadowing();
	var _pluginBugfixSafariIdDestructuringCollisionInFunctionExpression = requireLib$a();
	var _pluginBugfixSafariClassFieldInitializerScope = requireLib$9();
	var _pluginBugfixV8SpreadParametersInOptionalChaining = requireLib$8();
	var _pluginBugfixV8StaticClassFieldsRedefineReadonly = requireLib$7();
	const availablePlugins$1 = availablePlugins.default = {
	  "bugfix/transform-async-arrows-in-class": () => _index,
	  "bugfix/transform-edge-default-parameters": () => _index2,
	  "bugfix/transform-edge-function-name": () => _index3,
	  "bugfix/transform-firefox-class-in-computed-class-key": () => _pluginBugfixFirefoxClassInComputedClassKey.default,
	  "bugfix/transform-safari-block-shadowing": () => _index5,
	  "bugfix/transform-safari-class-field-initializer-scope": () => _pluginBugfixSafariClassFieldInitializerScope.default,
	  "bugfix/transform-safari-for-shadowing": () => _index6,
	  "bugfix/transform-safari-id-destructuring-collision-in-function-expression": () => _pluginBugfixSafariIdDestructuringCollisionInFunctionExpression.default,
	  "bugfix/transform-tagged-template-caching": () => _index4,
	  "bugfix/transform-v8-spread-parameters-in-optional-chaining": () => _pluginBugfixV8SpreadParametersInOptionalChaining.default,
	  "bugfix/transform-v8-static-class-fields-redefine-readonly": () => _pluginBugfixV8StaticClassFieldsRedefineReadonly.default,
	  "transform-arrow-functions": () => _pluginTransformArrowFunctions.default,
	  "transform-async-generator-functions": () => _pluginTransformAsyncGeneratorFunctions.default,
	  "transform-async-to-generator": () => _pluginTransformAsyncToGenerator.default,
	  "transform-block-scoped-functions": () => _pluginTransformBlockScopedFunctions.default,
	  "transform-block-scoping": () => _pluginTransformBlockScoping.default,
	  "transform-class-properties": () => _pluginTransformClassProperties.default,
	  "transform-class-static-block": () => _pluginTransformClassStaticBlock.default,
	  "transform-classes": () => _pluginTransformClasses.default,
	  "transform-computed-properties": () => _pluginTransformComputedProperties.default,
	  "transform-destructuring": () => _pluginTransformDestructuring.default,
	  "transform-dotall-regex": () => _pluginTransformDotallRegex.default,
	  "transform-duplicate-keys": () => _pluginTransformDuplicateKeys.default,
	  "transform-duplicate-named-capturing-groups-regex": () => _pluginTransformDuplicateNamedCapturingGroupsRegex.default,
	  "transform-dynamic-import": () => _pluginTransformDynamicImport.default,
	  "transform-exponentiation-operator": () => _pluginTransformExponentiationOperator.default,
	  "transform-export-namespace-from": () => _pluginTransformExportNamespaceFrom.default,
	  "transform-for-of": () => _pluginTransformForOf.default,
	  "transform-function-name": () => _pluginTransformFunctionName.default,
	  "transform-json-strings": () => _pluginTransformJsonStrings.default,
	  "transform-literals": () => _pluginTransformLiterals.default,
	  "transform-logical-assignment-operators": () => _pluginTransformLogicalAssignmentOperators.default,
	  "transform-member-expression-literals": () => _pluginTransformMemberExpressionLiterals.default,
	  "transform-modules-amd": () => _pluginTransformModulesAmd.default,
	  "transform-modules-commonjs": () => _pluginTransformModulesCommonjs.default,
	  "transform-modules-systemjs": () => _pluginTransformModulesSystemjs.default,
	  "transform-modules-umd": () => _pluginTransformModulesUmd.default,
	  "transform-named-capturing-groups-regex": () => _pluginTransformNamedCapturingGroupsRegex.default,
	  "transform-new-target": () => _pluginTransformNewTarget.default,
	  "transform-nullish-coalescing-operator": () => _pluginTransformNullishCoalescingOperator.default,
	  "transform-numeric-separator": () => _pluginTransformNumericSeparator.default,
	  "transform-object-rest-spread": () => _pluginTransformObjectRestSpread.default,
	  "transform-object-super": () => _pluginTransformObjectSuper.default,
	  "transform-optional-catch-binding": () => _pluginTransformOptionalCatchBinding.default,
	  "transform-optional-chaining": () => _pluginTransformOptionalChaining.default,
	  "transform-parameters": () => _pluginTransformParameters.default,
	  "transform-private-methods": () => _pluginTransformPrivateMethods.default,
	  "transform-private-property-in-object": () => _pluginTransformPrivatePropertyInObject.default,
	  "transform-property-literals": () => _pluginTransformPropertyLiterals.default,
	  "transform-regenerator": () => _pluginTransformRegenerator.default,
	  "transform-regexp-modifiers": () => _pluginTransformRegexpModifiers.default,
	  "transform-reserved-words": () => _pluginTransformReservedWords.default,
	  "transform-shorthand-properties": () => _pluginTransformShorthandProperties.default,
	  "transform-spread": () => _pluginTransformSpread.default,
	  "transform-sticky-regex": () => _pluginTransformStickyRegex.default,
	  "transform-template-literals": () => _pluginTransformTemplateLiterals.default,
	  "transform-typeof-symbol": () => _pluginTransformTypeofSymbol.default,
	  "transform-unicode-escapes": () => _pluginTransformUnicodeEscapes.default,
	  "transform-unicode-property-regex": () => _pluginTransformUnicodePropertyRegex.default,
	  "transform-unicode-regex": () => _pluginTransformUnicodeRegex.default,
	  "transform-unicode-sets-regex": () => _pluginTransformUnicodeSetsRegex.default
	};
	const minVersions = availablePlugins.minVersions = {};
	availablePlugins.legacyBabel7SyntaxPlugins = void 0;
	{
	  Object.assign(minVersions, {
	    "bugfix/transform-safari-id-destructuring-collision-in-function-expression": "7.16.0",
	    "bugfix/transform-v8-static-class-fields-redefine-readonly": "7.12.0",
	    "syntax-import-attributes": "7.22.0",
	    "transform-class-static-block": "7.12.0",
	    "transform-duplicate-named-capturing-groups-regex": "7.19.0",
	    "transform-private-property-in-object": "7.10.0",
	    "transform-regexp-modifiers": "7.19.0"
	  });
	  const syntax = (name) => () => () => ({
	    manipulateOptions: (_, p) => p.plugins.push(name)
	  });
	  const legacyBabel7SyntaxPluginsLoaders = {
	    "syntax-async-generators": syntax("asyncGenerators"),
	    "syntax-class-properties": syntax("classProperties"),
	    "syntax-class-static-block": syntax("classStaticBlock"),
	    "syntax-dynamic-import": syntax("dynamicImport"),
	    "syntax-export-namespace-from": syntax("exportNamespaceFrom"),
	    "syntax-import-meta": syntax("importMeta"),
	    "syntax-json-strings": syntax("jsonStrings"),
	    "syntax-logical-assignment-operators": syntax("logicalAssignment"),
	    "syntax-nullish-coalescing-operator": syntax("nullishCoalescingOperator"),
	    "syntax-numeric-separator": syntax("numericSeparator"),
	    "syntax-object-rest-spread": syntax("objectRestSpread"),
	    "syntax-optional-catch-binding": syntax("optionalCatchBinding"),
	    "syntax-optional-chaining": syntax("optionalChaining"),
	    "syntax-private-property-in-object": syntax("privateIn"),
	    "syntax-top-level-await": syntax("topLevelAwait"),
	    "syntax-import-assertions": () => _pluginSyntaxImportAssertions.default,
	    "syntax-import-attributes": () => _pluginSyntaxImportAttributes.default,
	    "syntax-unicode-sets-regex": () => requireLib$6()
	  };
	  Object.assign(availablePlugins$1, legacyBabel7SyntaxPluginsLoaders);
	  availablePlugins.legacyBabel7SyntaxPlugins = new Set(Object.keys(legacyBabel7SyntaxPluginsLoaders));
	}
	return availablePlugins;
}

var hasRequiredFilterItems;

function requireFilterItems () {
	if (hasRequiredFilterItems) return filterItems;
	hasRequiredFilterItems = 1;
	Object.defineProperty(filterItems, "__esModule", {
	  value: true
	});
	filterItems.addProposalSyntaxPlugins = addProposalSyntaxPlugins;
	filterItems.removeUnnecessaryItems = removeUnnecessaryItems;
	filterItems.removeUnsupportedItems = removeUnsupportedItems;
	var _semver = requireSemver();
	var _availablePlugins = requireAvailablePlugins();
	function addProposalSyntaxPlugins(items, proposalSyntaxPlugins) {
	  proposalSyntaxPlugins.forEach((plugin) => {
	    items.add(plugin);
	  });
	}
	function removeUnnecessaryItems(items, overlapping) {
	  items.forEach((item) => {
	    var _overlapping$item;
	    (_overlapping$item = overlapping[item]) == null || _overlapping$item.forEach((name) => items.delete(name));
	  });
	}
	function removeUnsupportedItems(items, babelVersion) {
	  items.forEach((item) => {
	    if (hasOwnProperty.call(_availablePlugins.minVersions, item) && _semver.lt(babelVersion, _availablePlugins.minVersions[item])) {
	      items.delete(item);
	    } else if (babelVersion[0] === "8" && _availablePlugins.legacyBabel7SyntaxPlugins.has(item)) {
	      items.delete(item);
	    }
	  });
	}
	return filterItems;
}

var moduleTransformations = {};

var hasRequiredModuleTransformations;

function requireModuleTransformations () {
	if (hasRequiredModuleTransformations) return moduleTransformations;
	hasRequiredModuleTransformations = 1;
	Object.defineProperty(moduleTransformations, "__esModule", {
	  value: true
	});
	moduleTransformations.default = void 0;
	moduleTransformations.default = {
	  amd: "transform-modules-amd",
	  commonjs: "transform-modules-commonjs",
	  cjs: "transform-modules-commonjs",
	  systemjs: "transform-modules-systemjs",
	  umd: "transform-modules-umd"
	};
	return moduleTransformations;
}

var normalizeOptions$2 = {};

var pluginsCompatData = {};

var require$$0$4 = {
	"bugfix/transform-async-arrows-in-class": {
	chrome: "55",
	opera: "42",
	edge: "15",
	firefox: "52",
	safari: "11",
	node: "7.6",
	deno: "1",
	ios: "11",
	samsung: "6",
	opera_mobile: "42",
	electron: "1.6"
},
	"bugfix/transform-edge-default-parameters": {
	chrome: "49",
	opera: "36",
	edge: "18",
	firefox: "52",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"bugfix/transform-edge-function-name": {
	chrome: "51",
	opera: "38",
	edge: "79",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"bugfix/transform-safari-block-shadowing": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "44",
	safari: "11",
	node: "6",
	deno: "1",
	ie: "11",
	ios: "11",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"bugfix/transform-safari-for-shadowing": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "4",
	safari: "11",
	node: "6",
	deno: "1",
	ie: "11",
	ios: "11",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "36",
	electron: "0.37"
},
	"bugfix/transform-safari-id-destructuring-collision-in-function-expression": {
	chrome: "49",
	opera: "36",
	edge: "14",
	firefox: "2",
	safari: "16.3",
	node: "6",
	deno: "1",
	ios: "16.3",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"bugfix/transform-tagged-template-caching": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "34",
	safari: "13",
	node: "4",
	deno: "1",
	ios: "13",
	samsung: "3.4",
	rhino: "1.7.14",
	opera_mobile: "28",
	electron: "0.21"
},
	"bugfix/transform-v8-spread-parameters-in-optional-chaining": {
	chrome: "91",
	opera: "77",
	edge: "91",
	firefox: "74",
	safari: "13.1",
	node: "16.9",
	deno: "1.9",
	ios: "13.4",
	samsung: "16",
	opera_mobile: "64",
	electron: "13.0"
},
	"transform-optional-chaining": {
	chrome: "80",
	opera: "67",
	edge: "80",
	firefox: "74",
	safari: "13.1",
	node: "14",
	deno: "1",
	ios: "13.4",
	samsung: "13",
	rhino: "1.8",
	opera_mobile: "57",
	electron: "8.0"
},
	"proposal-optional-chaining": {
	chrome: "80",
	opera: "67",
	edge: "80",
	firefox: "74",
	safari: "13.1",
	node: "14",
	deno: "1",
	ios: "13.4",
	samsung: "13",
	rhino: "1.8",
	opera_mobile: "57",
	electron: "8.0"
},
	"transform-parameters": {
	chrome: "49",
	opera: "36",
	edge: "15",
	firefox: "52",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"transform-async-to-generator": {
	chrome: "55",
	opera: "42",
	edge: "15",
	firefox: "52",
	safari: "10.1",
	node: "7.6",
	deno: "1",
	ios: "10.3",
	samsung: "6",
	opera_mobile: "42",
	electron: "1.6"
},
	"transform-template-literals": {
	chrome: "41",
	opera: "28",
	edge: "13",
	firefox: "34",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	opera_mobile: "28",
	electron: "0.21"
},
	"transform-function-name": {
	chrome: "51",
	opera: "38",
	edge: "14",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"transform-block-scoping": {
	chrome: "50",
	opera: "37",
	edge: "14",
	firefox: "53",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
}
};

var pluginBugfixes;
var hasRequiredPluginBugfixes;

function requirePluginBugfixes () {
	if (hasRequiredPluginBugfixes) return pluginBugfixes;
	hasRequiredPluginBugfixes = 1;
	pluginBugfixes = require$$0$4;
	return pluginBugfixes;
}

var require$$0$3 = {
	"transform-async-to-generator": [
	"bugfix/transform-async-arrows-in-class"
],
	"transform-parameters": [
	"bugfix/transform-edge-default-parameters",
	"bugfix/transform-safari-id-destructuring-collision-in-function-expression"
],
	"transform-function-name": [
	"bugfix/transform-edge-function-name"
],
	"transform-block-scoping": [
	"bugfix/transform-safari-block-shadowing",
	"bugfix/transform-safari-for-shadowing"
],
	"transform-template-literals": [
	"bugfix/transform-tagged-template-caching"
],
	"transform-optional-chaining": [
	"bugfix/transform-v8-spread-parameters-in-optional-chaining"
],
	"proposal-optional-chaining": [
	"bugfix/transform-v8-spread-parameters-in-optional-chaining"
],
	"transform-class-properties": [
	"bugfix/transform-v8-static-class-fields-redefine-readonly",
	"bugfix/transform-firefox-class-in-computed-class-key",
	"bugfix/transform-safari-class-field-initializer-scope"
],
	"proposal-class-properties": [
	"bugfix/transform-v8-static-class-fields-redefine-readonly",
	"bugfix/transform-firefox-class-in-computed-class-key",
	"bugfix/transform-safari-class-field-initializer-scope"
]
};

var overlappingPlugins;
var hasRequiredOverlappingPlugins;

function requireOverlappingPlugins () {
	if (hasRequiredOverlappingPlugins) return overlappingPlugins;
	hasRequiredOverlappingPlugins = 1;
	overlappingPlugins = require$$0$3;
	return overlappingPlugins;
}

var hasRequiredPluginsCompatData;

function requirePluginsCompatData () {
	if (hasRequiredPluginsCompatData) return pluginsCompatData;
	hasRequiredPluginsCompatData = 1;
	Object.defineProperty(pluginsCompatData, "__esModule", {
	  value: true
	});
	pluginsCompatData.pluginsBugfixes = pluginsCompatData.plugins = pluginsCompatData.overlappingPlugins = void 0;
	var _availablePlugins = requireAvailablePlugins();
	const originalPlugins = requirePlugins(), originalPluginsBugfixes = requirePluginBugfixes(), originalOverlappingPlugins = requireOverlappingPlugins();
	const keys = Object.keys;
	pluginsCompatData.plugins = filterAvailable(originalPlugins);
	pluginsCompatData.pluginsBugfixes = filterAvailable(originalPluginsBugfixes);
	const overlappingPlugins = pluginsCompatData.overlappingPlugins = filterAvailable(originalOverlappingPlugins);
	{
	  overlappingPlugins["syntax-import-attributes"] = ["syntax-import-assertions"];
	}
	function filterAvailable(data) {
	  const result = {};
	  for (const plugin of keys(data)) {
	    if (hasOwnProperty.call(_availablePlugins.default, plugin)) {
	      result[plugin] = data[plugin];
	    }
	  }
	  return result;
	}
	return pluginsCompatData;
}

var options = {};

var hasRequiredOptions;

function requireOptions () {
	if (hasRequiredOptions) return options;
	hasRequiredOptions = 1;
	Object.defineProperty(options, "__esModule", {
	  value: true
	});
	options.UseBuiltInsOption = options.TopLevelOptions = options.ModulesOption = void 0;
	const TopLevelOptions = options.TopLevelOptions = {
	  configPath: "configPath",
	  corejs: "corejs",
	  debug: "debug",
	  exclude: "exclude",
	  forceAllTransforms: "forceAllTransforms",
	  ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
	  include: "include",
	  modules: "modules",
	  shippedProposals: "shippedProposals",
	  targets: "targets",
	  useBuiltIns: "useBuiltIns",
	  browserslistEnv: "browserslistEnv"
	};
	{
	  Object.assign(TopLevelOptions, {
	    bugfixes: "bugfixes",
	    loose: "loose",
	    spec: "spec"
	  });
	}
	options.ModulesOption = {
	  false: false,
	  auto: "auto",
	  amd: "amd",
	  commonjs: "commonjs",
	  cjs: "cjs",
	  systemjs: "systemjs",
	  umd: "umd"
	};
	options.UseBuiltInsOption = {
	  false: false,
	  entry: "entry",
	  usage: "usage"
	};
	return options;
}

var babel7Plugins = {};

var lib$4 = {};

var require$$0$2 = {
	"es6.array.copy-within": {
	chrome: "45",
	opera: "32",
	edge: "12",
	firefox: "32",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.31"
},
	"es6.array.every": {
	chrome: "5",
	opera: "10.10",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.fill": {
	chrome: "45",
	opera: "32",
	edge: "12",
	firefox: "31",
	safari: "7.1",
	node: "4",
	deno: "1",
	ios: "8",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.31"
},
	"es6.array.filter": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.array.find": {
	chrome: "45",
	opera: "32",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "4",
	deno: "1",
	ios: "8",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.31"
},
	"es6.array.find-index": {
	chrome: "45",
	opera: "32",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "4",
	deno: "1",
	ios: "8",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.31"
},
	"es7.array.flat-map": {
	chrome: "69",
	opera: "56",
	edge: "79",
	firefox: "62",
	safari: "12",
	node: "11",
	deno: "1",
	ios: "12",
	samsung: "10",
	rhino: "1.7.15",
	opera_mobile: "48",
	electron: "4.0"
},
	"es6.array.for-each": {
	chrome: "5",
	opera: "10.10",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.from": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "36",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "41",
	electron: "1.2"
},
	"es7.array.includes": {
	chrome: "47",
	opera: "34",
	edge: "14",
	firefox: "102",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "34",
	electron: "0.36"
},
	"es6.array.index-of": {
	chrome: "5",
	opera: "10.10",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.is-array": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "4",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.iterator": {
	chrome: "66",
	opera: "53",
	edge: "12",
	firefox: "60",
	safari: "9",
	node: "10",
	deno: "1",
	ios: "9",
	samsung: "9",
	rhino: "1.7.13",
	opera_mobile: "47",
	electron: "3.0"
},
	"es6.array.last-index-of": {
	chrome: "5",
	opera: "10.10",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.map": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.array.of": {
	chrome: "45",
	opera: "32",
	edge: "12",
	firefox: "25",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.31"
},
	"es6.array.reduce": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "3",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.reduce-right": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "3",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.slice": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.array.some": {
	chrome: "5",
	opera: "10.10",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.array.sort": {
	chrome: "63",
	opera: "50",
	edge: "12",
	firefox: "5",
	safari: "12",
	node: "10",
	deno: "1",
	ie: "9",
	ios: "12",
	samsung: "8",
	rhino: "1.7.13",
	opera_mobile: "46",
	electron: "3.0"
},
	"es6.array.species": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.date.now": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "2",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.date.to-iso-string": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "3.5",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.date.to-json": {
	chrome: "5",
	opera: "12.10",
	edge: "12",
	firefox: "4",
	safari: "10",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "10",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12.1",
	electron: "0.20"
},
	"es6.date.to-primitive": {
	chrome: "47",
	opera: "34",
	edge: "15",
	firefox: "44",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "34",
	electron: "0.36"
},
	"es6.date.to-string": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "2",
	safari: "3.1",
	node: "0.4",
	deno: "1",
	ie: "10",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.function.bind": {
	chrome: "7",
	opera: "12",
	edge: "12",
	firefox: "4",
	safari: "5.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"es6.function.has-instance": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "50",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.function.name": {
	chrome: "5",
	opera: "10.50",
	edge: "14",
	firefox: "2",
	safari: "4",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es6.map": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.math.acosh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.asinh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.atanh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.cbrt": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.clz32": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "31",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.cosh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.expm1": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.fround": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "26",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.hypot": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "27",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.imul": {
	chrome: "30",
	opera: "17",
	edge: "12",
	firefox: "23",
	safari: "7",
	node: "0.12",
	deno: "1",
	android: "4.4",
	ios: "7",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "18",
	electron: "0.20"
},
	"es6.math.log1p": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.log10": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.log2": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.sign": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.sinh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.tanh": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.math.trunc": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "25",
	safari: "7.1",
	node: "0.12",
	deno: "1",
	ios: "8",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.number.constructor": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "36",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.number.epsilon": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "25",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.14",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.is-finite": {
	chrome: "19",
	opera: "15",
	edge: "12",
	firefox: "16",
	safari: "9",
	node: "0.8",
	deno: "1",
	android: "4.1",
	ios: "9",
	samsung: "1.5",
	rhino: "1.7.13",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.number.is-integer": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "16",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.is-nan": {
	chrome: "19",
	opera: "15",
	edge: "12",
	firefox: "15",
	safari: "9",
	node: "0.8",
	deno: "1",
	android: "4.1",
	ios: "9",
	samsung: "1.5",
	rhino: "1.7.13",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.number.is-safe-integer": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "32",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.max-safe-integer": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "31",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.min-safe-integer": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "31",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.parse-float": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "25",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.14",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.number.parse-int": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "25",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "2",
	rhino: "1.7.14",
	opera_mobile: "21",
	electron: "0.20"
},
	"es6.object.assign": {
	chrome: "49",
	opera: "36",
	edge: "13",
	firefox: "36",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.object.create": {
	chrome: "5",
	opera: "12",
	edge: "12",
	firefox: "4",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"es7.object.define-getter": {
	chrome: "62",
	opera: "49",
	edge: "16",
	firefox: "48",
	safari: "9",
	node: "8.10",
	deno: "1",
	ios: "9",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"es7.object.define-setter": {
	chrome: "62",
	opera: "49",
	edge: "16",
	firefox: "48",
	safari: "9",
	node: "8.10",
	deno: "1",
	ios: "9",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"es6.object.define-property": {
	chrome: "5",
	opera: "12",
	edge: "12",
	firefox: "4",
	safari: "5.1",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"es6.object.define-properties": {
	chrome: "5",
	opera: "12",
	edge: "12",
	firefox: "4",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"es7.object.entries": {
	chrome: "54",
	opera: "41",
	edge: "14",
	firefox: "47",
	safari: "10.1",
	node: "7",
	deno: "1",
	ios: "10.3",
	samsung: "6",
	rhino: "1.7.14",
	opera_mobile: "41",
	electron: "1.4"
},
	"es6.object.freeze": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.get-own-property-descriptor": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es7.object.get-own-property-descriptors": {
	chrome: "54",
	opera: "41",
	edge: "15",
	firefox: "50",
	safari: "10.1",
	node: "7",
	deno: "1",
	ios: "10.3",
	samsung: "6",
	rhino: "1.8",
	opera_mobile: "41",
	electron: "1.4"
},
	"es6.object.get-own-property-names": {
	chrome: "40",
	opera: "27",
	edge: "12",
	firefox: "33",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "27",
	electron: "0.21"
},
	"es6.object.get-prototype-of": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es7.object.lookup-getter": {
	chrome: "62",
	opera: "49",
	edge: "79",
	firefox: "36",
	safari: "9",
	node: "8.10",
	deno: "1",
	ios: "9",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"es7.object.lookup-setter": {
	chrome: "62",
	opera: "49",
	edge: "79",
	firefox: "36",
	safari: "9",
	node: "8.10",
	deno: "1",
	ios: "9",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"es6.object.prevent-extensions": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.to-string": {
	chrome: "57",
	opera: "44",
	edge: "15",
	firefox: "51",
	safari: "10",
	node: "8",
	deno: "1",
	ios: "10",
	samsung: "7",
	opera_mobile: "43",
	electron: "1.7"
},
	"es6.object.is": {
	chrome: "19",
	opera: "15",
	edge: "12",
	firefox: "22",
	safari: "9",
	node: "0.8",
	deno: "1",
	android: "4.1",
	ios: "9",
	samsung: "1.5",
	rhino: "1.7.13",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.object.is-frozen": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.is-sealed": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.is-extensible": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.keys": {
	chrome: "40",
	opera: "27",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "27",
	electron: "0.21"
},
	"es6.object.seal": {
	chrome: "44",
	opera: "31",
	edge: "12",
	firefox: "35",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "4",
	rhino: "1.7.13",
	opera_mobile: "32",
	electron: "0.30"
},
	"es6.object.set-prototype-of": {
	chrome: "34",
	opera: "21",
	edge: "12",
	firefox: "31",
	safari: "9",
	node: "0.12",
	deno: "1",
	ie: "11",
	ios: "9",
	samsung: "2",
	rhino: "1.7.13",
	opera_mobile: "21",
	electron: "0.20"
},
	"es7.object.values": {
	chrome: "54",
	opera: "41",
	edge: "14",
	firefox: "47",
	safari: "10.1",
	node: "7",
	deno: "1",
	ios: "10.3",
	samsung: "6",
	rhino: "1.7.14",
	opera_mobile: "41",
	electron: "1.4"
},
	"es6.promise": {
	chrome: "51",
	opera: "38",
	edge: "14",
	firefox: "45",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "41",
	electron: "1.2"
},
	"es7.promise.finally": {
	chrome: "63",
	opera: "50",
	edge: "18",
	firefox: "58",
	safari: "11.1",
	node: "10",
	deno: "1",
	ios: "11.3",
	samsung: "8",
	rhino: "1.7.15",
	opera_mobile: "46",
	electron: "3.0"
},
	"es6.reflect.apply": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.construct": {
	chrome: "49",
	opera: "36",
	edge: "13",
	firefox: "49",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.define-property": {
	chrome: "49",
	opera: "36",
	edge: "13",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.delete-property": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.get": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.get-own-property-descriptor": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.get-prototype-of": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.has": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.is-extensible": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.own-keys": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.prevent-extensions": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.set": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.reflect.set-prototype-of": {
	chrome: "49",
	opera: "36",
	edge: "12",
	firefox: "42",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.8",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.regexp.constructor": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "40",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.regexp.flags": {
	chrome: "49",
	opera: "36",
	edge: "79",
	firefox: "37",
	safari: "9",
	node: "6",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "36",
	electron: "0.37"
},
	"es6.regexp.match": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "49",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.regexp.replace": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "49",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.regexp.split": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "49",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.regexp.search": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "49",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.13",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.regexp.to-string": {
	chrome: "50",
	opera: "37",
	edge: "79",
	firefox: "39",
	safari: "10",
	node: "6",
	deno: "1",
	ios: "10",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "37",
	electron: "1.1"
},
	"es6.set": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.symbol": {
	chrome: "51",
	opera: "38",
	edge: "79",
	firefox: "51",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es7.symbol.async-iterator": {
	chrome: "63",
	opera: "50",
	edge: "79",
	firefox: "57",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "8",
	opera_mobile: "46",
	electron: "3.0"
},
	"es6.string.anchor": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.big": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.blink": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.bold": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.code-point-at": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "29",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.ends-with": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "29",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.fixed": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.fontcolor": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.fontsize": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.from-code-point": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "29",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.includes": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "40",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.italics": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.iterator": {
	chrome: "38",
	opera: "25",
	edge: "12",
	firefox: "36",
	safari: "9",
	node: "0.12",
	deno: "1",
	ios: "9",
	samsung: "3",
	rhino: "1.7.13",
	opera_mobile: "25",
	electron: "0.20"
},
	"es6.string.link": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es7.string.pad-start": {
	chrome: "57",
	opera: "44",
	edge: "15",
	firefox: "48",
	safari: "10",
	node: "8",
	deno: "1",
	ios: "10",
	samsung: "7",
	rhino: "1.7.13",
	opera_mobile: "43",
	electron: "1.7"
},
	"es7.string.pad-end": {
	chrome: "57",
	opera: "44",
	edge: "15",
	firefox: "48",
	safari: "10",
	node: "8",
	deno: "1",
	ios: "10",
	samsung: "7",
	rhino: "1.7.13",
	opera_mobile: "43",
	electron: "1.7"
},
	"es6.string.raw": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "34",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.14",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.repeat": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "24",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.small": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.starts-with": {
	chrome: "41",
	opera: "28",
	edge: "12",
	firefox: "29",
	safari: "9",
	node: "4",
	deno: "1",
	ios: "9",
	samsung: "3.4",
	rhino: "1.7.13",
	opera_mobile: "28",
	electron: "0.21"
},
	"es6.string.strike": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.sub": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.sup": {
	chrome: "5",
	opera: "15",
	edge: "12",
	firefox: "17",
	safari: "6",
	node: "0.4",
	deno: "1",
	android: "4",
	ios: "7",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.14",
	opera_mobile: "14",
	electron: "0.20"
},
	"es6.string.trim": {
	chrome: "5",
	opera: "10.50",
	edge: "12",
	firefox: "3.5",
	safari: "4",
	node: "0.4",
	deno: "1",
	ie: "9",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "10.1",
	electron: "0.20"
},
	"es7.string.trim-left": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "61",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "9",
	rhino: "1.7.13",
	opera_mobile: "47",
	electron: "3.0"
},
	"es7.string.trim-right": {
	chrome: "66",
	opera: "53",
	edge: "79",
	firefox: "61",
	safari: "12",
	node: "10",
	deno: "1",
	ios: "12",
	samsung: "9",
	rhino: "1.7.13",
	opera_mobile: "47",
	electron: "3.0"
},
	"es6.typed.array-buffer": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.data-view": {
	chrome: "5",
	opera: "12",
	edge: "12",
	firefox: "15",
	safari: "5.1",
	node: "0.4",
	deno: "1",
	ie: "10",
	android: "4",
	ios: "6",
	phantom: "1.9",
	samsung: "1",
	rhino: "1.7.13",
	opera_mobile: "12",
	electron: "0.20"
},
	"es6.typed.int8-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.uint8-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.uint8-clamped-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.int16-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.uint16-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.int32-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.uint32-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.float32-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.typed.float64-array": {
	chrome: "51",
	opera: "38",
	edge: "13",
	firefox: "48",
	safari: "10",
	node: "6.5",
	deno: "1",
	ios: "10",
	samsung: "5",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.weak-map": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "9",
	node: "6.5",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "41",
	electron: "1.2"
},
	"es6.weak-set": {
	chrome: "51",
	opera: "38",
	edge: "15",
	firefox: "53",
	safari: "9",
	node: "6.5",
	deno: "1",
	ios: "9",
	samsung: "5",
	rhino: "1.7.15",
	opera_mobile: "41",
	electron: "1.2"
}
};

var corejs2BuiltIns;
var hasRequiredCorejs2BuiltIns;

function requireCorejs2BuiltIns () {
	if (hasRequiredCorejs2BuiltIns) return corejs2BuiltIns;
	hasRequiredCorejs2BuiltIns = 1;
	corejs2BuiltIns = require$$0$2;
	return corejs2BuiltIns;
}

var builtInDefinitions$1 = {};

var hasRequiredBuiltInDefinitions$1;

function requireBuiltInDefinitions$1 () {
	if (hasRequiredBuiltInDefinitions$1) return builtInDefinitions$1;
	hasRequiredBuiltInDefinitions$1 = 1;
	builtInDefinitions$1.__esModule = true;
	builtInDefinitions$1.StaticProperties = builtInDefinitions$1.InstanceProperties = builtInDefinitions$1.CommonIterators = builtInDefinitions$1.BuiltIns = void 0;
	var _corejs2BuiltIns = _interopRequireDefault(requireCorejs2BuiltIns());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	const define = (name, pure, global = [], meta) => {
	  return {
	    name,
	    pure,
	    global,
	    meta
	  };
	};
	const pureAndGlobal = (pure, global, minRuntimeVersion = null) => define(global[0], pure, global, {
	  minRuntimeVersion
	});
	const globalOnly = (global) => define(global[0], null, global);
	const pureOnly = (pure, name) => define(name, pure, []);
	const ArrayNatureIterators = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
	const CommonIterators = ["es6.string.iterator", ...ArrayNatureIterators];
	builtInDefinitions$1.CommonIterators = CommonIterators;
	const PromiseDependencies = ["es6.object.to-string", "es6.promise"];
	const BuiltIns = {
	  DataView: globalOnly(["es6.typed.data-view"]),
	  Float32Array: globalOnly(["es6.typed.float32-array"]),
	  Float64Array: globalOnly(["es6.typed.float64-array"]),
	  Int8Array: globalOnly(["es6.typed.int8-array"]),
	  Int16Array: globalOnly(["es6.typed.int16-array"]),
	  Int32Array: globalOnly(["es6.typed.int32-array"]),
	  Map: pureAndGlobal("map", ["es6.map", ...CommonIterators]),
	  Number: globalOnly(["es6.number.constructor"]),
	  Promise: pureAndGlobal("promise", PromiseDependencies),
	  RegExp: globalOnly(["es6.regexp.constructor"]),
	  Set: pureAndGlobal("set", ["es6.set", ...CommonIterators]),
	  Symbol: pureAndGlobal("symbol/index", ["es6.symbol"]),
	  Uint8Array: globalOnly(["es6.typed.uint8-array"]),
	  Uint8ClampedArray: globalOnly(["es6.typed.uint8-clamped-array"]),
	  Uint16Array: globalOnly(["es6.typed.uint16-array"]),
	  Uint32Array: globalOnly(["es6.typed.uint32-array"]),
	  WeakMap: pureAndGlobal("weak-map", ["es6.weak-map", ...CommonIterators]),
	  WeakSet: pureAndGlobal("weak-set", ["es6.weak-set", ...CommonIterators]),
	  setImmediate: pureOnly("set-immediate", "web.immediate"),
	  clearImmediate: pureOnly("clear-immediate", "web.immediate"),
	  parseFloat: pureOnly("parse-float", "es6.parse-float"),
	  parseInt: pureOnly("parse-int", "es6.parse-int")
	};
	builtInDefinitions$1.BuiltIns = BuiltIns;
	const InstanceProperties = {
	  __defineGetter__: globalOnly(["es7.object.define-getter"]),
	  __defineSetter__: globalOnly(["es7.object.define-setter"]),
	  __lookupGetter__: globalOnly(["es7.object.lookup-getter"]),
	  __lookupSetter__: globalOnly(["es7.object.lookup-setter"]),
	  anchor: globalOnly(["es6.string.anchor"]),
	  big: globalOnly(["es6.string.big"]),
	  bind: globalOnly(["es6.function.bind"]),
	  blink: globalOnly(["es6.string.blink"]),
	  bold: globalOnly(["es6.string.bold"]),
	  codePointAt: globalOnly(["es6.string.code-point-at"]),
	  copyWithin: globalOnly(["es6.array.copy-within"]),
	  endsWith: globalOnly(["es6.string.ends-with"]),
	  entries: globalOnly(ArrayNatureIterators),
	  every: globalOnly(["es6.array.every"]),
	  fill: globalOnly(["es6.array.fill"]),
	  filter: globalOnly(["es6.array.filter"]),
	  finally: globalOnly(["es7.promise.finally", ...PromiseDependencies]),
	  find: globalOnly(["es6.array.find"]),
	  findIndex: globalOnly(["es6.array.find-index"]),
	  fixed: globalOnly(["es6.string.fixed"]),
	  flags: globalOnly(["es6.regexp.flags"]),
	  flatMap: globalOnly(["es7.array.flat-map"]),
	  fontcolor: globalOnly(["es6.string.fontcolor"]),
	  fontsize: globalOnly(["es6.string.fontsize"]),
	  forEach: globalOnly(["es6.array.for-each"]),
	  includes: globalOnly(["es6.string.includes", "es7.array.includes"]),
	  indexOf: globalOnly(["es6.array.index-of"]),
	  italics: globalOnly(["es6.string.italics"]),
	  keys: globalOnly(ArrayNatureIterators),
	  lastIndexOf: globalOnly(["es6.array.last-index-of"]),
	  link: globalOnly(["es6.string.link"]),
	  map: globalOnly(["es6.array.map"]),
	  match: globalOnly(["es6.regexp.match"]),
	  name: globalOnly(["es6.function.name"]),
	  padStart: globalOnly(["es7.string.pad-start"]),
	  padEnd: globalOnly(["es7.string.pad-end"]),
	  reduce: globalOnly(["es6.array.reduce"]),
	  reduceRight: globalOnly(["es6.array.reduce-right"]),
	  repeat: globalOnly(["es6.string.repeat"]),
	  replace: globalOnly(["es6.regexp.replace"]),
	  search: globalOnly(["es6.regexp.search"]),
	  small: globalOnly(["es6.string.small"]),
	  some: globalOnly(["es6.array.some"]),
	  sort: globalOnly(["es6.array.sort"]),
	  split: globalOnly(["es6.regexp.split"]),
	  startsWith: globalOnly(["es6.string.starts-with"]),
	  strike: globalOnly(["es6.string.strike"]),
	  sub: globalOnly(["es6.string.sub"]),
	  sup: globalOnly(["es6.string.sup"]),
	  toISOString: globalOnly(["es6.date.to-iso-string"]),
	  toJSON: globalOnly(["es6.date.to-json"]),
	  toString: globalOnly(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
	  trim: globalOnly(["es6.string.trim"]),
	  trimEnd: globalOnly(["es7.string.trim-right"]),
	  trimLeft: globalOnly(["es7.string.trim-left"]),
	  trimRight: globalOnly(["es7.string.trim-right"]),
	  trimStart: globalOnly(["es7.string.trim-left"]),
	  values: globalOnly(ArrayNatureIterators)
	};
	builtInDefinitions$1.InstanceProperties = InstanceProperties;
	if ("es6.array.slice" in _corejs2BuiltIns.default) {
	  InstanceProperties.slice = globalOnly(["es6.array.slice"]);
	}
	const StaticProperties = {
	  Array: {
	    from: pureAndGlobal("array/from", ["es6.symbol", "es6.array.from", ...CommonIterators]),
	    isArray: pureAndGlobal("array/is-array", ["es6.array.is-array"]),
	    of: pureAndGlobal("array/of", ["es6.array.of"])
	  },
	  Date: {
	    now: pureAndGlobal("date/now", ["es6.date.now"])
	  },
	  JSON: {
	    stringify: pureOnly("json/stringify", "es6.symbol")
	  },
	  Math: {
	    // 'Math' was not included in the 7.0.0
	    // release of '@babel/runtime'. See issue https://github.com/babel/babel/pull/8616.
	    acosh: pureAndGlobal("math/acosh", ["es6.math.acosh"], "7.0.1"),
	    asinh: pureAndGlobal("math/asinh", ["es6.math.asinh"], "7.0.1"),
	    atanh: pureAndGlobal("math/atanh", ["es6.math.atanh"], "7.0.1"),
	    cbrt: pureAndGlobal("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
	    clz32: pureAndGlobal("math/clz32", ["es6.math.clz32"], "7.0.1"),
	    cosh: pureAndGlobal("math/cosh", ["es6.math.cosh"], "7.0.1"),
	    expm1: pureAndGlobal("math/expm1", ["es6.math.expm1"], "7.0.1"),
	    fround: pureAndGlobal("math/fround", ["es6.math.fround"], "7.0.1"),
	    hypot: pureAndGlobal("math/hypot", ["es6.math.hypot"], "7.0.1"),
	    imul: pureAndGlobal("math/imul", ["es6.math.imul"], "7.0.1"),
	    log1p: pureAndGlobal("math/log1p", ["es6.math.log1p"], "7.0.1"),
	    log10: pureAndGlobal("math/log10", ["es6.math.log10"], "7.0.1"),
	    log2: pureAndGlobal("math/log2", ["es6.math.log2"], "7.0.1"),
	    sign: pureAndGlobal("math/sign", ["es6.math.sign"], "7.0.1"),
	    sinh: pureAndGlobal("math/sinh", ["es6.math.sinh"], "7.0.1"),
	    tanh: pureAndGlobal("math/tanh", ["es6.math.tanh"], "7.0.1"),
	    trunc: pureAndGlobal("math/trunc", ["es6.math.trunc"], "7.0.1")
	  },
	  Number: {
	    EPSILON: pureAndGlobal("number/epsilon", ["es6.number.epsilon"]),
	    MIN_SAFE_INTEGER: pureAndGlobal("number/min-safe-integer", ["es6.number.min-safe-integer"]),
	    MAX_SAFE_INTEGER: pureAndGlobal("number/max-safe-integer", ["es6.number.max-safe-integer"]),
	    isFinite: pureAndGlobal("number/is-finite", ["es6.number.is-finite"]),
	    isInteger: pureAndGlobal("number/is-integer", ["es6.number.is-integer"]),
	    isSafeInteger: pureAndGlobal("number/is-safe-integer", ["es6.number.is-safe-integer"]),
	    isNaN: pureAndGlobal("number/is-nan", ["es6.number.is-nan"]),
	    parseFloat: pureAndGlobal("number/parse-float", ["es6.number.parse-float"]),
	    parseInt: pureAndGlobal("number/parse-int", ["es6.number.parse-int"])
	  },
	  Object: {
	    assign: pureAndGlobal("object/assign", ["es6.object.assign"]),
	    create: pureAndGlobal("object/create", ["es6.object.create"]),
	    defineProperties: pureAndGlobal("object/define-properties", ["es6.object.define-properties"]),
	    defineProperty: pureAndGlobal("object/define-property", ["es6.object.define-property"]),
	    entries: pureAndGlobal("object/entries", ["es7.object.entries"]),
	    freeze: pureAndGlobal("object/freeze", ["es6.object.freeze"]),
	    getOwnPropertyDescriptor: pureAndGlobal("object/get-own-property-descriptor", ["es6.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: pureAndGlobal("object/get-own-property-descriptors", ["es7.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: pureAndGlobal("object/get-own-property-names", ["es6.object.get-own-property-names"]),
	    getOwnPropertySymbols: pureAndGlobal("object/get-own-property-symbols", ["es6.symbol"]),
	    getPrototypeOf: pureAndGlobal("object/get-prototype-of", ["es6.object.get-prototype-of"]),
	    is: pureAndGlobal("object/is", ["es6.object.is"]),
	    isExtensible: pureAndGlobal("object/is-extensible", ["es6.object.is-extensible"]),
	    isFrozen: pureAndGlobal("object/is-frozen", ["es6.object.is-frozen"]),
	    isSealed: pureAndGlobal("object/is-sealed", ["es6.object.is-sealed"]),
	    keys: pureAndGlobal("object/keys", ["es6.object.keys"]),
	    preventExtensions: pureAndGlobal("object/prevent-extensions", ["es6.object.prevent-extensions"]),
	    seal: pureAndGlobal("object/seal", ["es6.object.seal"]),
	    setPrototypeOf: pureAndGlobal("object/set-prototype-of", ["es6.object.set-prototype-of"]),
	    values: pureAndGlobal("object/values", ["es7.object.values"])
	  },
	  Promise: {
	    all: globalOnly(CommonIterators),
	    race: globalOnly(CommonIterators)
	  },
	  Reflect: {
	    apply: pureAndGlobal("reflect/apply", ["es6.reflect.apply"]),
	    construct: pureAndGlobal("reflect/construct", ["es6.reflect.construct"]),
	    defineProperty: pureAndGlobal("reflect/define-property", ["es6.reflect.define-property"]),
	    deleteProperty: pureAndGlobal("reflect/delete-property", ["es6.reflect.delete-property"]),
	    get: pureAndGlobal("reflect/get", ["es6.reflect.get"]),
	    getOwnPropertyDescriptor: pureAndGlobal("reflect/get-own-property-descriptor", ["es6.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: pureAndGlobal("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
	    has: pureAndGlobal("reflect/has", ["es6.reflect.has"]),
	    isExtensible: pureAndGlobal("reflect/is-extensible", ["es6.reflect.is-extensible"]),
	    ownKeys: pureAndGlobal("reflect/own-keys", ["es6.reflect.own-keys"]),
	    preventExtensions: pureAndGlobal("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
	    set: pureAndGlobal("reflect/set", ["es6.reflect.set"]),
	    setPrototypeOf: pureAndGlobal("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
	  },
	  String: {
	    at: pureOnly("string/at", "es7.string.at"),
	    fromCodePoint: pureAndGlobal("string/from-code-point", ["es6.string.from-code-point"]),
	    raw: pureAndGlobal("string/raw", ["es6.string.raw"])
	  },
	  Symbol: {
	    // FIXME: Pure disabled to work around zloirock/core-js#262.
	    asyncIterator: globalOnly(["es6.symbol", "es7.symbol.async-iterator"]),
	    for: pureOnly("symbol/for", "es6.symbol"),
	    hasInstance: pureOnly("symbol/has-instance", "es6.symbol"),
	    isConcatSpreadable: pureOnly("symbol/is-concat-spreadable", "es6.symbol"),
	    iterator: define("es6.symbol", "symbol/iterator", CommonIterators),
	    keyFor: pureOnly("symbol/key-for", "es6.symbol"),
	    match: pureAndGlobal("symbol/match", ["es6.regexp.match"]),
	    replace: pureOnly("symbol/replace", "es6.symbol"),
	    search: pureOnly("symbol/search", "es6.symbol"),
	    species: pureOnly("symbol/species", "es6.symbol"),
	    split: pureOnly("symbol/split", "es6.symbol"),
	    toPrimitive: pureOnly("symbol/to-primitive", "es6.symbol"),
	    toStringTag: pureOnly("symbol/to-string-tag", "es6.symbol"),
	    unscopables: pureOnly("symbol/unscopables", "es6.symbol")
	  }
	};
	builtInDefinitions$1.StaticProperties = StaticProperties;
	return builtInDefinitions$1;
}

var addPlatformSpecificPolyfills = {};

var hasRequiredAddPlatformSpecificPolyfills;

function requireAddPlatformSpecificPolyfills () {
	if (hasRequiredAddPlatformSpecificPolyfills) return addPlatformSpecificPolyfills;
	hasRequiredAddPlatformSpecificPolyfills = 1;
	addPlatformSpecificPolyfills.__esModule = true;
	addPlatformSpecificPolyfills.default = _default;
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	const webPolyfills = {
	  "web.timers": {},
	  "web.immediate": {},
	  "web.dom.iterable": {}
	};
	const purePolyfills = {
	  "es6.parse-float": {},
	  "es6.parse-int": {},
	  "es7.string.at": {}
	};
	function _default(targets, method, polyfills) {
	  const targetNames = Object.keys(targets);
	  const isAnyTarget = !targetNames.length;
	  const isWebTarget = targetNames.some((name) => name !== "node");
	  return _extends({}, polyfills, method === "usage-pure" ? purePolyfills : null, isAnyTarget || isWebTarget ? webPolyfills : null);
	}
	return addPlatformSpecificPolyfills;
}

var helpers$2 = {};

var hasRequiredHelpers$2;

function requireHelpers$2 () {
	if (hasRequiredHelpers$2) return helpers$2;
	hasRequiredHelpers$2 = 1;
	helpers$2.__esModule = true;
	helpers$2.hasMinVersion = hasMinVersion;
	var _semver = _interopRequireDefault(requireSemver());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	function hasMinVersion(minVersion, runtimeVersion) {
	  if (!runtimeVersion || !minVersion) return true;
	  runtimeVersion = String(runtimeVersion);
	  if (_semver.default.valid(runtimeVersion)) runtimeVersion = `^${runtimeVersion}`;
	  return !_semver.default.intersects(`<${minVersion}`, runtimeVersion) && !_semver.default.intersects(`>=8.0.0`, runtimeVersion);
	}
	return helpers$2;
}

var lib$3 = {};

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	utils$2.__esModule = true;
	utils$2.createUtilsGetter = createUtilsGetter;
	utils$2.getImportSource = getImportSource;
	utils$2.getRequireSource = getRequireSource;
	utils$2.has = has;
	utils$2.intersection = intersection;
	utils$2.resolveKey = resolveKey;
	utils$2.resolveSource = resolveSource;
	var _babel = _interopRequireWildcard(require$$0$b);
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	const {
	  types: t,
	  template
	} = _babel.default || _babel;
	function intersection(a, b) {
	  const result = /* @__PURE__ */ new Set();
	  a.forEach((v) => b.has(v) && result.add(v));
	  return result;
	}
	function has(object, key) {
	  return Object.prototype.hasOwnProperty.call(object, key);
	}
	function resolve(path, resolved = /* @__PURE__ */ new Set()) {
	  if (resolved.has(path)) return;
	  resolved.add(path);
	  if (path.isVariableDeclarator()) {
	    if (path.get("id").isIdentifier()) {
	      return resolve(path.get("init"), resolved);
	    }
	  } else if (path.isReferencedIdentifier()) {
	    const binding = path.scope.getBinding(path.node.name);
	    if (!binding) return path;
	    if (!binding.constant) return;
	    return resolve(binding.path, resolved);
	  }
	  return path;
	}
	function resolveId(path) {
	  if (path.isIdentifier() && !path.scope.hasBinding(
	    path.node.name,
	    /* noGlobals */
	    true
	  )) {
	    return path.node.name;
	  }
	  const resolved = resolve(path);
	  if (resolved != null && resolved.isIdentifier()) {
	    return resolved.node.name;
	  }
	}
	function resolveKey(path, computed = false) {
	  const {
	    scope
	  } = path;
	  if (path.isStringLiteral()) return path.node.value;
	  const isIdentifier = path.isIdentifier();
	  if (isIdentifier && !(computed || path.parent.computed)) {
	    return path.node.name;
	  }
	  if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
	    name: "Symbol"
	  }) && !scope.hasBinding(
	    "Symbol",
	    /* noGlobals */
	    true
	  )) {
	    const sym = resolveKey(path.get("property"), path.node.computed);
	    if (sym) return "Symbol." + sym;
	  }
	  if (isIdentifier ? scope.hasBinding(
	    path.node.name,
	    /* noGlobals */
	    true
	  ) : path.isPure()) {
	    const {
	      value
	    } = path.evaluate();
	    if (typeof value === "string") return value;
	  }
	}
	function resolveSource(obj) {
	  if (obj.isMemberExpression() && obj.get("property").isIdentifier({
	    name: "prototype"
	  })) {
	    const id2 = resolveId(obj.get("object"));
	    if (id2) {
	      return {
	        id: id2,
	        placement: "prototype"
	      };
	    }
	    return {
	      id: null,
	      placement: null
	    };
	  }
	  const id = resolveId(obj);
	  if (id) {
	    return {
	      id,
	      placement: "static"
	    };
	  }
	  const path = resolve(obj);
	  switch (path == null ? void 0 : path.type) {
	    case "RegExpLiteral":
	      return {
	        id: "RegExp",
	        placement: "prototype"
	      };
	    case "FunctionExpression":
	      return {
	        id: "Function",
	        placement: "prototype"
	      };
	    case "StringLiteral":
	      return {
	        id: "String",
	        placement: "prototype"
	      };
	    case "NumberLiteral":
	      return {
	        id: "Number",
	        placement: "prototype"
	      };
	    case "BooleanLiteral":
	      return {
	        id: "Boolean",
	        placement: "prototype"
	      };
	    case "ObjectExpression":
	      return {
	        id: "Object",
	        placement: "prototype"
	      };
	    case "ArrayExpression":
	      return {
	        id: "Array",
	        placement: "prototype"
	      };
	  }
	  return {
	    id: null,
	    placement: null
	  };
	}
	function getImportSource({
	  node
	}) {
	  if (node.specifiers.length === 0) return node.source.value;
	}
	function getRequireSource({
	  node
	}) {
	  if (!t.isExpressionStatement(node)) return;
	  const {
	    expression
	  } = node;
	  if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0])) {
	    return expression.arguments[0].value;
	  }
	}
	function hoist(node) {
	  node._blockHoist = 3;
	  return node;
	}
	function createUtilsGetter(cache) {
	  return (path) => {
	    const prog = path.findParent((p) => p.isProgram());
	    return {
	      injectGlobalImport(url, moduleName) {
	        cache.storeAnonymous(prog, url, moduleName, (isScript, source) => {
	          return isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source);
	        });
	      },
	      injectNamedImport(url, name, hint = name, moduleName) {
	        return cache.storeNamed(prog, url, name, moduleName, (isScript, source, name2) => {
	          const id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist(template.statement.ast`
                  var ${id} = require(${source}).${name2}
                `) : t.importDeclaration([t.importSpecifier(id, name2)], source),
	            name: id.name
	          };
	        });
	      },
	      injectDefaultImport(url, hint = url, moduleName) {
	        return cache.storeNamed(prog, url, "default", moduleName, (isScript, source) => {
	          const id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([t.importDefaultSpecifier(id)], source),
	            name: id.name
	          };
	        });
	      }
	    };
	  };
	}
	return utils$2;
}

var importsInjector = {};

var hasRequiredImportsInjector;

function requireImportsInjector () {
	if (hasRequiredImportsInjector) return importsInjector;
	hasRequiredImportsInjector = 1;
	importsInjector.__esModule = true;
	importsInjector.default = void 0;
	var _babel = _interopRequireWildcard(require$$0$b);
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	const {
	  types: t
	} = _babel.default || _babel;
	class ImportsCachedInjector {
	  constructor(resolver, getPreferredIndex) {
	    this._imports = /* @__PURE__ */ new WeakMap();
	    this._anonymousImports = /* @__PURE__ */ new WeakMap();
	    this._lastImports = /* @__PURE__ */ new WeakMap();
	    this._resolver = resolver;
	    this._getPreferredIndex = getPreferredIndex;
	  }
	  storeAnonymous(programPath, url, moduleName, getVal) {
	    const key = this._normalizeKey(programPath, url);
	    const imports = this._ensure(this._anonymousImports, programPath, Set);
	    if (imports.has(key)) return;
	    const node = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)));
	    imports.add(key);
	    this._injectImport(programPath, node, moduleName);
	  }
	  storeNamed(programPath, url, name, moduleName, getVal) {
	    const key = this._normalizeKey(programPath, url, name);
	    const imports = this._ensure(this._imports, programPath, Map);
	    if (!imports.has(key)) {
	      const {
	        node,
	        name: id
	      } = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)), t.identifier(name));
	      imports.set(key, id);
	      this._injectImport(programPath, node, moduleName);
	    }
	    return t.identifier(imports.get(key));
	  }
	  _injectImport(programPath, node, moduleName) {
	    var _this$_lastImports$ge;
	    const newIndex = this._getPreferredIndex(moduleName);
	    const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];
	    const isPathStillValid = (path) => path.node && // Sometimes the AST is modified and the "last import"
	    // we have has been replaced
	    path.parent === programPath.node && path.container === programPath.node.body;
	    let last;
	    if (newIndex === Infinity) {
	      if (lastImports.length > 0) {
	        last = lastImports[lastImports.length - 1].path;
	        if (!isPathStillValid(last)) last = void 0;
	      }
	    } else {
	      for (const [i, data] of lastImports.entries()) {
	        const {
	          path,
	          index
	        } = data;
	        if (isPathStillValid(path)) {
	          if (newIndex < index) {
	            const [newPath] = path.insertBefore(node);
	            lastImports.splice(i, 0, {
	              path: newPath,
	              index: newIndex
	            });
	            return;
	          }
	          last = path;
	        }
	      }
	    }
	    if (last) {
	      const [newPath] = last.insertAfter(node);
	      lastImports.push({
	        path: newPath,
	        index: newIndex
	      });
	    } else {
	      const [newPath] = programPath.unshiftContainer("body", node);
	      this._lastImports.set(programPath, [{
	        path: newPath,
	        index: newIndex
	      }]);
	    }
	  }
	  _ensure(map, programPath, Collection) {
	    let collection = map.get(programPath);
	    if (!collection) {
	      collection = new Collection();
	      map.set(programPath, collection);
	    }
	    return collection;
	  }
	  _normalizeKey(programPath, url, name = "") {
	    const {
	      sourceType
	    } = programPath.node;
	    return `${name && sourceType}::${url}::${name}`;
	  }
	}
	importsInjector.default = ImportsCachedInjector;
	return importsInjector;
}

var debugUtils = {};

var hasRequiredDebugUtils;

function requireDebugUtils () {
	if (hasRequiredDebugUtils) return debugUtils;
	hasRequiredDebugUtils = 1;
	debugUtils.__esModule = true;
	debugUtils.presetEnvSilentDebugHeader = void 0;
	debugUtils.stringifyTargets = stringifyTargets;
	debugUtils.stringifyTargetsMultiline = stringifyTargetsMultiline;
	var _helperCompilationTargets = requireLib$1g();
	const presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";
	debugUtils.presetEnvSilentDebugHeader = presetEnvSilentDebugHeader;
	function stringifyTargetsMultiline(targets) {
	  return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);
	}
	function stringifyTargets(targets) {
	  return JSON.stringify(targets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
	}
	return debugUtils;
}

var normalizeOptions$1 = {};

var hasRequiredNormalizeOptions$2;

function requireNormalizeOptions$2 () {
	if (hasRequiredNormalizeOptions$2) return normalizeOptions$1;
	hasRequiredNormalizeOptions$2 = 1;
	normalizeOptions$1.__esModule = true;
	normalizeOptions$1.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;
	normalizeOptions$1.validateIncludeExclude = validateIncludeExclude;
	var _utils = requireUtils$2();
	function patternToRegExp(pattern) {
	  if (pattern instanceof RegExp) return pattern;
	  try {
	    return new RegExp(`^${pattern}$`);
	  } catch (_unused) {
	    return null;
	  }
	}
	function buildUnusedError(label, unused) {
	  if (!unused.length) return "";
	  return `  - The following "${label}" patterns didn't match any polyfill:
` + unused.map((original) => `    ${String(original)}
`).join("");
	}
	function buldDuplicatesError(duplicates) {
	  if (!duplicates.size) return "";
	  return `  - The following polyfills were matched both by "include" and "exclude" patterns:
` + Array.from(duplicates, (name) => `    ${name}
`).join("");
	}
	function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
	  let current;
	  const filter = (pattern) => {
	    const regexp = patternToRegExp(pattern);
	    if (!regexp) return false;
	    let matched = false;
	    for (const polyfill of polyfills.keys()) {
	      if (regexp.test(polyfill)) {
	        matched = true;
	        current.add(polyfill);
	      }
	    }
	    return !matched;
	  };
	  const include = current = /* @__PURE__ */ new Set();
	  const unusedInclude = Array.from(includePatterns).filter(filter);
	  const exclude = current = /* @__PURE__ */ new Set();
	  const unusedExclude = Array.from(excludePatterns).filter(filter);
	  const duplicates = (0, _utils.intersection)(include, exclude);
	  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
	    throw new Error(`Error while validating the "${provider}" provider options:
` + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
	  }
	  return {
	    include,
	    exclude
	  };
	}
	function applyMissingDependenciesDefaults(options, babelApi) {
	  const {
	    missingDependencies = {}
	  } = options;
	  if (missingDependencies === false) return false;
	  const caller = babelApi.caller((caller2) => caller2 == null ? void 0 : caller2.name);
	  const {
	    log = "deferred",
	    inject = caller === "rollup-plugin-babel" ? "throw" : "import",
	    all = false
	  } = missingDependencies;
	  return {
	    log,
	    inject,
	    all
	  };
	}
	return normalizeOptions$1;
}

var visitors = {};

var usage = {};

var hasRequiredUsage;

function requireUsage () {
	if (hasRequiredUsage) return usage;
	hasRequiredUsage = 1;
	usage.__esModule = true;
	usage.default = void 0;
	var _utils = requireUtils$2();
	function isRemoved(path) {
	  if (path.removed) return true;
	  if (!path.parentPath) return false;
	  if (path.listKey) {
	    var _path$parentPath$node;
	    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;
	  } else {
	    if (path.parentPath.node[path.key] !== path.node) return true;
	  }
	  return isRemoved(path.parentPath);
	}
	var _default = (callProvider) => {
	  function property(object, key, placement, path) {
	    return callProvider({
	      kind: "property",
	      object,
	      key,
	      placement
	    }, path);
	  }
	  function handleReferencedIdentifier(path) {
	    const {
	      node: {
	        name
	      },
	      scope
	    } = path;
	    if (scope.getBindingIdentifier(name)) return;
	    callProvider({
	      kind: "global",
	      name
	    }, path);
	  }
	  function analyzeMemberExpression(path) {
	    const key = (0, _utils.resolveKey)(path.get("property"), path.node.computed);
	    return {
	      key,
	      handleAsMemberExpression: !!key && key !== "prototype"
	    };
	  }
	  return {
	    // Symbol(), new Promise
	    ReferencedIdentifier(path) {
	      const {
	        parentPath
	      } = path;
	      if (parentPath.isMemberExpression({
	        object: path.node
	      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {
	        return;
	      }
	      handleReferencedIdentifier(path);
	    },
	    "MemberExpression|OptionalMemberExpression"(path) {
	      const {
	        key,
	        handleAsMemberExpression
	      } = analyzeMemberExpression(path);
	      if (!handleAsMemberExpression) return;
	      const object = path.get("object");
	      let objectIsGlobalIdentifier = object.isIdentifier();
	      if (objectIsGlobalIdentifier) {
	        const binding = object.scope.getBinding(object.node.name);
	        if (binding) {
	          if (binding.path.isImportNamespaceSpecifier()) return;
	          objectIsGlobalIdentifier = false;
	        }
	      }
	      const source = (0, _utils.resolveSource)(object);
	      let skipObject = property(source.id, key, source.placement, path);
	      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));
	      if (!skipObject) handleReferencedIdentifier(object);
	    },
	    ObjectPattern(path) {
	      const {
	        parentPath,
	        parent
	      } = path;
	      let obj;
	      if (parentPath.isVariableDeclarator()) {
	        obj = parentPath.get("init");
	      } else if (parentPath.isAssignmentExpression()) {
	        obj = parentPath.get("right");
	      } else if (parentPath.isFunction()) {
	        const grand = parentPath.parentPath;
	        if (grand.isCallExpression() || grand.isNewExpression()) {
	          if (grand.node.callee === parent) {
	            obj = grand.get("arguments")[path.key];
	          }
	        }
	      }
	      let id = null;
	      let placement = null;
	      if (obj) ({
	        id,
	        placement
	      } = (0, _utils.resolveSource)(obj));
	      for (const prop of path.get("properties")) {
	        if (prop.isObjectProperty()) {
	          const key = (0, _utils.resolveKey)(prop.get("key"));
	          if (key) property(id, key, placement, prop);
	        }
	      }
	    },
	    BinaryExpression(path) {
	      if (path.node.operator !== "in") return;
	      const source = (0, _utils.resolveSource)(path.get("right"));
	      const key = (0, _utils.resolveKey)(path.get("left"), true);
	      if (!key) return;
	      callProvider({
	        kind: "in",
	        object: source.id,
	        key,
	        placement: source.placement
	      }, path);
	    }
	  };
	};
	usage.default = _default;
	return usage;
}

var entry = {};

var hasRequiredEntry;

function requireEntry () {
	if (hasRequiredEntry) return entry;
	hasRequiredEntry = 1;
	entry.__esModule = true;
	entry.default = void 0;
	var _utils = requireUtils$2();
	var _default = (callProvider) => ({
	  ImportDeclaration(path) {
	    const source = (0, _utils.getImportSource)(path);
	    if (!source) return;
	    callProvider({
	      kind: "import",
	      source
	    }, path);
	  },
	  Program(path) {
	    path.get("body").forEach((bodyPath) => {
	      const source = (0, _utils.getRequireSource)(bodyPath);
	      if (!source) return;
	      callProvider({
	        kind: "import",
	        source
	      }, bodyPath);
	    });
	  }
	});
	entry.default = _default;
	return entry;
}

var hasRequiredVisitors;

function requireVisitors () {
	if (hasRequiredVisitors) return visitors;
	hasRequiredVisitors = 1;
	visitors.__esModule = true;
	visitors.usage = visitors.entry = void 0;
	var _usage = _interopRequireDefault(requireUsage());
	visitors.usage = _usage.default;
	var _entry = _interopRequireDefault(requireEntry());
	visitors.entry = _entry.default;
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	return visitors;
}

var dependencies = {};

var lodash_debounce;
var hasRequiredLodash_debounce;

function requireLodash_debounce () {
	if (hasRequiredLodash_debounce) return lodash_debounce;
	hasRequiredLodash_debounce = 1;
	var FUNC_ERROR_TEXT = "Expected a function";
	var NAN = 0 / 0;
	var symbolTag = "[object Symbol]";
	var reTrim = /^\s+|\s+$/g;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	var root = freeGlobal || freeSelf || Function("return this")();
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	var nativeMax = Math.max, nativeMin = Math.min;
	var now = function() {
	  return root.Date.now();
	};
	function debounce(func, wait, options) {
	  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
	  if (typeof func != "function") {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = "maxWait" in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = "trailing" in options ? !!options.trailing : trailing;
	  }
	  function invokeFunc(time) {
	    var args = lastArgs, thisArg = lastThis;
	    lastArgs = lastThis = void 0;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	  function leadingEdge(time) {
	    lastInvokeTime = time;
	    timerId = setTimeout(timerExpired, wait);
	    return leading ? invokeFunc(time) : result;
	  }
	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
	    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
	  }
	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
	    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	  }
	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }
	  function trailingEdge(time) {
	    timerId = void 0;
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = void 0;
	    return result;
	  }
	  function cancel() {
	    if (timerId !== void 0) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = void 0;
	  }
	  function flush() {
	    return timerId === void 0 ? result : trailingEdge(now());
	  }
	  function debounced() {
	    var time = now(), isInvoking = shouldInvoke(time);
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;
	    if (isInvoking) {
	      if (timerId === void 0) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === void 0) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
	  return !!value && typeof value == "object";
	}
	function isSymbol(value) {
	  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
	}
	function toNumber(value) {
	  if (typeof value == "number") {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
	    value = isObject(other) ? other + "" : other;
	  }
	  if (typeof value != "string") {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, "");
	  var isBinary = reIsBinary.test(value);
	  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	lodash_debounce = debounce;
	return lodash_debounce;
}

var homedir;
var hasRequiredHomedir;

function requireHomedir () {
	if (hasRequiredHomedir) return homedir;
	hasRequiredHomedir = 1;
	var os = require$$0$d;
	homedir = os.homedir || function homedir() {
	  var home = process.env.HOME;
	  var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
	  if (process.platform === "win32") {
	    return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
	  }
	  if (process.platform === "darwin") {
	    return home || (user ? "/Users/" + user : null);
	  }
	  if (process.platform === "linux") {
	    return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
	  }
	  return home || null;
	};
	return homedir;
}

var caller;
var hasRequiredCaller;

function requireCaller () {
	if (hasRequiredCaller) return caller;
	hasRequiredCaller = 1;
	caller = function() {
	  var origPrepareStackTrace = Error.prepareStackTrace;
	  Error.prepareStackTrace = function(_, stack2) {
	    return stack2;
	  };
	  var stack = new Error().stack;
	  Error.prepareStackTrace = origPrepareStackTrace;
	  return stack[2].getFileName();
	};
	return caller;
}

var pathParse = {exports: {}};

var hasRequiredPathParse;

function requirePathParse () {
	if (hasRequiredPathParse) return pathParse.exports;
	hasRequiredPathParse = 1;
	var isWindows = process.platform === "win32";
	var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
	var win32 = {};
	function win32SplitPath(filename) {
	  return splitWindowsRe.exec(filename).slice(1);
	}
	win32.parse = function(pathString) {
	  if (typeof pathString !== "string") {
	    throw new TypeError(
	      "Parameter 'pathString' must be a string, not " + typeof pathString
	    );
	  }
	  var allParts = win32SplitPath(pathString);
	  if (!allParts || allParts.length !== 5) {
	    throw new TypeError("Invalid path '" + pathString + "'");
	  }
	  return {
	    root: allParts[1],
	    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
	    base: allParts[2],
	    ext: allParts[4],
	    name: allParts[3]
	  };
	};
	var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
	var posix = {};
	function posixSplitPath(filename) {
	  return splitPathRe.exec(filename).slice(1);
	}
	posix.parse = function(pathString) {
	  if (typeof pathString !== "string") {
	    throw new TypeError(
	      "Parameter 'pathString' must be a string, not " + typeof pathString
	    );
	  }
	  var allParts = posixSplitPath(pathString);
	  if (!allParts || allParts.length !== 5) {
	    throw new TypeError("Invalid path '" + pathString + "'");
	  }
	  return {
	    root: allParts[1],
	    dir: allParts[0].slice(0, -1),
	    base: allParts[2],
	    ext: allParts[4],
	    name: allParts[3]
	  };
	};
	if (isWindows)
	  pathParse.exports = win32.parse;
	else
	  pathParse.exports = posix.parse;
	pathParse.exports.posix = posix.parse;
	pathParse.exports.win32 = win32.parse;
	return pathParse.exports;
}

var nodeModulesPaths;
var hasRequiredNodeModulesPaths;

function requireNodeModulesPaths () {
	if (hasRequiredNodeModulesPaths) return nodeModulesPaths;
	hasRequiredNodeModulesPaths = 1;
	var path = require$$0$9;
	var parse = path.parse || requirePathParse();
	var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
	  var prefix = "/";
	  if (/^([A-Za-z]:)/.test(absoluteStart)) {
	    prefix = "";
	  } else if (/^\\\\/.test(absoluteStart)) {
	    prefix = "\\\\";
	  }
	  var paths = [absoluteStart];
	  var parsed = parse(absoluteStart);
	  while (parsed.dir !== paths[paths.length - 1]) {
	    paths.push(parsed.dir);
	    parsed = parse(parsed.dir);
	  }
	  return paths.reduce(function(dirs, aPath) {
	    return dirs.concat(modules.map(function(moduleDir) {
	      return path.resolve(prefix, aPath, moduleDir);
	    }));
	  }, []);
	};
	nodeModulesPaths = function nodeModulesPaths(start, opts, request) {
	  var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
	  if (opts && typeof opts.paths === "function") {
	    return opts.paths(
	      request,
	      start,
	      function() {
	        return getNodeModulesDirs(start, modules);
	      },
	      opts
	    );
	  }
	  var dirs = getNodeModulesDirs(start, modules);
	  return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
	};
	return nodeModulesPaths;
}

var normalizeOptions;
var hasRequiredNormalizeOptions$1;

function requireNormalizeOptions$1 () {
	if (hasRequiredNormalizeOptions$1) return normalizeOptions;
	hasRequiredNormalizeOptions$1 = 1;
	normalizeOptions = function(x, opts) {
	  return opts || {};
	};
	return normalizeOptions;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty2(a, b) {
	  var arr = [];
	  for (var i = 0; i < a.length; i += 1) {
	    arr[i] = a[i];
	  }
	  for (var j = 0; j < b.length; j += 1) {
	    arr[j + a.length] = b[j];
	  }
	  return arr;
	};
	var slicy = function slicy2(arrLike, offset) {
	  var arr = [];
	  for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	    arr[j] = arrLike[i];
	  }
	  return arr;
	};
	var joiny = function(arr, joiner) {
	  var str = "";
	  for (var i = 0; i < arr.length; i += 1) {
	    str += arr[i];
	    if (i + 1 < arr.length) {
	      str += joiner;
	    }
	  }
	  return str;
	};
	implementation = function bind(that) {
	  var target = this;
	  if (typeof target !== "function" || toStr.apply(target) !== funcType) {
	    throw new TypeError(ERROR_MESSAGE + target);
	  }
	  var args = slicy(arguments, 1);
	  var bound;
	  var binder = function() {
	    if (this instanceof bound) {
	      var result = target.apply(
	        this,
	        concatty(args, arguments)
	      );
	      if (Object(result) === result) {
	        return result;
	      }
	      return this;
	    }
	    return target.apply(
	      that,
	      concatty(args, arguments)
	    );
	  };
	  var boundLength = max(0, target.length - args.length);
	  var boundArgs = [];
	  for (var i = 0; i < boundLength; i++) {
	    boundArgs[i] = "$" + i;
	  }
	  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
	  if (target.prototype) {
	    var Empty = function Empty2() {
	    };
	    Empty.prototype = target.prototype;
	    bound.prototype = new Empty();
	    Empty.prototype = null;
	  }
	  return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;
	var implementation = requireImplementation();
	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var assert$1 = true;
var async_hooks$1 = ">= 8";
var buffer_ieee754$1 = ">= 0.5 && < 0.9.7";
var buffer$1 = true;
var child_process$1 = true;
var cluster$1 = ">= 0.5";
var console$2 = true;
var constants$1 = true;
var crypto$1 = true;
var _debug_agent$1 = ">= 1 && < 8";
var _debugger$1 = "< 8";
var dgram$1 = true;
var diagnostics_channel$1 = [
	">= 14.17 && < 15",
	">= 15.1"
];
var dns$1 = true;
var domain$1 = ">= 0.7.12";
var events$1 = true;
var freelist$1 = "< 6";
var fs$1 = true;
var _http_agent$1 = ">= 0.11.1";
var _http_client$1 = ">= 0.11.1";
var _http_common$1 = ">= 0.11.1";
var _http_incoming$1 = ">= 0.11.1";
var _http_outgoing$1 = ">= 0.11.1";
var _http_server$1 = ">= 0.11.1";
var http$1 = true;
var http2$1 = ">= 8.8";
var https$1 = true;
var inspector$1 = ">= 8";
var _linklist$1 = "< 8";
var module$2 = true;
var net$1 = true;
var os$1 = true;
var path$1 = true;
var perf_hooks$1 = ">= 8.5";
var process$2 = ">= 1";
var punycode$1 = ">= 0.5";
var querystring$1 = true;
var readline$1 = true;
var repl$1 = true;
var smalloc$1 = ">= 0.11.5 && < 3";
var _stream_duplex$1 = ">= 0.9.4";
var _stream_transform$1 = ">= 0.9.4";
var _stream_wrap$1 = ">= 1.4.1";
var _stream_passthrough$1 = ">= 0.9.4";
var _stream_readable$1 = ">= 0.9.4";
var _stream_writable$1 = ">= 0.9.4";
var stream$1 = true;
var string_decoder$1 = true;
var sys$1 = [
	">= 0.4 && < 0.7",
	">= 0.8"
];
var timers$1 = true;
var _tls_common$1 = ">= 0.11.13";
var _tls_legacy$1 = ">= 0.11.3 && < 10";
var _tls_wrap$1 = ">= 0.11.3";
var tls$1 = true;
var trace_events$1 = ">= 10";
var tty$1 = true;
var url$1 = true;
var util$1 = true;
var v8$1 = ">= 1";
var vm$1 = true;
var wasi$1 = [
	">= 13.4 && < 13.5",
	">= 18.17 && < 19",
	">= 20"
];
var worker_threads$1 = ">= 11.7";
var zlib$1 = ">= 0.5";
var require$$1$2 = {
	assert: assert$1,
	"node:assert": [
	">= 14.18 && < 15",
	">= 16"
],
	"assert/strict": ">= 15",
	"node:assert/strict": ">= 16",
	async_hooks: async_hooks$1,
	"node:async_hooks": [
	">= 14.18 && < 15",
	">= 16"
],
	buffer_ieee754: buffer_ieee754$1,
	buffer: buffer$1,
	"node:buffer": [
	">= 14.18 && < 15",
	">= 16"
],
	child_process: child_process$1,
	"node:child_process": [
	">= 14.18 && < 15",
	">= 16"
],
	cluster: cluster$1,
	"node:cluster": [
	">= 14.18 && < 15",
	">= 16"
],
	console: console$2,
	"node:console": [
	">= 14.18 && < 15",
	">= 16"
],
	constants: constants$1,
	"node:constants": [
	">= 14.18 && < 15",
	">= 16"
],
	crypto: crypto$1,
	"node:crypto": [
	">= 14.18 && < 15",
	">= 16"
],
	_debug_agent: _debug_agent$1,
	_debugger: _debugger$1,
	dgram: dgram$1,
	"node:dgram": [
	">= 14.18 && < 15",
	">= 16"
],
	diagnostics_channel: diagnostics_channel$1,
	"node:diagnostics_channel": [
	">= 14.18 && < 15",
	">= 16"
],
	dns: dns$1,
	"node:dns": [
	">= 14.18 && < 15",
	">= 16"
],
	"dns/promises": ">= 15",
	"node:dns/promises": ">= 16",
	domain: domain$1,
	"node:domain": [
	">= 14.18 && < 15",
	">= 16"
],
	events: events$1,
	"node:events": [
	">= 14.18 && < 15",
	">= 16"
],
	freelist: freelist$1,
	fs: fs$1,
	"node:fs": [
	">= 14.18 && < 15",
	">= 16"
],
	"fs/promises": [
	">= 10 && < 10.1",
	">= 14"
],
	"node:fs/promises": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_agent: _http_agent$1,
	"node:_http_agent": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_client: _http_client$1,
	"node:_http_client": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_common: _http_common$1,
	"node:_http_common": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_incoming: _http_incoming$1,
	"node:_http_incoming": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_outgoing: _http_outgoing$1,
	"node:_http_outgoing": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_server: _http_server$1,
	"node:_http_server": [
	">= 14.18 && < 15",
	">= 16"
],
	http: http$1,
	"node:http": [
	">= 14.18 && < 15",
	">= 16"
],
	http2: http2$1,
	"node:http2": [
	">= 14.18 && < 15",
	">= 16"
],
	https: https$1,
	"node:https": [
	">= 14.18 && < 15",
	">= 16"
],
	inspector: inspector$1,
	"node:inspector": [
	">= 14.18 && < 15",
	">= 16"
],
	"inspector/promises": [
	">= 19"
],
	"node:inspector/promises": [
	">= 19"
],
	_linklist: _linklist$1,
	module: module$2,
	"node:module": [
	">= 14.18 && < 15",
	">= 16"
],
	net: net$1,
	"node:net": [
	">= 14.18 && < 15",
	">= 16"
],
	"node-inspect/lib/_inspect": ">= 7.6 && < 12",
	"node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
	"node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
	os: os$1,
	"node:os": [
	">= 14.18 && < 15",
	">= 16"
],
	path: path$1,
	"node:path": [
	">= 14.18 && < 15",
	">= 16"
],
	"path/posix": ">= 15.3",
	"node:path/posix": ">= 16",
	"path/win32": ">= 15.3",
	"node:path/win32": ">= 16",
	perf_hooks: perf_hooks$1,
	"node:perf_hooks": [
	">= 14.18 && < 15",
	">= 16"
],
	process: process$2,
	"node:process": [
	">= 14.18 && < 15",
	">= 16"
],
	punycode: punycode$1,
	"node:punycode": [
	">= 14.18 && < 15",
	">= 16"
],
	querystring: querystring$1,
	"node:querystring": [
	">= 14.18 && < 15",
	">= 16"
],
	readline: readline$1,
	"node:readline": [
	">= 14.18 && < 15",
	">= 16"
],
	"readline/promises": ">= 17",
	"node:readline/promises": ">= 17",
	repl: repl$1,
	"node:repl": [
	">= 14.18 && < 15",
	">= 16"
],
	"node:sea": [
	">= 20.12 && < 21",
	">= 21.7"
],
	smalloc: smalloc$1,
	"node:sqlite": [
	">= 22.13 && < 23",
	">= 23.4"
],
	_stream_duplex: _stream_duplex$1,
	"node:_stream_duplex": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_transform: _stream_transform$1,
	"node:_stream_transform": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_wrap: _stream_wrap$1,
	"node:_stream_wrap": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_passthrough: _stream_passthrough$1,
	"node:_stream_passthrough": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_readable: _stream_readable$1,
	"node:_stream_readable": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_writable: _stream_writable$1,
	"node:_stream_writable": [
	">= 14.18 && < 15",
	">= 16"
],
	stream: stream$1,
	"node:stream": [
	">= 14.18 && < 15",
	">= 16"
],
	"stream/consumers": ">= 16.7",
	"node:stream/consumers": ">= 16.7",
	"stream/promises": ">= 15",
	"node:stream/promises": ">= 16",
	"stream/web": ">= 16.5",
	"node:stream/web": ">= 16.5",
	string_decoder: string_decoder$1,
	"node:string_decoder": [
	">= 14.18 && < 15",
	">= 16"
],
	sys: sys$1,
	"node:sys": [
	">= 14.18 && < 15",
	">= 16"
],
	"test/reporters": ">= 19.9 && < 20.2",
	"node:test/reporters": [
	">= 18.17 && < 19",
	">= 19.9",
	">= 20"
],
	"test/mock_loader": ">= 22.3 && < 22.7",
	"node:test/mock_loader": ">= 22.3 && < 22.7",
	"node:test": [
	">= 16.17 && < 17",
	">= 18"
],
	timers: timers$1,
	"node:timers": [
	">= 14.18 && < 15",
	">= 16"
],
	"timers/promises": ">= 15",
	"node:timers/promises": ">= 16",
	_tls_common: _tls_common$1,
	"node:_tls_common": [
	">= 14.18 && < 15",
	">= 16"
],
	_tls_legacy: _tls_legacy$1,
	_tls_wrap: _tls_wrap$1,
	"node:_tls_wrap": [
	">= 14.18 && < 15",
	">= 16"
],
	tls: tls$1,
	"node:tls": [
	">= 14.18 && < 15",
	">= 16"
],
	trace_events: trace_events$1,
	"node:trace_events": [
	">= 14.18 && < 15",
	">= 16"
],
	tty: tty$1,
	"node:tty": [
	">= 14.18 && < 15",
	">= 16"
],
	url: url$1,
	"node:url": [
	">= 14.18 && < 15",
	">= 16"
],
	util: util$1,
	"node:util": [
	">= 14.18 && < 15",
	">= 16"
],
	"util/types": ">= 15.3",
	"node:util/types": ">= 16",
	"v8/tools/arguments": ">= 10 && < 12",
	"v8/tools/codemap": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/consarray": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/csvparser": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/logreader": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/profile_view": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/splaytree": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	v8: v8$1,
	"node:v8": [
	">= 14.18 && < 15",
	">= 16"
],
	vm: vm$1,
	"node:vm": [
	">= 14.18 && < 15",
	">= 16"
],
	wasi: wasi$1,
	"node:wasi": [
	">= 18.17 && < 19",
	">= 20"
],
	worker_threads: worker_threads$1,
	"node:worker_threads": [
	">= 14.18 && < 15",
	">= 16"
],
	zlib: zlib$1,
	"node:zlib": [
	">= 14.18 && < 15",
	">= 16"
]
};

var isCoreModule;
var hasRequiredIsCoreModule;

function requireIsCoreModule () {
	if (hasRequiredIsCoreModule) return isCoreModule;
	hasRequiredIsCoreModule = 1;
	var hasOwn = /*@__PURE__*/ requireHasown();
	function specifierIncluded(current, specifier) {
	  var nodeParts = current.split(".");
	  var parts = specifier.split(" ");
	  var op = parts.length > 1 ? parts[0] : "=";
	  var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
	  for (var i = 0; i < 3; ++i) {
	    var cur = parseInt(nodeParts[i] || 0, 10);
	    var ver = parseInt(versionParts[i] || 0, 10);
	    if (cur === ver) {
	      continue;
	    }
	    if (op === "<") {
	      return cur < ver;
	    }
	    if (op === ">=") {
	      return cur >= ver;
	    }
	    return false;
	  }
	  return op === ">=";
	}
	function matchesRange(current, range) {
	  var specifiers = range.split(/ ?&& ?/);
	  if (specifiers.length === 0) {
	    return false;
	  }
	  for (var i = 0; i < specifiers.length; ++i) {
	    if (!specifierIncluded(current, specifiers[i])) {
	      return false;
	    }
	  }
	  return true;
	}
	function versionIncluded(nodeVersion, specifierValue) {
	  if (typeof specifierValue === "boolean") {
	    return specifierValue;
	  }
	  var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
	  if (typeof current !== "string") {
	    throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
	  }
	  if (specifierValue && typeof specifierValue === "object") {
	    for (var i = 0; i < specifierValue.length; ++i) {
	      if (matchesRange(current, specifierValue[i])) {
	        return true;
	      }
	    }
	    return false;
	  }
	  return matchesRange(current, specifierValue);
	}
	var data = require$$1$2;
	isCoreModule = function isCore(x, nodeVersion) {
	  return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
	};
	return isCoreModule;
}

var async;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	var fs = require$$2$1;
	var getHomedir = requireHomedir();
	var path = require$$0$9;
	var caller = requireCaller();
	var nodeModulesPaths = requireNodeModulesPaths();
	var normalizeOptions = requireNormalizeOptions$1();
	var isCore = /*@__PURE__*/ requireIsCoreModule();
	var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
	var homedir = getHomedir();
	var defaultPaths = function() {
	  return [
	    path.join(homedir, ".node_modules"),
	    path.join(homedir, ".node_libraries")
	  ];
	};
	var defaultIsFile = function isFile(file, cb) {
	  fs.stat(file, function(err, stat) {
	    if (!err) {
	      return cb(null, stat.isFile() || stat.isFIFO());
	    }
	    if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
	    return cb(err);
	  });
	};
	var defaultIsDir = function isDirectory(dir, cb) {
	  fs.stat(dir, function(err, stat) {
	    if (!err) {
	      return cb(null, stat.isDirectory());
	    }
	    if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
	    return cb(err);
	  });
	};
	var defaultRealpath = function realpath(x, cb) {
	  realpathFS(x, function(realpathErr, realPath) {
	    if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
	    else cb(null, realpathErr ? x : realPath);
	  });
	};
	var maybeRealpath = function maybeRealpath2(realpath2, x, opts, cb) {
	  if (opts && opts.preserveSymlinks === false) {
	    realpath2(x, cb);
	  } else {
	    cb(null, x);
	  }
	};
	var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
	  readFile(pkgfile, function(readFileErr, body) {
	    if (readFileErr) cb(readFileErr);
	    else {
	      try {
	        var pkg = JSON.parse(body);
	        cb(null, pkg);
	      } catch (jsonErr) {
	        cb(null);
	      }
	    }
	  });
	};
	var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
	  var dirs = nodeModulesPaths(start, opts, x);
	  for (var i = 0; i < dirs.length; i++) {
	    dirs[i] = path.join(dirs[i], x);
	  }
	  return dirs;
	};
	async = function resolve(x, options, callback) {
	  var cb = callback;
	  var opts = options;
	  if (typeof options === "function") {
	    cb = opts;
	    opts = {};
	  }
	  if (typeof x !== "string") {
	    var err = new TypeError("Path must be a string.");
	    return process.nextTick(function() {
	      cb(err);
	    });
	  }
	  opts = normalizeOptions(x, opts);
	  var isFile2 = opts.isFile || defaultIsFile;
	  var isDirectory2 = opts.isDirectory || defaultIsDir;
	  var readFile = opts.readFile || fs.readFile;
	  var realpath2 = opts.realpath || defaultRealpath;
	  var readPackage = opts.readPackage || defaultReadPackage;
	  if (opts.readFile && opts.readPackage) {
	    var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
	    return process.nextTick(function() {
	      cb(conflictErr);
	    });
	  }
	  var packageIterator = opts.packageIterator;
	  var extensions = opts.extensions || [".js"];
	  var includeCoreModules = opts.includeCoreModules !== false;
	  var basedir = opts.basedir || path.dirname(caller());
	  var parent = opts.filename || basedir;
	  opts.paths = opts.paths || defaultPaths();
	  var absoluteStart = path.resolve(basedir);
	  maybeRealpath(
	    realpath2,
	    absoluteStart,
	    opts,
	    function(err2, realStart) {
	      if (err2) cb(err2);
	      else init(realStart);
	    }
	  );
	  var res;
	  function init(basedir2) {
	    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
	      res = path.resolve(basedir2, x);
	      if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
	      if (/\/$/.test(x) && res === basedir2) {
	        loadAsDirectory(res, opts.package, onfile);
	      } else loadAsFile(res, opts.package, onfile);
	    } else if (includeCoreModules && isCore(x)) {
	      return cb(null, x);
	    } else loadNodeModules(x, basedir2, function(err2, n, pkg) {
	      if (err2) cb(err2);
	      else if (n) {
	        return maybeRealpath(realpath2, n, opts, function(err3, realN) {
	          if (err3) {
	            cb(err3);
	          } else {
	            cb(null, realN, pkg);
	          }
	        });
	      } else {
	        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
	        moduleError.code = "MODULE_NOT_FOUND";
	        cb(moduleError);
	      }
	    });
	  }
	  function onfile(err2, m, pkg) {
	    if (err2) cb(err2);
	    else if (m) cb(null, m, pkg);
	    else loadAsDirectory(res, function(err3, d, pkg2) {
	      if (err3) cb(err3);
	      else if (d) {
	        maybeRealpath(realpath2, d, opts, function(err4, realD) {
	          if (err4) {
	            cb(err4);
	          } else {
	            cb(null, realD, pkg2);
	          }
	        });
	      } else {
	        var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
	        moduleError.code = "MODULE_NOT_FOUND";
	        cb(moduleError);
	      }
	    });
	  }
	  function loadAsFile(x2, thePackage, callback2) {
	    var loadAsFilePackage = thePackage;
	    var cb2 = callback2;
	    if (typeof loadAsFilePackage === "function") {
	      cb2 = loadAsFilePackage;
	      loadAsFilePackage = void 0;
	    }
	    var exts = [""].concat(extensions);
	    load(exts, x2, loadAsFilePackage);
	    function load(exts2, x3, loadPackage) {
	      if (exts2.length === 0) return cb2(null, void 0, loadPackage);
	      var file = x3 + exts2[0];
	      var pkg = loadPackage;
	      if (pkg) onpkg(null, pkg);
	      else loadpkg(path.dirname(file), onpkg);
	      function onpkg(err2, pkg_, dir) {
	        pkg = pkg_;
	        if (err2) return cb2(err2);
	        if (dir && pkg && opts.pathFilter) {
	          var rfile = path.relative(dir, file);
	          var rel = rfile.slice(0, rfile.length - exts2[0].length);
	          var r = opts.pathFilter(pkg, x3, rel);
	          if (r) return load(
	            [""].concat(extensions.slice()),
	            path.resolve(dir, r),
	            pkg
	          );
	        }
	        isFile2(file, onex);
	      }
	      function onex(err2, ex) {
	        if (err2) return cb2(err2);
	        if (ex) return cb2(null, file, pkg);
	        load(exts2.slice(1), x3, pkg);
	      }
	    }
	  }
	  function loadpkg(dir, cb2) {
	    if (dir === "" || dir === "/") return cb2(null);
	    if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
	      return cb2(null);
	    }
	    if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb2(null);
	    maybeRealpath(realpath2, dir, opts, function(unwrapErr, pkgdir) {
	      if (unwrapErr) return loadpkg(path.dirname(dir), cb2);
	      var pkgfile = path.join(pkgdir, "package.json");
	      isFile2(pkgfile, function(err2, ex) {
	        if (!ex) return loadpkg(path.dirname(dir), cb2);
	        readPackage(readFile, pkgfile, function(err3, pkgParam) {
	          if (err3) cb2(err3);
	          var pkg = pkgParam;
	          if (pkg && opts.packageFilter) {
	            pkg = opts.packageFilter(pkg, pkgfile);
	          }
	          cb2(null, pkg, dir);
	        });
	      });
	    });
	  }
	  function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
	    var cb2 = callback2;
	    var fpkg = loadAsDirectoryPackage;
	    if (typeof fpkg === "function") {
	      cb2 = fpkg;
	      fpkg = opts.package;
	    }
	    maybeRealpath(realpath2, x2, opts, function(unwrapErr, pkgdir) {
	      if (unwrapErr) return cb2(unwrapErr);
	      var pkgfile = path.join(pkgdir, "package.json");
	      isFile2(pkgfile, function(err2, ex) {
	        if (err2) return cb2(err2);
	        if (!ex) return loadAsFile(path.join(x2, "index"), fpkg, cb2);
	        readPackage(readFile, pkgfile, function(err3, pkgParam) {
	          if (err3) return cb2(err3);
	          var pkg = pkgParam;
	          if (pkg && opts.packageFilter) {
	            pkg = opts.packageFilter(pkg, pkgfile);
	          }
	          if (pkg && pkg.main) {
	            if (typeof pkg.main !== "string") {
	              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
	              mainError.code = "INVALID_PACKAGE_MAIN";
	              return cb2(mainError);
	            }
	            if (pkg.main === "." || pkg.main === "./") {
	              pkg.main = "index";
	            }
	            loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
	              if (err4) return cb2(err4);
	              if (m) return cb2(null, m, pkg2);
	              if (!pkg2) return loadAsFile(path.join(x2, "index"), pkg2, cb2);
	              var dir = path.resolve(x2, pkg2.main);
	              loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
	                if (err5) return cb2(err5);
	                if (n) return cb2(null, n, pkg3);
	                loadAsFile(path.join(x2, "index"), pkg3, cb2);
	              });
	            });
	            return;
	          }
	          loadAsFile(path.join(x2, "/index"), pkg, cb2);
	        });
	      });
	    });
	  }
	  function processDirs(cb2, dirs) {
	    if (dirs.length === 0) return cb2(null, void 0);
	    var dir = dirs[0];
	    isDirectory2(path.dirname(dir), isdir);
	    function isdir(err2, isdir2) {
	      if (err2) return cb2(err2);
	      if (!isdir2) return processDirs(cb2, dirs.slice(1));
	      loadAsFile(dir, opts.package, onfile2);
	    }
	    function onfile2(err2, m, pkg) {
	      if (err2) return cb2(err2);
	      if (m) return cb2(null, m, pkg);
	      loadAsDirectory(dir, opts.package, ondir);
	    }
	    function ondir(err2, n, pkg) {
	      if (err2) return cb2(err2);
	      if (n) return cb2(null, n, pkg);
	      processDirs(cb2, dirs.slice(1));
	    }
	  }
	  function loadNodeModules(x2, start, cb2) {
	    var thunk = function() {
	      return getPackageCandidates(x2, start, opts);
	    };
	    processDirs(
	      cb2,
	      packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
	    );
	  }
	};
	return async;
}

var assert = true;
var async_hooks = ">= 8";
var buffer_ieee754 = ">= 0.5 && < 0.9.7";
var buffer = true;
var child_process = true;
var cluster = ">= 0.5";
var console$1 = true;
var constants = true;
var crypto = true;
var _debug_agent = ">= 1 && < 8";
var _debugger = "< 8";
var dgram = true;
var diagnostics_channel = [
	">= 14.17 && < 15",
	">= 15.1"
];
var dns = true;
var domain = ">= 0.7.12";
var events = true;
var freelist = "< 6";
var fs = true;
var _http_agent = ">= 0.11.1";
var _http_client = ">= 0.11.1";
var _http_common = ">= 0.11.1";
var _http_incoming = ">= 0.11.1";
var _http_outgoing = ">= 0.11.1";
var _http_server = ">= 0.11.1";
var http = true;
var http2 = ">= 8.8";
var https = true;
var inspector = ">= 8";
var _linklist = "< 8";
var module$1 = true;
var net = true;
var os = true;
var path = true;
var perf_hooks = ">= 8.5";
var process$1 = ">= 1";
var punycode = ">= 0.5";
var querystring = true;
var readline = true;
var repl = true;
var smalloc = ">= 0.11.5 && < 3";
var _stream_duplex = ">= 0.9.4";
var _stream_transform = ">= 0.9.4";
var _stream_wrap = ">= 1.4.1";
var _stream_passthrough = ">= 0.9.4";
var _stream_readable = ">= 0.9.4";
var _stream_writable = ">= 0.9.4";
var stream = true;
var string_decoder = true;
var sys = [
	">= 0.4 && < 0.7",
	">= 0.8"
];
var timers = true;
var _tls_common = ">= 0.11.13";
var _tls_legacy = ">= 0.11.3 && < 10";
var _tls_wrap = ">= 0.11.3";
var tls = true;
var trace_events = ">= 10";
var tty = true;
var url = true;
var util = true;
var v8 = ">= 1";
var vm = true;
var wasi = [
	">= 13.4 && < 13.5",
	">= 18.17 && < 19",
	">= 20"
];
var worker_threads = ">= 11.7";
var zlib = ">= 0.5";
var require$$1$1 = {
	assert: assert,
	"node:assert": [
	">= 14.18 && < 15",
	">= 16"
],
	"assert/strict": ">= 15",
	"node:assert/strict": ">= 16",
	async_hooks: async_hooks,
	"node:async_hooks": [
	">= 14.18 && < 15",
	">= 16"
],
	buffer_ieee754: buffer_ieee754,
	buffer: buffer,
	"node:buffer": [
	">= 14.18 && < 15",
	">= 16"
],
	child_process: child_process,
	"node:child_process": [
	">= 14.18 && < 15",
	">= 16"
],
	cluster: cluster,
	"node:cluster": [
	">= 14.18 && < 15",
	">= 16"
],
	console: console$1,
	"node:console": [
	">= 14.18 && < 15",
	">= 16"
],
	constants: constants,
	"node:constants": [
	">= 14.18 && < 15",
	">= 16"
],
	crypto: crypto,
	"node:crypto": [
	">= 14.18 && < 15",
	">= 16"
],
	_debug_agent: _debug_agent,
	_debugger: _debugger,
	dgram: dgram,
	"node:dgram": [
	">= 14.18 && < 15",
	">= 16"
],
	diagnostics_channel: diagnostics_channel,
	"node:diagnostics_channel": [
	">= 14.18 && < 15",
	">= 16"
],
	dns: dns,
	"node:dns": [
	">= 14.18 && < 15",
	">= 16"
],
	"dns/promises": ">= 15",
	"node:dns/promises": ">= 16",
	domain: domain,
	"node:domain": [
	">= 14.18 && < 15",
	">= 16"
],
	events: events,
	"node:events": [
	">= 14.18 && < 15",
	">= 16"
],
	freelist: freelist,
	fs: fs,
	"node:fs": [
	">= 14.18 && < 15",
	">= 16"
],
	"fs/promises": [
	">= 10 && < 10.1",
	">= 14"
],
	"node:fs/promises": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_agent: _http_agent,
	"node:_http_agent": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_client: _http_client,
	"node:_http_client": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_common: _http_common,
	"node:_http_common": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_incoming: _http_incoming,
	"node:_http_incoming": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_outgoing: _http_outgoing,
	"node:_http_outgoing": [
	">= 14.18 && < 15",
	">= 16"
],
	_http_server: _http_server,
	"node:_http_server": [
	">= 14.18 && < 15",
	">= 16"
],
	http: http,
	"node:http": [
	">= 14.18 && < 15",
	">= 16"
],
	http2: http2,
	"node:http2": [
	">= 14.18 && < 15",
	">= 16"
],
	https: https,
	"node:https": [
	">= 14.18 && < 15",
	">= 16"
],
	inspector: inspector,
	"node:inspector": [
	">= 14.18 && < 15",
	">= 16"
],
	"inspector/promises": [
	">= 19"
],
	"node:inspector/promises": [
	">= 19"
],
	_linklist: _linklist,
	module: module$1,
	"node:module": [
	">= 14.18 && < 15",
	">= 16"
],
	net: net,
	"node:net": [
	">= 14.18 && < 15",
	">= 16"
],
	"node-inspect/lib/_inspect": ">= 7.6 && < 12",
	"node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
	"node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
	os: os,
	"node:os": [
	">= 14.18 && < 15",
	">= 16"
],
	path: path,
	"node:path": [
	">= 14.18 && < 15",
	">= 16"
],
	"path/posix": ">= 15.3",
	"node:path/posix": ">= 16",
	"path/win32": ">= 15.3",
	"node:path/win32": ">= 16",
	perf_hooks: perf_hooks,
	"node:perf_hooks": [
	">= 14.18 && < 15",
	">= 16"
],
	process: process$1,
	"node:process": [
	">= 14.18 && < 15",
	">= 16"
],
	punycode: punycode,
	"node:punycode": [
	">= 14.18 && < 15",
	">= 16"
],
	querystring: querystring,
	"node:querystring": [
	">= 14.18 && < 15",
	">= 16"
],
	readline: readline,
	"node:readline": [
	">= 14.18 && < 15",
	">= 16"
],
	"readline/promises": ">= 17",
	"node:readline/promises": ">= 17",
	repl: repl,
	"node:repl": [
	">= 14.18 && < 15",
	">= 16"
],
	"node:sea": [
	">= 20.12 && < 21",
	">= 21.7"
],
	smalloc: smalloc,
	"node:sqlite": ">= 23.4",
	_stream_duplex: _stream_duplex,
	"node:_stream_duplex": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_transform: _stream_transform,
	"node:_stream_transform": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_wrap: _stream_wrap,
	"node:_stream_wrap": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_passthrough: _stream_passthrough,
	"node:_stream_passthrough": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_readable: _stream_readable,
	"node:_stream_readable": [
	">= 14.18 && < 15",
	">= 16"
],
	_stream_writable: _stream_writable,
	"node:_stream_writable": [
	">= 14.18 && < 15",
	">= 16"
],
	stream: stream,
	"node:stream": [
	">= 14.18 && < 15",
	">= 16"
],
	"stream/consumers": ">= 16.7",
	"node:stream/consumers": ">= 16.7",
	"stream/promises": ">= 15",
	"node:stream/promises": ">= 16",
	"stream/web": ">= 16.5",
	"node:stream/web": ">= 16.5",
	string_decoder: string_decoder,
	"node:string_decoder": [
	">= 14.18 && < 15",
	">= 16"
],
	sys: sys,
	"node:sys": [
	">= 14.18 && < 15",
	">= 16"
],
	"test/reporters": ">= 19.9 && < 20.2",
	"node:test/reporters": [
	">= 18.17 && < 19",
	">= 19.9",
	">= 20"
],
	"test/mock_loader": ">= 22.3 && < 22.7",
	"node:test/mock_loader": ">= 22.3 && < 22.7",
	"node:test": [
	">= 16.17 && < 17",
	">= 18"
],
	timers: timers,
	"node:timers": [
	">= 14.18 && < 15",
	">= 16"
],
	"timers/promises": ">= 15",
	"node:timers/promises": ">= 16",
	_tls_common: _tls_common,
	"node:_tls_common": [
	">= 14.18 && < 15",
	">= 16"
],
	_tls_legacy: _tls_legacy,
	_tls_wrap: _tls_wrap,
	"node:_tls_wrap": [
	">= 14.18 && < 15",
	">= 16"
],
	tls: tls,
	"node:tls": [
	">= 14.18 && < 15",
	">= 16"
],
	trace_events: trace_events,
	"node:trace_events": [
	">= 14.18 && < 15",
	">= 16"
],
	tty: tty,
	"node:tty": [
	">= 14.18 && < 15",
	">= 16"
],
	url: url,
	"node:url": [
	">= 14.18 && < 15",
	">= 16"
],
	util: util,
	"node:util": [
	">= 14.18 && < 15",
	">= 16"
],
	"util/types": ">= 15.3",
	"node:util/types": ">= 16",
	"v8/tools/arguments": ">= 10 && < 12",
	"v8/tools/codemap": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/consarray": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/csvparser": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/logreader": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/profile_view": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	"v8/tools/splaytree": [
	">= 4.4 && < 5",
	">= 5.2 && < 12"
],
	v8: v8,
	"node:v8": [
	">= 14.18 && < 15",
	">= 16"
],
	vm: vm,
	"node:vm": [
	">= 14.18 && < 15",
	">= 16"
],
	wasi: wasi,
	"node:wasi": [
	">= 18.17 && < 19",
	">= 20"
],
	worker_threads: worker_threads,
	"node:worker_threads": [
	">= 14.18 && < 15",
	">= 16"
],
	zlib: zlib,
	"node:zlib": [
	">= 14.18 && < 15",
	">= 16"
]
};

var core_1;
var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core_1;
	hasRequiredCore = 1;
	var isCoreModule = /*@__PURE__*/ requireIsCoreModule();
	var data = require$$1$1;
	var core = {};
	for (var mod in data) {
	  if (Object.prototype.hasOwnProperty.call(data, mod)) {
	    core[mod] = isCoreModule(mod);
	  }
	}
	core_1 = core;
	return core_1;
}

var isCore;
var hasRequiredIsCore;

function requireIsCore () {
	if (hasRequiredIsCore) return isCore;
	hasRequiredIsCore = 1;
	var isCoreModule = /*@__PURE__*/ requireIsCoreModule();
	isCore = function isCore(x) {
	  return isCoreModule(x);
	};
	return isCore;
}

var sync;
var hasRequiredSync;

function requireSync () {
	if (hasRequiredSync) return sync;
	hasRequiredSync = 1;
	var isCore = /*@__PURE__*/ requireIsCoreModule();
	var fs = require$$2$1;
	var path = require$$0$9;
	var getHomedir = requireHomedir();
	var caller = requireCaller();
	var nodeModulesPaths = requireNodeModulesPaths();
	var normalizeOptions = requireNormalizeOptions$1();
	var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
	var homedir = getHomedir();
	var defaultPaths = function() {
	  return [
	    path.join(homedir, ".node_modules"),
	    path.join(homedir, ".node_libraries")
	  ];
	};
	var defaultIsFile = function isFile(file) {
	  try {
	    var stat = fs.statSync(file, { throwIfNoEntry: false });
	  } catch (e) {
	    if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
	    throw e;
	  }
	  return !!stat && (stat.isFile() || stat.isFIFO());
	};
	var defaultIsDir = function isDirectory(dir) {
	  try {
	    var stat = fs.statSync(dir, { throwIfNoEntry: false });
	  } catch (e) {
	    if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
	    throw e;
	  }
	  return !!stat && stat.isDirectory();
	};
	var defaultRealpathSync = function realpathSync(x) {
	  try {
	    return realpathFS(x);
	  } catch (realpathErr) {
	    if (realpathErr.code !== "ENOENT") {
	      throw realpathErr;
	    }
	  }
	  return x;
	};
	var maybeRealpathSync = function maybeRealpathSync2(realpathSync2, x, opts) {
	  if (opts && opts.preserveSymlinks === false) {
	    return realpathSync2(x);
	  }
	  return x;
	};
	var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
	  var body = readFileSync(pkgfile);
	  try {
	    var pkg = JSON.parse(body);
	    return pkg;
	  } catch (jsonErr) {
	  }
	};
	var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
	  var dirs = nodeModulesPaths(start, opts, x);
	  for (var i = 0; i < dirs.length; i++) {
	    dirs[i] = path.join(dirs[i], x);
	  }
	  return dirs;
	};
	sync = function resolveSync(x, options) {
	  if (typeof x !== "string") {
	    throw new TypeError("Path must be a string.");
	  }
	  var opts = normalizeOptions(x, options);
	  var isFile2 = opts.isFile || defaultIsFile;
	  var readFileSync = opts.readFileSync || fs.readFileSync;
	  var isDirectory2 = opts.isDirectory || defaultIsDir;
	  var realpathSync2 = opts.realpathSync || defaultRealpathSync;
	  var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
	  if (opts.readFileSync && opts.readPackageSync) {
	    throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
	  }
	  var packageIterator = opts.packageIterator;
	  var extensions = opts.extensions || [".js"];
	  var includeCoreModules = opts.includeCoreModules !== false;
	  var basedir = opts.basedir || path.dirname(caller());
	  var parent = opts.filename || basedir;
	  opts.paths = opts.paths || defaultPaths();
	  var absoluteStart = maybeRealpathSync(realpathSync2, path.resolve(basedir), opts);
	  if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
	    var res = path.resolve(absoluteStart, x);
	    if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
	    var m = loadAsFileSync(res) || loadAsDirectorySync(res);
	    if (m) return maybeRealpathSync(realpathSync2, m, opts);
	  } else if (includeCoreModules && isCore(x)) {
	    return x;
	  } else {
	    var n = loadNodeModulesSync(x, absoluteStart);
	    if (n) return maybeRealpathSync(realpathSync2, n, opts);
	  }
	  var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
	  err.code = "MODULE_NOT_FOUND";
	  throw err;
	  function loadAsFileSync(x2) {
	    var pkg = loadpkg(path.dirname(x2));
	    if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
	      var rfile = path.relative(pkg.dir, x2);
	      var r = opts.pathFilter(pkg.pkg, x2, rfile);
	      if (r) {
	        x2 = path.resolve(pkg.dir, r);
	      }
	    }
	    if (isFile2(x2)) {
	      return x2;
	    }
	    for (var i = 0; i < extensions.length; i++) {
	      var file = x2 + extensions[i];
	      if (isFile2(file)) {
	        return file;
	      }
	    }
	  }
	  function loadpkg(dir) {
	    if (dir === "" || dir === "/") return;
	    if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
	      return;
	    }
	    if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
	    var pkgfile = path.join(maybeRealpathSync(realpathSync2, dir, opts), "package.json");
	    if (!isFile2(pkgfile)) {
	      return loadpkg(path.dirname(dir));
	    }
	    var pkg = readPackageSync(readFileSync, pkgfile);
	    if (pkg && opts.packageFilter) {
	      pkg = opts.packageFilter(
	        pkg,
	        /*pkgfile,*/
	        dir
	      );
	    }
	    return { pkg, dir };
	  }
	  function loadAsDirectorySync(x2) {
	    var pkgfile = path.join(maybeRealpathSync(realpathSync2, x2, opts), "/package.json");
	    if (isFile2(pkgfile)) {
	      try {
	        var pkg = readPackageSync(readFileSync, pkgfile);
	      } catch (e) {
	      }
	      if (pkg && opts.packageFilter) {
	        pkg = opts.packageFilter(
	          pkg,
	          /*pkgfile,*/
	          x2
	        );
	      }
	      if (pkg && pkg.main) {
	        if (typeof pkg.main !== "string") {
	          var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
	          mainError.code = "INVALID_PACKAGE_MAIN";
	          throw mainError;
	        }
	        if (pkg.main === "." || pkg.main === "./") {
	          pkg.main = "index";
	        }
	        try {
	          var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
	          if (m2) return m2;
	          var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
	          if (n2) return n2;
	        } catch (e) {
	        }
	      }
	    }
	    return loadAsFileSync(path.join(x2, "/index"));
	  }
	  function loadNodeModulesSync(x2, start) {
	    var thunk = function() {
	      return getPackageCandidates(x2, start, opts);
	    };
	    var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
	    for (var i = 0; i < dirs.length; i++) {
	      var dir = dirs[i];
	      if (isDirectory2(path.dirname(dir))) {
	        var m2 = loadAsFileSync(dir);
	        if (m2) return m2;
	        var n2 = loadAsDirectorySync(dir);
	        if (n2) return n2;
	      }
	    }
	  }
	};
	return sync;
}

var resolve;
var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	var async = requireAsync();
	async.core = requireCore();
	async.isCore = requireIsCore();
	async.sync = requireSync();
	resolve = async;
	return resolve;
}

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	dependencies.__esModule = true;
	dependencies.has = has;
	dependencies.laterLogMissing = laterLogMissing;
	dependencies.logMissing = logMissing;
	dependencies.resolve = resolve;
	var _path = _interopRequireDefault(require$$0$9);
	var _lodash = _interopRequireDefault(requireLodash_debounce());
	var _resolve = _interopRequireDefault(requireResolve());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	const nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;
	function myResolve(name, basedir) {
	  if (nativeRequireResolve) {
	    return require.resolve(name, {
	      paths: [basedir]
	    }).replace(/\\/g, "/");
	  } else {
	    return _resolve.default.sync(name, {
	      basedir
	    }).replace(/\\/g, "/");
	  }
	}
	function resolve(dirname, moduleName, absoluteImports) {
	  if (absoluteImports === false) return moduleName;
	  let basedir = dirname;
	  if (typeof absoluteImports === "string") {
	    basedir = _path.default.resolve(basedir, absoluteImports);
	  }
	  try {
	    return myResolve(moduleName, basedir);
	  } catch (err) {
	    if (err.code !== "MODULE_NOT_FOUND") throw err;
	    throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
	      code: "BABEL_POLYFILL_NOT_FOUND",
	      polyfill: moduleName,
	      dirname
	    });
	  }
	}
	function has(basedir, name) {
	  try {
	    myResolve(name, basedir);
	    return true;
	  } catch (_unused) {
	    return false;
	  }
	}
	function logMissing(missingDeps) {
	  if (missingDeps.size === 0) return;
	  const deps = Array.from(missingDeps).sort().join(" ");
	  console.warn(`
Some polyfills have been added but are not present in your dependencies.
Please run one of the following commands:
	npm install --save ${deps}
	yarn add ${deps}
`);
	  process.exitCode = 1;
	}
	let allMissingDeps = /* @__PURE__ */ new Set();
	const laterLogMissingDependencies = (0, _lodash.default)(() => {
	  logMissing(allMissingDeps);
	  allMissingDeps = /* @__PURE__ */ new Set();
	}, 100);
	function laterLogMissing(missingDeps) {
	  if (missingDeps.size === 0) return;
	  missingDeps.forEach((name) => allMissingDeps.add(name));
	  laterLogMissingDependencies();
	}
	return dependencies;
}

var metaResolver = {};

var hasRequiredMetaResolver;

function requireMetaResolver () {
	if (hasRequiredMetaResolver) return metaResolver;
	hasRequiredMetaResolver = 1;
	metaResolver.__esModule = true;
	metaResolver.default = createMetaResolver;
	var _utils = requireUtils$2();
	const PossibleGlobalObjects = /* @__PURE__ */ new Set(["global", "globalThis", "self", "window"]);
	function createMetaResolver(polyfills) {
	  const {
	    static: staticP,
	    instance: instanceP,
	    global: globalP
	  } = polyfills;
	  return (meta) => {
	    if (meta.kind === "global" && globalP && (0, _utils.has)(globalP, meta.name)) {
	      return {
	        kind: "global",
	        desc: globalP[meta.name],
	        name: meta.name
	      };
	    }
	    if (meta.kind === "property" || meta.kind === "in") {
	      const {
	        placement,
	        object,
	        key
	      } = meta;
	      if (object && placement === "static") {
	        if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) {
	          return {
	            kind: "global",
	            desc: globalP[key],
	            name: key
	          };
	        }
	        if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) {
	          return {
	            kind: "static",
	            desc: staticP[object][key],
	            name: `${object}$${key}`
	          };
	        }
	      }
	      if (instanceP && (0, _utils.has)(instanceP, key)) {
	        return {
	          kind: "instance",
	          desc: instanceP[key],
	          name: `${key}`
	        };
	      }
	    }
	  };
	}
	return metaResolver;
}

var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$3;
	hasRequiredLib$5 = 1;
	lib$3.__esModule = true;
	lib$3.default = definePolyfillProvider;
	var _helperPluginUtils = requireLib$1f();
	var _helperCompilationTargets = _interopRequireWildcard(requireLib$1g());
	var _utils = requireUtils$2();
	var _importsInjector = _interopRequireDefault(requireImportsInjector());
	var _debugUtils = requireDebugUtils();
	var _normalizeOptions = requireNormalizeOptions$2();
	var v = _interopRequireWildcard(requireVisitors());
	var deps = _interopRequireWildcard(requireDependencies());
	var _metaResolver = _interopRequireDefault(requireMetaResolver());
	const _excluded = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	const getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;
	function resolveOptions(options, babelApi) {
	  const {
	    method,
	    targets: targetsOption,
	    ignoreBrowserslistConfig,
	    configPath,
	    debug,
	    shouldInjectPolyfill,
	    absoluteImports
	  } = options, providerOptions = _objectWithoutPropertiesLoose(options, _excluded);
	  if (isEmpty(options)) {
	    throw new Error(`This plugin requires options, for example:
    {
      "plugins": [
        ["<plugin name>", { method: "usage-pure" }]
      ]
    }

See more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);
	  }
	  let methodName;
	  if (method === "usage-global") methodName = "usageGlobal";
	  else if (method === "entry-global") methodName = "entryGlobal";
	  else if (method === "usage-pure") methodName = "usagePure";
	  else if (typeof method !== "string") {
	    throw new Error(".method must be a string");
	  } else {
	    throw new Error(`.method must be one of "entry-global", "usage-global" or "usage-pure" (received ${JSON.stringify(method)})`);
	  }
	  if (typeof shouldInjectPolyfill === "function") {
	    if (options.include || options.exclude) {
	      throw new Error(`.include and .exclude are not supported when using the .shouldInjectPolyfill function.`);
	    }
	  } else if (shouldInjectPolyfill != null) {
	    throw new Error(`.shouldInjectPolyfill must be a function, or undefined (received ${JSON.stringify(shouldInjectPolyfill)})`);
	  }
	  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
	    throw new Error(`.absoluteImports must be a boolean, a string, or undefined (received ${JSON.stringify(absoluteImports)})`);
	  }
	  let targets;
	  if (
	    // If any browserslist-related option is specified, fallback to the old
	    // behavior of not using the targets specified in the top-level options.
	    targetsOption || configPath || ignoreBrowserslistConfig
	  ) {
	    const targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
	      browsers: targetsOption
	    } : targetsOption;
	    targets = getTargets(targetsObj, {
	      ignoreBrowserslistConfig,
	      configPath
	    });
	  } else {
	    targets = babelApi.targets();
	  }
	  return {
	    method,
	    methodName,
	    targets,
	    absoluteImports: absoluteImports != null ? absoluteImports : false,
	    shouldInjectPolyfill,
	    debug: !!debug,
	    providerOptions
	  };
	}
	function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
	  const {
	    method,
	    methodName,
	    targets,
	    debug,
	    shouldInjectPolyfill,
	    providerOptions,
	    absoluteImports
	  } = resolveOptions(options, babelApi);
	  let include, exclude;
	  let polyfillsSupport;
	  let polyfillsNames;
	  let filterPolyfills;
	  const getUtils = (0, _utils.createUtilsGetter)(new _importsInjector.default((moduleName) => deps.resolve(dirname, moduleName, absoluteImports), (name) => {
	    var _polyfillsNames$get, _polyfillsNames;
	    return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;
	  }));
	  const depsCache = /* @__PURE__ */ new Map();
	  const api = {
	    babel: babelApi,
	    getUtils,
	    method: options.method,
	    targets,
	    createMetaResolver: _metaResolver.default,
	    shouldInjectPolyfill(name) {
	      if (polyfillsNames === void 0) {
	        throw new Error(`Internal error in the ${factory.name} provider: shouldInjectPolyfill() can't be called during initialization.`);
	      }
	      if (!polyfillsNames.has(name)) {
	        console.warn(`Internal error in the ${providerName} provider: unknown polyfill "${name}".`);
	      }
	      if (filterPolyfills && !filterPolyfills(name)) return false;
	      let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
	        compatData: polyfillsSupport,
	        includes: include,
	        excludes: exclude
	      });
	      if (shouldInjectPolyfill) {
	        shouldInject = shouldInjectPolyfill(name, shouldInject);
	        if (typeof shouldInject !== "boolean") {
	          throw new Error(`.shouldInjectPolyfill must return a boolean.`);
	        }
	      }
	      return shouldInject;
	    },
	    debug(name) {
	      var _debugLog, _debugLog$polyfillsSu;
	      debugLog().found = true;
	      if (!debug || !name) return;
	      if (debugLog().polyfills.has(providerName)) return;
	      debugLog().polyfills.add(name);
	      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;
	    },
	    assertDependency(name, version = "*") {
	      if (missingDependencies === false) return;
	      if (absoluteImports) {
	        return;
	      }
	      const dep = version === "*" ? name : `${name}@^${version}`;
	      const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, () => deps.has(dirname, name));
	      if (!found) {
	        debugLog().missingDeps.add(dep);
	      }
	    }
	  };
	  const provider = factory(api, providerOptions, dirname);
	  const providerName = provider.name || factory.name;
	  if (typeof provider[methodName] !== "function") {
	    throw new Error(`The "${providerName}" provider doesn't support the "${method}" polyfilling method.`);
	  }
	  if (Array.isArray(provider.polyfills)) {
	    polyfillsNames = new Map(provider.polyfills.map((name, index) => [name, index]));
	    filterPolyfills = provider.filterPolyfills;
	  } else if (provider.polyfills) {
	    polyfillsNames = new Map(Object.keys(provider.polyfills).map((name, index) => [name, index]));
	    polyfillsSupport = provider.polyfills;
	    filterPolyfills = provider.filterPolyfills;
	  } else {
	    polyfillsNames = /* @__PURE__ */ new Map();
	  }
	  ({
	    include,
	    exclude
	  } = (0, _normalizeOptions.validateIncludeExclude)(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));
	  let callProvider;
	  if (methodName === "usageGlobal") {
	    callProvider = (payload, path) => {
	      var _ref;
	      const utils = getUtils(path);
	      return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;
	    };
	  } else {
	    callProvider = (payload, path) => {
	      const utils = getUtils(path);
	      provider[methodName](payload, utils, path);
	      return false;
	    };
	  }
	  return {
	    debug,
	    method,
	    targets,
	    provider,
	    providerName,
	    callProvider
	  };
	}
	function definePolyfillProvider(factory) {
	  return (0, _helperPluginUtils.declare)((babelApi, options, dirname) => {
	    babelApi.assertVersion("^7.0.0 || ^8.0.0-alpha.0");
	    const {
	      traverse
	    } = babelApi;
	    let debugLog;
	    const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);
	    const {
	      debug,
	      method,
	      targets,
	      provider,
	      providerName,
	      callProvider
	    } = instantiateProvider(factory, options, missingDependencies, dirname, () => debugLog, babelApi);
	    const createVisitor = method === "entry-global" ? v.entry : v.usage;
	    const visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);
	    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {
	      console.log(`${providerName}: \`DEBUG\` option`);
	      console.log(`
Using targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`);
	      console.log(`
Using polyfills with \`${method}\` method:`);
	    }
	    const {
	      runtimeName
	    } = provider;
	    return {
	      name: "inject-polyfills",
	      visitor,
	      pre(file) {
	        var _provider$pre;
	        if (runtimeName) {
	          if (file.get("runtimeHelpersModuleName") && file.get("runtimeHelpersModuleName") !== runtimeName) {
	            console.warn(`Two different polyfill providers (${file.get("runtimeHelpersModuleProvider")} and ${providerName}) are trying to define two conflicting @babel/runtime alternatives: ${file.get("runtimeHelpersModuleName")} and ${runtimeName}. The second one will be ignored.`);
	          } else {
	            file.set("runtimeHelpersModuleName", runtimeName);
	            file.set("runtimeHelpersModuleProvider", providerName);
	          }
	        }
	        debugLog = {
	          polyfills: /* @__PURE__ */ new Set(),
	          polyfillsSupport: void 0,
	          found: false,
	          providers: /* @__PURE__ */ new Set(),
	          missingDeps: /* @__PURE__ */ new Set()
	        };
	        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
	      },
	      post() {
	        var _provider$post;
	        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);
	        if (missingDependencies !== false) {
	          if (missingDependencies.log === "per-file") {
	            deps.logMissing(debugLog.missingDeps);
	          } else {
	            deps.laterLogMissing(debugLog.missingDeps);
	          }
	        }
	        if (!debug) return;
	        if (this.filename) console.log(`
[${this.filename}]`);
	        if (debugLog.polyfills.size === 0) {
	          console.log(method === "entry-global" ? debugLog.found ? `Based on your targets, the ${providerName} polyfill did not add any polyfill.` : `The entry point for the ${providerName} polyfill has not been found.` : `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`);
	          return;
	        }
	        if (method === "entry-global") {
	          console.log(`The ${providerName} polyfill entry has been replaced with the following polyfills:`);
	        } else {
	          console.log(`The ${providerName} polyfill added the following polyfills:`);
	        }
	        for (const name of debugLog.polyfills) {
	          var _debugLog$polyfillsSu2;
	          if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {
	            const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);
	            const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
	            console.log(`  ${name} ${formattedTargets}`);
	          } else {
	            console.log(`  ${name}`);
	          }
	        }
	      }
	    };
	  });
	}
	function mapGetOr(map, key, getDefault) {
	  let val = map.get(key);
	  if (val === void 0) {
	    val = getDefault();
	    map.set(key, val);
	  }
	  return val;
	}
	function isEmpty(obj) {
	  return Object.keys(obj).length === 0;
	}
	return lib$3;
}

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$4;
	hasRequiredLib$4 = 1;
	lib$4.__esModule = true;
	lib$4.default = void 0;
	var _corejs2BuiltIns = _interopRequireDefault(requireCorejs2BuiltIns());
	var _builtInDefinitions = requireBuiltInDefinitions$1();
	var _addPlatformSpecificPolyfills = _interopRequireDefault(requireAddPlatformSpecificPolyfills());
	var _helpers = requireHelpers$2();
	var _helperDefinePolyfillProvider = _interopRequireDefault(requireLib$5());
	var _babel = _interopRequireWildcard(require$$0$b);
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	const {
	  types: t
	} = _babel.default || _babel;
	const BABEL_RUNTIME = "@babel/runtime-corejs2";
	const presetEnvCompat = "#__secret_key__@babel/preset-env__compatibility";
	const runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
	const has = Function.call.bind(Object.hasOwnProperty);
	var _default = (0, _helperDefinePolyfillProvider.default)(function(api, {
	  [presetEnvCompat]: {
	    entryInjectRegenerator = false,
	    noRuntimeName = false
	  } = {},
	  [runtimeCompat]: {
	    useBabelRuntime = false,
	    runtimeVersion = "",
	    ext = ".js"
	  } = {}
	}) {
	  const resolve = api.createMetaResolver({
	    global: _builtInDefinitions.BuiltIns,
	    static: _builtInDefinitions.StaticProperties,
	    instance: _builtInDefinitions.InstanceProperties
	  });
	  const {
	    debug,
	    shouldInjectPolyfill,
	    method
	  } = api;
	  const polyfills = (0, _addPlatformSpecificPolyfills.default)(api.targets, method, _corejs2BuiltIns.default);
	  const coreJSBase = useBabelRuntime ? `${BABEL_RUNTIME}/core-js` : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";
	  function inject(name, utils) {
	    if (typeof name === "string") {
	      if (has(polyfills, name) && shouldInjectPolyfill(name)) {
	        debug(name);
	        utils.injectGlobalImport(`${coreJSBase}/${name}.js`);
	      }
	      return;
	    }
	    name.forEach((name2) => inject(name2, utils));
	  }
	  function maybeInjectPure(desc, hint, utils) {
	    let {
	      pure,
	      meta,
	      name
	    } = desc;
	    if (!pure || !shouldInjectPolyfill(name)) return;
	    if (runtimeVersion && meta && meta.minRuntimeVersion && !(0, _helpers.hasMinVersion)(meta && meta.minRuntimeVersion, runtimeVersion)) {
	      return;
	    }
	    if (useBabelRuntime && pure === "symbol/index") pure = "symbol";
	    return utils.injectDefaultImport(`${coreJSBase}/${pure}${ext}`, hint);
	  }
	  return {
	    name: "corejs2",
	    runtimeName: noRuntimeName ? null : BABEL_RUNTIME,
	    polyfills,
	    entryGlobal(meta, utils, path) {
	      if (meta.kind === "import" && meta.source === "core-js") {
	        debug(null);
	        inject(Object.keys(polyfills), utils);
	        if (entryInjectRegenerator) {
	          utils.injectGlobalImport("regenerator-runtime/runtime.js");
	        }
	        path.remove();
	      }
	    },
	    usageGlobal(meta, utils) {
	      const resolved = resolve(meta);
	      if (!resolved) return;
	      let deps = resolved.desc.global;
	      if (resolved.kind !== "global" && "object" in meta && meta.object && meta.placement === "prototype") {
	        const low = meta.object.toLowerCase();
	        deps = deps.filter((m) => m.includes(low));
	      }
	      inject(deps, utils);
	    },
	    usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t.callExpression(
	            utils.injectDefaultImport(`${coreJSBase}/is-iterable${ext}`, "isIterable"),
	            [path.node.right]
	            // meta.kind === "in" narrows this
	          ));
	        }
	        return;
	      }
	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;
	      if (meta.kind === "property") {
	        if (!path.isMemberExpression()) return;
	        if (!path.isReferenced()) return;
	        if (meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
	          callee: path.node
	        }) && path.parentPath.node.arguments.length === 0) {
	          path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport(`${coreJSBase}/get-iterator${ext}`, "getIterator"), [path.node.object]));
	          path.skip();
	          return;
	        }
	      }
	      const resolved = resolve(meta);
	      if (!resolved) return;
	      const id = maybeInjectPure(resolved.desc, resolved.name, utils);
	      if (id) path.replaceWith(id);
	    },
	    visitor: method === "usage-global" && {
	      // yield*
	      YieldExpression(path) {
	        if (path.node.delegate) {
	          inject("web.dom.iterable", api.getUtils(path));
	        }
	      },
	      // for-of, [a, b] = c
	      "ForOfStatement|ArrayPattern"(path) {
	        _builtInDefinitions.CommonIterators.forEach((name) => inject(name, api.getUtils(path)));
	      }
	    }
	  };
	});
	lib$4.default = _default;
	return lib$4;
}

var lib$2 = {};

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$2;
	hasRequiredLib$3 = 1;
	lib$2.__esModule = true;
	lib$2.default = void 0;
	var _helperDefinePolyfillProvider = _interopRequireDefault(requireLib$5());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	const runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
	var _default = (0, _helperDefinePolyfillProvider.default)(({
	  debug,
	  targets,
	  babel
	}, options) => {
	  if (!shallowEqual(targets, babel.targets())) {
	    throw new Error("This plugin does not use the targets option. Only preset-env's targets or top-level targets need to be configured for this plugin to work. See https://github.com/babel/babel-polyfills/issues/36 for more details.");
	  }
	  const {
	    [runtimeCompat]: {
	      moduleName = null,
	      useBabelRuntime = false
	    } = {}
	  } = options;
	  return {
	    name: "regenerator",
	    polyfills: ["regenerator-runtime"],
	    usageGlobal(meta, utils) {
	      if (isRegenerator(meta)) {
	        debug("regenerator-runtime");
	        utils.injectGlobalImport("regenerator-runtime/runtime.js");
	      }
	    },
	    usagePure(meta, utils, path) {
	      if (isRegenerator(meta)) {
	        let pureName = "regenerator-runtime";
	        if (useBabelRuntime) {
	          var _ref;
	          const runtimeName = (_ref = moduleName != null ? moduleName : path.hub.file.get("runtimeHelpersModuleName")) != null ? _ref : "@babel/runtime";
	          pureName = `${runtimeName}/regenerator`;
	        }
	        path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
	      }
	    }
	  };
	});
	lib$2.default = _default;
	const isRegenerator = (meta) => meta.kind === "global" && meta.name === "regeneratorRuntime";
	function shallowEqual(obj1, obj2) {
	  return JSON.stringify(obj1) === JSON.stringify(obj2);
	}
	return lib$2;
}

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	utils$1.getImportSource = function({
	  node
	}) {
	  if (node.specifiers.length === 0) return node.source.value;
	};
	utils$1.getRequireSource = function({
	  node
	}) {
	  if (node.type !== "ExpressionStatement") return;
	  const {
	    expression
	  } = node;
	  if (expression.type === "CallExpression" && expression.callee.type === "Identifier" && expression.callee.name === "require" && expression.arguments.length === 1 && expression.arguments[0].type === "StringLiteral") {
	    return expression.arguments[0].value;
	  }
	};
	utils$1.isPolyfillSource = function(source) {
	  return source === "@babel/polyfill" || source === "core-js";
	};
	return utils$1;
}

var babelPolyfill;
var hasRequiredBabelPolyfill;

function requireBabelPolyfill () {
	if (hasRequiredBabelPolyfill) return babelPolyfill;
	hasRequiredBabelPolyfill = 1;
	const {
	  getImportSource,
	  getRequireSource,
	  isPolyfillSource
	} = requireUtils$1();
	const BABEL_POLYFILL_DEPRECATION = `
  \`@babel/polyfill\` is deprecated. Please, use required parts of \`core-js\`
  and \`regenerator-runtime/runtime\` separately`;
	const NO_DIRECT_POLYFILL_IMPORT = `
  When setting \`useBuiltIns: 'usage'\`, polyfills are automatically imported when needed.
  Please remove the direct import of \`SPECIFIER\` or use \`useBuiltIns: 'entry'\` instead.`;
	babelPolyfill = function({
	  template
	}, {
	  regenerator,
	  deprecated,
	  usage
	}) {
	  return {
	    name: "preset-env/replace-babel-polyfill",
	    visitor: {
	      ImportDeclaration(path) {
	        const src = getImportSource(path);
	        if (usage && isPolyfillSource(src)) {
	          console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
	          if (!deprecated) path.remove();
	        } else if (src === "@babel/polyfill") {
	          if (deprecated) {
	            console.warn(BABEL_POLYFILL_DEPRECATION);
	          } else if (regenerator) {
	            path.replaceWithMultiple(template.ast`
              import "core-js";
              import "regenerator-runtime/runtime.js";
            `);
	          } else {
	            path.replaceWith(template.ast`
              import "core-js";
            `);
	          }
	        }
	      },
	      Program(path) {
	        path.get("body").forEach((bodyPath) => {
	          const src = getRequireSource(bodyPath);
	          if (usage && isPolyfillSource(src)) {
	            console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
	            if (!deprecated) bodyPath.remove();
	          } else if (src === "@babel/polyfill") {
	            if (deprecated) {
	              console.warn(BABEL_POLYFILL_DEPRECATION);
	            } else if (regenerator) {
	              bodyPath.replaceWithMultiple(template.ast`
                require("core-js");
                require("regenerator-runtime/runtime.js");
              `);
	            } else {
	              bodyPath.replaceWith(template.ast`
                require("core-js");
              `);
	            }
	          }
	        });
	      }
	    }
	  };
	};
	return babelPolyfill;
}

var regenerator;
var hasRequiredRegenerator;

function requireRegenerator () {
	if (hasRequiredRegenerator) return regenerator;
	hasRequiredRegenerator = 1;
	const {
	  getImportSource,
	  getRequireSource
	} = requireUtils$1();
	function isRegeneratorSource(source) {
	  return source === "regenerator-runtime/runtime" || source === "regenerator-runtime/runtime.js";
	}
	regenerator = function() {
	  const visitor = {
	    ImportDeclaration(path) {
	      if (isRegeneratorSource(getImportSource(path))) {
	        this.regeneratorImportExcluded = true;
	        path.remove();
	      }
	    },
	    Program(path) {
	      path.get("body").forEach((bodyPath) => {
	        if (isRegeneratorSource(getRequireSource(bodyPath))) {
	          this.regeneratorImportExcluded = true;
	          bodyPath.remove();
	        }
	      });
	    }
	  };
	  return {
	    name: "preset-env/remove-regenerator",
	    visitor,
	    pre() {
	      this.regeneratorImportExcluded = false;
	    },
	    post() {
	      if (this.opts.debug && this.regeneratorImportExcluded) {
	        let filename = this.file.opts.filename;
	        if (process.env.BABEL_ENV === "test") {
	          filename = filename.replace(/\\/g, "/");
	        }
	        console.log(`
[${filename}] Based on your targets, regenerator-runtime import excluded.`);
	      }
	    }
	  };
	};
	return regenerator;
}

var hasRequiredBabel7Plugins;

function requireBabel7Plugins () {
	if (hasRequiredBabel7Plugins) return babel7Plugins;
	hasRequiredBabel7Plugins = 1;
	(function (exports) {
		{
		  Object.defineProperties(exports, {
		    pluginCoreJS2: {
		      get: () => requireLib$4().default
		    },
		    pluginRegenerator: {
		      get: () => requireLib$3().default
		    },
		    legacyBabelPolyfillPlugin: {
		      get: () => requireBabelPolyfill()
		    },
		    removeRegeneratorEntryPlugin: {
		      get: () => requireRegenerator()
		    },
		    corejs2Polyfills: {
		      get: () => requireCorejs2BuiltIns()
		    }
		  });
		} 
	} (babel7Plugins));
	return babel7Plugins;
}

var require$$0$1 = {
	"es.symbol": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.description": {
	android: "70",
	bun: "0.1.1",
	chrome: "70",
	"chrome-android": "70",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "63",
	"firefox-android": "63",
	ios: "12.2",
	node: "11.0",
	oculus: "6.0",
	opera: "57",
	"opera-android": "49",
	opera_mobile: "49",
	quest: "6.0",
	rhino: "1.8.0",
	safari: "12.1",
	samsung: "10.0"
},
	"es.symbol.async-iterator": {
	android: "63",
	bun: "0.1.1",
	chrome: "63",
	"chrome-android": "63",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "55",
	"firefox-android": "55",
	ios: "12.0",
	node: "10.0",
	oculus: "5.0",
	opera: "50",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	safari: "12.0",
	samsung: "8.0"
},
	"es.symbol.has-instance": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "15",
	electron: "1.1",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.is-concat-spreadable": {
	android: "48",
	bun: "0.1.1",
	chrome: "48",
	"chrome-android": "48",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "35",
	"opera-android": "35",
	opera_mobile: "35",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.iterator": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "36",
	"firefox-android": "36",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.symbol.match": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "79",
	electron: "1.1",
	firefox: "40",
	"firefox-android": "40",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.match-all": {
	android: "73",
	bun: "0.1.1",
	chrome: "73",
	"chrome-android": "73",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "67",
	"firefox-android": "67",
	hermes: "0.6",
	ios: "13.0",
	node: "12.0",
	oculus: "6.0",
	opera: "60",
	"opera-android": "52",
	opera_mobile: "52",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "13",
	samsung: "11.0"
},
	"es.symbol.replace": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "79",
	electron: "1.1",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.search": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "79",
	electron: "1.1",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.species": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "41",
	"firefox-android": "41",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.split": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "79",
	electron: "1.1",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.to-primitive": {
	android: "47",
	bun: "0.1.1",
	chrome: "47",
	"chrome-android": "47",
	deno: "1.0",
	edge: "15",
	electron: "0.36",
	firefox: "44",
	"firefox-android": "44",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "34",
	"opera-android": "34",
	opera_mobile: "34",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.to-string-tag": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.symbol.unscopables": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "48",
	"firefox-android": "48",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.error.cause": {
	android: "94",
	bun: "0.1.1",
	chrome: "94",
	"chrome-android": "94",
	deno: "1.14",
	edge: "94",
	electron: "15.0",
	firefox: "91",
	"firefox-android": "91",
	hermes: "0.8",
	ios: "15.0",
	node: "16.11",
	oculus: "18.0",
	opera: "80",
	"opera-android": "66",
	opera_mobile: "66",
	quest: "18.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.0",
	samsung: "17.0"
},
	"es.error.to-string": {
	android: "4.4.3",
	bun: "0.1.1",
	chrome: "33",
	"chrome-android": "33",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "11",
	"firefox-android": "11",
	hermes: "0.1",
	ie: "9",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "20",
	"opera-android": "20",
	opera_mobile: "20",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "8.0",
	samsung: "2.0"
},
	"es.aggregate-error": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.2",
	edge: "85",
	electron: "10.0",
	firefox: "79",
	"firefox-android": "79",
	hermes: "0.13",
	ios: "14.0",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	"react-native": "0.72",
	rhino: "1.8.0",
	safari: "14.0",
	samsung: "14.0"
},
	"es.aggregate-error.cause": {
	android: "94",
	bun: "0.1.1",
	chrome: "94",
	"chrome-android": "94",
	deno: "1.14",
	edge: "94",
	electron: "15.0",
	firefox: "91",
	"firefox-android": "91",
	hermes: "0.13",
	ios: "15.0",
	node: "16.11",
	oculus: "18.0",
	opera: "80",
	"opera-android": "66",
	opera_mobile: "66",
	quest: "18.0",
	"react-native": "0.72",
	rhino: "1.8.0",
	safari: "15.0",
	samsung: "17.0"
},
	"es.array.at": {
	android: "92",
	bun: "0.1.1",
	chrome: "92",
	"chrome-android": "92",
	deno: "1.12",
	edge: "92",
	electron: "14.0",
	firefox: "90",
	"firefox-android": "90",
	hermes: "0.13",
	ios: "15.4",
	node: "16.6",
	oculus: "17.0",
	opera: "78",
	"opera-android": "65",
	opera_mobile: "65",
	quest: "17.0",
	"react-native": "0.71",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "16.0"
},
	"es.array.concat": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "48",
	"firefox-android": "48",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.copy-within": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "12",
	electron: "0.31",
	firefox: "48",
	"firefox-android": "48",
	ios: "9.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	rhino: "1.8.0",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.every": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.array.fill": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "12",
	electron: "0.31",
	firefox: "48",
	"firefox-android": "48",
	ios: "9.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	rhino: "1.8.0",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.filter": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "48",
	"firefox-android": "48",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.find": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "48",
	"firefox-android": "48",
	ios: "9.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	rhino: "1.8.0",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.find-index": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "48",
	"firefox-android": "48",
	ios: "9.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	rhino: "1.8.0",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.find-last": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"es.array.find-last-index": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"es.array.flat": {
	android: "69",
	bun: "0.1.1",
	chrome: "69",
	"chrome-android": "69",
	deno: "1.0",
	edge: "79",
	electron: "4.0",
	firefox: "62",
	"firefox-android": "62",
	hermes: "0.4",
	ios: "12.0",
	node: "11.0",
	oculus: "6.0",
	opera: "56",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "12.0",
	samsung: "10.0"
},
	"es.array.flat-map": {
	android: "69",
	bun: "0.1.1",
	chrome: "69",
	"chrome-android": "69",
	deno: "1.0",
	edge: "79",
	electron: "4.0",
	firefox: "62",
	"firefox-android": "62",
	hermes: "0.4",
	ios: "12.0",
	node: "11.0",
	oculus: "6.0",
	opera: "56",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "12.0",
	samsung: "10.0"
},
	"es.array.for-each": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.array.from": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "53",
	"firefox-android": "53",
	hermes: "0.13",
	ios: "9.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.73",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.includes": {
	android: "53",
	bun: "0.1.1",
	chrome: "53",
	"chrome-android": "53",
	deno: "1.0",
	edge: "14",
	electron: "1.4",
	firefox: "102",
	"firefox-android": "102",
	ios: "10.0",
	node: "7.0",
	oculus: "3.0",
	opera: "40",
	"opera-android": "40",
	opera_mobile: "40",
	quest: "3.0",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "6.0"
},
	"es.array.index-of": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "12",
	electron: "1.2",
	firefox: "47",
	"firefox-android": "47",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "5.0"
},
	"es.array.is-array": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "3.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "4.0",
	samsung: "1.0"
},
	"es.array.iterator": {
	android: "66",
	bun: "0.1.1",
	chrome: "66",
	"chrome-android": "66",
	deno: "1.0",
	edge: "15",
	electron: "3.0",
	firefox: "60",
	"firefox-android": "60",
	ios: "10.0",
	node: "10.0",
	oculus: "5.0",
	opera: "53",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "9.0"
},
	"es.array.join": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.array.last-index-of": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "12",
	electron: "1.2",
	firefox: "47",
	"firefox-android": "47",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "5.0"
},
	"es.array.map": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "50",
	"firefox-android": "50",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.of": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "9.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "5.0"
},
	"es.array.push": {
	android: "122",
	bun: "0.1.1",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.41.3",
	edge: "122",
	electron: "29.0",
	firefox: "55",
	"firefox-android": "55",
	hermes: "0.2",
	ios: "16.0",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	"react-native": "0.69",
	safari: "16.0",
	samsung: "26.0"
},
	"es.array.reduce": {
	android: "83",
	bun: "0.1.1",
	chrome: "83",
	"chrome-android": "83",
	deno: "1.0",
	edge: "12",
	electron: "9.0",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "6.0",
	oculus: "10.0",
	opera: "69",
	"opera-android": "59",
	opera_mobile: "59",
	quest: "10.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "13.0"
},
	"es.array.reduce-right": {
	android: "83",
	bun: "0.1.1",
	chrome: "83",
	"chrome-android": "83",
	deno: "1.0",
	edge: "12",
	electron: "9.0",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "6.0",
	oculus: "10.0",
	opera: "69",
	"opera-android": "59",
	opera_mobile: "59",
	quest: "10.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "13.0"
},
	"es.array.reverse": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "5.5",
	ios: "12.2",
	node: "0.0.3",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "12.0.2",
	samsung: "1.0"
},
	"es.array.slice": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "48",
	"firefox-android": "48",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.some": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.array.sort": {
	android: "70",
	bun: "0.1.1",
	chrome: "70",
	"chrome-android": "70",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.10",
	ios: "12.0",
	node: "11.0",
	oculus: "6.0",
	opera: "57",
	"opera-android": "49",
	opera_mobile: "49",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "12.0",
	samsung: "10.0"
},
	"es.array.species": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "48",
	"firefox-android": "48",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.splice": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "49",
	"firefox-android": "49",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.array.to-reversed": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.array.to-sorted": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.array.to-spliced": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.array.unscopables.flat": {
	android: "73",
	bun: "0.1.1",
	chrome: "73",
	"chrome-android": "73",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "67",
	"firefox-android": "67",
	ios: "13.0",
	node: "12.0",
	oculus: "6.0",
	opera: "60",
	"opera-android": "52",
	opera_mobile: "52",
	quest: "6.0",
	rhino: "1.8.0",
	safari: "13",
	samsung: "11.0"
},
	"es.array.unscopables.flat-map": {
	android: "73",
	bun: "0.1.1",
	chrome: "73",
	"chrome-android": "73",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "67",
	"firefox-android": "67",
	ios: "13.0",
	node: "12.0",
	oculus: "6.0",
	opera: "60",
	"opera-android": "52",
	opera_mobile: "52",
	quest: "6.0",
	rhino: "1.8.0",
	safari: "13",
	samsung: "11.0"
},
	"es.array.unshift": {
	android: "71",
	bun: "0.1.1",
	chrome: "71",
	"chrome-android": "71",
	deno: "1.0",
	edge: "12",
	electron: "5.0",
	firefox: "23",
	"firefox-android": "23",
	hermes: "0.1",
	ie: "9",
	ios: "16.0",
	node: "12.0",
	oculus: "6.0",
	opera: "58",
	"opera-android": "50",
	opera_mobile: "50",
	quest: "6.0",
	"react-native": "0.69",
	safari: "16.0",
	samsung: "10.0"
},
	"es.array.with": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.array-buffer.constructor": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "28",
	"chrome-android": "28",
	deno: "1.0",
	edge: "14",
	electron: "0.20",
	firefox: "44",
	"firefox-android": "44",
	hermes: "0.1",
	ios: "12.0",
	node: "0.11.1",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "12.0",
	samsung: "1.5"
},
	"es.array-buffer.is-view": {
	android: "4.4.3",
	bun: "0.1.1",
	chrome: "32",
	"chrome-android": "32",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "29",
	"firefox-android": "29",
	hermes: "0.1",
	ie: "11",
	ios: "8.0",
	node: "0.11.9",
	oculus: "3.0",
	opera: "19",
	"opera-android": "19",
	opera_mobile: "19",
	quest: "3.0",
	"react-native": "0.69",
	safari: "7.1",
	samsung: "2.0"
},
	"es.array-buffer.slice": {
	android: "4.4.3",
	bun: "0.1.1",
	chrome: "31",
	"chrome-android": "31",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "46",
	"firefox-android": "46",
	hermes: "0.1",
	ie: "11",
	ios: "12.2",
	node: "0.11.8",
	oculus: "3.0",
	opera: "18",
	"opera-android": "18",
	opera_mobile: "18",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "12.1",
	samsung: "2.0"
},
	"es.data-view": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "15",
	"firefox-android": "15",
	hermes: "0.1",
	ie: "10",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.data-view.get-float16": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"es.data-view.set-float16": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"es.array-buffer.detached": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"es.array-buffer.transfer": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"es.array-buffer.transfer-to-fixed-length": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"es.date.get-year": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "3",
	"opera-android": "3",
	opera_mobile: "3",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.date.now": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "3.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "4.0",
	samsung: "1.0"
},
	"es.date.set-year": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "3",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "3",
	"opera-android": "3",
	opera_mobile: "3",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.date.to-gmt-string": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "3",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "3",
	"opera-android": "3",
	opera_mobile: "3",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.date.to-iso-string": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "7",
	"firefox-android": "7",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.date.to-json": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "10.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "1.5"
},
	"es.date.to-primitive": {
	android: "47",
	bun: "0.1.1",
	chrome: "47",
	"chrome-android": "47",
	deno: "1.0",
	edge: "15",
	electron: "0.36",
	firefox: "44",
	"firefox-android": "44",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "34",
	"opera-android": "34",
	opera_mobile: "34",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.date.to-string": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.escape": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "3",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "3",
	"opera-android": "3",
	opera_mobile: "3",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.function.bind": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "7",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "5.0",
	node: "0.1.101",
	oculus: "3.0",
	opera: "12",
	"opera-android": "12",
	opera_mobile: "12",
	phantom: "2.0",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "5.1",
	samsung: "1.0"
},
	"es.function.has-instance": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "50",
	"firefox-android": "50",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.function.name": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	hermes: "0.1",
	ios: "3.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "4.0",
	samsung: "1.0"
},
	"es.global-this": {
	android: "71",
	bun: "0.1.1",
	chrome: "71",
	"chrome-android": "71",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "65",
	"firefox-android": "65",
	hermes: "0.2",
	ios: "12.2",
	node: "12.0",
	oculus: "6.0",
	opera: "58",
	"opera-android": "50",
	opera_mobile: "50",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "12.1",
	samsung: "10.0"
},
	"es.iterator.constructor": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"es.iterator.drop": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.every": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.filter": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.find": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.flat-map": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.for-each": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.from": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"es.iterator.map": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.reduce": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.some": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.take": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"es.iterator.to-array": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"es.json.stringify": {
	android: "72",
	bun: "0.1.1",
	chrome: "72",
	"chrome-android": "72",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "64",
	"firefox-android": "64",
	hermes: "0.13",
	ios: "12.2",
	node: "12.0",
	oculus: "6.0",
	opera: "59",
	"opera-android": "51",
	opera_mobile: "51",
	quest: "6.0",
	"react-native": "0.72",
	rhino: "1.8.0",
	safari: "12.1",
	samsung: "11.0"
},
	"es.json.to-string-tag": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "15",
	electron: "1.1",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.map": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "53",
	"firefox-android": "53",
	hermes: "0.13",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.73",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.map.group-by": {
	android: "117",
	bun: "1.1.2",
	chrome: "117",
	"chrome-android": "117",
	deno: "1.37",
	edge: "117",
	electron: "27.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "18.0",
	node: "21.0",
	oculus: "30.0",
	opera: "103",
	"opera-android": "78",
	opera_mobile: "78",
	quest: "30.0",
	rhino: "1.8.0",
	safari: "18.0",
	samsung: "24.0"
},
	"es.math.acosh": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "13",
	electron: "1.4",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	"react-native": "0.69",
	safari: "7.1",
	samsung: "6.0"
},
	"es.math.asinh": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.atanh": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.cbrt": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.clz32": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "31",
	"firefox-android": "31",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.0"
},
	"es.math.cosh": {
	android: "39",
	bun: "0.1.1",
	chrome: "39",
	"chrome-android": "39",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "1.0",
	oculus: "3.0",
	opera: "26",
	"opera-android": "26",
	opera_mobile: "26",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.4"
},
	"es.math.expm1": {
	android: "39",
	bun: "0.1.1",
	chrome: "39",
	"chrome-android": "39",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "46",
	"firefox-android": "46",
	hermes: "0.1",
	ios: "8.0",
	node: "1.0",
	oculus: "3.0",
	opera: "26",
	"opera-android": "26",
	opera_mobile: "26",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.4"
},
	"es.math.fround": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "26",
	"firefox-android": "26",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.f16round": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"es.math.hypot": {
	android: "78",
	bun: "0.1.1",
	chrome: "78",
	"chrome-android": "78",
	deno: "1.0",
	edge: "12",
	electron: "7.0",
	firefox: "27",
	"firefox-android": "27",
	hermes: "0.1",
	ios: "8.0",
	node: "12.16",
	oculus: "8.0",
	opera: "65",
	"opera-android": "56",
	opera_mobile: "56",
	quest: "8.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "12.0"
},
	"es.math.imul": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "28",
	"chrome-android": "28",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "20",
	"firefox-android": "20",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.1",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "1.5"
},
	"es.math.log10": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.log1p": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.log2": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.sign": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.0"
},
	"es.math.sinh": {
	android: "39",
	bun: "0.1.1",
	chrome: "39",
	"chrome-android": "39",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "1.0",
	oculus: "3.0",
	opera: "26",
	"opera-android": "26",
	opera_mobile: "26",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.4"
},
	"es.math.tanh": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.math.to-string-tag": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "15",
	electron: "1.1",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.math.trunc": {
	android: "38",
	bun: "0.1.1",
	chrome: "38",
	"chrome-android": "38",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "25",
	"opera-android": "25",
	opera_mobile: "25",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.number.constructor": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "46",
	"firefox-android": "46",
	hermes: "0.5",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.number.epsilon": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "25",
	"firefox-android": "25",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "9.0",
	samsung: "2.0"
},
	"es.number.is-finite": {
	android: "4.1",
	bun: "0.1.1",
	chrome: "19",
	"chrome-android": "25",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "16",
	"firefox-android": "16",
	hermes: "0.1",
	ios: "9.0",
	node: "0.7.3",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "1.5"
},
	"es.number.is-integer": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "16",
	"firefox-android": "16",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "2.0"
},
	"es.number.is-nan": {
	android: "4.1",
	bun: "0.1.1",
	chrome: "19",
	"chrome-android": "25",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "15",
	"firefox-android": "15",
	hermes: "0.1",
	ios: "9.0",
	node: "0.7.3",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "1.5"
},
	"es.number.is-safe-integer": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "32",
	"firefox-android": "32",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "2.0"
},
	"es.number.max-safe-integer": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "31",
	"firefox-android": "31",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "2.0"
},
	"es.number.min-safe-integer": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "31",
	"firefox-android": "31",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "2.0"
},
	"es.number.parse-float": {
	android: "37",
	bun: "0.1.1",
	chrome: "35",
	"chrome-android": "35",
	deno: "1.0",
	edge: "79",
	electron: "0.20",
	firefox: "39",
	"firefox-android": "39",
	hermes: "0.1",
	ios: "11.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "22",
	"opera-android": "22",
	opera_mobile: "22",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "11.0",
	samsung: "3.0"
},
	"es.number.parse-int": {
	android: "37",
	bun: "0.1.1",
	chrome: "35",
	"chrome-android": "35",
	deno: "1.0",
	edge: "79",
	electron: "0.20",
	firefox: "39",
	"firefox-android": "39",
	hermes: "0.1",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "22",
	"opera-android": "22",
	opera_mobile: "22",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "9.0",
	samsung: "3.0"
},
	"es.number.to-exponential": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "18",
	electron: "1.2",
	firefox: "87",
	"firefox-android": "87",
	hermes: "0.1",
	ios: "11.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "11",
	samsung: "5.0"
},
	"es.number.to-fixed": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "79",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.number.to-precision": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "8",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "1.5"
},
	"es.object.assign": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "79",
	electron: "0.37",
	firefox: "36",
	"firefox-android": "36",
	hermes: "0.4",
	ios: "9.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	safari: "9.0",
	samsung: "5.0"
},
	"es.object.create": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "3.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "12",
	"opera-android": "12",
	opera_mobile: "12",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "4.0",
	samsung: "1.0"
},
	"es.object.define-getter": {
	android: "62",
	bun: "0.1.1",
	chrome: "62",
	"chrome-android": "62",
	deno: "1.0",
	edge: "16",
	electron: "3.0",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "8.0",
	node: "8.10",
	oculus: "5.0",
	opera: "49",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "8.0"
},
	"es.object.define-properties": {
	android: "37",
	bun: "0.1.1",
	chrome: "37",
	"chrome-android": "37",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "5.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "12",
	"opera-android": "12",
	opera_mobile: "12",
	phantom: "2.0",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "5.1",
	samsung: "3.0"
},
	"es.object.define-property": {
	android: "37",
	bun: "0.1.1",
	chrome: "37",
	"chrome-android": "37",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "4",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "5.0",
	node: "0.11.15",
	oculus: "3.0",
	opera: "12",
	"opera-android": "12",
	opera_mobile: "12",
	phantom: "2.0",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "5.1",
	samsung: "3.0"
},
	"es.object.define-setter": {
	android: "62",
	bun: "0.1.1",
	chrome: "62",
	"chrome-android": "62",
	deno: "1.0",
	edge: "16",
	electron: "3.0",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "8.0",
	node: "8.10",
	oculus: "5.0",
	opera: "49",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "8.0"
},
	"es.object.entries": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "14",
	electron: "1.4",
	firefox: "47",
	"firefox-android": "47",
	hermes: "0.1",
	ios: "10.3",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "10.1",
	samsung: "6.0"
},
	"es.object.freeze": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.from-entries": {
	android: "73",
	bun: "0.1.1",
	chrome: "73",
	"chrome-android": "73",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "63",
	"firefox-android": "63",
	hermes: "0.4",
	ios: "12.2",
	node: "12.0",
	oculus: "6.0",
	opera: "60",
	"opera-android": "52",
	opera_mobile: "52",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "12.1",
	samsung: "11.0"
},
	"es.object.get-own-property-descriptor": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.get-own-property-descriptors": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "50",
	"firefox-android": "50",
	hermes: "0.6",
	ios: "10.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "6.0"
},
	"es.object.get-own-property-names": {
	android: "40",
	bun: "0.1.1",
	chrome: "40",
	"chrome-android": "40",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "34",
	"firefox-android": "34",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "27",
	"opera-android": "27",
	opera_mobile: "27",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.object.get-prototype-of": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.group-by": {
	android: "117",
	bun: "1.1.2",
	chrome: "117",
	"chrome-android": "117",
	deno: "1.37",
	edge: "117",
	electron: "27.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "18.0",
	node: "21.0",
	oculus: "30.0",
	opera: "103",
	"opera-android": "78",
	opera_mobile: "78",
	quest: "30.0",
	rhino: "1.8.0",
	safari: "18.0",
	samsung: "24.0"
},
	"es.object.has-own": {
	android: "93",
	bun: "0.1.1",
	chrome: "93",
	"chrome-android": "93",
	deno: "1.13",
	edge: "93",
	electron: "14.0",
	firefox: "92",
	"firefox-android": "92",
	hermes: "0.10",
	ios: "15.4",
	node: "16.9",
	oculus: "17.0",
	opera: "79",
	"opera-android": "66",
	opera_mobile: "66",
	quest: "17.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "17.0"
},
	"es.object.is": {
	android: "4.1",
	bun: "0.1.1",
	chrome: "19",
	"chrome-android": "25",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "22",
	"firefox-android": "22",
	hermes: "0.1",
	ios: "9.0",
	node: "0.7.3",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "1.5"
},
	"es.object.is-extensible": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.is-frozen": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.is-sealed": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.keys": {
	android: "40",
	bun: "0.1.1",
	chrome: "40",
	"chrome-android": "40",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "27",
	"opera-android": "27",
	opera_mobile: "27",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.object.lookup-getter": {
	android: "62",
	bun: "0.1.1",
	chrome: "62",
	"chrome-android": "62",
	deno: "1.0",
	edge: "16",
	electron: "3.0",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "8.0",
	node: "8.10",
	oculus: "5.0",
	opera: "49",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "8.0"
},
	"es.object.lookup-setter": {
	android: "62",
	bun: "0.1.1",
	chrome: "62",
	"chrome-android": "62",
	deno: "1.0",
	edge: "16",
	electron: "3.0",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "8.0",
	node: "8.10",
	oculus: "5.0",
	opera: "49",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "8.0"
},
	"es.object.prevent-extensions": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.proto": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "11",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	safari: "3.1",
	samsung: "1.0"
},
	"es.object.seal": {
	android: "44",
	bun: "0.1.1",
	chrome: "44",
	"chrome-android": "44",
	deno: "1.0",
	edge: "13",
	electron: "0.30",
	firefox: "35",
	"firefox-android": "35",
	hermes: "0.1",
	ios: "9.0",
	node: "3.0",
	oculus: "3.0",
	opera: "31",
	"opera-android": "31",
	opera_mobile: "31",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "4.0"
},
	"es.object.set-prototype-of": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "31",
	"firefox-android": "31",
	hermes: "0.1",
	ie: "11",
	ios: "9.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "21",
	"opera-android": "21",
	opera_mobile: "21",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "2.0"
},
	"es.object.to-string": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.object.values": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "14",
	electron: "1.4",
	firefox: "47",
	"firefox-android": "47",
	hermes: "0.1",
	ios: "10.3",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "10.1",
	samsung: "6.0"
},
	"es.parse-float": {
	android: "37",
	bun: "0.1.1",
	chrome: "35",
	"chrome-android": "35",
	deno: "1.0",
	edge: "74",
	electron: "0.20",
	firefox: "8",
	"firefox-android": "8",
	hermes: "0.1",
	ie: "8",
	ios: "8.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "22",
	"opera-android": "22",
	opera_mobile: "22",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.parse-int": {
	android: "37",
	bun: "0.1.1",
	chrome: "35",
	"chrome-android": "35",
	deno: "1.0",
	edge: "74",
	electron: "0.20",
	firefox: "21",
	"firefox-android": "21",
	hermes: "0.1",
	ie: "9",
	ios: "8.0",
	node: "0.11.13",
	oculus: "3.0",
	opera: "22",
	"opera-android": "22",
	opera_mobile: "22",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "7.1",
	samsung: "3.0"
},
	"es.promise": {
	android: "67",
	bun: "0.1.1",
	chrome: "67",
	"chrome-android": "67",
	deno: "1.24",
	edge: "79",
	electron: "4.0",
	firefox: "69",
	"firefox-android": "69",
	ios: "11.0",
	node: "10.4",
	oculus: "6.0",
	opera: "54",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	rhino: "1.7.14",
	safari: "11.0",
	samsung: "9.0"
},
	"es.promise.all-settled": {
	android: "76",
	bun: "0.1.1",
	chrome: "76",
	"chrome-android": "76",
	deno: "1.24",
	edge: "79",
	electron: "6.0",
	firefox: "71",
	"firefox-android": "71",
	ios: "13.0",
	node: "12.9",
	oculus: "7.0",
	opera: "63",
	"opera-android": "54",
	opera_mobile: "54",
	quest: "7.0",
	rhino: "1.7.15",
	safari: "13",
	samsung: "12.0"
},
	"es.promise.any": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.24",
	edge: "85",
	electron: "10.0",
	firefox: "79",
	"firefox-android": "79",
	ios: "14.0",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	rhino: "1.8.0",
	safari: "14.0",
	samsung: "14.0"
},
	"es.promise.finally": {
	android: "67",
	bun: "0.1.1",
	chrome: "67",
	"chrome-android": "67",
	deno: "1.24",
	edge: "79",
	electron: "4.0",
	firefox: "69",
	"firefox-android": "69",
	ios: "13.2.3",
	node: "10.4",
	oculus: "6.0",
	opera: "54",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	rhino: "1.7.14",
	safari: "13.0.3",
	samsung: "9.0"
},
	"es.promise.try": {
	android: "128",
	bun: "1.1.22",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "134",
	"firefox-android": "134",
	ios: "18.2",
	node: "23.0",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.2",
	samsung: "28.0"
},
	"es.promise.with-resolvers": {
	android: "119",
	bun: "0.7.1",
	chrome: "119",
	"chrome-android": "119",
	deno: "1.38",
	edge: "119",
	electron: "28.0",
	firefox: "121",
	"firefox-android": "121",
	ios: "17.4",
	node: "22.0",
	oculus: "31.0",
	opera: "105",
	"opera-android": "79",
	opera_mobile: "79",
	quest: "31.0",
	safari: "17.4",
	samsung: "25.0"
},
	"es.reflect.apply": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.construct": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "15",
	electron: "0.37",
	firefox: "44",
	"firefox-android": "44",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.define-property": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "13",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.delete-property": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.get": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.get-own-property-descriptor": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.get-prototype-of": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.has": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.is-extensible": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.own-keys": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.prevent-extensions": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.set": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "79",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.set-prototype-of": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "12",
	electron: "0.37",
	firefox: "42",
	"firefox-android": "42",
	hermes: "0.7",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.reflect.to-string-tag": {
	android: "86",
	bun: "0.1.1",
	chrome: "86",
	"chrome-android": "86",
	deno: "1.3",
	edge: "86",
	electron: "11.0",
	firefox: "82",
	"firefox-android": "82",
	hermes: "0.7",
	ios: "14.0",
	node: "15.0",
	oculus: "12.0",
	opera: "72",
	"opera-android": "61",
	opera_mobile: "61",
	quest: "12.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "14.0",
	samsung: "14.0"
},
	"es.regexp.constructor": {
	android: "64",
	bun: "0.1.1",
	chrome: "64",
	"chrome-android": "64",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "78",
	"firefox-android": "78",
	ios: "11.3",
	node: "10.0",
	oculus: "5.0",
	opera: "51",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	safari: "11.1",
	samsung: "9.0"
},
	"es.regexp.escape": {
	android: "136",
	bun: "1.1.22",
	chrome: "136",
	"chrome-android": "136",
	edge: "136",
	electron: "36.0",
	firefox: "134",
	"firefox-android": "134",
	ios: "18.2",
	node: "24.0",
	opera: "121",
	safari: "18.2"
},
	"es.regexp.dot-all": {
	android: "62",
	bun: "0.1.1",
	chrome: "62",
	"chrome-android": "62",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "78",
	"firefox-android": "78",
	hermes: "0.4",
	ios: "11.3",
	node: "8.10",
	oculus: "5.0",
	opera: "49",
	"opera-android": "46",
	opera_mobile: "46",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "11.1",
	samsung: "8.0"
},
	"es.regexp.exec": {
	android: "64",
	bun: "0.1.1",
	chrome: "64",
	"chrome-android": "64",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "78",
	"firefox-android": "78",
	hermes: "0.13",
	ios: "11.3",
	node: "10.0",
	oculus: "5.0",
	opera: "51",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	"react-native": "0.71",
	safari: "11.1",
	samsung: "9.0"
},
	"es.regexp.flags": {
	android: "111",
	bun: "0.1.1",
	chrome: "111",
	"chrome-android": "111",
	deno: "1.32",
	edge: "111",
	electron: "24.0",
	firefox: "78",
	"firefox-android": "78",
	hermes: "0.4",
	ios: "11.3",
	node: "20.0",
	oculus: "27.0",
	opera: "97",
	"opera-android": "75",
	opera_mobile: "75",
	quest: "27.0",
	"react-native": "0.69",
	safari: "11.1",
	samsung: "22.0"
},
	"es.regexp.sticky": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "13",
	electron: "0.37",
	firefox: "3",
	"firefox-android": "4",
	hermes: "0.3",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.regexp.test": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "46",
	"firefox-android": "46",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	safari: "10.0",
	samsung: "5.0"
},
	"es.regexp.to-string": {
	android: "50",
	bun: "0.1.1",
	chrome: "50",
	"chrome-android": "50",
	deno: "1.0",
	edge: "79",
	electron: "1.1",
	firefox: "46",
	"firefox-android": "46",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "37",
	"opera-android": "37",
	opera_mobile: "37",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.set": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "53",
	"firefox-android": "53",
	hermes: "0.13",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.73",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.set.difference.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"es.set.intersection.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"es.set.is-disjoint-from.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"es.set.is-subset-of.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"es.set.is-superset-of.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"es.set.symmetric-difference.v2": {
	android: "123",
	bun: "1.1.1",
	chrome: "123",
	"chrome-android": "123",
	deno: "1.41.3",
	edge: "123",
	electron: "30.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.0",
	oculus: "33.0",
	opera: "109",
	"opera-android": "82",
	opera_mobile: "82",
	quest: "33.0",
	safari: "18.0",
	samsung: "27.0"
},
	"es.set.union.v2": {
	android: "123",
	bun: "1.1.1",
	chrome: "123",
	"chrome-android": "123",
	deno: "1.41.3",
	edge: "123",
	electron: "30.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.0",
	oculus: "33.0",
	opera: "109",
	"opera-android": "82",
	opera_mobile: "82",
	quest: "33.0",
	safari: "18.0",
	samsung: "27.0"
},
	"es.string.at-alternative": {
	android: "92",
	bun: "0.1.1",
	chrome: "92",
	"chrome-android": "92",
	deno: "1.12",
	edge: "92",
	electron: "14.0",
	firefox: "90",
	"firefox-android": "90",
	hermes: "0.13",
	ios: "15.4",
	node: "16.6",
	oculus: "17.0",
	opera: "78",
	"opera-android": "65",
	opera_mobile: "65",
	quest: "17.0",
	"react-native": "0.71",
	safari: "15.4",
	samsung: "16.0"
},
	"es.string.code-point-at": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "29",
	"firefox-android": "29",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.string.ends-with": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "40",
	"firefox-android": "40",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.string.from-code-point": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "29",
	"firefox-android": "29",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.string.includes": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "40",
	"firefox-android": "40",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.string.is-well-formed": {
	android: "111",
	bun: "0.4.0",
	chrome: "111",
	"chrome-android": "111",
	deno: "1.32",
	edge: "111",
	electron: "24.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "16.4",
	node: "20.0",
	oculus: "27.0",
	opera: "97",
	"opera-android": "75",
	opera_mobile: "75",
	quest: "27.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "22.0"
},
	"es.string.iterator": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "36",
	"firefox-android": "36",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.string.match": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.string.match-all": {
	android: "80",
	bun: "0.1.1",
	chrome: "80",
	"chrome-android": "80",
	deno: "1.0",
	edge: "80",
	electron: "8.0",
	firefox: "73",
	"firefox-android": "73",
	hermes: "0.6",
	ios: "13.4",
	node: "14.0",
	oculus: "9.0",
	opera: "67",
	"opera-android": "57",
	opera_mobile: "57",
	quest: "9.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "13.1",
	samsung: "13.0"
},
	"es.string.pad-end": {
	android: "57",
	bun: "0.1.1",
	chrome: "57",
	"chrome-android": "57",
	deno: "1.0",
	edge: "15",
	electron: "1.7",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "11.0",
	node: "8.0",
	oculus: "3.0",
	opera: "44",
	"opera-android": "43",
	opera_mobile: "43",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "11.0",
	samsung: "7.0"
},
	"es.string.pad-start": {
	android: "57",
	bun: "0.1.1",
	chrome: "57",
	"chrome-android": "57",
	deno: "1.0",
	edge: "15",
	electron: "1.7",
	firefox: "48",
	"firefox-android": "48",
	hermes: "0.1",
	ios: "11.0",
	node: "8.0",
	oculus: "3.0",
	opera: "44",
	"opera-android": "43",
	opera_mobile: "43",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "11.0",
	samsung: "7.0"
},
	"es.string.raw": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "34",
	"firefox-android": "34",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "9.0",
	samsung: "3.4"
},
	"es.string.repeat": {
	android: "41",
	bun: "0.1.1",
	chrome: "41",
	"chrome-android": "41",
	deno: "1.0",
	edge: "13",
	electron: "0.21",
	firefox: "24",
	"firefox-android": "24",
	hermes: "0.1",
	ios: "9.0",
	node: "1.0",
	oculus: "3.0",
	opera: "28",
	"opera-android": "28",
	opera_mobile: "28",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "9.0",
	samsung: "3.4"
},
	"es.string.replace": {
	android: "64",
	bun: "0.1.1",
	chrome: "64",
	"chrome-android": "64",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "78",
	"firefox-android": "78",
	hermes: "0.13",
	ios: "14.0",
	node: "10.0",
	oculus: "5.0",
	opera: "51",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	"react-native": "0.71",
	safari: "14.0",
	samsung: "9.0"
},
	"es.string.replace-all": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.2",
	edge: "85",
	electron: "10.0",
	firefox: "77",
	"firefox-android": "77",
	hermes: "0.7",
	ios: "13.4",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "13.1",
	samsung: "14.0"
},
	"es.string.search": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "49",
	"firefox-android": "49",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.string.split": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "79",
	electron: "1.4",
	firefox: "49",
	"firefox-android": "49",
	ios: "10.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "10.0",
	samsung: "6.0"
},
	"es.string.starts-with": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "40",
	"firefox-android": "40",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "10.0",
	samsung: "5.0"
},
	"es.string.substr": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "9",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "4",
	"opera-android": "4",
	opera_mobile: "4",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.string.to-well-formed": {
	android: "111",
	bun: "0.5.7",
	chrome: "111",
	"chrome-android": "111",
	deno: "1.32",
	edge: "111",
	electron: "24.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "16.4",
	node: "20.0",
	oculus: "27.0",
	opera: "97",
	"opera-android": "75",
	opera_mobile: "75",
	quest: "27.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "22.0"
},
	"es.string.trim": {
	android: "59",
	bun: "0.1.1",
	chrome: "59",
	"chrome-android": "59",
	deno: "1.0",
	edge: "15",
	electron: "1.8",
	firefox: "52",
	"firefox-android": "52",
	hermes: "0.1",
	ios: "12.2",
	node: "8.3",
	oculus: "4.0",
	opera: "46",
	"opera-android": "43",
	opera_mobile: "43",
	quest: "4.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "12.1",
	samsung: "7.0"
},
	"es.string.trim-end": {
	android: "66",
	bun: "0.1.1",
	chrome: "66",
	"chrome-android": "66",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "61",
	"firefox-android": "61",
	hermes: "0.3",
	ios: "12.2",
	node: "10.0",
	oculus: "5.0",
	opera: "53",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	"react-native": "0.69",
	safari: "12.1",
	samsung: "9.0"
},
	"es.string.trim-start": {
	android: "66",
	bun: "0.1.1",
	chrome: "66",
	"chrome-android": "66",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "61",
	"firefox-android": "61",
	hermes: "0.3",
	ios: "12.0",
	node: "10.0",
	oculus: "5.0",
	opera: "53",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	"react-native": "0.69",
	safari: "12.0",
	samsung: "9.0"
},
	"es.string.anchor": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "17",
	"firefox-android": "17",
	ios: "6.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	phantom: "2.0",
	quest: "3.0",
	rhino: "1.7.14",
	safari: "6.0",
	samsung: "1.0"
},
	"es.string.big": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.blink": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.bold": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.fixed": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.fontcolor": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "17",
	"firefox-android": "17",
	ios: "6.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	phantom: "2.0",
	quest: "3.0",
	rhino: "1.7.14",
	safari: "6.0",
	samsung: "1.0"
},
	"es.string.fontsize": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "17",
	"firefox-android": "17",
	ios: "6.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	phantom: "2.0",
	quest: "3.0",
	rhino: "1.7.14",
	safari: "6.0",
	samsung: "1.0"
},
	"es.string.italics": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.link": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "17",
	"firefox-android": "17",
	ios: "6.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	phantom: "2.0",
	quest: "3.0",
	rhino: "1.7.14",
	safari: "6.0",
	samsung: "1.0"
},
	"es.string.small": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.strike": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.sub": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.string.sup": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "5",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "2",
	"firefox-android": "4",
	ios: "2.0",
	node: "0.1.27",
	oculus: "3.0",
	opera: "10.50",
	"opera-android": "10.50",
	opera_mobile: "10.50",
	phantom: "1.9",
	quest: "3.0",
	rhino: "1.7.13",
	safari: "3.1",
	samsung: "1.0"
},
	"es.typed-array.float32-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.float64-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.int8-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.int16-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.int32-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.uint8-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.uint8-clamped-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.uint16-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.uint32-array": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.at": {
	android: "92",
	bun: "0.1.1",
	chrome: "92",
	"chrome-android": "92",
	deno: "1.12",
	edge: "92",
	electron: "14.0",
	firefox: "90",
	"firefox-android": "90",
	hermes: "0.13",
	ios: "15.4",
	node: "16.6",
	oculus: "17.0",
	opera: "78",
	"opera-android": "65",
	opera_mobile: "65",
	quest: "17.0",
	"react-native": "0.71",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "16.0"
},
	"es.typed-array.copy-within": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "34",
	"firefox-android": "34",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.every": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.fill": {
	android: "58",
	bun: "0.1.1",
	chrome: "58",
	"chrome-android": "58",
	deno: "1.0",
	edge: "79",
	electron: "1.7",
	firefox: "55",
	"firefox-android": "55",
	hermes: "0.1",
	ios: "14.5",
	node: "8.0",
	oculus: "4.0",
	opera: "45",
	"opera-android": "43",
	opera_mobile: "43",
	quest: "4.0",
	"react-native": "0.69",
	safari: "14.1",
	samsung: "7.0"
},
	"es.typed-array.filter": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "38",
	"firefox-android": "38",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.find": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.find-index": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.find-last": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"es.typed-array.find-last-index": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"es.typed-array.for-each": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "38",
	"firefox-android": "38",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.from": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.includes": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.0",
	edge: "14",
	electron: "0.37",
	firefox: "43",
	"firefox-android": "43",
	hermes: "0.1",
	ios: "10.0",
	node: "6.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.index-of": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.iterator": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.join": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.last-index-of": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.map": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "38",
	"firefox-android": "38",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.of": {
	android: "54",
	bun: "0.1.1",
	chrome: "54",
	"chrome-android": "54",
	deno: "1.0",
	edge: "15",
	electron: "1.4",
	firefox: "55",
	"firefox-android": "55",
	ios: "14.0",
	node: "7.0",
	oculus: "3.0",
	opera: "41",
	"opera-android": "41",
	opera_mobile: "41",
	quest: "3.0",
	safari: "14.0",
	samsung: "6.0"
},
	"es.typed-array.reduce": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.reduce-right": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.reverse": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.set": {
	android: "95",
	bun: "0.1.1",
	chrome: "95",
	"chrome-android": "95",
	deno: "1.15",
	edge: "95",
	electron: "16.0",
	firefox: "54",
	"firefox-android": "54",
	hermes: "0.1",
	ios: "14.5",
	node: "17.0",
	oculus: "18.0",
	opera: "81",
	"opera-android": "67",
	opera_mobile: "67",
	quest: "18.0",
	"react-native": "0.69",
	safari: "14.1",
	samsung: "17.0"
},
	"es.typed-array.slice": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "38",
	"firefox-android": "38",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.some": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "13",
	electron: "0.31",
	firefox: "37",
	"firefox-android": "37",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.sort": {
	android: "74",
	bun: "0.1.1",
	chrome: "74",
	"chrome-android": "74",
	deno: "1.0",
	edge: "79",
	electron: "6.0",
	firefox: "67",
	"firefox-android": "67",
	hermes: "0.10",
	ios: "14.5",
	node: "12.0",
	oculus: "6.0",
	opera: "61",
	"opera-android": "53",
	opera_mobile: "53",
	quest: "6.0",
	"react-native": "0.69",
	safari: "14.1",
	samsung: "11.0"
},
	"es.typed-array.subarray": {
	android: "4.4",
	bun: "0.1.1",
	chrome: "26",
	"chrome-android": "26",
	deno: "1.0",
	edge: "13",
	electron: "0.20",
	firefox: "15",
	"firefox-android": "15",
	hermes: "0.1",
	ios: "8.0",
	node: "0.11.0",
	oculus: "3.0",
	opera: "15",
	"opera-android": "15",
	opera_mobile: "15",
	quest: "3.0",
	"react-native": "0.69",
	safari: "7.1",
	samsung: "1.5"
},
	"es.typed-array.to-locale-string": {
	android: "45",
	bun: "0.1.1",
	chrome: "45",
	"chrome-android": "45",
	deno: "1.0",
	edge: "79",
	electron: "0.31",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "4.0",
	oculus: "3.0",
	opera: "32",
	"opera-android": "32",
	opera_mobile: "32",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.to-reversed": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.typed-array.to-sorted": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"es.typed-array.to-string": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "13",
	electron: "1.2",
	firefox: "51",
	"firefox-android": "51",
	hermes: "0.1",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.69",
	safari: "10.0",
	samsung: "5.0"
},
	"es.typed-array.with": {
	android: "110",
	bun: "0.1.9",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.4",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "21.0"
},
	"es.unescape": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "3",
	ios: "1.0",
	node: "0.0.3",
	oculus: "3.0",
	opera: "3",
	"opera-android": "3",
	opera_mobile: "3",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1",
	samsung: "1.0"
},
	"es.weak-map": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "79",
	electron: "1.2",
	firefox: "53",
	"firefox-android": "53",
	hermes: "0.13",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.73",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"es.weak-set": {
	android: "51",
	bun: "0.1.1",
	chrome: "51",
	"chrome-android": "51",
	deno: "1.0",
	edge: "15",
	electron: "1.2",
	firefox: "53",
	"firefox-android": "53",
	hermes: "0.13",
	ios: "10.0",
	node: "6.5",
	oculus: "3.0",
	opera: "38",
	"opera-android": "38",
	opera_mobile: "38",
	quest: "3.0",
	"react-native": "0.73",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "5.0"
},
	"esnext.aggregate-error": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.2",
	edge: "85",
	electron: "10.0",
	firefox: "79",
	"firefox-android": "79",
	hermes: "0.13",
	ios: "14.0",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	"react-native": "0.72",
	rhino: "1.8.0",
	safari: "14.0",
	samsung: "14.0"
},
	"esnext.suppressed-error.constructor": {
	android: "136",
	chrome: "136",
	"chrome-android": "136",
	deno: "2.2.10",
	edge: "136",
	electron: "36.0",
	node: "24.0",
	opera: "121"
},
	"esnext.array.from-async": {
	android: "121",
	bun: "1.1.2",
	chrome: "121",
	"chrome-android": "121",
	deno: "1.38",
	edge: "121",
	electron: "29.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "18.0",
	node: "22.0",
	oculus: "32.0",
	opera: "107",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.0",
	samsung: "25.0"
},
	"esnext.array.at": {
	android: "92",
	bun: "0.1.1",
	chrome: "92",
	"chrome-android": "92",
	deno: "1.12",
	edge: "92",
	electron: "14.0",
	firefox: "90",
	"firefox-android": "90",
	hermes: "0.13",
	ios: "15.4",
	node: "16.6",
	oculus: "17.0",
	opera: "78",
	"opera-android": "65",
	opera_mobile: "65",
	quest: "17.0",
	"react-native": "0.71",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "16.0"
},
	"esnext.array.filter-out": {
},
	"esnext.array.filter-reject": {
},
	"esnext.array.find-last": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"esnext.array.find-last-index": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"esnext.array.group": {
},
	"esnext.array.group-by": {
},
	"esnext.array.group-by-to-map": {
},
	"esnext.array.group-to-map": {
},
	"esnext.array.is-template-object": {
},
	"esnext.array.last-index": {
},
	"esnext.array.last-item": {
},
	"esnext.array.to-reversed": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.array.to-sorted": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.array.to-spliced": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.array.unique-by": {
},
	"esnext.array.with": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	hermes: "0.13",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	"react-native": "0.74",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.array-buffer.detached": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"esnext.array-buffer.transfer": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"esnext.array-buffer.transfer-to-fixed-length": {
	android: "114",
	bun: "1.0.19",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "122",
	"firefox-android": "122",
	ios: "17.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.4",
	samsung: "23.0"
},
	"esnext.async-disposable-stack.constructor": {
	android: "136",
	chrome: "136",
	"chrome-android": "136",
	edge: "136",
	electron: "36.0",
	node: "24.0",
	opera: "121"
},
	"esnext.async-iterator.constructor": {
},
	"esnext.async-iterator.as-indexed-pairs": {
},
	"esnext.async-iterator.async-dispose": {
},
	"esnext.async-iterator.drop": {
},
	"esnext.async-iterator.every": {
},
	"esnext.async-iterator.filter": {
},
	"esnext.async-iterator.find": {
},
	"esnext.async-iterator.flat-map": {
},
	"esnext.async-iterator.for-each": {
},
	"esnext.async-iterator.from": {
},
	"esnext.async-iterator.indexed": {
},
	"esnext.async-iterator.map": {
},
	"esnext.async-iterator.reduce": {
},
	"esnext.async-iterator.some": {
},
	"esnext.async-iterator.take": {
},
	"esnext.async-iterator.to-array": {
},
	"esnext.bigint.range": {
},
	"esnext.composite-key": {
},
	"esnext.composite-symbol": {
},
	"esnext.data-view.get-float16": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"esnext.data-view.get-uint8-clamped": {
},
	"esnext.data-view.set-float16": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"esnext.data-view.set-uint8-clamped": {
},
	"esnext.disposable-stack.constructor": {
	android: "136",
	chrome: "136",
	"chrome-android": "136",
	deno: "2.2.10",
	edge: "136",
	electron: "36.0",
	node: "24.0",
	opera: "121"
},
	"esnext.error.is-error": {
	android: "134",
	chrome: "134",
	"chrome-android": "134",
	deno: "2.2",
	edge: "134",
	electron: "35.0",
	firefox: "138",
	"firefox-android": "138",
	node: "24.0",
	opera: "119",
	"opera-android": "88",
	opera_mobile: "88"
},
	"esnext.function.demethodize": {
},
	"esnext.function.is-callable": {
},
	"esnext.function.is-constructor": {
},
	"esnext.function.metadata": {
},
	"esnext.function.un-this": {
},
	"esnext.global-this": {
	android: "71",
	bun: "0.1.1",
	chrome: "71",
	"chrome-android": "71",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "65",
	"firefox-android": "65",
	hermes: "0.2",
	ios: "12.2",
	node: "12.0",
	oculus: "6.0",
	opera: "58",
	"opera-android": "50",
	opera_mobile: "50",
	quest: "6.0",
	"react-native": "0.69",
	rhino: "1.7.14",
	safari: "12.1",
	samsung: "10.0"
},
	"esnext.iterator.constructor": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"esnext.iterator.as-indexed-pairs": {
},
	"esnext.iterator.concat": {
},
	"esnext.iterator.dispose": {
	android: "136",
	chrome: "136",
	"chrome-android": "136",
	deno: "2.2.10",
	edge: "136",
	electron: "36.0",
	firefox: "135",
	"firefox-android": "135",
	node: "24.0",
	opera: "121"
},
	"esnext.iterator.drop": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.every": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.filter": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.find": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.flat-map": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.for-each": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.from": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"esnext.iterator.indexed": {
},
	"esnext.iterator.map": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.range": {
},
	"esnext.iterator.reduce": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.some": {
	android: "135",
	bun: "1.2.4",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.take": {
	android: "135",
	bun: "1.2.11",
	chrome: "135",
	"chrome-android": "135",
	deno: "2.2.5",
	edge: "135",
	electron: "36.0",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89"
},
	"esnext.iterator.to-array": {
	android: "122",
	bun: "1.1.31",
	chrome: "122",
	"chrome-android": "122",
	deno: "1.38.1",
	edge: "122",
	electron: "29.0",
	firefox: "131",
	"firefox-android": "131",
	ios: "18.4",
	node: "22.0",
	oculus: "32.0",
	opera: "108",
	"opera-android": "81",
	opera_mobile: "81",
	quest: "32.0",
	safari: "18.4",
	samsung: "26.0"
},
	"esnext.iterator.to-async": {
},
	"esnext.json.is-raw-json": {
	android: "114",
	bun: "1.1.43",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "135",
	"firefox-android": "135",
	ios: "18.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "18.4",
	samsung: "23.0"
},
	"esnext.json.parse": {
	android: "114",
	bun: "1.1.43",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "135",
	"firefox-android": "135",
	ios: "18.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "18.4",
	samsung: "23.0"
},
	"esnext.json.raw-json": {
	android: "114",
	bun: "1.1.43",
	chrome: "114",
	"chrome-android": "114",
	deno: "1.33",
	edge: "114",
	electron: "25.0",
	firefox: "135",
	"firefox-android": "135",
	ios: "18.4",
	node: "21.0",
	oculus: "28.0",
	opera: "100",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "18.4",
	samsung: "23.0"
},
	"esnext.map.delete-all": {
},
	"esnext.map.emplace": {
},
	"esnext.map.every": {
},
	"esnext.map.filter": {
},
	"esnext.map.find": {
},
	"esnext.map.find-key": {
},
	"esnext.map.from": {
},
	"esnext.map.get-or-insert": {
},
	"esnext.map.get-or-insert-computed": {
},
	"esnext.map.group-by": {
	android: "117",
	bun: "1.1.2",
	chrome: "117",
	"chrome-android": "117",
	deno: "1.37",
	edge: "117",
	electron: "27.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "18.0",
	node: "21.0",
	oculus: "30.0",
	opera: "103",
	"opera-android": "78",
	opera_mobile: "78",
	quest: "30.0",
	rhino: "1.8.0",
	safari: "18.0",
	samsung: "24.0"
},
	"esnext.map.includes": {
},
	"esnext.map.key-by": {
},
	"esnext.map.key-of": {
},
	"esnext.map.map-keys": {
},
	"esnext.map.map-values": {
},
	"esnext.map.merge": {
},
	"esnext.map.of": {
},
	"esnext.map.reduce": {
},
	"esnext.map.some": {
},
	"esnext.map.update": {
},
	"esnext.map.update-or-insert": {
},
	"esnext.map.upsert": {
},
	"esnext.math.clamp": {
},
	"esnext.math.deg-per-rad": {
},
	"esnext.math.degrees": {
},
	"esnext.math.fscale": {
},
	"esnext.math.f16round": {
	android: "135",
	bun: "1.1.23",
	chrome: "135",
	"chrome-android": "135",
	deno: "1.43",
	edge: "135",
	electron: "36.0",
	firefox: "129",
	"firefox-android": "129",
	ios: "18.2",
	node: "24.0",
	opera: "120",
	"opera-android": "89",
	opera_mobile: "89",
	safari: "18.2"
},
	"esnext.math.iaddh": {
},
	"esnext.math.imulh": {
},
	"esnext.math.isubh": {
},
	"esnext.math.rad-per-deg": {
},
	"esnext.math.radians": {
},
	"esnext.math.scale": {
},
	"esnext.math.seeded-prng": {
},
	"esnext.math.signbit": {
},
	"esnext.math.sum-precise": {
	firefox: "137",
	"firefox-android": "137"
},
	"esnext.math.umulh": {
},
	"esnext.number.from-string": {
},
	"esnext.number.range": {
},
	"esnext.object.has-own": {
	android: "93",
	bun: "0.1.1",
	chrome: "93",
	"chrome-android": "93",
	deno: "1.13",
	edge: "93",
	electron: "14.0",
	firefox: "92",
	"firefox-android": "92",
	hermes: "0.10",
	ios: "15.4",
	node: "16.9",
	oculus: "17.0",
	opera: "79",
	"opera-android": "66",
	opera_mobile: "66",
	quest: "17.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "17.0"
},
	"esnext.object.iterate-entries": {
},
	"esnext.object.iterate-keys": {
},
	"esnext.object.iterate-values": {
},
	"esnext.object.group-by": {
	android: "117",
	bun: "1.1.2",
	chrome: "117",
	"chrome-android": "117",
	deno: "1.37",
	edge: "117",
	electron: "27.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "18.0",
	node: "21.0",
	oculus: "30.0",
	opera: "103",
	"opera-android": "78",
	opera_mobile: "78",
	quest: "30.0",
	rhino: "1.8.0",
	safari: "18.0",
	samsung: "24.0"
},
	"esnext.observable": {
},
	"esnext.promise.all-settled": {
	android: "76",
	bun: "0.1.1",
	chrome: "76",
	"chrome-android": "76",
	deno: "1.24",
	edge: "79",
	electron: "6.0",
	firefox: "71",
	"firefox-android": "71",
	ios: "13.0",
	node: "12.9",
	oculus: "7.0",
	opera: "63",
	"opera-android": "54",
	opera_mobile: "54",
	quest: "7.0",
	rhino: "1.7.15",
	safari: "13",
	samsung: "12.0"
},
	"esnext.promise.any": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.24",
	edge: "85",
	electron: "10.0",
	firefox: "79",
	"firefox-android": "79",
	ios: "14.0",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	rhino: "1.8.0",
	safari: "14.0",
	samsung: "14.0"
},
	"esnext.promise.try": {
	android: "128",
	bun: "1.1.22",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "134",
	"firefox-android": "134",
	ios: "18.2",
	node: "23.0",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.2",
	samsung: "28.0"
},
	"esnext.promise.with-resolvers": {
	android: "119",
	bun: "0.7.1",
	chrome: "119",
	"chrome-android": "119",
	deno: "1.38",
	edge: "119",
	electron: "28.0",
	firefox: "121",
	"firefox-android": "121",
	ios: "17.4",
	node: "22.0",
	oculus: "31.0",
	opera: "105",
	"opera-android": "79",
	opera_mobile: "79",
	quest: "31.0",
	safari: "17.4",
	samsung: "25.0"
},
	"esnext.reflect.define-metadata": {
},
	"esnext.reflect.delete-metadata": {
},
	"esnext.reflect.get-metadata": {
},
	"esnext.reflect.get-metadata-keys": {
},
	"esnext.reflect.get-own-metadata": {
},
	"esnext.reflect.get-own-metadata-keys": {
},
	"esnext.reflect.has-metadata": {
},
	"esnext.reflect.has-own-metadata": {
},
	"esnext.reflect.metadata": {
},
	"esnext.regexp.escape": {
	android: "136",
	bun: "1.1.22",
	chrome: "136",
	"chrome-android": "136",
	edge: "136",
	electron: "36.0",
	firefox: "134",
	"firefox-android": "134",
	ios: "18.2",
	node: "24.0",
	opera: "121",
	safari: "18.2"
},
	"esnext.set.add-all": {
},
	"esnext.set.delete-all": {
},
	"esnext.set.difference.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"esnext.set.difference": {
},
	"esnext.set.every": {
},
	"esnext.set.filter": {
},
	"esnext.set.find": {
},
	"esnext.set.from": {
},
	"esnext.set.intersection.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"esnext.set.intersection": {
},
	"esnext.set.is-disjoint-from.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"esnext.set.is-disjoint-from": {
},
	"esnext.set.is-subset-of.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"esnext.set.is-subset-of": {
},
	"esnext.set.is-superset-of.v2": {
	android: "128",
	bun: "1.1.1",
	chrome: "128",
	"chrome-android": "128",
	deno: "1.46",
	edge: "128",
	electron: "32.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.10",
	oculus: "35.0",
	opera: "114",
	"opera-android": "85",
	opera_mobile: "85",
	quest: "35.0",
	safari: "18.0",
	samsung: "28.0"
},
	"esnext.set.is-superset-of": {
},
	"esnext.set.join": {
},
	"esnext.set.map": {
},
	"esnext.set.of": {
},
	"esnext.set.reduce": {
},
	"esnext.set.some": {
},
	"esnext.set.symmetric-difference.v2": {
	android: "123",
	bun: "1.1.1",
	chrome: "123",
	"chrome-android": "123",
	deno: "1.41.3",
	edge: "123",
	electron: "30.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.0",
	oculus: "33.0",
	opera: "109",
	"opera-android": "82",
	opera_mobile: "82",
	quest: "33.0",
	safari: "18.0",
	samsung: "27.0"
},
	"esnext.set.symmetric-difference": {
},
	"esnext.set.union.v2": {
	android: "123",
	bun: "1.1.1",
	chrome: "123",
	"chrome-android": "123",
	deno: "1.41.3",
	edge: "123",
	electron: "30.0",
	firefox: "127",
	"firefox-android": "127",
	ios: "18.0",
	node: "22.0",
	oculus: "33.0",
	opera: "109",
	"opera-android": "82",
	opera_mobile: "82",
	quest: "33.0",
	safari: "18.0",
	samsung: "27.0"
},
	"esnext.set.union": {
},
	"esnext.string.at": {
},
	"esnext.string.cooked": {
},
	"esnext.string.code-points": {
},
	"esnext.string.dedent": {
},
	"esnext.string.is-well-formed": {
	android: "111",
	bun: "0.4.0",
	chrome: "111",
	"chrome-android": "111",
	deno: "1.32",
	edge: "111",
	electron: "24.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "16.4",
	node: "20.0",
	oculus: "27.0",
	opera: "97",
	"opera-android": "75",
	opera_mobile: "75",
	quest: "27.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "22.0"
},
	"esnext.string.match-all": {
	android: "80",
	bun: "0.1.1",
	chrome: "80",
	"chrome-android": "80",
	deno: "1.0",
	edge: "80",
	electron: "8.0",
	firefox: "73",
	"firefox-android": "73",
	hermes: "0.6",
	ios: "13.4",
	node: "14.0",
	oculus: "9.0",
	opera: "67",
	"opera-android": "57",
	opera_mobile: "57",
	quest: "9.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "13.1",
	samsung: "13.0"
},
	"esnext.string.replace-all": {
	android: "85",
	bun: "0.1.1",
	chrome: "85",
	"chrome-android": "85",
	deno: "1.2",
	edge: "85",
	electron: "10.0",
	firefox: "77",
	"firefox-android": "77",
	hermes: "0.7",
	ios: "13.4",
	node: "15.0",
	oculus: "12.0",
	opera: "71",
	"opera-android": "60",
	opera_mobile: "60",
	quest: "12.0",
	"react-native": "0.69",
	rhino: "1.7.15",
	safari: "13.1",
	samsung: "14.0"
},
	"esnext.string.to-well-formed": {
	android: "111",
	bun: "0.5.7",
	chrome: "111",
	"chrome-android": "111",
	deno: "1.32",
	edge: "111",
	electron: "24.0",
	firefox: "119",
	"firefox-android": "119",
	ios: "16.4",
	node: "20.0",
	oculus: "27.0",
	opera: "97",
	"opera-android": "75",
	opera_mobile: "75",
	quest: "27.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "22.0"
},
	"esnext.symbol.async-dispose": {
	android: "127",
	bun: "1.0.23",
	chrome: "127",
	"chrome-android": "127",
	deno: "1.38",
	edge: "127",
	electron: "32.0",
	firefox: "135",
	"firefox-android": "135",
	node: "20.5.0",
	oculus: "35.0",
	opera: "113",
	"opera-android": "84",
	opera_mobile: "84",
	quest: "35.0",
	samsung: "28.0"
},
	"esnext.symbol.custom-matcher": {
},
	"esnext.symbol.dispose": {
	android: "125",
	bun: "1.0.23",
	chrome: "125",
	"chrome-android": "125",
	deno: "1.38",
	edge: "125",
	electron: "31.0",
	firefox: "135",
	"firefox-android": "135",
	node: "20.5.0",
	oculus: "34.0",
	opera: "111",
	"opera-android": "83",
	opera_mobile: "83",
	quest: "34.0",
	samsung: "27.0"
},
	"esnext.symbol.is-registered-symbol": {
},
	"esnext.symbol.is-registered": {
},
	"esnext.symbol.is-well-known-symbol": {
},
	"esnext.symbol.is-well-known": {
},
	"esnext.symbol.matcher": {
},
	"esnext.symbol.metadata": {
	deno: "1.40.4"
},
	"esnext.symbol.metadata-key": {
},
	"esnext.symbol.observable": {
},
	"esnext.symbol.pattern-match": {
},
	"esnext.symbol.replace-all": {
},
	"esnext.typed-array.from-async": {
},
	"esnext.typed-array.at": {
	android: "92",
	bun: "0.1.1",
	chrome: "92",
	"chrome-android": "92",
	deno: "1.12",
	edge: "92",
	electron: "14.0",
	firefox: "90",
	"firefox-android": "90",
	hermes: "0.13",
	ios: "15.4",
	node: "16.6",
	oculus: "17.0",
	opera: "78",
	"opera-android": "65",
	opera_mobile: "65",
	quest: "17.0",
	"react-native": "0.71",
	rhino: "1.7.15",
	safari: "15.4",
	samsung: "16.0"
},
	"esnext.typed-array.filter-out": {
},
	"esnext.typed-array.filter-reject": {
},
	"esnext.typed-array.find-last": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"esnext.typed-array.find-last-index": {
	android: "97",
	bun: "0.1.1",
	chrome: "97",
	"chrome-android": "97",
	deno: "1.16",
	edge: "97",
	electron: "17.0",
	firefox: "104",
	"firefox-android": "104",
	hermes: "0.11",
	ios: "15.4",
	node: "18.0",
	oculus: "20.0",
	opera: "83",
	"opera-android": "68",
	opera_mobile: "68",
	quest: "20.0",
	"react-native": "0.69",
	rhino: "1.8.0",
	safari: "15.4",
	samsung: "18.0"
},
	"esnext.typed-array.group-by": {
},
	"esnext.typed-array.to-reversed": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.typed-array.to-sorted": {
	android: "110",
	bun: "0.1.1",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.0",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.0",
	samsung: "21.0"
},
	"esnext.typed-array.to-spliced": {
},
	"esnext.typed-array.unique-by": {
},
	"esnext.typed-array.with": {
	android: "110",
	bun: "0.1.9",
	chrome: "110",
	"chrome-android": "110",
	deno: "1.27",
	edge: "110",
	electron: "23.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "16.4",
	node: "20.0",
	oculus: "26.0",
	opera: "96",
	"opera-android": "74",
	opera_mobile: "74",
	quest: "26.0",
	rhino: "1.8.0",
	safari: "16.4",
	samsung: "21.0"
},
	"esnext.uint8-array.from-base64": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.uint8-array.from-hex": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.uint8-array.set-from-base64": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.uint8-array.set-from-hex": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.uint8-array.to-base64": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.uint8-array.to-hex": {
	bun: "1.1.22",
	firefox: "133",
	"firefox-android": "133",
	ios: "18.2",
	safari: "18.2"
},
	"esnext.weak-map.delete-all": {
},
	"esnext.weak-map.from": {
},
	"esnext.weak-map.of": {
},
	"esnext.weak-map.emplace": {
},
	"esnext.weak-map.get-or-insert": {
},
	"esnext.weak-map.get-or-insert-computed": {
},
	"esnext.weak-map.upsert": {
},
	"esnext.weak-set.add-all": {
},
	"esnext.weak-set.delete-all": {
},
	"esnext.weak-set.from": {
},
	"esnext.weak-set.of": {
},
	"web.atob": {
	android: "37",
	bun: "0.1.1",
	chrome: "34",
	"chrome-android": "34",
	deno: "1.0",
	edge: "16",
	electron: "0.20",
	firefox: "27",
	"firefox-android": "27",
	hermes: "0.13",
	ios: "10.3",
	node: "18.0",
	oculus: "3.0",
	opera: "10.5",
	"opera-android": "10.5",
	opera_mobile: "10.5",
	quest: "3.0",
	"react-native": "0.74",
	safari: "10.1",
	samsung: "2.0"
},
	"web.btoa": {
	android: "3.0",
	bun: "0.1.1",
	chrome: "4",
	"chrome-android": "18",
	deno: "1.0",
	edge: "16",
	electron: "0.20",
	firefox: "27",
	"firefox-android": "27",
	ios: "1.0",
	node: "17.5",
	oculus: "3.0",
	opera: "10.5",
	"opera-android": "10.5",
	opera_mobile: "10.5",
	phantom: "1.9",
	quest: "3.0",
	safari: "3.0",
	samsung: "1.0"
},
	"web.dom-collections.for-each": {
	android: "58",
	bun: "0.1.1",
	chrome: "58",
	"chrome-android": "58",
	deno: "1.0",
	edge: "16",
	electron: "1.7",
	firefox: "50",
	"firefox-android": "50",
	hermes: "0.1",
	ios: "10.0",
	node: "0.0.1",
	oculus: "4.0",
	opera: "45",
	"opera-android": "43",
	opera_mobile: "43",
	quest: "4.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "10.0",
	samsung: "7.0"
},
	"web.dom-collections.iterator": {
	android: "66",
	bun: "0.1.1",
	chrome: "66",
	"chrome-android": "66",
	deno: "1.0",
	edge: "79",
	electron: "3.0",
	firefox: "60",
	"firefox-android": "60",
	hermes: "0.1",
	ios: "13.4",
	node: "0.0.1",
	oculus: "5.0",
	opera: "53",
	"opera-android": "47",
	opera_mobile: "47",
	quest: "5.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "13.1",
	samsung: "9.0"
},
	"web.dom-exception.constructor": {
	android: "46",
	bun: "0.1.1",
	chrome: "46",
	"chrome-android": "46",
	deno: "1.7",
	edge: "79",
	electron: "0.36",
	firefox: "37",
	"firefox-android": "37",
	ios: "11.3",
	node: "17.0",
	oculus: "3.0",
	opera: "33",
	"opera-android": "33",
	opera_mobile: "33",
	quest: "3.0",
	safari: "11.1",
	samsung: "5.0"
},
	"web.dom-exception.stack": {
	deno: "1.15",
	firefox: "37",
	"firefox-android": "37",
	node: "17.0"
},
	"web.dom-exception.to-string-tag": {
	android: "49",
	bun: "0.1.1",
	chrome: "49",
	"chrome-android": "49",
	deno: "1.7",
	edge: "79",
	electron: "0.37",
	firefox: "51",
	"firefox-android": "51",
	ios: "11.3",
	node: "17.0",
	oculus: "3.0",
	opera: "36",
	"opera-android": "36",
	opera_mobile: "36",
	quest: "3.0",
	safari: "11.1",
	samsung: "5.0"
},
	"web.immediate": {
	bun: "0.4.0",
	ie: "10",
	node: "0.9.1"
},
	"web.queue-microtask": {
	android: "71",
	chrome: "71",
	"chrome-android": "71",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "69",
	"firefox-android": "69",
	ios: "12.2",
	node: "12.0",
	oculus: "6.0",
	opera: "58",
	"opera-android": "50",
	opera_mobile: "50",
	quest: "6.0",
	safari: "12.1",
	samsung: "10.0"
},
	"web.self": {
	android: "86",
	bun: "1.0.22",
	chrome: "86",
	"chrome-android": "86",
	deno: "1.46.0",
	edge: "86",
	electron: "11.0",
	firefox: "31",
	"firefox-android": "31",
	ios: "10.0",
	oculus: "12.0",
	opera: "72",
	"opera-android": "61",
	opera_mobile: "61",
	quest: "12.0",
	safari: "10",
	samsung: "14.0"
},
	"web.structured-clone": {
},
	"web.timers": {
	android: "1.5",
	bun: "0.4.0",
	chrome: "1",
	"chrome-android": "18",
	deno: "1.0",
	edge: "12",
	electron: "0.20",
	firefox: "1",
	"firefox-android": "4",
	hermes: "0.1",
	ie: "10",
	ios: "1.0",
	node: "0.0.1",
	oculus: "3.0",
	opera: "7",
	"opera-android": "7",
	opera_mobile: "7",
	phantom: "1.9",
	quest: "3.0",
	"react-native": "0.69",
	rhino: "1.7.13",
	safari: "1.0",
	samsung: "1.0"
},
	"web.url": {
	android: "67",
	bun: "0.1.1",
	chrome: "67",
	"chrome-android": "67",
	deno: "1.0",
	edge: "79",
	electron: "4.0",
	firefox: "57",
	"firefox-android": "57",
	ios: "14.0",
	node: "10.0",
	oculus: "6.0",
	opera: "54",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	safari: "14.0",
	samsung: "9.0"
},
	"web.url.can-parse": {
	android: "120",
	bun: "1.1.0",
	chrome: "120",
	"chrome-android": "120",
	deno: "1.33.2",
	edge: "120",
	electron: "28.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "17.0",
	node: "20.1",
	oculus: "31.0",
	opera: "106",
	"opera-android": "80",
	opera_mobile: "80",
	quest: "31.0",
	safari: "17.0",
	samsung: "25.0"
},
	"web.url.parse": {
	android: "126",
	bun: "1.1.4",
	chrome: "126",
	"chrome-android": "126",
	deno: "1.43",
	edge: "126",
	electron: "31.0",
	firefox: "126",
	"firefox-android": "126",
	ios: "18.0",
	node: "22.1",
	oculus: "34.0",
	opera: "112",
	"opera-android": "83",
	opera_mobile: "83",
	quest: "34.0",
	safari: "18.0",
	samsung: "28.0"
},
	"web.url.to-json": {
	android: "71",
	bun: "0.1.1",
	chrome: "71",
	"chrome-android": "71",
	deno: "1.0",
	edge: "79",
	electron: "5.0",
	firefox: "57",
	"firefox-android": "57",
	ios: "14.0",
	node: "10.0",
	oculus: "6.0",
	opera: "58",
	"opera-android": "50",
	opera_mobile: "50",
	quest: "6.0",
	safari: "14.0",
	samsung: "10.0"
},
	"web.url-search-params": {
	android: "67",
	bun: "0.1.1",
	chrome: "67",
	"chrome-android": "67",
	deno: "1.0",
	edge: "79",
	electron: "4.0",
	firefox: "57",
	"firefox-android": "57",
	ios: "14.0",
	node: "10.0",
	oculus: "6.0",
	opera: "54",
	"opera-android": "48",
	opera_mobile: "48",
	quest: "6.0",
	safari: "14.0",
	samsung: "9.0"
},
	"web.url-search-params.delete": {
	android: "118",
	bun: "1.0.31",
	chrome: "118",
	"chrome-android": "118",
	deno: "1.35",
	edge: "118",
	electron: "27.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "17.0",
	node: "20.2",
	oculus: "30.0",
	opera: "104",
	"opera-android": "79",
	opera_mobile: "79",
	quest: "30.0",
	safari: "17.0",
	samsung: "25.0"
},
	"web.url-search-params.has": {
	android: "118",
	bun: "1.0.31",
	chrome: "118",
	"chrome-android": "118",
	deno: "1.35",
	edge: "118",
	electron: "27.0",
	firefox: "115",
	"firefox-android": "115",
	ios: "17.0",
	node: "20.2",
	oculus: "30.0",
	opera: "104",
	"opera-android": "79",
	opera_mobile: "79",
	quest: "30.0",
	safari: "17.0",
	samsung: "25.0"
},
	"web.url-search-params.size": {
	android: "113",
	bun: "1.0.2",
	chrome: "113",
	"chrome-android": "113",
	deno: "1.32",
	edge: "113",
	electron: "25.0",
	firefox: "112",
	"firefox-android": "112",
	ios: "17.0",
	node: "19.8",
	oculus: "28.0",
	opera: "99",
	"opera-android": "76",
	opera_mobile: "76",
	quest: "28.0",
	safari: "17.0",
	samsung: "23.0"
}
};

var hasRequiredNormalizeOptions;

function requireNormalizeOptions () {
	if (hasRequiredNormalizeOptions) return normalizeOptions$2;
	hasRequiredNormalizeOptions = 1;
	Object.defineProperty(normalizeOptions$2, "__esModule", {
	  value: true
	});
	normalizeOptions$2.checkDuplicateIncludeExcludes = void 0;
	normalizeOptions$2.default = normalizeOptions;
	normalizeOptions$2.normalizeCoreJSOption = normalizeCoreJSOption;
	normalizeOptions$2.validateUseBuiltInsOption = normalizeOptions$2.validateModulesOption = normalizeOptions$2.normalizePluginName = void 0;
	var _semver = requireSemver();
	var _pluginsCompatData = requirePluginsCompatData();
	var _moduleTransformations = requireModuleTransformations();
	var _options = requireOptions();
	var _helperValidatorOption = requireLib$1h();
	var _babel7Plugins = requireBabel7Plugins();
	const corejs3Polyfills = require$$0$1;
	const v = new _helperValidatorOption.OptionValidator("@babel/preset-env");
	const allPluginsList = Object.keys(_pluginsCompatData.plugins);
	const modulePlugins = ["transform-dynamic-import", ...Object.keys(_moduleTransformations.default).map((m) => _moduleTransformations.default[m])];
	const getValidIncludesAndExcludes = (type, corejs) => {
	  const set = new Set(allPluginsList);
	  if (type === "exclude") modulePlugins.map(set.add, set);
	  if (corejs) {
	    if (corejs === 2) {
	      Object.keys(_babel7Plugins.corejs2Polyfills).map(set.add, set);
	      set.add("web.timers").add("web.immediate").add("web.dom.iterable");
	    } else {
	      Object.keys(corejs3Polyfills).map(set.add, set);
	    }
	  }
	  return Array.from(set);
	};
	function flatMap(array, fn) {
	  return Array.prototype.concat.apply([], array.map(fn));
	}
	const normalizePluginName = (plugin) => plugin.replace(/^(?:@babel\/|babel-)(?:plugin-)?/, "");
	normalizeOptions$2.normalizePluginName = normalizePluginName;
	const expandIncludesAndExcludes = (filterList = [], type, corejs) => {
	  if (filterList.length === 0) return [];
	  const filterableItems = getValidIncludesAndExcludes(type, corejs);
	  const invalidFilters = [];
	  const selectedPlugins = flatMap(filterList, (filter) => {
	    let re;
	    if (typeof filter === "string") {
	      try {
	        re = new RegExp(`^${normalizePluginName(filter)}$`);
	      } catch (_) {
	        invalidFilters.push(filter);
	        return [];
	      }
	    } else {
	      re = filter;
	    }
	    const items = filterableItems.filter((item) => {
	      return re.test(item) || re.test(item.replace(/^transform-/, "proposal-"));
	    });
	    if (items.length === 0) invalidFilters.push(filter);
	    return items;
	  });
	  v.invariant(invalidFilters.length === 0, `The plugins/built-ins '${invalidFilters.join(", ")}' passed to the '${type}' option are not
    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`);
	  return selectedPlugins;
	};
	const checkDuplicateIncludeExcludes = (include = [], exclude = []) => {
	  const duplicates = include.filter((opt) => exclude.includes(opt));
	  v.invariant(duplicates.length === 0, `The plugins/built-ins '${duplicates.join(", ")}' were found in both the "include" and
    "exclude" options.`);
	};
	normalizeOptions$2.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;
	const normalizeTargets = (targets) => {
	  if (typeof targets === "string" || Array.isArray(targets)) {
	    return {
	      browsers: targets
	    };
	  }
	  return Object.assign({}, targets);
	};
	const validateModulesOption = (modulesOpt = _options.ModulesOption.auto) => {
	  v.invariant(_options.ModulesOption[modulesOpt.toString()] || modulesOpt === _options.ModulesOption.false, `The 'modules' option must be one of 
 - 'false' to indicate no module processing
 - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs' - 'auto' (default) which will automatically select 'false' if the current
   process is known to support ES module syntax, or "commonjs" otherwise
`);
	  return modulesOpt;
	};
	normalizeOptions$2.validateModulesOption = validateModulesOption;
	const validateUseBuiltInsOption = (builtInsOpt = false) => {
	  v.invariant(_options.UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === _options.UseBuiltInsOption.false, `The 'useBuiltIns' option must be either
    'false' (default) to indicate no polyfill,
    '"entry"' to indicate replacing the entry polyfill, or
    '"usage"' to import only used polyfills per file`);
	  return builtInsOpt;
	};
	normalizeOptions$2.validateUseBuiltInsOption = validateUseBuiltInsOption;
	function normalizeCoreJSOption(corejs, useBuiltIns) {
	  let proposals = false;
	  let rawVersion;
	  if (useBuiltIns && corejs === void 0) {
	    {
	      rawVersion = 2;
	      console.warn(`
WARNING (@babel/preset-env): We noticed you're using the \`useBuiltIns\` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the \`corejs\` option.

You should also be sure that the version you pass to the \`corejs\` option matches the version specified in your \`package.json\`'s \`dependencies\` section. If it doesn't, you need to run one of the following commands:

  npm install --save core-js@2    npm install --save core-js@3
  yarn add core-js@2              yarn add core-js@3

More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins
More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs`);
	    }
	  } else if (typeof corejs === "object" && corejs !== null) {
	    rawVersion = corejs.version;
	    proposals = Boolean(corejs.proposals);
	  } else {
	    rawVersion = corejs;
	  }
	  const version = rawVersion ? _semver.coerce(String(rawVersion)) : false;
	  if (version) {
	    if (useBuiltIns) {
	      {
	        if (version.major < 2 || version.major > 3) {
	          throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, only core-js@2 and core-js@3 are supported.");
	        }
	      }
	    } else {
	      console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
	    }
	  }
	  return {
	    version,
	    proposals
	  };
	}
	function normalizeOptions(opts) {
	  v.validateTopLevelOptions(opts, _options.TopLevelOptions);
	  const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
	  const corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
	  const include = expandIncludesAndExcludes(opts.include, _options.TopLevelOptions.include, !!corejs.version && corejs.version.major);
	  const exclude = expandIncludesAndExcludes(opts.exclude, _options.TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
	  checkDuplicateIncludeExcludes(include, exclude);
	  {
	    v.validateBooleanOption("loose", opts.loose);
	    v.validateBooleanOption("spec", opts.spec);
	    v.validateBooleanOption("bugfixes", opts.bugfixes);
	  }
	  return {
	    configPath: v.validateStringOption(_options.TopLevelOptions.configPath, opts.configPath, process.cwd()),
	    corejs,
	    debug: v.validateBooleanOption(_options.TopLevelOptions.debug, opts.debug, false),
	    include,
	    exclude,
	    forceAllTransforms: v.validateBooleanOption(_options.TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
	    ignoreBrowserslistConfig: v.validateBooleanOption(_options.TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false),
	    modules: validateModulesOption(opts.modules),
	    shippedProposals: v.validateBooleanOption(_options.TopLevelOptions.shippedProposals, opts.shippedProposals, false),
	    targets: normalizeTargets(opts.targets),
	    useBuiltIns,
	    browserslistEnv: v.validateStringOption(_options.TopLevelOptions.browserslistEnv, opts.browserslistEnv)
	  };
	}
	return normalizeOptions$2;
}

var shippedProposals$1 = {};

var hasRequiredShippedProposals$1;

function requireShippedProposals$1 () {
	if (hasRequiredShippedProposals$1) return shippedProposals$1;
	hasRequiredShippedProposals$1 = 1;
	Object.defineProperty(shippedProposals$1, "__esModule", {
	  value: true
	});
	shippedProposals$1.proposalSyntaxPlugins = shippedProposals$1.proposalPlugins = shippedProposals$1.pluginSyntaxMap = void 0;
	shippedProposals$1.proposalPlugins = /* @__PURE__ */ new Set([]);
	shippedProposals$1.proposalSyntaxPlugins = ["syntax-import-assertions", "syntax-import-attributes"];
	const pluginSyntaxObject = {
	  "transform-async-generator-functions": "syntax-async-generators",
	  "transform-class-properties": "syntax-class-properties",
	  "transform-class-static-block": "syntax-class-static-block",
	  "transform-export-namespace-from": "syntax-export-namespace-from",
	  "transform-json-strings": "syntax-json-strings",
	  "transform-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
	  "transform-numeric-separator": "syntax-numeric-separator",
	  "transform-object-rest-spread": "syntax-object-rest-spread",
	  "transform-optional-catch-binding": "syntax-optional-catch-binding",
	  "transform-optional-chaining": "syntax-optional-chaining",
	  "transform-private-methods": "syntax-class-properties",
	  "transform-private-property-in-object": "syntax-private-property-in-object",
	  "transform-unicode-property-regex": null
	};
	const pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function(key) {
	  return [key, pluginSyntaxObject[key]];
	});
	shippedProposals$1.pluginSyntaxMap = new Map(pluginSyntaxEntries);
	return shippedProposals$1;
}

var lib$1 = {};

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	data = require$$0$1;
	return data;
}

var shippedProposals = {};

var hasRequiredShippedProposals;

function requireShippedProposals () {
	if (hasRequiredShippedProposals) return shippedProposals;
	hasRequiredShippedProposals = 1;
	shippedProposals.__esModule = true;
	shippedProposals.default = void 0;
	var _default = /* @__PURE__ */ new Set(["esnext.suppressed-error.constructor", "esnext.array.from-async", "esnext.array.group", "esnext.array.group-to-map", "esnext.data-view.get-float16", "esnext.data-view.set-float16", "esnext.error.is-error", "esnext.iterator.dispose", "esnext.json.is-raw-json", "esnext.json.parse", "esnext.json.raw-json", "esnext.math.f16round", "esnext.regexp.escape", "esnext.symbol.async-dispose", "esnext.symbol.dispose", "esnext.symbol.metadata", "esnext.uint8-array.from-base64", "esnext.uint8-array.from-hex", "esnext.uint8-array.set-from-base64", "esnext.uint8-array.set-from-hex", "esnext.uint8-array.to-base64", "esnext.uint8-array.to-hex"]);
	shippedProposals.default = _default;
	return shippedProposals;
}

var helpers$1;
var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers$1;
	hasRequiredHelpers$1 = 1;
	const has = Object.hasOwn || Function.call.bind({}.hasOwnProperty);
	const VERSION_PATTERN = /(\d+)(?:\.(\d+))?(?:\.(\d+))?/;
	class SemVer {
	  constructor(input) {
	    const match = VERSION_PATTERN.exec(input);
	    if (!match) throw new TypeError(`Invalid version: ${input}`);
	    const [, $major, $minor, $patch] = match;
	    this.major = +$major;
	    this.minor = $minor ? +$minor : 0;
	    this.patch = $patch ? +$patch : 0;
	  }
	  toString() {
	    return `${this.major}.${this.minor}.${this.patch}`;
	  }
	}
	function semver(input) {
	  return input instanceof SemVer ? input : new SemVer(input);
	}
	function compare($a, operator, $b) {
	  const a = semver($a);
	  const b = semver($b);
	  for (const component of ["major", "minor", "patch"]) {
	    if (a[component] < b[component]) return operator === "<" || operator === "<=" || operator === "!=";
	    if (a[component] > b[component]) return operator === ">" || operator === ">=" || operator === "!=";
	  }
	  return operator === "==" || operator === "<=" || operator === ">=";
	}
	function filterOutStabilizedProposals(modules) {
	  const modulesSet = new Set(modules);
	  for (const $module of modulesSet) {
	    if ($module.startsWith("esnext.") && modulesSet.has($module.replace(/^esnext\./, "es."))) {
	      modulesSet.delete($module);
	    }
	  }
	  return [...modulesSet];
	}
	function intersection(list, order) {
	  const set = list instanceof Set ? list : new Set(list);
	  return order.filter((name) => set.has(name));
	}
	function sortObjectByKey(object, fn) {
	  return Object.keys(object).sort(fn).reduce((memo, key) => {
	    memo[key] = object[key];
	    return memo;
	  }, {});
	}
	helpers$1 = {
	  compare,
	  filterOutStabilizedProposals,
	  has,
	  intersection,
	  semver,
	  sortObjectByKey
	};
	return helpers$1;
}

var require$$1 = {
	"3.0": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.date.now",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.json.to-string-tag",
	"es.map",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.finally",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.to-string",
	"es.set",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-string",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.global-this",
	"esnext.map.delete-all",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.code-points",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.symbol.dispose",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.immediate",
	"web.queue-microtask",
	"web.timers",
	"web.url",
	"web.url.to-json",
	"web.url-search-params"
],
	"3.1": [
	"es.string.match-all",
	"es.symbol.match-all",
	"esnext.symbol.replace-all"
],
	"3.2": [
	"es.promise.all-settled",
	"esnext.array.is-template-object",
	"esnext.map.update-or-insert",
	"esnext.symbol.async-dispose"
],
	"3.3": [
	"es.global-this",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.map.upsert",
	"esnext.weak-map.upsert"
],
	"3.4": [
	"es.json.stringify"
],
	"3.5": [
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values"
],
	"3.6": [
	"es.regexp.sticky",
	"es.regexp.test"
],
	"3.7": [
	"es.aggregate-error",
	"es.promise.any",
	"es.reflect.to-string-tag",
	"es.string.replace-all",
	"esnext.map.emplace",
	"esnext.weak-map.emplace"
],
	"3.8": [
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.unique-by",
	"esnext.bigint.range",
	"esnext.number.range",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out"
],
	"3.9": [
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.unique-by"
],
	"3.11": [
	"esnext.object.has-own"
],
	"3.12": [
	"esnext.symbol.matcher",
	"esnext.symbol.metadata"
],
	"3.15": [
	"es.date.get-year",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.escape",
	"es.regexp.dot-all",
	"es.string.substr",
	"es.unescape"
],
	"3.16": [
	"esnext.array.filter-reject",
	"esnext.array.group-by",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.group-by"
],
	"3.17": [
	"es.array.at",
	"es.object.has-own",
	"es.string.at-alternative",
	"es.typed-array.at"
],
	"3.18": [
	"esnext.array.from-async",
	"esnext.typed-array.from-async"
],
	"3.20": [
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error.cause",
	"es.number.to-exponential",
	"esnext.array.group-by-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.un-this",
	"esnext.iterator.to-async",
	"esnext.string.cooked",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.structured-clone"
],
	"3.21": [
	"web.atob",
	"web.btoa"
],
	"3.23": [
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.push",
	"es.array.unshift",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-to-map",
	"esnext.symbol.metadata-key"
],
	"3.24": [
	"esnext.async-iterator.indexed",
	"esnext.iterator.indexed"
],
	"3.25": [
	"es.object.proto"
],
	"3.26": [
	"esnext.string.is-well-formed",
	"esnext.string.to-well-formed",
	"web.self"
],
	"3.27": [
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"esnext.string.dedent"
],
	"3.28": [
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.with",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.function.demethodize",
	"esnext.iterator.range",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known"
],
	"3.29": [
	"web.url-search-params.size"
],
	"3.30": [
	"web.url.can-parse"
],
	"3.31": [
	"es.string.is-well-formed",
	"es.string.to-well-formed",
	"esnext.function.metadata",
	"esnext.object.group-by",
	"esnext.promise.with-resolvers",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-well-known-symbol",
	"web.url-search-params.delete",
	"web.url-search-params.has"
],
	"3.32": [
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.math.f16round"
],
	"3.33": [
	"esnext.regexp.escape"
],
	"3.34": [
	"es.map.group-by",
	"es.object.group-by",
	"es.promise.with-resolvers",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"3.36": [
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length"
],
	"3.37": [
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"esnext.math.sum-precise",
	"esnext.symbol.custom-matcher",
	"web.url.parse"
],
	"3.38": [
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex"
],
	"3.39": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.promise.try",
	"esnext.iterator.concat",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"3.40": [
	"esnext.error.is-error"
],
	"3.41": [
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.math.f16round",
	"es.regexp.escape"
]
};

var require$$2 = [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
];

var getModulesListForTargetVersion$1;
var hasRequiredGetModulesListForTargetVersion$1;

function requireGetModulesListForTargetVersion$1 () {
	if (hasRequiredGetModulesListForTargetVersion$1) return getModulesListForTargetVersion$1;
	hasRequiredGetModulesListForTargetVersion$1 = 1;
	const { compare, intersection, semver } = /*@__PURE__*/ requireHelpers$1();
	const modulesByVersions = require$$1;
	const modules = require$$2;
	getModulesListForTargetVersion$1 = function(raw) {
	  const corejs = semver(raw);
	  if (corejs.major !== 3) {
	    throw new RangeError("This version of `core-js-compat` works only with `core-js@3`.");
	  }
	  const result = [];
	  for (const version of Object.keys(modulesByVersions)) {
	    if (compare(version, "<=", corejs)) {
	      result.push(...modulesByVersions[version]);
	    }
	  }
	  return intersection(result, modules);
	};
	return getModulesListForTargetVersion$1;
}

var getModulesListForTargetVersion;
var hasRequiredGetModulesListForTargetVersion;

function requireGetModulesListForTargetVersion () {
	if (hasRequiredGetModulesListForTargetVersion) return getModulesListForTargetVersion;
	hasRequiredGetModulesListForTargetVersion = 1;
	getModulesListForTargetVersion = /*@__PURE__*/ requireGetModulesListForTargetVersion$1();
	return getModulesListForTargetVersion;
}

var builtInDefinitions = {};

var hasRequiredBuiltInDefinitions;

function requireBuiltInDefinitions () {
	if (hasRequiredBuiltInDefinitions) return builtInDefinitions;
	hasRequiredBuiltInDefinitions = 1;
	builtInDefinitions.__esModule = true;
	builtInDefinitions.StaticProperties = builtInDefinitions.PromiseDependenciesWithIterators = builtInDefinitions.PromiseDependencies = builtInDefinitions.InstanceProperties = builtInDefinitions.DecoratorMetadataDependencies = builtInDefinitions.CommonIterators = builtInDefinitions.BuiltIns = void 0;
	var _data = _interopRequireDefault(requireData());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	const polyfillsOrder = {};
	Object.keys(_data.default).forEach((name, index) => {
	  polyfillsOrder[name] = index;
	});
	const define = (pure, global, name = global[0], exclude) => {
	  return {
	    name,
	    pure,
	    global: global.sort((a, b) => polyfillsOrder[a] - polyfillsOrder[b]),
	    exclude
	  };
	};
	const typed = (...modules) => define(null, [...modules, ...TypedArrayDependencies]);
	const ArrayNatureIterators = ["es.array.iterator", "web.dom-collections.iterator"];
	const CommonIterators = ["es.string.iterator", ...ArrayNatureIterators];
	builtInDefinitions.CommonIterators = CommonIterators;
	const ArrayNatureIteratorsWithTag = ["es.object.to-string", ...ArrayNatureIterators];
	const CommonIteratorsWithTag = ["es.object.to-string", ...CommonIterators];
	const ErrorDependencies = ["es.error.cause", "es.error.to-string"];
	const SuppressedErrorDependencies = ["esnext.suppressed-error.constructor", ...ErrorDependencies];
	const ArrayBufferDependencies = ["es.array-buffer.constructor", "es.array-buffer.slice", "es.data-view", "es.array-buffer.detached", "es.array-buffer.transfer", "es.array-buffer.transfer-to-fixed-length", "es.object.to-string"];
	const TypedArrayDependencies = ["es.typed-array.at", "es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.find-last", "es.typed-array.find-last-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-reversed", "es.typed-array.to-sorted", "es.typed-array.to-string", "es.typed-array.with", "es.object.to-string", "es.array.iterator", "esnext.typed-array.filter-reject", "esnext.typed-array.group-by", "esnext.typed-array.to-spliced", "esnext.typed-array.unique-by", ...ArrayBufferDependencies];
	const PromiseDependencies = ["es.promise", "es.object.to-string"];
	builtInDefinitions.PromiseDependencies = PromiseDependencies;
	const PromiseDependenciesWithIterators = [...PromiseDependencies, ...CommonIterators];
	builtInDefinitions.PromiseDependenciesWithIterators = PromiseDependenciesWithIterators;
	const SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
	const MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.emplace", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.get-or-insert", "esnext.map.get-or-insert-computed", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update", ...CommonIteratorsWithTag];
	const SetDependencies = ["es.set", "es.set.difference.v2", "es.set.intersection.v2", "es.set.is-disjoint-from.v2", "es.set.is-subset-of.v2", "es.set.is-superset-of.v2", "es.set.symmetric-difference.v2", "es.set.union.v2", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union", ...CommonIteratorsWithTag];
	const WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all", "esnext.weak-map.emplace", "esnext.weak-map.get-or-insert", "esnext.weak-map.get-or-insert-computed", ...CommonIteratorsWithTag];
	const WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all", ...CommonIteratorsWithTag];
	const DOMExceptionDependencies = ["web.dom-exception.constructor", "web.dom-exception.stack", "web.dom-exception.to-string-tag", "es.error.to-string"];
	const URLSearchParamsDependencies = ["web.url-search-params", "web.url-search-params.delete", "web.url-search-params.has", "web.url-search-params.size", ...CommonIteratorsWithTag];
	const AsyncIteratorDependencies = ["esnext.async-iterator.constructor", ...PromiseDependencies];
	const AsyncIteratorProblemMethods = ["esnext.async-iterator.every", "esnext.async-iterator.filter", "esnext.async-iterator.find", "esnext.async-iterator.flat-map", "esnext.async-iterator.for-each", "esnext.async-iterator.map", "esnext.async-iterator.reduce", "esnext.async-iterator.some"];
	const IteratorDependencies = ["es.iterator.constructor", "es.object.to-string"];
	const DecoratorMetadataDependencies = ["esnext.symbol.metadata", "esnext.function.metadata"];
	builtInDefinitions.DecoratorMetadataDependencies = DecoratorMetadataDependencies;
	const TypedArrayStaticMethods = (base) => ({
	  from: define(null, ["es.typed-array.from", base, ...TypedArrayDependencies]),
	  fromAsync: define(null, ["esnext.typed-array.from-async", base, ...PromiseDependenciesWithIterators, ...TypedArrayDependencies]),
	  of: define(null, ["es.typed-array.of", base, ...TypedArrayDependencies])
	});
	const DataViewDependencies = ["es.data-view", ...ArrayBufferDependencies];
	const BuiltIns = {
	  AsyncDisposableStack: define("async-disposable-stack/index", ["esnext.async-disposable-stack.constructor", "es.object.to-string", "esnext.async-iterator.async-dispose", "esnext.iterator.dispose", ...PromiseDependencies, ...SuppressedErrorDependencies]),
	  AsyncIterator: define("async-iterator/index", AsyncIteratorDependencies),
	  AggregateError: define("aggregate-error", ["es.aggregate-error", ...ErrorDependencies, ...CommonIteratorsWithTag, "es.aggregate-error.cause"]),
	  ArrayBuffer: define(null, ArrayBufferDependencies),
	  DataView: define(null, DataViewDependencies),
	  Date: define(null, ["es.date.to-string"]),
	  DOMException: define("dom-exception/index", DOMExceptionDependencies),
	  DisposableStack: define("disposable-stack/index", ["esnext.disposable-stack.constructor", "es.object.to-string", "esnext.iterator.dispose", ...SuppressedErrorDependencies]),
	  Error: define(null, ErrorDependencies),
	  EvalError: define(null, ErrorDependencies),
	  Float32Array: typed("es.typed-array.float32-array"),
	  Float64Array: typed("es.typed-array.float64-array"),
	  Int8Array: typed("es.typed-array.int8-array"),
	  Int16Array: typed("es.typed-array.int16-array"),
	  Int32Array: typed("es.typed-array.int32-array"),
	  Iterator: define("iterator/index", IteratorDependencies),
	  Uint8Array: typed("es.typed-array.uint8-array", "esnext.uint8-array.set-from-base64", "esnext.uint8-array.set-from-hex", "esnext.uint8-array.to-base64", "esnext.uint8-array.to-hex"),
	  Uint8ClampedArray: typed("es.typed-array.uint8-clamped-array"),
	  Uint16Array: typed("es.typed-array.uint16-array"),
	  Uint32Array: typed("es.typed-array.uint32-array"),
	  Map: define("map/index", MapDependencies),
	  Number: define(null, ["es.number.constructor"]),
	  Observable: define("observable/index", ["esnext.observable", "esnext.symbol.observable", "es.object.to-string", ...CommonIteratorsWithTag]),
	  Promise: define("promise/index", PromiseDependencies),
	  RangeError: define(null, ErrorDependencies),
	  ReferenceError: define(null, ErrorDependencies),
	  Reflect: define(null, ["es.reflect.to-string-tag", "es.object.to-string"]),
	  RegExp: define(null, ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec", "es.regexp.sticky", "es.regexp.to-string"]),
	  Set: define("set/index", SetDependencies),
	  SuppressedError: define("suppressed-error", SuppressedErrorDependencies),
	  Symbol: define("symbol/index", SymbolDependencies),
	  SyntaxError: define(null, ErrorDependencies),
	  TypeError: define(null, ErrorDependencies),
	  URIError: define(null, ErrorDependencies),
	  URL: define("url/index", ["web.url", "web.url.to-json", ...URLSearchParamsDependencies]),
	  URLSearchParams: define("url-search-params/index", URLSearchParamsDependencies),
	  WeakMap: define("weak-map/index", WeakMapDependencies),
	  WeakSet: define("weak-set/index", WeakSetDependencies),
	  atob: define("atob", ["web.atob", ...DOMExceptionDependencies]),
	  btoa: define("btoa", ["web.btoa", ...DOMExceptionDependencies]),
	  clearImmediate: define("clear-immediate", ["web.immediate"]),
	  compositeKey: define("composite-key", ["esnext.composite-key"]),
	  compositeSymbol: define("composite-symbol", ["esnext.composite-symbol"]),
	  escape: define("escape", ["es.escape"]),
	  fetch: define(null, PromiseDependencies),
	  globalThis: define("global-this", ["es.global-this"]),
	  parseFloat: define("parse-float", ["es.parse-float"]),
	  parseInt: define("parse-int", ["es.parse-int"]),
	  queueMicrotask: define("queue-microtask", ["web.queue-microtask"]),
	  self: define("self", ["web.self"]),
	  setImmediate: define("set-immediate", ["web.immediate"]),
	  setInterval: define("set-interval", ["web.timers"]),
	  setTimeout: define("set-timeout", ["web.timers"]),
	  structuredClone: define("structured-clone", ["web.structured-clone", ...DOMExceptionDependencies, "es.array.iterator", "es.object.keys", "es.object.to-string", "es.map", "es.set"]),
	  unescape: define("unescape", ["es.unescape"])
	};
	builtInDefinitions.BuiltIns = BuiltIns;
	const StaticProperties = {
	  AsyncIterator: {
	    from: define("async-iterator/from", ["esnext.async-iterator.from", ...AsyncIteratorDependencies, ...AsyncIteratorProblemMethods, ...CommonIterators])
	  },
	  Array: {
	    from: define("array/from", ["es.array.from", "es.string.iterator"]),
	    fromAsync: define("array/from-async", ["esnext.array.from-async", ...PromiseDependenciesWithIterators]),
	    isArray: define("array/is-array", ["es.array.is-array"]),
	    isTemplateObject: define("array/is-template-object", ["esnext.array.is-template-object"]),
	    of: define("array/of", ["es.array.of"])
	  },
	  ArrayBuffer: {
	    isView: define(null, ["es.array-buffer.is-view"])
	  },
	  BigInt: {
	    range: define("bigint/range", ["esnext.bigint.range", "es.object.to-string"])
	  },
	  Date: {
	    now: define("date/now", ["es.date.now"])
	  },
	  Error: {
	    isError: define("error/is-error", ["esnext.error.is-error", "es.object.create"])
	  },
	  Function: {
	    isCallable: define("function/is-callable", ["esnext.function.is-callable"]),
	    isConstructor: define("function/is-constructor", ["esnext.function.is-constructor"])
	  },
	  Iterator: {
	    concat: define("iterator/concat", ["esnext.iterator.concat", ...IteratorDependencies, ...CommonIterators]),
	    from: define("iterator/from", ["es.iterator.from", ...IteratorDependencies, ...CommonIterators]),
	    range: define("iterator/range", ["esnext.iterator.range", ...IteratorDependencies, "es.object.to-string"])
	  },
	  JSON: {
	    isRawJSON: define("json/is-raw-json", ["esnext.json.is-raw-json"]),
	    parse: define("json/parse", ["esnext.json.parse", "es.object.keys"]),
	    rawJSON: define("json/raw-json", ["esnext.json.raw-json", "es.object.create", "es.object.freeze"]),
	    stringify: define("json/stringify", ["es.json.stringify", "es.date.to-json"], "es.symbol")
	  },
	  Math: {
	    DEG_PER_RAD: define("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
	    RAD_PER_DEG: define("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
	    acosh: define("math/acosh", ["es.math.acosh"]),
	    asinh: define("math/asinh", ["es.math.asinh"]),
	    atanh: define("math/atanh", ["es.math.atanh"]),
	    cbrt: define("math/cbrt", ["es.math.cbrt"]),
	    clamp: define("math/clamp", ["esnext.math.clamp"]),
	    clz32: define("math/clz32", ["es.math.clz32"]),
	    cosh: define("math/cosh", ["es.math.cosh"]),
	    degrees: define("math/degrees", ["esnext.math.degrees"]),
	    expm1: define("math/expm1", ["es.math.expm1"]),
	    fround: define("math/fround", ["es.math.fround"]),
	    f16round: define("math/f16round", ["esnext.math.f16round"]),
	    fscale: define("math/fscale", ["esnext.math.fscale"]),
	    hypot: define("math/hypot", ["es.math.hypot"]),
	    iaddh: define("math/iaddh", ["esnext.math.iaddh"]),
	    imul: define("math/imul", ["es.math.imul"]),
	    imulh: define("math/imulh", ["esnext.math.imulh"]),
	    isubh: define("math/isubh", ["esnext.math.isubh"]),
	    log10: define("math/log10", ["es.math.log10"]),
	    log1p: define("math/log1p", ["es.math.log1p"]),
	    log2: define("math/log2", ["es.math.log2"]),
	    radians: define("math/radians", ["esnext.math.radians"]),
	    scale: define("math/scale", ["esnext.math.scale"]),
	    seededPRNG: define("math/seeded-prng", ["esnext.math.seeded-prng"]),
	    sign: define("math/sign", ["es.math.sign"]),
	    signbit: define("math/signbit", ["esnext.math.signbit"]),
	    sinh: define("math/sinh", ["es.math.sinh"]),
	    sumPrecise: define("math/sum-precise", ["esnext.math.sum-precise", "es.array.iterator"]),
	    tanh: define("math/tanh", ["es.math.tanh"]),
	    trunc: define("math/trunc", ["es.math.trunc"]),
	    umulh: define("math/umulh", ["esnext.math.umulh"])
	  },
	  Map: {
	    from: define("map/from", ["esnext.map.from", ...MapDependencies]),
	    groupBy: define("map/group-by", ["es.map.group-by", ...MapDependencies]),
	    keyBy: define("map/key-by", ["esnext.map.key-by", ...MapDependencies]),
	    of: define("map/of", ["esnext.map.of", ...MapDependencies])
	  },
	  Number: {
	    EPSILON: define("number/epsilon", ["es.number.epsilon"]),
	    MAX_SAFE_INTEGER: define("number/max-safe-integer", ["es.number.max-safe-integer"]),
	    MIN_SAFE_INTEGER: define("number/min-safe-integer", ["es.number.min-safe-integer"]),
	    fromString: define("number/from-string", ["esnext.number.from-string"]),
	    isFinite: define("number/is-finite", ["es.number.is-finite"]),
	    isInteger: define("number/is-integer", ["es.number.is-integer"]),
	    isNaN: define("number/is-nan", ["es.number.is-nan"]),
	    isSafeInteger: define("number/is-safe-integer", ["es.number.is-safe-integer"]),
	    parseFloat: define("number/parse-float", ["es.number.parse-float"]),
	    parseInt: define("number/parse-int", ["es.number.parse-int"]),
	    range: define("number/range", ["esnext.number.range", "es.object.to-string"])
	  },
	  Object: {
	    assign: define("object/assign", ["es.object.assign"]),
	    create: define("object/create", ["es.object.create"]),
	    defineProperties: define("object/define-properties", ["es.object.define-properties"]),
	    defineProperty: define("object/define-property", ["es.object.define-property"]),
	    entries: define("object/entries", ["es.object.entries"]),
	    freeze: define("object/freeze", ["es.object.freeze"]),
	    fromEntries: define("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
	    getOwnPropertyDescriptor: define("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: define("object/get-own-property-descriptors", ["es.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: define("object/get-own-property-names", ["es.object.get-own-property-names"]),
	    getOwnPropertySymbols: define("object/get-own-property-symbols", ["es.symbol"]),
	    getPrototypeOf: define("object/get-prototype-of", ["es.object.get-prototype-of"]),
	    groupBy: define("object/group-by", ["es.object.group-by", "es.object.create"]),
	    hasOwn: define("object/has-own", ["es.object.has-own"]),
	    is: define("object/is", ["es.object.is"]),
	    isExtensible: define("object/is-extensible", ["es.object.is-extensible"]),
	    isFrozen: define("object/is-frozen", ["es.object.is-frozen"]),
	    isSealed: define("object/is-sealed", ["es.object.is-sealed"]),
	    keys: define("object/keys", ["es.object.keys"]),
	    preventExtensions: define("object/prevent-extensions", ["es.object.prevent-extensions"]),
	    seal: define("object/seal", ["es.object.seal"]),
	    setPrototypeOf: define("object/set-prototype-of", ["es.object.set-prototype-of"]),
	    values: define("object/values", ["es.object.values"])
	  },
	  Promise: {
	    all: define(null, PromiseDependenciesWithIterators),
	    allSettled: define("promise/all-settled", ["es.promise.all-settled", ...PromiseDependenciesWithIterators]),
	    any: define("promise/any", ["es.promise.any", "es.aggregate-error", ...PromiseDependenciesWithIterators]),
	    race: define(null, PromiseDependenciesWithIterators),
	    try: define("promise/try", ["es.promise.try", ...PromiseDependencies]),
	    withResolvers: define("promise/with-resolvers", ["es.promise.with-resolvers", ...PromiseDependencies])
	  },
	  Reflect: {
	    apply: define("reflect/apply", ["es.reflect.apply"]),
	    construct: define("reflect/construct", ["es.reflect.construct"]),
	    defineMetadata: define("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
	    defineProperty: define("reflect/define-property", ["es.reflect.define-property"]),
	    deleteMetadata: define("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
	    deleteProperty: define("reflect/delete-property", ["es.reflect.delete-property"]),
	    get: define("reflect/get", ["es.reflect.get"]),
	    getMetadata: define("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
	    getMetadataKeys: define("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
	    getOwnMetadata: define("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
	    getOwnMetadataKeys: define("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
	    getOwnPropertyDescriptor: define("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: define("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
	    has: define("reflect/has", ["es.reflect.has"]),
	    hasMetadata: define("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
	    hasOwnMetadata: define("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
	    isExtensible: define("reflect/is-extensible", ["es.reflect.is-extensible"]),
	    metadata: define("reflect/metadata", ["esnext.reflect.metadata"]),
	    ownKeys: define("reflect/own-keys", ["es.reflect.own-keys"]),
	    preventExtensions: define("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
	    set: define("reflect/set", ["es.reflect.set"]),
	    setPrototypeOf: define("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
	  },
	  RegExp: {
	    escape: define("regexp/escape", ["esnext.regexp.escape"])
	  },
	  Set: {
	    from: define("set/from", ["esnext.set.from", ...SetDependencies]),
	    of: define("set/of", ["esnext.set.of", ...SetDependencies])
	  },
	  String: {
	    cooked: define("string/cooked", ["esnext.string.cooked"]),
	    dedent: define("string/dedent", ["esnext.string.dedent", "es.string.from-code-point", "es.weak-map"]),
	    fromCodePoint: define("string/from-code-point", ["es.string.from-code-point"]),
	    raw: define("string/raw", ["es.string.raw"])
	  },
	  Symbol: {
	    asyncDispose: define("symbol/async-dispose", ["esnext.symbol.async-dispose", "esnext.async-iterator.async-dispose"]),
	    asyncIterator: define("symbol/async-iterator", ["es.symbol.async-iterator"]),
	    customMatcher: define("symbol/custom-matcher", ["esnext.symbol.custom-matcher"]),
	    dispose: define("symbol/dispose", ["esnext.symbol.dispose", "esnext.iterator.dispose"]),
	    for: define("symbol/for", [], "es.symbol"),
	    hasInstance: define("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
	    isConcatSpreadable: define("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
	    isRegistered: define("symbol/is-registered", ["esnext.symbol.is-registered", "es.symbol"]),
	    isRegisteredSymbol: define("symbol/is-registered-symbol", ["esnext.symbol.is-registered-symbol", "es.symbol"]),
	    isWellKnown: define("symbol/is-well-known", ["esnext.symbol.is-well-known", "es.symbol"]),
	    isWellKnownSymbol: define("symbol/is-well-known-symbol", ["esnext.symbol.is-well-known-symbol", "es.symbol"]),
	    iterator: define("symbol/iterator", ["es.symbol.iterator", ...CommonIteratorsWithTag]),
	    keyFor: define("symbol/key-for", [], "es.symbol"),
	    match: define("symbol/match", ["es.symbol.match", "es.string.match"]),
	    matcher: define("symbol/matcher", ["esnext.symbol.matcher"]),
	    matchAll: define("symbol/match-all", ["es.symbol.match-all", "es.string.match-all"]),
	    metadata: define("symbol/metadata", DecoratorMetadataDependencies),
	    metadataKey: define("symbol/metadata-key", ["esnext.symbol.metadata-key"]),
	    observable: define("symbol/observable", ["esnext.symbol.observable"]),
	    patternMatch: define("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
	    replace: define("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
	    search: define("symbol/search", ["es.symbol.search", "es.string.search"]),
	    species: define("symbol/species", ["es.symbol.species", "es.array.species"]),
	    split: define("symbol/split", ["es.symbol.split", "es.string.split"]),
	    toPrimitive: define("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
	    toStringTag: define("symbol/to-string-tag", ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"]),
	    unscopables: define("symbol/unscopables", ["es.symbol.unscopables"])
	  },
	  URL: {
	    canParse: define("url/can-parse", ["web.url.can-parse", "web.url"]),
	    parse: define("url/parse", ["web.url.parse", "web.url"])
	  },
	  WeakMap: {
	    from: define("weak-map/from", ["esnext.weak-map.from", ...WeakMapDependencies]),
	    of: define("weak-map/of", ["esnext.weak-map.of", ...WeakMapDependencies])
	  },
	  WeakSet: {
	    from: define("weak-set/from", ["esnext.weak-set.from", ...WeakSetDependencies]),
	    of: define("weak-set/of", ["esnext.weak-set.of", ...WeakSetDependencies])
	  },
	  Int8Array: TypedArrayStaticMethods("es.typed-array.int8-array"),
	  Uint8Array: _extends({
	    fromBase64: define(null, ["esnext.uint8-array.from-base64", ...TypedArrayDependencies]),
	    fromHex: define(null, ["esnext.uint8-array.from-hex", ...TypedArrayDependencies])
	  }, TypedArrayStaticMethods("es.typed-array.uint8-array")),
	  Uint8ClampedArray: TypedArrayStaticMethods("es.typed-array.uint8-clamped-array"),
	  Int16Array: TypedArrayStaticMethods("es.typed-array.int16-array"),
	  Uint16Array: TypedArrayStaticMethods("es.typed-array.uint16-array"),
	  Int32Array: TypedArrayStaticMethods("es.typed-array.int32-array"),
	  Uint32Array: TypedArrayStaticMethods("es.typed-array.uint32-array"),
	  Float32Array: TypedArrayStaticMethods("es.typed-array.float32-array"),
	  Float64Array: TypedArrayStaticMethods("es.typed-array.float64-array"),
	  WebAssembly: {
	    CompileError: define(null, ErrorDependencies),
	    LinkError: define(null, ErrorDependencies),
	    RuntimeError: define(null, ErrorDependencies)
	  }
	};
	builtInDefinitions.StaticProperties = StaticProperties;
	["AggregateError", "EvalError", "RangeError", "ReferenceError", "SuppressedError", "SyntaxError", "TypeError", "URIError"].forEach((ERROR_SUBCLASS) => {
	  StaticProperties[ERROR_SUBCLASS] = StaticProperties.Error;
	});
	const InstanceProperties = {
	  asIndexedPairs: define(null, ["esnext.async-iterator.as-indexed-pairs", ...AsyncIteratorDependencies, "esnext.iterator.as-indexed-pairs", ...IteratorDependencies]),
	  at: define("instance/at", [
	    // TODO: We should introduce overloaded instance methods definition
	    // Before that is implemented, the `esnext.string.at` must be the first
	    // In pure mode, the provider resolves the descriptor as a "pure" `esnext.string.at`
	    // and treats the compat-data of `esnext.string.at` as the compat-data of
	    // pure import `instance/at`. The first polyfill here should have the lowest corejs
	    // supported versions.
	    "esnext.string.at",
	    "es.string.at-alternative",
	    "es.array.at"
	  ]),
	  anchor: define(null, ["es.string.anchor"]),
	  big: define(null, ["es.string.big"]),
	  bind: define("instance/bind", ["es.function.bind"]),
	  blink: define(null, ["es.string.blink"]),
	  bold: define(null, ["es.string.bold"]),
	  codePointAt: define("instance/code-point-at", ["es.string.code-point-at"]),
	  codePoints: define("instance/code-points", ["esnext.string.code-points"]),
	  concat: define("instance/concat", ["es.array.concat"], void 0, ["String"]),
	  copyWithin: define("instance/copy-within", ["es.array.copy-within"]),
	  demethodize: define("instance/demethodize", ["esnext.function.demethodize"]),
	  description: define(null, ["es.symbol", "es.symbol.description"]),
	  dotAll: define(null, ["es.regexp.dot-all"]),
	  drop: define(null, ["es.iterator.drop", ...IteratorDependencies, "esnext.async-iterator.drop", ...AsyncIteratorDependencies]),
	  endsWith: define("instance/ends-with", ["es.string.ends-with"]),
	  entries: define("instance/entries", ArrayNatureIteratorsWithTag),
	  every: define("instance/every", [
	    "es.array.every",
	    "es.iterator.every",
	    ...IteratorDependencies
	    // TODO: add async iterator dependencies when we support sub-dependencies
	    // esnext.async-iterator.every depends on es.promise
	    // but we don't want to pull es.promise when esnext.async-iterator is disabled
	    //
	    // "esnext.async-iterator.every",
	    // ...AsyncIteratorDependencies
	  ]),
	  exec: define(null, ["es.regexp.exec"]),
	  fill: define("instance/fill", ["es.array.fill"]),
	  filter: define("instance/filter", [
	    "es.array.filter",
	    "es.iterator.filter",
	    ...IteratorDependencies
	    // "esnext.async-iterator.filter",
	  ]),
	  filterReject: define("instance/filterReject", ["esnext.array.filter-reject"]),
	  finally: define(null, ["es.promise.finally", ...PromiseDependencies]),
	  find: define("instance/find", [
	    "es.array.find",
	    "es.iterator.find",
	    ...IteratorDependencies
	    // "esnext.async-iterator.find",
	  ]),
	  findIndex: define("instance/find-index", ["es.array.find-index"]),
	  findLast: define("instance/find-last", ["es.array.find-last"]),
	  findLastIndex: define("instance/find-last-index", ["es.array.find-last-index"]),
	  fixed: define(null, ["es.string.fixed"]),
	  flags: define("instance/flags", ["es.regexp.flags"]),
	  flatMap: define("instance/flat-map", [
	    "es.array.flat-map",
	    "es.array.unscopables.flat-map",
	    "es.iterator.flat-map",
	    ...IteratorDependencies
	    // "esnext.async-iterator.flat-map",
	  ]),
	  flat: define("instance/flat", ["es.array.flat", "es.array.unscopables.flat"]),
	  getFloat16: define(null, ["esnext.data-view.get-float16", ...DataViewDependencies]),
	  getUint8Clamped: define(null, ["esnext.data-view.get-uint8-clamped", ...DataViewDependencies]),
	  getYear: define(null, ["es.date.get-year"]),
	  group: define("instance/group", ["esnext.array.group"]),
	  groupBy: define("instance/group-by", ["esnext.array.group-by"]),
	  groupByToMap: define("instance/group-by-to-map", ["esnext.array.group-by-to-map", "es.map", "es.object.to-string"]),
	  groupToMap: define("instance/group-to-map", ["esnext.array.group-to-map", "es.map", "es.object.to-string"]),
	  fontcolor: define(null, ["es.string.fontcolor"]),
	  fontsize: define(null, ["es.string.fontsize"]),
	  forEach: define("instance/for-each", [
	    "es.array.for-each",
	    "es.iterator.for-each",
	    ...IteratorDependencies,
	    // "esnext.async-iterator.for-each",
	    "web.dom-collections.for-each"
	  ]),
	  includes: define("instance/includes", ["es.array.includes", "es.string.includes"]),
	  indexed: define(null, ["esnext.async-iterator.indexed", ...AsyncIteratorDependencies, "esnext.iterator.indexed", ...IteratorDependencies]),
	  indexOf: define("instance/index-of", ["es.array.index-of"]),
	  isWellFormed: define("instance/is-well-formed", ["es.string.is-well-formed"]),
	  italic: define(null, ["es.string.italics"]),
	  join: define(null, ["es.array.join"]),
	  keys: define("instance/keys", ArrayNatureIteratorsWithTag),
	  lastIndex: define(null, ["esnext.array.last-index"]),
	  lastIndexOf: define("instance/last-index-of", ["es.array.last-index-of"]),
	  lastItem: define(null, ["esnext.array.last-item"]),
	  link: define(null, ["es.string.link"]),
	  map: define("instance/map", [
	    "es.array.map",
	    "es.iterator.map",
	    ...IteratorDependencies
	    // "esnext.async-iterator.map",
	  ]),
	  match: define(null, ["es.string.match", "es.regexp.exec"]),
	  matchAll: define("instance/match-all", ["es.string.match-all", "es.regexp.exec"]),
	  name: define(null, ["es.function.name"]),
	  padEnd: define("instance/pad-end", ["es.string.pad-end"]),
	  padStart: define("instance/pad-start", ["es.string.pad-start"]),
	  push: define("instance/push", ["es.array.push"]),
	  reduce: define("instance/reduce", [
	    "es.array.reduce",
	    "es.iterator.reduce",
	    ...IteratorDependencies
	    // "esnext.async-iterator.reduce",
	  ]),
	  reduceRight: define("instance/reduce-right", ["es.array.reduce-right"]),
	  repeat: define("instance/repeat", ["es.string.repeat"]),
	  replace: define(null, ["es.string.replace", "es.regexp.exec"]),
	  replaceAll: define("instance/replace-all", ["es.string.replace-all", "es.string.replace", "es.regexp.exec"]),
	  reverse: define("instance/reverse", ["es.array.reverse"]),
	  search: define(null, ["es.string.search", "es.regexp.exec"]),
	  setFloat16: define(null, ["esnext.data-view.set-float16", ...DataViewDependencies]),
	  setUint8Clamped: define(null, ["esnext.data-view.set-uint8-clamped", ...DataViewDependencies]),
	  setYear: define(null, ["es.date.set-year"]),
	  slice: define("instance/slice", ["es.array.slice"]),
	  small: define(null, ["es.string.small"]),
	  some: define("instance/some", [
	    "es.array.some",
	    "es.iterator.some",
	    ...IteratorDependencies
	    // "esnext.async-iterator.some",
	  ]),
	  sort: define("instance/sort", ["es.array.sort"]),
	  splice: define("instance/splice", ["es.array.splice"]),
	  split: define(null, ["es.string.split", "es.regexp.exec"]),
	  startsWith: define("instance/starts-with", ["es.string.starts-with"]),
	  sticky: define(null, ["es.regexp.sticky"]),
	  strike: define(null, ["es.string.strike"]),
	  sub: define(null, ["es.string.sub"]),
	  substr: define(null, ["es.string.substr"]),
	  sup: define(null, ["es.string.sup"]),
	  take: define(null, ["es.iterator.take", ...IteratorDependencies, "esnext.async-iterator.take", ...AsyncIteratorDependencies]),
	  test: define(null, ["es.regexp.test", "es.regexp.exec"]),
	  toArray: define(null, ["es.iterator.to-array", ...IteratorDependencies, "esnext.async-iterator.to-array", ...AsyncIteratorDependencies]),
	  toAsync: define(null, ["esnext.iterator.to-async", ...IteratorDependencies, ...AsyncIteratorDependencies, ...AsyncIteratorProblemMethods]),
	  toExponential: define(null, ["es.number.to-exponential"]),
	  toFixed: define(null, ["es.number.to-fixed"]),
	  toGMTString: define(null, ["es.date.to-gmt-string"]),
	  toISOString: define(null, ["es.date.to-iso-string"]),
	  toJSON: define(null, ["es.date.to-json"]),
	  toPrecision: define(null, ["es.number.to-precision"]),
	  toReversed: define("instance/to-reversed", ["es.array.to-reversed"]),
	  toSorted: define("instance/to-sorted", ["es.array.to-sorted", "es.array.sort"]),
	  toSpliced: define("instance/to-spliced", ["es.array.to-spliced"]),
	  toString: define(null, ["es.object.to-string", "es.error.to-string", "es.date.to-string", "es.regexp.to-string"]),
	  toWellFormed: define("instance/to-well-formed", ["es.string.to-well-formed"]),
	  trim: define("instance/trim", ["es.string.trim"]),
	  trimEnd: define("instance/trim-end", ["es.string.trim-end"]),
	  trimLeft: define("instance/trim-left", ["es.string.trim-start"]),
	  trimRight: define("instance/trim-right", ["es.string.trim-end"]),
	  trimStart: define("instance/trim-start", ["es.string.trim-start"]),
	  uniqueBy: define("instance/unique-by", ["esnext.array.unique-by", "es.map"]),
	  unshift: define("instance/unshift", ["es.array.unshift"]),
	  unThis: define("instance/un-this", ["esnext.function.un-this"]),
	  values: define("instance/values", ArrayNatureIteratorsWithTag),
	  with: define("instance/with", ["es.array.with"]),
	  __defineGetter__: define(null, ["es.object.define-getter"]),
	  __defineSetter__: define(null, ["es.object.define-setter"]),
	  __lookupGetter__: define(null, ["es.object.lookup-getter"]),
	  __lookupSetter__: define(null, ["es.object.lookup-setter"]),
	  ["__proto__"]: define(null, ["es.object.proto"])
	};
	builtInDefinitions.InstanceProperties = InstanceProperties;
	return builtInDefinitions;
}

var babelRuntimeCorejs3Paths = {};

var hasRequiredBabelRuntimeCorejs3Paths;

function requireBabelRuntimeCorejs3Paths () {
	if (hasRequiredBabelRuntimeCorejs3Paths) return babelRuntimeCorejs3Paths;
	hasRequiredBabelRuntimeCorejs3Paths = 1;
	babelRuntimeCorejs3Paths.__esModule = true;
	babelRuntimeCorejs3Paths.stable = babelRuntimeCorejs3Paths.proposals = void 0;
	const stable = /* @__PURE__ */ new Set(["array", "array/from", "array/is-array", "array/of", "clear-immediate", "date/now", "instance/bind", "instance/code-point-at", "instance/concat", "instance/copy-within", "instance/ends-with", "instance/entries", "instance/every", "instance/fill", "instance/filter", "instance/find", "instance/find-index", "instance/flags", "instance/flat", "instance/flat-map", "instance/for-each", "instance/includes", "instance/index-of", "instance/keys", "instance/last-index-of", "instance/map", "instance/pad-end", "instance/pad-start", "instance/reduce", "instance/reduce-right", "instance/repeat", "instance/reverse", "instance/slice", "instance/some", "instance/sort", "instance/splice", "instance/starts-with", "instance/trim", "instance/trim-end", "instance/trim-left", "instance/trim-right", "instance/trim-start", "instance/values", "json/stringify", "map", "math/acosh", "math/asinh", "math/atanh", "math/cbrt", "math/clz32", "math/cosh", "math/expm1", "math/fround", "math/hypot", "math/imul", "math/log10", "math/log1p", "math/log2", "math/sign", "math/sinh", "math/tanh", "math/trunc", "number/epsilon", "number/is-finite", "number/is-integer", "number/is-nan", "number/is-safe-integer", "number/max-safe-integer", "number/min-safe-integer", "number/parse-float", "number/parse-int", "object/assign", "object/create", "object/define-properties", "object/define-property", "object/entries", "object/freeze", "object/from-entries", "object/get-own-property-descriptor", "object/get-own-property-descriptors", "object/get-own-property-names", "object/get-own-property-symbols", "object/get-prototype-of", "object/is", "object/is-extensible", "object/is-frozen", "object/is-sealed", "object/keys", "object/prevent-extensions", "object/seal", "object/set-prototype-of", "object/values", "parse-float", "parse-int", "promise", "queue-microtask", "reflect/apply", "reflect/construct", "reflect/define-property", "reflect/delete-property", "reflect/get", "reflect/get-own-property-descriptor", "reflect/get-prototype-of", "reflect/has", "reflect/is-extensible", "reflect/own-keys", "reflect/prevent-extensions", "reflect/set", "reflect/set-prototype-of", "set", "set-immediate", "set-interval", "set-timeout", "string/from-code-point", "string/raw", "symbol", "symbol/async-iterator", "symbol/for", "symbol/has-instance", "symbol/is-concat-spreadable", "symbol/iterator", "symbol/key-for", "symbol/match", "symbol/replace", "symbol/search", "symbol/species", "symbol/split", "symbol/to-primitive", "symbol/to-string-tag", "symbol/unscopables", "url", "url-search-params", "weak-map", "weak-set"]);
	babelRuntimeCorejs3Paths.stable = stable;
	const proposals = /* @__PURE__ */ new Set([...stable, "aggregate-error", "composite-key", "composite-symbol", "global-this", "instance/at", "instance/code-points", "instance/match-all", "instance/replace-all", "math/clamp", "math/degrees", "math/deg-per-rad", "math/fscale", "math/iaddh", "math/imulh", "math/isubh", "math/rad-per-deg", "math/radians", "math/scale", "math/seeded-prng", "math/signbit", "math/umulh", "number/from-string", "observable", "reflect/define-metadata", "reflect/delete-metadata", "reflect/get-metadata", "reflect/get-metadata-keys", "reflect/get-own-metadata", "reflect/get-own-metadata-keys", "reflect/has-metadata", "reflect/has-own-metadata", "reflect/metadata", "symbol/dispose", "symbol/observable", "symbol/pattern-match"]);
	babelRuntimeCorejs3Paths.proposals = proposals;
	return babelRuntimeCorejs3Paths;
}

var usageFilters = {};

var hasRequiredUsageFilters;

function requireUsageFilters () {
	if (hasRequiredUsageFilters) return usageFilters;
	hasRequiredUsageFilters = 1;
	usageFilters.__esModule = true;
	usageFilters.default = canSkipPolyfill;
	var _babel = _interopRequireWildcard(require$$0$b);
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	const {
	  types: t
	} = _babel.default || _babel;
	function canSkipPolyfill(desc, path) {
	  const {
	    node,
	    parent
	  } = path;
	  switch (desc.name) {
	    case "es.string.split": {
	      if (!t.isCallExpression(parent, {
	        callee: node
	      })) return false;
	      if (parent.arguments.length < 1) return true;
	      const splitter = parent.arguments[0];
	      return t.isStringLiteral(splitter) || t.isTemplateLiteral(splitter);
	    }
	  }
	}
	return usageFilters;
}

var utils = {};

var require$$0 = {
	"core-js": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/actual": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.metadata",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.group-by",
	"esnext.math.f16round",
	"esnext.math.sum-precise",
	"esnext.object.has-own",
	"esnext.object.group-by",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose",
	"esnext.symbol.metadata",
	"esnext.typed-array.at",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/actual/aggregate-error": [
],
	"core-js/actual/array": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with"
],
	"core-js/actual/array-buffer": [
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/actual/array-buffer/constructor": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/actual/array-buffer/detached": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"esnext.array-buffer.detached"
],
	"core-js/actual/array-buffer/is-view": [
	"es.array-buffer.is-view"
],
	"core-js/actual/array-buffer/slice": [
	"es.array-buffer.slice"
],
	"core-js/actual/array-buffer/transfer": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer",
	"esnext.array-buffer.transfer"
],
	"core-js/actual/array-buffer/transfer-to-fixed-length": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer-to-fixed-length",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/actual/array/at": [
	"es.array.at"
],
	"core-js/actual/array/concat": [
	"es.array.concat"
],
	"core-js/actual/array/copy-within": [
	"es.array.copy-within"
],
	"core-js/actual/array/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/every": [
	"es.array.every"
],
	"core-js/actual/array/fill": [
	"es.array.fill"
],
	"core-js/actual/array/filter": [
	"es.array.filter"
],
	"core-js/actual/array/find": [
	"es.array.find"
],
	"core-js/actual/array/find-index": [
	"es.array.find-index"
],
	"core-js/actual/array/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/actual/array/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/actual/array/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/actual/array/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/actual/array/for-each": [
	"es.array.for-each"
],
	"core-js/actual/array/from": [
	"es.array.from",
	"es.string.iterator"
],
	"core-js/actual/array/from-async": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async"
],
	"core-js/actual/array/group": [
	"esnext.array.group"
],
	"core-js/actual/array/group-by": [
	"esnext.array.group-by"
],
	"core-js/actual/array/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/actual/array/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/actual/array/includes": [
	"es.array.includes"
],
	"core-js/actual/array/index-of": [
	"es.array.index-of"
],
	"core-js/actual/array/is-array": [
	"es.array.is-array"
],
	"core-js/actual/array/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/join": [
	"es.array.join"
],
	"core-js/actual/array/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/actual/array/map": [
	"es.array.map"
],
	"core-js/actual/array/of": [
	"es.array.of"
],
	"core-js/actual/array/push": [
	"es.array.push"
],
	"core-js/actual/array/reduce": [
	"es.array.reduce"
],
	"core-js/actual/array/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/actual/array/reverse": [
	"es.array.reverse"
],
	"core-js/actual/array/slice": [
	"es.array.slice"
],
	"core-js/actual/array/some": [
	"es.array.some"
],
	"core-js/actual/array/sort": [
	"es.array.sort"
],
	"core-js/actual/array/splice": [
	"es.array.splice"
],
	"core-js/actual/array/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/actual/array/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/actual/array/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/actual/array/unshift": [
	"es.array.unshift"
],
	"core-js/actual/array/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/virtual": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.includes",
	"es.array.index-of",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.map",
	"es.object.to-string",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with"
],
	"core-js/actual/array/virtual/at": [
	"es.array.at"
],
	"core-js/actual/array/virtual/concat": [
	"es.array.concat"
],
	"core-js/actual/array/virtual/copy-within": [
	"es.array.copy-within"
],
	"core-js/actual/array/virtual/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/virtual/every": [
	"es.array.every"
],
	"core-js/actual/array/virtual/fill": [
	"es.array.fill"
],
	"core-js/actual/array/virtual/filter": [
	"es.array.filter"
],
	"core-js/actual/array/virtual/find": [
	"es.array.find"
],
	"core-js/actual/array/virtual/find-index": [
	"es.array.find-index"
],
	"core-js/actual/array/virtual/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/actual/array/virtual/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/actual/array/virtual/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/actual/array/virtual/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/actual/array/virtual/for-each": [
	"es.array.for-each"
],
	"core-js/actual/array/virtual/group": [
	"esnext.array.group"
],
	"core-js/actual/array/virtual/group-by": [
	"esnext.array.group-by"
],
	"core-js/actual/array/virtual/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/actual/array/virtual/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/actual/array/virtual/includes": [
	"es.array.includes"
],
	"core-js/actual/array/virtual/index-of": [
	"es.array.index-of"
],
	"core-js/actual/array/virtual/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/virtual/join": [
	"es.array.join"
],
	"core-js/actual/array/virtual/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/virtual/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/actual/array/virtual/map": [
	"es.array.map"
],
	"core-js/actual/array/virtual/push": [
	"es.array.push"
],
	"core-js/actual/array/virtual/reduce": [
	"es.array.reduce"
],
	"core-js/actual/array/virtual/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/actual/array/virtual/reverse": [
	"es.array.reverse"
],
	"core-js/actual/array/virtual/slice": [
	"es.array.slice"
],
	"core-js/actual/array/virtual/some": [
	"es.array.some"
],
	"core-js/actual/array/virtual/sort": [
	"es.array.sort"
],
	"core-js/actual/array/virtual/splice": [
	"es.array.splice"
],
	"core-js/actual/array/virtual/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/actual/array/virtual/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/actual/array/virtual/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/actual/array/virtual/unshift": [
	"es.array.unshift"
],
	"core-js/actual/array/virtual/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/actual/array/virtual/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/actual/array/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/actual/async-disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/actual/async-disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/actual/async-iterator": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/actual/async-iterator/async-dispose": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.async-dispose"
],
	"core-js/actual/async-iterator/drop": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop"
],
	"core-js/actual/async-iterator/every": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.every"
],
	"core-js/actual/async-iterator/filter": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.filter"
],
	"core-js/actual/async-iterator/find": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.find"
],
	"core-js/actual/async-iterator/flat-map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.flat-map"
],
	"core-js/actual/async-iterator/for-each": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.for-each"
],
	"core-js/actual/async-iterator/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/actual/async-iterator/map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.map"
],
	"core-js/actual/async-iterator/reduce": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.reduce"
],
	"core-js/actual/async-iterator/some": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.some"
],
	"core-js/actual/async-iterator/take": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.take"
],
	"core-js/actual/async-iterator/to-array": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.to-array"
],
	"core-js/actual/atob": [
	"es.error.to-string",
	"es.object.to-string",
	"web.atob",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/actual/btoa": [
	"es.error.to-string",
	"es.object.to-string",
	"web.btoa",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/actual/clear-immediate": [
	"web.immediate"
],
	"core-js/actual/data-view": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.object.to-string",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16"
],
	"core-js/actual/data-view/get-float16": [
	"es.data-view.get-float16",
	"esnext.data-view.get-float16"
],
	"core-js/actual/data-view/set-float16": [
	"es.data-view.set-float16",
	"esnext.data-view.set-float16"
],
	"core-js/actual/date": [
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string"
],
	"core-js/actual/date/get-year": [
	"es.date.get-year"
],
	"core-js/actual/date/now": [
	"es.date.now"
],
	"core-js/actual/date/set-year": [
	"es.date.set-year"
],
	"core-js/actual/date/to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/actual/date/to-iso-string": [
	"es.date.to-iso-string",
	"es.date.to-json"
],
	"core-js/actual/date/to-json": [
	"es.date.to-json"
],
	"core-js/actual/date/to-primitive": [
	"es.date.to-primitive"
],
	"core-js/actual/date/to-string": [
	"es.date.to-string"
],
	"core-js/actual/disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/actual/disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/actual/dom-collections": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator"
],
	"core-js/actual/dom-collections/for-each": [
	"web.dom-collections.for-each"
],
	"core-js/actual/dom-collections/iterator": [
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/actual/dom-exception": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/actual/dom-exception/constructor": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack"
],
	"core-js/actual/dom-exception/to-string-tag": [
	"web.dom-exception.to-string-tag"
],
	"core-js/actual/error": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/actual/error/constructor": [
	"es.error.cause"
],
	"core-js/actual/error/is-error": [
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/actual/error/to-string": [
	"es.error.to-string"
],
	"core-js/actual/escape": [
	"es.escape"
],
	"core-js/actual/function": [
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"esnext.function.metadata"
],
	"core-js/actual/function/bind": [
	"es.function.bind"
],
	"core-js/actual/function/has-instance": [
	"es.function.has-instance"
],
	"core-js/actual/function/metadata": [
	"esnext.function.metadata"
],
	"core-js/actual/function/name": [
	"es.function.name"
],
	"core-js/actual/function/virtual": [
	"es.function.bind"
],
	"core-js/actual/function/virtual/bind": [
	"es.function.bind"
],
	"core-js/actual/get-iterator": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/get-iterator-method": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/global-this": [
	"es.global-this"
],
	"core-js/actual/instance/at": [
	"es.array.at",
	"es.string.at-alternative"
],
	"core-js/actual/instance/bind": [
	"es.function.bind"
],
	"core-js/actual/instance/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/actual/instance/concat": [
	"es.array.concat"
],
	"core-js/actual/instance/copy-within": [
	"es.array.copy-within"
],
	"core-js/actual/instance/ends-with": [
	"es.string.ends-with"
],
	"core-js/actual/instance/entries": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/actual/instance/every": [
	"es.array.every"
],
	"core-js/actual/instance/fill": [
	"es.array.fill"
],
	"core-js/actual/instance/filter": [
	"es.array.filter"
],
	"core-js/actual/instance/find": [
	"es.array.find"
],
	"core-js/actual/instance/find-index": [
	"es.array.find-index"
],
	"core-js/actual/instance/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/actual/instance/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/actual/instance/flags": [
	"es.regexp.flags"
],
	"core-js/actual/instance/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/actual/instance/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/actual/instance/for-each": [
	"es.array.for-each",
	"web.dom-collections.for-each"
],
	"core-js/actual/instance/group": [
	"esnext.array.group"
],
	"core-js/actual/instance/group-by": [
	"esnext.array.group-by"
],
	"core-js/actual/instance/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/actual/instance/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/actual/instance/includes": [
	"es.array.includes",
	"es.string.includes"
],
	"core-js/actual/instance/index-of": [
	"es.array.index-of"
],
	"core-js/actual/instance/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/actual/instance/keys": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/actual/instance/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/actual/instance/map": [
	"es.array.map"
],
	"core-js/actual/instance/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/actual/instance/pad-end": [
	"es.string.pad-end"
],
	"core-js/actual/instance/pad-start": [
	"es.string.pad-start"
],
	"core-js/actual/instance/push": [
	"es.array.push"
],
	"core-js/actual/instance/reduce": [
	"es.array.reduce"
],
	"core-js/actual/instance/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/actual/instance/repeat": [
	"es.string.repeat"
],
	"core-js/actual/instance/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/actual/instance/reverse": [
	"es.array.reverse"
],
	"core-js/actual/instance/slice": [
	"es.array.slice"
],
	"core-js/actual/instance/some": [
	"es.array.some"
],
	"core-js/actual/instance/sort": [
	"es.array.sort"
],
	"core-js/actual/instance/splice": [
	"es.array.splice"
],
	"core-js/actual/instance/starts-with": [
	"es.string.starts-with"
],
	"core-js/actual/instance/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/actual/instance/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/actual/instance/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/actual/instance/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/actual/instance/trim": [
	"es.string.trim"
],
	"core-js/actual/instance/trim-end": [
	"es.string.trim-end"
],
	"core-js/actual/instance/trim-left": [
	"es.string.trim-start"
],
	"core-js/actual/instance/trim-right": [
	"es.string.trim-end"
],
	"core-js/actual/instance/trim-start": [
	"es.string.trim-start"
],
	"core-js/actual/instance/unshift": [
	"es.array.unshift"
],
	"core-js/actual/instance/values": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/actual/instance/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/actual/is-iterable": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/iterator": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/actual/iterator/dispose": [
	"esnext.iterator.dispose"
],
	"core-js/actual/iterator/drop": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.drop"
],
	"core-js/actual/iterator/every": [
	"es.iterator.constructor",
	"es.iterator.every",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.every"
],
	"core-js/actual/iterator/filter": [
	"es.iterator.constructor",
	"es.iterator.filter",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.filter"
],
	"core-js/actual/iterator/find": [
	"es.iterator.constructor",
	"es.iterator.find",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.find"
],
	"core-js/actual/iterator/flat-map": [
	"es.iterator.constructor",
	"es.iterator.flat-map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.flat-map"
],
	"core-js/actual/iterator/for-each": [
	"es.iterator.constructor",
	"es.iterator.for-each",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.for-each"
],
	"core-js/actual/iterator/from": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/actual/iterator/map": [
	"es.iterator.constructor",
	"es.iterator.map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.map"
],
	"core-js/actual/iterator/reduce": [
	"es.iterator.constructor",
	"es.iterator.reduce",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.reduce"
],
	"core-js/actual/iterator/some": [
	"es.iterator.constructor",
	"es.iterator.some",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.some"
],
	"core-js/actual/iterator/take": [
	"es.iterator.constructor",
	"es.iterator.take",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.take"
],
	"core-js/actual/iterator/to-array": [
	"es.iterator.constructor",
	"es.iterator.to-array",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.to-array"
],
	"core-js/actual/iterator/to-async": [
	"es.iterator.constructor",
	"es.object.to-string",
	"es.promise",
	"esnext.iterator.constructor",
	"esnext.iterator.to-async"
],
	"core-js/actual/json": [
	"es.date.to-json",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.object.create",
	"es.object.freeze",
	"es.object.keys",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json"
],
	"core-js/actual/json/is-raw-json": [
	"esnext.json.is-raw-json"
],
	"core-js/actual/json/parse": [
	"es.object.keys",
	"esnext.json.parse"
],
	"core-js/actual/json/raw-json": [
	"es.object.create",
	"es.object.freeze",
	"esnext.json.raw-json"
],
	"core-js/actual/json/stringify": [
	"es.date.to-json",
	"es.json.stringify"
],
	"core-js/actual/json/to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/actual/map": [
	"es.array.iterator",
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.map.group-by",
	"web.dom-collections.iterator"
],
	"core-js/actual/map/group-by": [
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"esnext.map.group-by"
],
	"core-js/actual/math": [
	"es.array.iterator",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"esnext.math.f16round",
	"esnext.math.sum-precise"
],
	"core-js/actual/math/acosh": [
	"es.math.acosh"
],
	"core-js/actual/math/asinh": [
	"es.math.asinh"
],
	"core-js/actual/math/atanh": [
	"es.math.atanh"
],
	"core-js/actual/math/cbrt": [
	"es.math.cbrt"
],
	"core-js/actual/math/clz32": [
	"es.math.clz32"
],
	"core-js/actual/math/cosh": [
	"es.math.cosh"
],
	"core-js/actual/math/expm1": [
	"es.math.expm1"
],
	"core-js/actual/math/f16round": [
	"es.math.f16round",
	"esnext.math.f16round"
],
	"core-js/actual/math/fround": [
	"es.math.fround"
],
	"core-js/actual/math/hypot": [
	"es.math.hypot"
],
	"core-js/actual/math/imul": [
	"es.math.imul"
],
	"core-js/actual/math/log10": [
	"es.math.log10"
],
	"core-js/actual/math/log1p": [
	"es.math.log1p"
],
	"core-js/actual/math/log2": [
	"es.math.log2"
],
	"core-js/actual/math/sign": [
	"es.math.sign"
],
	"core-js/actual/math/sinh": [
	"es.math.sinh"
],
	"core-js/actual/math/sum-precise": [
	"es.array.iterator",
	"esnext.math.sum-precise"
],
	"core-js/actual/math/tanh": [
	"es.math.tanh"
],
	"core-js/actual/math/to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/actual/math/trunc": [
	"es.math.trunc"
],
	"core-js/actual/number": [
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/actual/number/constructor": [
	"es.number.constructor"
],
	"core-js/actual/number/epsilon": [
	"es.number.epsilon"
],
	"core-js/actual/number/is-finite": [
	"es.number.is-finite"
],
	"core-js/actual/number/is-integer": [
	"es.number.is-integer"
],
	"core-js/actual/number/is-nan": [
	"es.number.is-nan"
],
	"core-js/actual/number/is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/actual/number/max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/actual/number/min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/actual/number/parse-float": [
	"es.number.parse-float"
],
	"core-js/actual/number/parse-int": [
	"es.number.parse-int"
],
	"core-js/actual/number/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/actual/number/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/actual/number/to-precision": [
	"es.number.to-precision"
],
	"core-js/actual/number/virtual": [
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/actual/number/virtual/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/actual/number/virtual/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/actual/number/virtual/to-precision": [
	"es.number.to-precision"
],
	"core-js/actual/object": [
	"es.symbol",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.reflect.to-string-tag",
	"esnext.object.group-by",
	"web.dom-collections.iterator"
],
	"core-js/actual/object/assign": [
	"es.object.assign"
],
	"core-js/actual/object/create": [
	"es.object.create"
],
	"core-js/actual/object/define-getter": [
	"es.object.define-getter"
],
	"core-js/actual/object/define-properties": [
	"es.object.define-properties"
],
	"core-js/actual/object/define-property": [
	"es.object.define-property"
],
	"core-js/actual/object/define-setter": [
	"es.object.define-setter"
],
	"core-js/actual/object/entries": [
	"es.object.entries"
],
	"core-js/actual/object/freeze": [
	"es.object.freeze"
],
	"core-js/actual/object/from-entries": [
	"es.array.iterator",
	"es.object.from-entries",
	"web.dom-collections.iterator"
],
	"core-js/actual/object/get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/actual/object/get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/actual/object/get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/actual/object/get-own-property-symbols": [
	"es.symbol"
],
	"core-js/actual/object/get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/actual/object/group-by": [
	"es.object.create",
	"es.object.group-by",
	"esnext.object.group-by"
],
	"core-js/actual/object/has-own": [
	"es.object.has-own"
],
	"core-js/actual/object/is": [
	"es.object.is"
],
	"core-js/actual/object/is-extensible": [
	"es.object.is-extensible"
],
	"core-js/actual/object/is-frozen": [
	"es.object.is-frozen"
],
	"core-js/actual/object/is-sealed": [
	"es.object.is-sealed"
],
	"core-js/actual/object/keys": [
	"es.object.keys"
],
	"core-js/actual/object/lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/actual/object/lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/actual/object/prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/actual/object/proto": [
	"es.object.proto"
],
	"core-js/actual/object/seal": [
	"es.object.seal"
],
	"core-js/actual/object/set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/actual/object/to-string": [
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/actual/object/values": [
	"es.object.values"
],
	"core-js/actual/parse-float": [
	"es.parse-float"
],
	"core-js/actual/parse-int": [
	"es.parse-int"
],
	"core-js/actual/promise": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.string.iterator",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"web.dom-collections.iterator"
],
	"core-js/actual/promise/all-settled": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/promise/any": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.any",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/promise/finally": [
	"es.object.to-string",
	"es.promise",
	"es.promise.finally"
],
	"core-js/actual/promise/try": [
	"es.object.to-string",
	"es.promise",
	"es.promise.try",
	"esnext.promise.try"
],
	"core-js/actual/promise/with-resolvers": [
	"es.promise",
	"es.promise.with-resolvers",
	"esnext.promise.with-resolvers"
],
	"core-js/actual/queue-microtask": [
	"web.queue-microtask"
],
	"core-js/actual/reflect": [
	"es.object.to-string",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag"
],
	"core-js/actual/reflect/apply": [
	"es.reflect.apply"
],
	"core-js/actual/reflect/construct": [
	"es.reflect.construct"
],
	"core-js/actual/reflect/define-property": [
	"es.reflect.define-property"
],
	"core-js/actual/reflect/delete-property": [
	"es.reflect.delete-property"
],
	"core-js/actual/reflect/get": [
	"es.reflect.get"
],
	"core-js/actual/reflect/get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/actual/reflect/get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/actual/reflect/has": [
	"es.reflect.has"
],
	"core-js/actual/reflect/is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/actual/reflect/own-keys": [
	"es.reflect.own-keys"
],
	"core-js/actual/reflect/prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/actual/reflect/set": [
	"es.reflect.set"
],
	"core-js/actual/reflect/set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/actual/reflect/to-string-tag": [
	"es.reflect.to-string-tag"
],
	"core-js/actual/regexp": [
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.string.match",
	"es.string.replace",
	"es.string.search",
	"es.string.split",
	"esnext.regexp.escape"
],
	"core-js/actual/regexp/constructor": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/actual/regexp/dot-all": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec"
],
	"core-js/actual/regexp/escape": [
	"es.regexp.escape",
	"esnext.regexp.escape"
],
	"core-js/actual/regexp/flags": [
	"es.regexp.flags"
],
	"core-js/actual/regexp/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/actual/regexp/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/actual/regexp/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/actual/regexp/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/actual/regexp/sticky": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/actual/regexp/test": [
	"es.regexp.exec",
	"es.regexp.test"
],
	"core-js/actual/regexp/to-string": [
	"es.regexp.to-string"
],
	"core-js/actual/self": [
	"web.self"
],
	"core-js/actual/set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.iterator",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"web.dom-collections.iterator"
],
	"core-js/actual/set-immediate": [
	"web.immediate"
],
	"core-js/actual/set-interval": [
	"web.timers"
],
	"core-js/actual/set-timeout": [
	"web.timers"
],
	"core-js/actual/set/difference": [
	"es.set",
	"es.set.difference.v2",
	"esnext.set.difference.v2"
],
	"core-js/actual/set/intersection": [
	"es.set",
	"es.set.intersection.v2",
	"esnext.set.intersection.v2"
],
	"core-js/actual/set/is-disjoint-from": [
	"es.set",
	"es.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from.v2"
],
	"core-js/actual/set/is-subset-of": [
	"es.set",
	"es.set.is-subset-of.v2",
	"esnext.set.is-subset-of.v2"
],
	"core-js/actual/set/is-superset-of": [
	"es.set",
	"es.set.is-superset-of.v2",
	"esnext.set.is-superset-of.v2"
],
	"core-js/actual/set/symmetric-difference": [
	"es.set",
	"es.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference.v2"
],
	"core-js/actual/set/union": [
	"es.set",
	"es.set.union.v2",
	"esnext.set.union.v2"
],
	"core-js/actual/string": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"esnext.string.is-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/actual/string/anchor": [
	"es.string.anchor"
],
	"core-js/actual/string/at": [
	"es.string.at-alternative"
],
	"core-js/actual/string/big": [
	"es.string.big"
],
	"core-js/actual/string/blink": [
	"es.string.blink"
],
	"core-js/actual/string/bold": [
	"es.string.bold"
],
	"core-js/actual/string/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/actual/string/ends-with": [
	"es.string.ends-with"
],
	"core-js/actual/string/fixed": [
	"es.string.fixed"
],
	"core-js/actual/string/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/actual/string/fontsize": [
	"es.string.fontsize"
],
	"core-js/actual/string/from-code-point": [
	"es.string.from-code-point"
],
	"core-js/actual/string/includes": [
	"es.string.includes"
],
	"core-js/actual/string/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/actual/string/italics": [
	"es.string.italics"
],
	"core-js/actual/string/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/actual/string/link": [
	"es.string.link"
],
	"core-js/actual/string/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/actual/string/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/actual/string/pad-end": [
	"es.string.pad-end"
],
	"core-js/actual/string/pad-start": [
	"es.string.pad-start"
],
	"core-js/actual/string/raw": [
	"es.string.raw"
],
	"core-js/actual/string/repeat": [
	"es.string.repeat"
],
	"core-js/actual/string/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/actual/string/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/actual/string/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/actual/string/small": [
	"es.string.small"
],
	"core-js/actual/string/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/actual/string/starts-with": [
	"es.string.starts-with"
],
	"core-js/actual/string/strike": [
	"es.string.strike"
],
	"core-js/actual/string/sub": [
	"es.string.sub"
],
	"core-js/actual/string/substr": [
	"es.string.substr"
],
	"core-js/actual/string/sup": [
	"es.string.sup"
],
	"core-js/actual/string/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/actual/string/trim": [
	"es.string.trim"
],
	"core-js/actual/string/trim-end": [
	"es.string.trim-end"
],
	"core-js/actual/string/trim-left": [
	"es.string.trim-start"
],
	"core-js/actual/string/trim-right": [
	"es.string.trim-end"
],
	"core-js/actual/string/trim-start": [
	"es.string.trim-start"
],
	"core-js/actual/string/virtual": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"esnext.string.is-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/actual/string/virtual/anchor": [
	"es.string.anchor"
],
	"core-js/actual/string/virtual/at": [
	"es.string.at-alternative"
],
	"core-js/actual/string/virtual/big": [
	"es.string.big"
],
	"core-js/actual/string/virtual/blink": [
	"es.string.blink"
],
	"core-js/actual/string/virtual/bold": [
	"es.string.bold"
],
	"core-js/actual/string/virtual/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/actual/string/virtual/ends-with": [
	"es.string.ends-with"
],
	"core-js/actual/string/virtual/fixed": [
	"es.string.fixed"
],
	"core-js/actual/string/virtual/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/actual/string/virtual/fontsize": [
	"es.string.fontsize"
],
	"core-js/actual/string/virtual/includes": [
	"es.string.includes"
],
	"core-js/actual/string/virtual/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/actual/string/virtual/italics": [
	"es.string.italics"
],
	"core-js/actual/string/virtual/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/actual/string/virtual/link": [
	"es.string.link"
],
	"core-js/actual/string/virtual/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/actual/string/virtual/pad-end": [
	"es.string.pad-end"
],
	"core-js/actual/string/virtual/pad-start": [
	"es.string.pad-start"
],
	"core-js/actual/string/virtual/repeat": [
	"es.string.repeat"
],
	"core-js/actual/string/virtual/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/actual/string/virtual/small": [
	"es.string.small"
],
	"core-js/actual/string/virtual/starts-with": [
	"es.string.starts-with"
],
	"core-js/actual/string/virtual/strike": [
	"es.string.strike"
],
	"core-js/actual/string/virtual/sub": [
	"es.string.sub"
],
	"core-js/actual/string/virtual/substr": [
	"es.string.substr"
],
	"core-js/actual/string/virtual/sup": [
	"es.string.sup"
],
	"core-js/actual/string/virtual/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/actual/string/virtual/trim": [
	"es.string.trim"
],
	"core-js/actual/string/virtual/trim-end": [
	"es.string.trim-end"
],
	"core-js/actual/string/virtual/trim-left": [
	"es.string.trim-start"
],
	"core-js/actual/string/virtual/trim-right": [
	"es.string.trim-end"
],
	"core-js/actual/string/virtual/trim-start": [
	"es.string.trim-start"
],
	"core-js/actual/structured-clone": [
	"es.error.to-string",
	"es.array.iterator",
	"es.map",
	"es.object.keys",
	"es.object.to-string",
	"es.set",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.structured-clone"
],
	"core-js/actual/suppressed-error": [
],
	"core-js/actual/symbol": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag",
	"esnext.function.metadata",
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose",
	"esnext.symbol.metadata",
	"web.dom-collections.iterator"
],
	"core-js/actual/symbol/async-dispose": [
	"esnext.symbol.async-dispose"
],
	"core-js/actual/symbol/async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/actual/symbol/description": [
	"es.symbol.description"
],
	"core-js/actual/symbol/dispose": [
	"esnext.symbol.dispose"
],
	"core-js/actual/symbol/for": [
	"es.symbol"
],
	"core-js/actual/symbol/has-instance": [
	"es.symbol.has-instance",
	"es.function.has-instance"
],
	"core-js/actual/symbol/is-concat-spreadable": [
	"es.symbol.is-concat-spreadable",
	"es.array.concat"
],
	"core-js/actual/symbol/iterator": [
	"es.symbol.iterator",
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/actual/symbol/key-for": [
	"es.symbol"
],
	"core-js/actual/symbol/match": [
	"es.symbol.match",
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/actual/symbol/match-all": [
	"es.symbol.match-all",
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/actual/symbol/metadata": [
	"esnext.function.metadata",
	"esnext.symbol.metadata"
],
	"core-js/actual/symbol/replace": [
	"es.symbol.replace",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/actual/symbol/search": [
	"es.symbol.search",
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/actual/symbol/species": [
	"es.symbol.species"
],
	"core-js/actual/symbol/split": [
	"es.symbol.split",
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/actual/symbol/to-primitive": [
	"es.symbol.to-primitive",
	"es.date.to-primitive"
],
	"core-js/actual/symbol/to-string-tag": [
	"es.symbol.to-string-tag",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/actual/symbol/unscopables": [
	"es.symbol.unscopables"
],
	"core-js/actual/typed-array": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/at": [
	"es.typed-array.at"
],
	"core-js/actual/typed-array/copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/actual/typed-array/entries": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/actual/typed-array/every": [
	"es.typed-array.every"
],
	"core-js/actual/typed-array/fill": [
	"es.typed-array.fill"
],
	"core-js/actual/typed-array/filter": [
	"es.typed-array.filter"
],
	"core-js/actual/typed-array/find": [
	"es.typed-array.find"
],
	"core-js/actual/typed-array/find-index": [
	"es.typed-array.find-index"
],
	"core-js/actual/typed-array/find-last": [
	"es.typed-array.find-last",
	"esnext.typed-array.find-last"
],
	"core-js/actual/typed-array/find-last-index": [
	"es.typed-array.find-last-index",
	"esnext.typed-array.find-last-index"
],
	"core-js/actual/typed-array/float32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/float64-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float64-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/for-each": [
	"es.typed-array.for-each"
],
	"core-js/actual/typed-array/from": [
	"es.typed-array.from"
],
	"core-js/actual/typed-array/from-base64": [
	"esnext.uint8-array.from-base64"
],
	"core-js/actual/typed-array/from-hex": [
	"esnext.uint8-array.from-hex"
],
	"core-js/actual/typed-array/includes": [
	"es.typed-array.includes"
],
	"core-js/actual/typed-array/index-of": [
	"es.typed-array.index-of"
],
	"core-js/actual/typed-array/int16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/int32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/int8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/iterator": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/actual/typed-array/join": [
	"es.typed-array.join"
],
	"core-js/actual/typed-array/keys": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/actual/typed-array/last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/actual/typed-array/map": [
	"es.typed-array.map"
],
	"core-js/actual/typed-array/methods": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/of": [
	"es.typed-array.of"
],
	"core-js/actual/typed-array/reduce": [
	"es.typed-array.reduce"
],
	"core-js/actual/typed-array/reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/actual/typed-array/reverse": [
	"es.typed-array.reverse"
],
	"core-js/actual/typed-array/set": [
	"es.typed-array.set"
],
	"core-js/actual/typed-array/set-from-base64": [
	"esnext.uint8-array.set-from-base64"
],
	"core-js/actual/typed-array/set-from-hex": [
	"esnext.uint8-array.set-from-hex"
],
	"core-js/actual/typed-array/slice": [
	"es.typed-array.slice"
],
	"core-js/actual/typed-array/some": [
	"es.typed-array.some"
],
	"core-js/actual/typed-array/sort": [
	"es.typed-array.sort"
],
	"core-js/actual/typed-array/subarray": [
	"es.typed-array.subarray"
],
	"core-js/actual/typed-array/to-base64": [
	"esnext.uint8-array.to-base64"
],
	"core-js/actual/typed-array/to-hex": [
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/actual/typed-array/to-reversed": [
	"es.typed-array.to-reversed",
	"esnext.typed-array.to-reversed"
],
	"core-js/actual/typed-array/to-sorted": [
	"es.typed-array.sort",
	"es.typed-array.to-sorted",
	"esnext.typed-array.to-sorted"
],
	"core-js/actual/typed-array/to-spliced": [
	"esnext.typed-array.to-spliced"
],
	"core-js/actual/typed-array/to-string": [
	"es.typed-array.to-string"
],
	"core-js/actual/typed-array/uint16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/uint32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/uint8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/uint8-clamped-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/actual/typed-array/values": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/actual/typed-array/with": [
	"es.typed-array.with",
	"esnext.typed-array.with"
],
	"core-js/actual/unescape": [
	"es.unescape"
],
	"core-js/actual/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/actual/url-search-params": [
	"web.dom-collections.iterator",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/actual/url/can-parse": [
	"web.url",
	"web.url.can-parse"
],
	"core-js/actual/url/parse": [
	"web.url",
	"web.url.parse"
],
	"core-js/actual/url/to-json": [
	"web.url.to-json"
],
	"core-js/actual/weak-map": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-map",
	"web.dom-collections.iterator"
],
	"core-js/actual/weak-set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-set",
	"web.dom-collections.iterator"
],
	"core-js/es": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set"
],
	"core-js/es/aggregate-error": [
],
	"core-js/es/array": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/array-buffer": [
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string"
],
	"core-js/es/array-buffer/constructor": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string"
],
	"core-js/es/array-buffer/detached": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached"
],
	"core-js/es/array-buffer/is-view": [
	"es.array-buffer.is-view"
],
	"core-js/es/array-buffer/slice": [
	"es.array-buffer.slice"
],
	"core-js/es/array-buffer/transfer": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer"
],
	"core-js/es/array-buffer/transfer-to-fixed-length": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer-to-fixed-length"
],
	"core-js/es/array/at": [
	"es.array.at"
],
	"core-js/es/array/concat": [
	"es.array.concat"
],
	"core-js/es/array/copy-within": [
	"es.array.copy-within"
],
	"core-js/es/array/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/every": [
	"es.array.every"
],
	"core-js/es/array/fill": [
	"es.array.fill"
],
	"core-js/es/array/filter": [
	"es.array.filter"
],
	"core-js/es/array/find": [
	"es.array.find"
],
	"core-js/es/array/find-index": [
	"es.array.find-index"
],
	"core-js/es/array/find-last": [
	"es.array.find-last"
],
	"core-js/es/array/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/es/array/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/es/array/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/es/array/for-each": [
	"es.array.for-each"
],
	"core-js/es/array/from": [
	"es.array.from",
	"es.string.iterator"
],
	"core-js/es/array/includes": [
	"es.array.includes"
],
	"core-js/es/array/index-of": [
	"es.array.index-of"
],
	"core-js/es/array/is-array": [
	"es.array.is-array"
],
	"core-js/es/array/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/join": [
	"es.array.join"
],
	"core-js/es/array/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/es/array/map": [
	"es.array.map"
],
	"core-js/es/array/of": [
	"es.array.of"
],
	"core-js/es/array/push": [
	"es.array.push"
],
	"core-js/es/array/reduce": [
	"es.array.reduce"
],
	"core-js/es/array/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/es/array/reverse": [
	"es.array.reverse"
],
	"core-js/es/array/slice": [
	"es.array.slice"
],
	"core-js/es/array/some": [
	"es.array.some"
],
	"core-js/es/array/sort": [
	"es.array.sort"
],
	"core-js/es/array/splice": [
	"es.array.splice"
],
	"core-js/es/array/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/es/array/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/es/array/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/es/array/unshift": [
	"es.array.unshift"
],
	"core-js/es/array/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/virtual": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.includes",
	"es.array.index-of",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.object.to-string"
],
	"core-js/es/array/virtual/at": [
	"es.array.at"
],
	"core-js/es/array/virtual/concat": [
	"es.array.concat"
],
	"core-js/es/array/virtual/copy-within": [
	"es.array.copy-within"
],
	"core-js/es/array/virtual/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/virtual/every": [
	"es.array.every"
],
	"core-js/es/array/virtual/fill": [
	"es.array.fill"
],
	"core-js/es/array/virtual/filter": [
	"es.array.filter"
],
	"core-js/es/array/virtual/find": [
	"es.array.find"
],
	"core-js/es/array/virtual/find-index": [
	"es.array.find-index"
],
	"core-js/es/array/virtual/find-last": [
	"es.array.find-last"
],
	"core-js/es/array/virtual/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/es/array/virtual/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/es/array/virtual/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/es/array/virtual/for-each": [
	"es.array.for-each"
],
	"core-js/es/array/virtual/includes": [
	"es.array.includes"
],
	"core-js/es/array/virtual/index-of": [
	"es.array.index-of"
],
	"core-js/es/array/virtual/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/virtual/join": [
	"es.array.join"
],
	"core-js/es/array/virtual/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/virtual/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/es/array/virtual/map": [
	"es.array.map"
],
	"core-js/es/array/virtual/push": [
	"es.array.push"
],
	"core-js/es/array/virtual/reduce": [
	"es.array.reduce"
],
	"core-js/es/array/virtual/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/es/array/virtual/reverse": [
	"es.array.reverse"
],
	"core-js/es/array/virtual/slice": [
	"es.array.slice"
],
	"core-js/es/array/virtual/some": [
	"es.array.some"
],
	"core-js/es/array/virtual/sort": [
	"es.array.sort"
],
	"core-js/es/array/virtual/splice": [
	"es.array.splice"
],
	"core-js/es/array/virtual/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/es/array/virtual/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/es/array/virtual/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/es/array/virtual/unshift": [
	"es.array.unshift"
],
	"core-js/es/array/virtual/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/array/virtual/with": [
	"es.array.with"
],
	"core-js/es/array/with": [
	"es.array.with"
],
	"core-js/es/data-view": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.object.to-string"
],
	"core-js/es/data-view/get-float16": [
	"es.data-view.get-float16"
],
	"core-js/es/data-view/set-float16": [
	"es.data-view.set-float16"
],
	"core-js/es/date": [
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string"
],
	"core-js/es/date/get-year": [
	"es.date.get-year"
],
	"core-js/es/date/now": [
	"es.date.now"
],
	"core-js/es/date/set-year": [
	"es.date.set-year"
],
	"core-js/es/date/to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/es/date/to-iso-string": [
	"es.date.to-iso-string",
	"es.date.to-json"
],
	"core-js/es/date/to-json": [
	"es.date.to-json"
],
	"core-js/es/date/to-primitive": [
	"es.date.to-primitive"
],
	"core-js/es/date/to-string": [
	"es.date.to-string"
],
	"core-js/es/error": [
	"es.error.cause",
	"es.error.to-string"
],
	"core-js/es/error/constructor": [
	"es.error.cause"
],
	"core-js/es/error/to-string": [
	"es.error.to-string"
],
	"core-js/es/escape": [
	"es.escape"
],
	"core-js/es/function": [
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name"
],
	"core-js/es/function/bind": [
	"es.function.bind"
],
	"core-js/es/function/has-instance": [
	"es.function.has-instance"
],
	"core-js/es/function/name": [
	"es.function.name"
],
	"core-js/es/function/virtual": [
	"es.function.bind"
],
	"core-js/es/function/virtual/bind": [
	"es.function.bind"
],
	"core-js/es/get-iterator": [
	"es.array.iterator",
	"es.string.iterator"
],
	"core-js/es/get-iterator-method": [
	"es.array.iterator",
	"es.string.iterator"
],
	"core-js/es/global-this": [
	"es.global-this"
],
	"core-js/es/instance/at": [
	"es.array.at",
	"es.string.at-alternative"
],
	"core-js/es/instance/bind": [
	"es.function.bind"
],
	"core-js/es/instance/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/es/instance/concat": [
	"es.array.concat"
],
	"core-js/es/instance/copy-within": [
	"es.array.copy-within"
],
	"core-js/es/instance/ends-with": [
	"es.string.ends-with"
],
	"core-js/es/instance/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/instance/every": [
	"es.array.every"
],
	"core-js/es/instance/fill": [
	"es.array.fill"
],
	"core-js/es/instance/filter": [
	"es.array.filter"
],
	"core-js/es/instance/find": [
	"es.array.find"
],
	"core-js/es/instance/find-index": [
	"es.array.find-index"
],
	"core-js/es/instance/find-last": [
	"es.array.find-last"
],
	"core-js/es/instance/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/es/instance/flags": [
	"es.regexp.flags"
],
	"core-js/es/instance/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/es/instance/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/es/instance/for-each": [
	"es.array.for-each"
],
	"core-js/es/instance/includes": [
	"es.array.includes",
	"es.string.includes"
],
	"core-js/es/instance/index-of": [
	"es.array.index-of"
],
	"core-js/es/instance/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/es/instance/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/instance/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/es/instance/map": [
	"es.array.map"
],
	"core-js/es/instance/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/es/instance/pad-end": [
	"es.string.pad-end"
],
	"core-js/es/instance/pad-start": [
	"es.string.pad-start"
],
	"core-js/es/instance/push": [
	"es.array.push"
],
	"core-js/es/instance/reduce": [
	"es.array.reduce"
],
	"core-js/es/instance/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/es/instance/repeat": [
	"es.string.repeat"
],
	"core-js/es/instance/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/es/instance/reverse": [
	"es.array.reverse"
],
	"core-js/es/instance/slice": [
	"es.array.slice"
],
	"core-js/es/instance/some": [
	"es.array.some"
],
	"core-js/es/instance/sort": [
	"es.array.sort"
],
	"core-js/es/instance/splice": [
	"es.array.splice"
],
	"core-js/es/instance/starts-with": [
	"es.string.starts-with"
],
	"core-js/es/instance/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/es/instance/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/es/instance/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/es/instance/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/es/instance/trim": [
	"es.string.trim"
],
	"core-js/es/instance/trim-end": [
	"es.string.trim-end"
],
	"core-js/es/instance/trim-left": [
	"es.string.trim-start"
],
	"core-js/es/instance/trim-right": [
	"es.string.trim-end"
],
	"core-js/es/instance/trim-start": [
	"es.string.trim-start"
],
	"core-js/es/instance/unshift": [
	"es.array.unshift"
],
	"core-js/es/instance/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/es/instance/with": [
	"es.array.with"
],
	"core-js/es/is-iterable": [
	"es.array.iterator",
	"es.string.iterator"
],
	"core-js/es/iterator": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/iterator/drop": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.object.to-string"
],
	"core-js/es/iterator/every": [
	"es.iterator.constructor",
	"es.iterator.every",
	"es.object.to-string"
],
	"core-js/es/iterator/filter": [
	"es.iterator.constructor",
	"es.iterator.filter",
	"es.object.to-string"
],
	"core-js/es/iterator/find": [
	"es.iterator.constructor",
	"es.iterator.find",
	"es.object.to-string"
],
	"core-js/es/iterator/flat-map": [
	"es.iterator.constructor",
	"es.iterator.flat-map",
	"es.object.to-string"
],
	"core-js/es/iterator/for-each": [
	"es.iterator.constructor",
	"es.iterator.for-each",
	"es.object.to-string"
],
	"core-js/es/iterator/from": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/iterator/map": [
	"es.iterator.constructor",
	"es.iterator.map",
	"es.object.to-string"
],
	"core-js/es/iterator/reduce": [
	"es.iterator.constructor",
	"es.iterator.reduce",
	"es.object.to-string"
],
	"core-js/es/iterator/some": [
	"es.iterator.constructor",
	"es.iterator.some",
	"es.object.to-string"
],
	"core-js/es/iterator/take": [
	"es.iterator.constructor",
	"es.iterator.take",
	"es.object.to-string"
],
	"core-js/es/iterator/to-array": [
	"es.iterator.constructor",
	"es.iterator.to-array",
	"es.object.to-string"
],
	"core-js/es/json": [
	"es.date.to-json",
	"es.json.stringify",
	"es.json.to-string-tag"
],
	"core-js/es/json/stringify": [
	"es.date.to-json",
	"es.json.stringify"
],
	"core-js/es/json/to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/es/map": [
	"es.array.iterator",
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/map/group-by": [
	"es.map",
	"es.map.group-by",
	"es.object.to-string"
],
	"core-js/es/math": [
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc"
],
	"core-js/es/math/acosh": [
	"es.math.acosh"
],
	"core-js/es/math/asinh": [
	"es.math.asinh"
],
	"core-js/es/math/atanh": [
	"es.math.atanh"
],
	"core-js/es/math/cbrt": [
	"es.math.cbrt"
],
	"core-js/es/math/clz32": [
	"es.math.clz32"
],
	"core-js/es/math/cosh": [
	"es.math.cosh"
],
	"core-js/es/math/expm1": [
	"es.math.expm1"
],
	"core-js/es/math/f16round": [
	"es.math.f16round"
],
	"core-js/es/math/fround": [
	"es.math.fround"
],
	"core-js/es/math/hypot": [
	"es.math.hypot"
],
	"core-js/es/math/imul": [
	"es.math.imul"
],
	"core-js/es/math/log10": [
	"es.math.log10"
],
	"core-js/es/math/log1p": [
	"es.math.log1p"
],
	"core-js/es/math/log2": [
	"es.math.log2"
],
	"core-js/es/math/sign": [
	"es.math.sign"
],
	"core-js/es/math/sinh": [
	"es.math.sinh"
],
	"core-js/es/math/tanh": [
	"es.math.tanh"
],
	"core-js/es/math/to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/es/math/trunc": [
	"es.math.trunc"
],
	"core-js/es/number": [
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/es/number/constructor": [
	"es.number.constructor"
],
	"core-js/es/number/epsilon": [
	"es.number.epsilon"
],
	"core-js/es/number/is-finite": [
	"es.number.is-finite"
],
	"core-js/es/number/is-integer": [
	"es.number.is-integer"
],
	"core-js/es/number/is-nan": [
	"es.number.is-nan"
],
	"core-js/es/number/is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/es/number/max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/es/number/min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/es/number/parse-float": [
	"es.number.parse-float"
],
	"core-js/es/number/parse-int": [
	"es.number.parse-int"
],
	"core-js/es/number/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/es/number/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/es/number/to-precision": [
	"es.number.to-precision"
],
	"core-js/es/number/virtual": [
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/es/number/virtual/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/es/number/virtual/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/es/number/virtual/to-precision": [
	"es.number.to-precision"
],
	"core-js/es/object": [
	"es.symbol",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.reflect.to-string-tag"
],
	"core-js/es/object/assign": [
	"es.object.assign"
],
	"core-js/es/object/create": [
	"es.object.create"
],
	"core-js/es/object/define-getter": [
	"es.object.define-getter"
],
	"core-js/es/object/define-properties": [
	"es.object.define-properties"
],
	"core-js/es/object/define-property": [
	"es.object.define-property"
],
	"core-js/es/object/define-setter": [
	"es.object.define-setter"
],
	"core-js/es/object/entries": [
	"es.object.entries"
],
	"core-js/es/object/freeze": [
	"es.object.freeze"
],
	"core-js/es/object/from-entries": [
	"es.array.iterator",
	"es.object.from-entries"
],
	"core-js/es/object/get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/es/object/get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/es/object/get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/es/object/get-own-property-symbols": [
	"es.symbol"
],
	"core-js/es/object/get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/es/object/group-by": [
	"es.object.create",
	"es.object.group-by"
],
	"core-js/es/object/has-own": [
	"es.object.has-own"
],
	"core-js/es/object/is": [
	"es.object.is"
],
	"core-js/es/object/is-extensible": [
	"es.object.is-extensible"
],
	"core-js/es/object/is-frozen": [
	"es.object.is-frozen"
],
	"core-js/es/object/is-sealed": [
	"es.object.is-sealed"
],
	"core-js/es/object/keys": [
	"es.object.keys"
],
	"core-js/es/object/lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/es/object/lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/es/object/prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/es/object/proto": [
	"es.object.proto"
],
	"core-js/es/object/seal": [
	"es.object.seal"
],
	"core-js/es/object/set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/es/object/to-string": [
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/es/object/values": [
	"es.object.values"
],
	"core-js/es/parse-float": [
	"es.parse-float"
],
	"core-js/es/parse-int": [
	"es.parse-int"
],
	"core-js/es/promise": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.string.iterator"
],
	"core-js/es/promise/all-settled": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.string.iterator"
],
	"core-js/es/promise/any": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.any",
	"es.string.iterator"
],
	"core-js/es/promise/finally": [
	"es.object.to-string",
	"es.promise",
	"es.promise.finally"
],
	"core-js/es/promise/try": [
	"es.object.to-string",
	"es.promise",
	"es.promise.try"
],
	"core-js/es/promise/with-resolvers": [
	"es.promise",
	"es.promise.with-resolvers"
],
	"core-js/es/reflect": [
	"es.object.to-string",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag"
],
	"core-js/es/reflect/apply": [
	"es.reflect.apply"
],
	"core-js/es/reflect/construct": [
	"es.reflect.construct"
],
	"core-js/es/reflect/define-property": [
	"es.reflect.define-property"
],
	"core-js/es/reflect/delete-property": [
	"es.reflect.delete-property"
],
	"core-js/es/reflect/get": [
	"es.reflect.get"
],
	"core-js/es/reflect/get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/es/reflect/get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/es/reflect/has": [
	"es.reflect.has"
],
	"core-js/es/reflect/is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/es/reflect/own-keys": [
	"es.reflect.own-keys"
],
	"core-js/es/reflect/prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/es/reflect/set": [
	"es.reflect.set"
],
	"core-js/es/reflect/set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/es/reflect/to-string-tag": [
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/es/regexp": [
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.string.match",
	"es.string.replace",
	"es.string.search",
	"es.string.split"
],
	"core-js/es/regexp/constructor": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/es/regexp/dot-all": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec"
],
	"core-js/es/regexp/escape": [
	"es.regexp.escape"
],
	"core-js/es/regexp/flags": [
	"es.regexp.flags"
],
	"core-js/es/regexp/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/es/regexp/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/es/regexp/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/es/regexp/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/es/regexp/sticky": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/es/regexp/test": [
	"es.regexp.exec",
	"es.regexp.test"
],
	"core-js/es/regexp/to-string": [
	"es.regexp.to-string"
],
	"core-js/es/set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.iterator"
],
	"core-js/es/set/difference": [
	"es.set",
	"es.set.difference.v2"
],
	"core-js/es/set/intersection": [
	"es.set",
	"es.set.intersection.v2"
],
	"core-js/es/set/is-disjoint-from": [
	"es.set",
	"es.set.is-disjoint-from.v2"
],
	"core-js/es/set/is-subset-of": [
	"es.set",
	"es.set.is-subset-of.v2"
],
	"core-js/es/set/is-superset-of": [
	"es.set",
	"es.set.is-superset-of.v2"
],
	"core-js/es/set/symmetric-difference": [
	"es.set",
	"es.set.symmetric-difference.v2"
],
	"core-js/es/set/union": [
	"es.set",
	"es.set.union.v2"
],
	"core-js/es/string": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup"
],
	"core-js/es/string/anchor": [
	"es.string.anchor"
],
	"core-js/es/string/at": [
	"es.string.at-alternative"
],
	"core-js/es/string/big": [
	"es.string.big"
],
	"core-js/es/string/blink": [
	"es.string.blink"
],
	"core-js/es/string/bold": [
	"es.string.bold"
],
	"core-js/es/string/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/es/string/ends-with": [
	"es.string.ends-with"
],
	"core-js/es/string/fixed": [
	"es.string.fixed"
],
	"core-js/es/string/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/es/string/fontsize": [
	"es.string.fontsize"
],
	"core-js/es/string/from-code-point": [
	"es.string.from-code-point"
],
	"core-js/es/string/includes": [
	"es.string.includes"
],
	"core-js/es/string/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/es/string/italics": [
	"es.string.italics"
],
	"core-js/es/string/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/string/link": [
	"es.string.link"
],
	"core-js/es/string/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/es/string/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/es/string/pad-end": [
	"es.string.pad-end"
],
	"core-js/es/string/pad-start": [
	"es.string.pad-start"
],
	"core-js/es/string/raw": [
	"es.string.raw"
],
	"core-js/es/string/repeat": [
	"es.string.repeat"
],
	"core-js/es/string/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/es/string/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/es/string/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/es/string/small": [
	"es.string.small"
],
	"core-js/es/string/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/es/string/starts-with": [
	"es.string.starts-with"
],
	"core-js/es/string/strike": [
	"es.string.strike"
],
	"core-js/es/string/sub": [
	"es.string.sub"
],
	"core-js/es/string/substr": [
	"es.string.substr"
],
	"core-js/es/string/sup": [
	"es.string.sup"
],
	"core-js/es/string/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/es/string/trim": [
	"es.string.trim"
],
	"core-js/es/string/trim-end": [
	"es.string.trim-end"
],
	"core-js/es/string/trim-left": [
	"es.string.trim-start"
],
	"core-js/es/string/trim-right": [
	"es.string.trim-end"
],
	"core-js/es/string/trim-start": [
	"es.string.trim-start"
],
	"core-js/es/string/virtual": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup"
],
	"core-js/es/string/virtual/anchor": [
	"es.string.anchor"
],
	"core-js/es/string/virtual/at": [
	"es.string.at-alternative"
],
	"core-js/es/string/virtual/big": [
	"es.string.big"
],
	"core-js/es/string/virtual/blink": [
	"es.string.blink"
],
	"core-js/es/string/virtual/bold": [
	"es.string.bold"
],
	"core-js/es/string/virtual/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/es/string/virtual/ends-with": [
	"es.string.ends-with"
],
	"core-js/es/string/virtual/fixed": [
	"es.string.fixed"
],
	"core-js/es/string/virtual/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/es/string/virtual/fontsize": [
	"es.string.fontsize"
],
	"core-js/es/string/virtual/includes": [
	"es.string.includes"
],
	"core-js/es/string/virtual/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/es/string/virtual/italics": [
	"es.string.italics"
],
	"core-js/es/string/virtual/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/string/virtual/link": [
	"es.string.link"
],
	"core-js/es/string/virtual/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/es/string/virtual/pad-end": [
	"es.string.pad-end"
],
	"core-js/es/string/virtual/pad-start": [
	"es.string.pad-start"
],
	"core-js/es/string/virtual/repeat": [
	"es.string.repeat"
],
	"core-js/es/string/virtual/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/es/string/virtual/small": [
	"es.string.small"
],
	"core-js/es/string/virtual/starts-with": [
	"es.string.starts-with"
],
	"core-js/es/string/virtual/strike": [
	"es.string.strike"
],
	"core-js/es/string/virtual/sub": [
	"es.string.sub"
],
	"core-js/es/string/virtual/substr": [
	"es.string.substr"
],
	"core-js/es/string/virtual/sup": [
	"es.string.sup"
],
	"core-js/es/string/virtual/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/es/string/virtual/trim": [
	"es.string.trim"
],
	"core-js/es/string/virtual/trim-end": [
	"es.string.trim-end"
],
	"core-js/es/string/virtual/trim-left": [
	"es.string.trim-start"
],
	"core-js/es/string/virtual/trim-right": [
	"es.string.trim-end"
],
	"core-js/es/string/virtual/trim-start": [
	"es.string.trim-start"
],
	"core-js/es/symbol": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/es/symbol/async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/es/symbol/description": [
	"es.symbol.description"
],
	"core-js/es/symbol/for": [
	"es.symbol"
],
	"core-js/es/symbol/has-instance": [
	"es.symbol.has-instance",
	"es.function.has-instance"
],
	"core-js/es/symbol/is-concat-spreadable": [
	"es.symbol.is-concat-spreadable",
	"es.array.concat"
],
	"core-js/es/symbol/iterator": [
	"es.symbol.iterator",
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/es/symbol/key-for": [
	"es.symbol"
],
	"core-js/es/symbol/match": [
	"es.symbol.match",
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/es/symbol/match-all": [
	"es.symbol.match-all",
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/es/symbol/replace": [
	"es.symbol.replace",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/es/symbol/search": [
	"es.symbol.search",
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/es/symbol/species": [
	"es.symbol.species"
],
	"core-js/es/symbol/split": [
	"es.symbol.split",
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/es/symbol/to-primitive": [
	"es.symbol.to-primitive",
	"es.date.to-primitive"
],
	"core-js/es/symbol/to-string-tag": [
	"es.symbol.to-string-tag",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/es/symbol/unscopables": [
	"es.symbol.unscopables"
],
	"core-js/es/typed-array": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/at": [
	"es.typed-array.at"
],
	"core-js/es/typed-array/copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/es/typed-array/entries": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/es/typed-array/every": [
	"es.typed-array.every"
],
	"core-js/es/typed-array/fill": [
	"es.typed-array.fill"
],
	"core-js/es/typed-array/filter": [
	"es.typed-array.filter"
],
	"core-js/es/typed-array/find": [
	"es.typed-array.find"
],
	"core-js/es/typed-array/find-index": [
	"es.typed-array.find-index"
],
	"core-js/es/typed-array/find-last": [
	"es.typed-array.find-last"
],
	"core-js/es/typed-array/find-last-index": [
	"es.typed-array.find-last-index"
],
	"core-js/es/typed-array/float32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/float64-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float64-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/for-each": [
	"es.typed-array.for-each"
],
	"core-js/es/typed-array/from": [
	"es.typed-array.from"
],
	"core-js/es/typed-array/includes": [
	"es.typed-array.includes"
],
	"core-js/es/typed-array/index-of": [
	"es.typed-array.index-of"
],
	"core-js/es/typed-array/int16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/int32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/int8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/iterator": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/es/typed-array/join": [
	"es.typed-array.join"
],
	"core-js/es/typed-array/keys": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/es/typed-array/last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/es/typed-array/map": [
	"es.typed-array.map"
],
	"core-js/es/typed-array/methods": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/of": [
	"es.typed-array.of"
],
	"core-js/es/typed-array/reduce": [
	"es.typed-array.reduce"
],
	"core-js/es/typed-array/reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/es/typed-array/reverse": [
	"es.typed-array.reverse"
],
	"core-js/es/typed-array/set": [
	"es.typed-array.set"
],
	"core-js/es/typed-array/slice": [
	"es.typed-array.slice"
],
	"core-js/es/typed-array/some": [
	"es.typed-array.some"
],
	"core-js/es/typed-array/sort": [
	"es.typed-array.sort"
],
	"core-js/es/typed-array/subarray": [
	"es.typed-array.subarray"
],
	"core-js/es/typed-array/to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/es/typed-array/to-reversed": [
	"es.typed-array.to-reversed"
],
	"core-js/es/typed-array/to-sorted": [
	"es.typed-array.sort",
	"es.typed-array.to-sorted"
],
	"core-js/es/typed-array/to-string": [
	"es.typed-array.to-string"
],
	"core-js/es/typed-array/uint16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/uint32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/uint8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/uint8-clamped-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/es/typed-array/values": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/es/typed-array/with": [
	"es.typed-array.with"
],
	"core-js/es/unescape": [
	"es.unescape"
],
	"core-js/es/weak-map": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-map"
],
	"core-js/es/weak-set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-set"
],
	"core-js/features": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/features/aggregate-error": [
],
	"core-js/features/array": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with"
],
	"core-js/features/array-buffer": [
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/features/array-buffer/constructor": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/features/array-buffer/detached": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"esnext.array-buffer.detached"
],
	"core-js/features/array-buffer/is-view": [
	"es.array-buffer.is-view"
],
	"core-js/features/array-buffer/slice": [
	"es.array-buffer.slice"
],
	"core-js/features/array-buffer/transfer": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer",
	"esnext.array-buffer.transfer"
],
	"core-js/features/array-buffer/transfer-to-fixed-length": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer-to-fixed-length",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/features/array/at": [
	"es.array.at",
	"esnext.array.at"
],
	"core-js/features/array/concat": [
	"es.array.concat"
],
	"core-js/features/array/copy-within": [
	"es.array.copy-within"
],
	"core-js/features/array/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/every": [
	"es.array.every"
],
	"core-js/features/array/fill": [
	"es.array.fill"
],
	"core-js/features/array/filter": [
	"es.array.filter"
],
	"core-js/features/array/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/features/array/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/features/array/find": [
	"es.array.find"
],
	"core-js/features/array/find-index": [
	"es.array.find-index"
],
	"core-js/features/array/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/features/array/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/features/array/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/features/array/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/features/array/for-each": [
	"es.array.for-each"
],
	"core-js/features/array/from": [
	"es.array.from",
	"es.string.iterator"
],
	"core-js/features/array/from-async": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async"
],
	"core-js/features/array/group": [
	"esnext.array.group"
],
	"core-js/features/array/group-by": [
	"esnext.array.group-by"
],
	"core-js/features/array/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/features/array/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/features/array/includes": [
	"es.array.includes"
],
	"core-js/features/array/index-of": [
	"es.array.index-of"
],
	"core-js/features/array/is-array": [
	"es.array.is-array"
],
	"core-js/features/array/is-template-object": [
	"esnext.array.is-template-object"
],
	"core-js/features/array/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/join": [
	"es.array.join"
],
	"core-js/features/array/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/last-index": [
	"esnext.array.last-index"
],
	"core-js/features/array/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/features/array/last-item": [
	"esnext.array.last-item"
],
	"core-js/features/array/map": [
	"es.array.map"
],
	"core-js/features/array/of": [
	"es.array.of"
],
	"core-js/features/array/push": [
	"es.array.push"
],
	"core-js/features/array/reduce": [
	"es.array.reduce"
],
	"core-js/features/array/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/features/array/reverse": [
	"es.array.reverse"
],
	"core-js/features/array/slice": [
	"es.array.slice"
],
	"core-js/features/array/some": [
	"es.array.some"
],
	"core-js/features/array/sort": [
	"es.array.sort"
],
	"core-js/features/array/splice": [
	"es.array.splice"
],
	"core-js/features/array/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/features/array/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/features/array/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/features/array/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/features/array/unshift": [
	"es.array.unshift"
],
	"core-js/features/array/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/virtual": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.includes",
	"es.array.index-of",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.map",
	"es.object.to-string",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with"
],
	"core-js/features/array/virtual/at": [
	"es.array.at",
	"esnext.array.at"
],
	"core-js/features/array/virtual/concat": [
	"es.array.concat"
],
	"core-js/features/array/virtual/copy-within": [
	"es.array.copy-within"
],
	"core-js/features/array/virtual/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/virtual/every": [
	"es.array.every"
],
	"core-js/features/array/virtual/fill": [
	"es.array.fill"
],
	"core-js/features/array/virtual/filter": [
	"es.array.filter"
],
	"core-js/features/array/virtual/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/features/array/virtual/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/features/array/virtual/find": [
	"es.array.find"
],
	"core-js/features/array/virtual/find-index": [
	"es.array.find-index"
],
	"core-js/features/array/virtual/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/features/array/virtual/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/features/array/virtual/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/features/array/virtual/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/features/array/virtual/for-each": [
	"es.array.for-each"
],
	"core-js/features/array/virtual/group": [
	"esnext.array.group"
],
	"core-js/features/array/virtual/group-by": [
	"esnext.array.group-by"
],
	"core-js/features/array/virtual/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/features/array/virtual/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/features/array/virtual/includes": [
	"es.array.includes"
],
	"core-js/features/array/virtual/index-of": [
	"es.array.index-of"
],
	"core-js/features/array/virtual/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/virtual/join": [
	"es.array.join"
],
	"core-js/features/array/virtual/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/virtual/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/features/array/virtual/map": [
	"es.array.map"
],
	"core-js/features/array/virtual/push": [
	"es.array.push"
],
	"core-js/features/array/virtual/reduce": [
	"es.array.reduce"
],
	"core-js/features/array/virtual/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/features/array/virtual/reverse": [
	"es.array.reverse"
],
	"core-js/features/array/virtual/slice": [
	"es.array.slice"
],
	"core-js/features/array/virtual/some": [
	"es.array.some"
],
	"core-js/features/array/virtual/sort": [
	"es.array.sort"
],
	"core-js/features/array/virtual/splice": [
	"es.array.splice"
],
	"core-js/features/array/virtual/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/features/array/virtual/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/features/array/virtual/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/features/array/virtual/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/features/array/virtual/unshift": [
	"es.array.unshift"
],
	"core-js/features/array/virtual/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/features/array/virtual/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/features/array/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/features/async-disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/features/async-disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/features/async-iterator": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/features/async-iterator/as-indexed-pairs": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs"
],
	"core-js/features/async-iterator/async-dispose": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.async-dispose"
],
	"core-js/features/async-iterator/drop": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop"
],
	"core-js/features/async-iterator/every": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.every"
],
	"core-js/features/async-iterator/filter": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.filter"
],
	"core-js/features/async-iterator/find": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.find"
],
	"core-js/features/async-iterator/flat-map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.flat-map"
],
	"core-js/features/async-iterator/for-each": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.for-each"
],
	"core-js/features/async-iterator/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/features/async-iterator/indexed": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.indexed"
],
	"core-js/features/async-iterator/map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.map"
],
	"core-js/features/async-iterator/reduce": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.reduce"
],
	"core-js/features/async-iterator/some": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.some"
],
	"core-js/features/async-iterator/take": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.take"
],
	"core-js/features/async-iterator/to-array": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.to-array"
],
	"core-js/features/atob": [
	"es.error.to-string",
	"es.object.to-string",
	"web.atob",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/features/bigint": [
	"es.object.to-string",
	"esnext.bigint.range"
],
	"core-js/features/bigint/range": [
	"es.object.to-string",
	"esnext.bigint.range"
],
	"core-js/features/btoa": [
	"es.error.to-string",
	"es.object.to-string",
	"web.btoa",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/features/clear-immediate": [
	"web.immediate"
],
	"core-js/features/composite-key": [
	"esnext.composite-key"
],
	"core-js/features/composite-symbol": [
	"es.symbol",
	"esnext.composite-symbol"
],
	"core-js/features/data-view": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.object.to-string",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/features/data-view/get-float16": [
	"es.data-view.get-float16",
	"esnext.data-view.get-float16"
],
	"core-js/features/data-view/get-uint8-clamped": [
	"esnext.data-view.get-uint8-clamped"
],
	"core-js/features/data-view/set-float16": [
	"es.data-view.set-float16",
	"esnext.data-view.set-float16"
],
	"core-js/features/data-view/set-uint8-clamped": [
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/features/date": [
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string"
],
	"core-js/features/date/get-year": [
	"es.date.get-year"
],
	"core-js/features/date/now": [
	"es.date.now"
],
	"core-js/features/date/set-year": [
	"es.date.set-year"
],
	"core-js/features/date/to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/features/date/to-iso-string": [
	"es.date.to-iso-string",
	"es.date.to-json"
],
	"core-js/features/date/to-json": [
	"es.date.to-json"
],
	"core-js/features/date/to-primitive": [
	"es.date.to-primitive"
],
	"core-js/features/date/to-string": [
	"es.date.to-string"
],
	"core-js/features/disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/features/disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/features/dom-collections": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator"
],
	"core-js/features/dom-collections/for-each": [
	"web.dom-collections.for-each"
],
	"core-js/features/dom-collections/iterator": [
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/features/dom-exception": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/features/dom-exception/constructor": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack"
],
	"core-js/features/dom-exception/to-string-tag": [
	"web.dom-exception.to-string-tag"
],
	"core-js/features/error": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/features/error/constructor": [
	"es.error.cause"
],
	"core-js/features/error/is-error": [
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/features/error/to-string": [
	"es.error.to-string"
],
	"core-js/features/escape": [
	"es.escape"
],
	"core-js/features/function": [
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this"
],
	"core-js/features/function/bind": [
	"es.function.bind"
],
	"core-js/features/function/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/features/function/has-instance": [
	"es.function.has-instance"
],
	"core-js/features/function/is-callable": [
	"esnext.function.is-callable"
],
	"core-js/features/function/is-constructor": [
	"esnext.function.is-constructor"
],
	"core-js/features/function/metadata": [
	"esnext.function.metadata"
],
	"core-js/features/function/name": [
	"es.function.name"
],
	"core-js/features/function/un-this": [
	"esnext.function.un-this"
],
	"core-js/features/function/virtual": [
	"es.function.bind",
	"esnext.function.demethodize",
	"esnext.function.un-this"
],
	"core-js/features/function/virtual/bind": [
	"es.function.bind"
],
	"core-js/features/function/virtual/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/features/function/virtual/un-this": [
	"esnext.function.un-this"
],
	"core-js/features/get-iterator": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/features/get-iterator-method": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/features/global-this": [
	"es.global-this",
	"esnext.global-this"
],
	"core-js/features/instance/at": [
	"es.array.at",
	"es.string.at-alternative",
	"esnext.array.at",
	"esnext.string.at"
],
	"core-js/features/instance/bind": [
	"es.function.bind"
],
	"core-js/features/instance/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/features/instance/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/features/instance/concat": [
	"es.array.concat"
],
	"core-js/features/instance/copy-within": [
	"es.array.copy-within"
],
	"core-js/features/instance/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/features/instance/ends-with": [
	"es.string.ends-with"
],
	"core-js/features/instance/entries": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/features/instance/every": [
	"es.array.every"
],
	"core-js/features/instance/fill": [
	"es.array.fill"
],
	"core-js/features/instance/filter": [
	"es.array.filter"
],
	"core-js/features/instance/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/features/instance/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/features/instance/find": [
	"es.array.find"
],
	"core-js/features/instance/find-index": [
	"es.array.find-index"
],
	"core-js/features/instance/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/features/instance/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/features/instance/flags": [
	"es.regexp.flags"
],
	"core-js/features/instance/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/features/instance/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/features/instance/for-each": [
	"es.array.for-each",
	"web.dom-collections.for-each"
],
	"core-js/features/instance/group": [
	"esnext.array.group"
],
	"core-js/features/instance/group-by": [
	"esnext.array.group-by"
],
	"core-js/features/instance/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/features/instance/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/features/instance/includes": [
	"es.array.includes",
	"es.string.includes"
],
	"core-js/features/instance/index-of": [
	"es.array.index-of"
],
	"core-js/features/instance/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/features/instance/keys": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/features/instance/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/features/instance/map": [
	"es.array.map"
],
	"core-js/features/instance/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/features/instance/pad-end": [
	"es.string.pad-end"
],
	"core-js/features/instance/pad-start": [
	"es.string.pad-start"
],
	"core-js/features/instance/push": [
	"es.array.push"
],
	"core-js/features/instance/reduce": [
	"es.array.reduce"
],
	"core-js/features/instance/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/features/instance/repeat": [
	"es.string.repeat"
],
	"core-js/features/instance/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/features/instance/reverse": [
	"es.array.reverse"
],
	"core-js/features/instance/slice": [
	"es.array.slice"
],
	"core-js/features/instance/some": [
	"es.array.some"
],
	"core-js/features/instance/sort": [
	"es.array.sort"
],
	"core-js/features/instance/splice": [
	"es.array.splice"
],
	"core-js/features/instance/starts-with": [
	"es.string.starts-with"
],
	"core-js/features/instance/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/features/instance/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/features/instance/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/features/instance/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/features/instance/trim": [
	"es.string.trim"
],
	"core-js/features/instance/trim-end": [
	"es.string.trim-end"
],
	"core-js/features/instance/trim-left": [
	"es.string.trim-start"
],
	"core-js/features/instance/trim-right": [
	"es.string.trim-end"
],
	"core-js/features/instance/trim-start": [
	"es.string.trim-start"
],
	"core-js/features/instance/un-this": [
	"esnext.function.un-this"
],
	"core-js/features/instance/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/features/instance/unshift": [
	"es.array.unshift"
],
	"core-js/features/instance/values": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/features/instance/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/features/is-iterable": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/features/iterator": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/features/iterator/as-indexed-pairs": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs"
],
	"core-js/features/iterator/concat": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.iterator.concat"
],
	"core-js/features/iterator/dispose": [
	"esnext.iterator.dispose"
],
	"core-js/features/iterator/drop": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.drop"
],
	"core-js/features/iterator/every": [
	"es.iterator.constructor",
	"es.iterator.every",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.every"
],
	"core-js/features/iterator/filter": [
	"es.iterator.constructor",
	"es.iterator.filter",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.filter"
],
	"core-js/features/iterator/find": [
	"es.iterator.constructor",
	"es.iterator.find",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.find"
],
	"core-js/features/iterator/flat-map": [
	"es.iterator.constructor",
	"es.iterator.flat-map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.flat-map"
],
	"core-js/features/iterator/for-each": [
	"es.iterator.constructor",
	"es.iterator.for-each",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.for-each"
],
	"core-js/features/iterator/from": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/features/iterator/indexed": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.indexed"
],
	"core-js/features/iterator/map": [
	"es.iterator.constructor",
	"es.iterator.map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.map"
],
	"core-js/features/iterator/range": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.range"
],
	"core-js/features/iterator/reduce": [
	"es.iterator.constructor",
	"es.iterator.reduce",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.reduce"
],
	"core-js/features/iterator/some": [
	"es.iterator.constructor",
	"es.iterator.some",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.some"
],
	"core-js/features/iterator/take": [
	"es.iterator.constructor",
	"es.iterator.take",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.take"
],
	"core-js/features/iterator/to-array": [
	"es.iterator.constructor",
	"es.iterator.to-array",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.to-array"
],
	"core-js/features/iterator/to-async": [
	"es.iterator.constructor",
	"es.object.to-string",
	"es.promise",
	"esnext.iterator.constructor",
	"esnext.iterator.to-async"
],
	"core-js/features/json": [
	"es.date.to-json",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.object.create",
	"es.object.freeze",
	"es.object.keys",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json"
],
	"core-js/features/json/is-raw-json": [
	"esnext.json.is-raw-json"
],
	"core-js/features/json/parse": [
	"es.object.keys",
	"esnext.json.parse"
],
	"core-js/features/json/raw-json": [
	"es.object.create",
	"es.object.freeze",
	"esnext.json.raw-json"
],
	"core-js/features/json/stringify": [
	"es.date.to-json",
	"es.json.stringify"
],
	"core-js/features/json/to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/features/map": [
	"es.array.iterator",
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"web.dom-collections.iterator"
],
	"core-js/features/map/delete-all": [
	"es.map",
	"esnext.map.delete-all"
],
	"core-js/features/map/emplace": [
	"es.map",
	"esnext.map.emplace"
],
	"core-js/features/map/every": [
	"es.map",
	"esnext.map.every"
],
	"core-js/features/map/filter": [
	"es.map",
	"esnext.map.filter"
],
	"core-js/features/map/find": [
	"es.map",
	"esnext.map.find"
],
	"core-js/features/map/find-key": [
	"es.map",
	"esnext.map.find-key"
],
	"core-js/features/map/from": [
	"es.array.iterator",
	"es.map",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"web.dom-collections.iterator"
],
	"core-js/features/map/get-or-insert": [
	"es.map",
	"esnext.map.get-or-insert"
],
	"core-js/features/map/get-or-insert-computed": [
	"es.map",
	"esnext.map.get-or-insert-computed"
],
	"core-js/features/map/group-by": [
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/features/map/includes": [
	"es.map",
	"esnext.map.includes"
],
	"core-js/features/map/key-by": [
	"es.map",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/features/map/key-of": [
	"es.map",
	"esnext.map.key-of"
],
	"core-js/features/map/map-keys": [
	"es.map",
	"esnext.map.map-keys"
],
	"core-js/features/map/map-values": [
	"es.map",
	"esnext.map.map-values"
],
	"core-js/features/map/merge": [
	"es.map",
	"esnext.map.merge"
],
	"core-js/features/map/of": [
	"es.array.iterator",
	"es.map",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/features/map/reduce": [
	"es.map",
	"esnext.map.reduce"
],
	"core-js/features/map/some": [
	"es.map",
	"esnext.map.some"
],
	"core-js/features/map/update": [
	"es.map",
	"esnext.map.update"
],
	"core-js/features/map/update-or-insert": [
	"es.map",
	"esnext.map.update-or-insert"
],
	"core-js/features/map/upsert": [
	"es.map",
	"esnext.map.upsert"
],
	"core-js/features/math": [
	"es.array.iterator",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh"
],
	"core-js/features/math/acosh": [
	"es.math.acosh"
],
	"core-js/features/math/asinh": [
	"es.math.asinh"
],
	"core-js/features/math/atanh": [
	"es.math.atanh"
],
	"core-js/features/math/cbrt": [
	"es.math.cbrt"
],
	"core-js/features/math/clamp": [
	"esnext.math.clamp"
],
	"core-js/features/math/clz32": [
	"es.math.clz32"
],
	"core-js/features/math/cosh": [
	"es.math.cosh"
],
	"core-js/features/math/deg-per-rad": [
	"esnext.math.deg-per-rad"
],
	"core-js/features/math/degrees": [
	"esnext.math.degrees"
],
	"core-js/features/math/expm1": [
	"es.math.expm1"
],
	"core-js/features/math/f16round": [
	"es.math.f16round",
	"esnext.math.f16round"
],
	"core-js/features/math/fround": [
	"es.math.fround"
],
	"core-js/features/math/fscale": [
	"esnext.math.fscale"
],
	"core-js/features/math/hypot": [
	"es.math.hypot"
],
	"core-js/features/math/iaddh": [
	"esnext.math.iaddh"
],
	"core-js/features/math/imul": [
	"es.math.imul"
],
	"core-js/features/math/imulh": [
	"esnext.math.imulh"
],
	"core-js/features/math/isubh": [
	"esnext.math.isubh"
],
	"core-js/features/math/log10": [
	"es.math.log10"
],
	"core-js/features/math/log1p": [
	"es.math.log1p"
],
	"core-js/features/math/log2": [
	"es.math.log2"
],
	"core-js/features/math/rad-per-deg": [
	"esnext.math.rad-per-deg"
],
	"core-js/features/math/radians": [
	"esnext.math.radians"
],
	"core-js/features/math/scale": [
	"esnext.math.scale"
],
	"core-js/features/math/seeded-prng": [
	"esnext.math.seeded-prng"
],
	"core-js/features/math/sign": [
	"es.math.sign"
],
	"core-js/features/math/signbit": [
	"esnext.math.signbit"
],
	"core-js/features/math/sinh": [
	"es.math.sinh"
],
	"core-js/features/math/sum-precise": [
	"es.array.iterator",
	"esnext.math.sum-precise"
],
	"core-js/features/math/tanh": [
	"es.math.tanh"
],
	"core-js/features/math/to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/features/math/trunc": [
	"es.math.trunc"
],
	"core-js/features/math/umulh": [
	"esnext.math.umulh"
],
	"core-js/features/number": [
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.to-string",
	"esnext.number.from-string",
	"esnext.number.range"
],
	"core-js/features/number/constructor": [
	"es.number.constructor"
],
	"core-js/features/number/epsilon": [
	"es.number.epsilon"
],
	"core-js/features/number/from-string": [
	"esnext.number.from-string"
],
	"core-js/features/number/is-finite": [
	"es.number.is-finite"
],
	"core-js/features/number/is-integer": [
	"es.number.is-integer"
],
	"core-js/features/number/is-nan": [
	"es.number.is-nan"
],
	"core-js/features/number/is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/features/number/max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/features/number/min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/features/number/parse-float": [
	"es.number.parse-float"
],
	"core-js/features/number/parse-int": [
	"es.number.parse-int"
],
	"core-js/features/number/range": [
	"es.object.to-string",
	"esnext.number.range"
],
	"core-js/features/number/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/features/number/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/features/number/to-precision": [
	"es.number.to-precision"
],
	"core-js/features/number/virtual": [
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/features/number/virtual/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/features/number/virtual/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/features/number/virtual/to-precision": [
	"es.number.to-precision"
],
	"core-js/features/object": [
	"es.symbol",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.reflect.to-string-tag",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"web.dom-collections.iterator"
],
	"core-js/features/object/assign": [
	"es.object.assign"
],
	"core-js/features/object/create": [
	"es.object.create"
],
	"core-js/features/object/define-getter": [
	"es.object.define-getter"
],
	"core-js/features/object/define-properties": [
	"es.object.define-properties"
],
	"core-js/features/object/define-property": [
	"es.object.define-property"
],
	"core-js/features/object/define-setter": [
	"es.object.define-setter"
],
	"core-js/features/object/entries": [
	"es.object.entries"
],
	"core-js/features/object/freeze": [
	"es.object.freeze"
],
	"core-js/features/object/from-entries": [
	"es.array.iterator",
	"es.object.from-entries",
	"web.dom-collections.iterator"
],
	"core-js/features/object/get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/features/object/get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/features/object/get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/features/object/get-own-property-symbols": [
	"es.symbol"
],
	"core-js/features/object/get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/features/object/group-by": [
	"es.object.create",
	"es.object.group-by",
	"esnext.object.group-by"
],
	"core-js/features/object/has-own": [
	"es.object.has-own",
	"esnext.object.has-own"
],
	"core-js/features/object/is": [
	"es.object.is"
],
	"core-js/features/object/is-extensible": [
	"es.object.is-extensible"
],
	"core-js/features/object/is-frozen": [
	"es.object.is-frozen"
],
	"core-js/features/object/is-sealed": [
	"es.object.is-sealed"
],
	"core-js/features/object/iterate-entries": [
	"esnext.object.iterate-entries"
],
	"core-js/features/object/iterate-keys": [
	"esnext.object.iterate-keys"
],
	"core-js/features/object/iterate-values": [
	"esnext.object.iterate-values"
],
	"core-js/features/object/keys": [
	"es.object.keys"
],
	"core-js/features/object/lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/features/object/lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/features/object/prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/features/object/proto": [
	"es.object.proto"
],
	"core-js/features/object/seal": [
	"es.object.seal"
],
	"core-js/features/object/set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/features/object/to-string": [
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/features/object/values": [
	"es.object.values"
],
	"core-js/features/observable": [
	"es.object.to-string",
	"es.string.iterator",
	"esnext.observable",
	"esnext.symbol.observable",
	"web.dom-collections.iterator"
],
	"core-js/features/parse-float": [
	"es.parse-float"
],
	"core-js/features/parse-int": [
	"es.parse-int"
],
	"core-js/features/promise": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.string.iterator",
	"esnext.aggregate-error",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"web.dom-collections.iterator"
],
	"core-js/features/promise/all-settled": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.string.iterator",
	"esnext.promise.all-settled",
	"web.dom-collections.iterator"
],
	"core-js/features/promise/any": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.any",
	"es.string.iterator",
	"esnext.aggregate-error",
	"esnext.promise.any",
	"web.dom-collections.iterator"
],
	"core-js/features/promise/finally": [
	"es.object.to-string",
	"es.promise",
	"es.promise.finally"
],
	"core-js/features/promise/try": [
	"es.object.to-string",
	"es.promise",
	"es.promise.try",
	"esnext.promise.try"
],
	"core-js/features/promise/with-resolvers": [
	"es.promise",
	"es.promise.with-resolvers",
	"esnext.promise.with-resolvers"
],
	"core-js/features/queue-microtask": [
	"web.queue-microtask"
],
	"core-js/features/reflect": [
	"es.object.to-string",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata"
],
	"core-js/features/reflect/apply": [
	"es.reflect.apply"
],
	"core-js/features/reflect/construct": [
	"es.reflect.construct"
],
	"core-js/features/reflect/define-metadata": [
	"esnext.reflect.define-metadata"
],
	"core-js/features/reflect/define-property": [
	"es.reflect.define-property"
],
	"core-js/features/reflect/delete-metadata": [
	"esnext.reflect.delete-metadata"
],
	"core-js/features/reflect/delete-property": [
	"es.reflect.delete-property"
],
	"core-js/features/reflect/get": [
	"es.reflect.get"
],
	"core-js/features/reflect/get-metadata": [
	"esnext.reflect.get-metadata"
],
	"core-js/features/reflect/get-metadata-keys": [
	"esnext.reflect.get-metadata-keys"
],
	"core-js/features/reflect/get-own-metadata": [
	"esnext.reflect.get-own-metadata"
],
	"core-js/features/reflect/get-own-metadata-keys": [
	"esnext.reflect.get-own-metadata-keys"
],
	"core-js/features/reflect/get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/features/reflect/get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/features/reflect/has": [
	"es.reflect.has"
],
	"core-js/features/reflect/has-metadata": [
	"esnext.reflect.has-metadata"
],
	"core-js/features/reflect/has-own-metadata": [
	"esnext.reflect.has-own-metadata"
],
	"core-js/features/reflect/is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/features/reflect/metadata": [
	"esnext.reflect.metadata"
],
	"core-js/features/reflect/own-keys": [
	"es.reflect.own-keys"
],
	"core-js/features/reflect/prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/features/reflect/set": [
	"es.reflect.set"
],
	"core-js/features/reflect/set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/features/reflect/to-string-tag": [
	"es.reflect.to-string-tag"
],
	"core-js/features/regexp": [
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.string.match",
	"es.string.replace",
	"es.string.search",
	"es.string.split",
	"esnext.regexp.escape"
],
	"core-js/features/regexp/constructor": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/features/regexp/dot-all": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec"
],
	"core-js/features/regexp/escape": [
	"es.regexp.escape",
	"esnext.regexp.escape"
],
	"core-js/features/regexp/flags": [
	"es.regexp.flags"
],
	"core-js/features/regexp/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/features/regexp/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/features/regexp/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/features/regexp/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/features/regexp/sticky": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/features/regexp/test": [
	"es.regexp.exec",
	"es.regexp.test"
],
	"core-js/features/regexp/to-string": [
	"es.regexp.to-string"
],
	"core-js/features/self": [
	"web.self"
],
	"core-js/features/set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.iterator",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"web.dom-collections.iterator"
],
	"core-js/features/set-immediate": [
	"web.immediate"
],
	"core-js/features/set-interval": [
	"web.timers"
],
	"core-js/features/set-timeout": [
	"web.timers"
],
	"core-js/features/set/add-all": [
	"es.set",
	"esnext.set.add-all"
],
	"core-js/features/set/delete-all": [
	"es.set",
	"esnext.set.delete-all"
],
	"core-js/features/set/difference": [
	"es.array.iterator",
	"es.set",
	"es.set.difference.v2",
	"es.string.iterator",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"web.dom-collections.iterator"
],
	"core-js/features/set/every": [
	"es.set",
	"esnext.set.every"
],
	"core-js/features/set/filter": [
	"es.set",
	"esnext.set.filter"
],
	"core-js/features/set/find": [
	"es.set",
	"esnext.set.find"
],
	"core-js/features/set/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.string.iterator",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"web.dom-collections.iterator"
],
	"core-js/features/set/intersection": [
	"es.array.iterator",
	"es.set",
	"es.set.intersection.v2",
	"es.string.iterator",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"web.dom-collections.iterator"
],
	"core-js/features/set/is-disjoint-from": [
	"es.array.iterator",
	"es.set",
	"es.set.is-disjoint-from.v2",
	"es.string.iterator",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"web.dom-collections.iterator"
],
	"core-js/features/set/is-subset-of": [
	"es.array.iterator",
	"es.set",
	"es.set.is-subset-of.v2",
	"es.string.iterator",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"web.dom-collections.iterator"
],
	"core-js/features/set/is-superset-of": [
	"es.array.iterator",
	"es.set",
	"es.set.is-superset-of.v2",
	"es.string.iterator",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"web.dom-collections.iterator"
],
	"core-js/features/set/join": [
	"es.set",
	"esnext.set.join"
],
	"core-js/features/set/map": [
	"es.set",
	"esnext.set.map"
],
	"core-js/features/set/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2"
],
	"core-js/features/set/reduce": [
	"es.set",
	"esnext.set.reduce"
],
	"core-js/features/set/some": [
	"es.set",
	"esnext.set.some"
],
	"core-js/features/set/symmetric-difference": [
	"es.array.iterator",
	"es.set",
	"es.set.symmetric-difference.v2",
	"es.string.iterator",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"web.dom-collections.iterator"
],
	"core-js/features/set/union": [
	"es.array.iterator",
	"es.set",
	"es.set.union.v2",
	"es.string.iterator",
	"esnext.set.union.v2",
	"esnext.set.union",
	"web.dom-collections.iterator"
],
	"core-js/features/string": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.weak-map",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed"
],
	"core-js/features/string/anchor": [
	"es.string.anchor"
],
	"core-js/features/string/at": [
	"es.string.at-alternative",
	"esnext.string.at"
],
	"core-js/features/string/big": [
	"es.string.big"
],
	"core-js/features/string/blink": [
	"es.string.blink"
],
	"core-js/features/string/bold": [
	"es.string.bold"
],
	"core-js/features/string/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/features/string/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/features/string/cooked": [
	"esnext.string.cooked"
],
	"core-js/features/string/dedent": [
	"es.string.from-code-point",
	"es.weak-map",
	"esnext.string.dedent"
],
	"core-js/features/string/ends-with": [
	"es.string.ends-with"
],
	"core-js/features/string/fixed": [
	"es.string.fixed"
],
	"core-js/features/string/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/features/string/fontsize": [
	"es.string.fontsize"
],
	"core-js/features/string/from-code-point": [
	"es.string.from-code-point"
],
	"core-js/features/string/includes": [
	"es.string.includes"
],
	"core-js/features/string/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/features/string/italics": [
	"es.string.italics"
],
	"core-js/features/string/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/features/string/link": [
	"es.string.link"
],
	"core-js/features/string/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/features/string/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/features/string/pad-end": [
	"es.string.pad-end"
],
	"core-js/features/string/pad-start": [
	"es.string.pad-start"
],
	"core-js/features/string/raw": [
	"es.string.raw"
],
	"core-js/features/string/repeat": [
	"es.string.repeat"
],
	"core-js/features/string/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/features/string/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/features/string/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/features/string/small": [
	"es.string.small"
],
	"core-js/features/string/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/features/string/starts-with": [
	"es.string.starts-with"
],
	"core-js/features/string/strike": [
	"es.string.strike"
],
	"core-js/features/string/sub": [
	"es.string.sub"
],
	"core-js/features/string/substr": [
	"es.string.substr"
],
	"core-js/features/string/sup": [
	"es.string.sup"
],
	"core-js/features/string/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/features/string/trim": [
	"es.string.trim"
],
	"core-js/features/string/trim-end": [
	"es.string.trim-end"
],
	"core-js/features/string/trim-left": [
	"es.string.trim-start"
],
	"core-js/features/string/trim-right": [
	"es.string.trim-end"
],
	"core-js/features/string/trim-start": [
	"es.string.trim-start"
],
	"core-js/features/string/virtual": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"esnext.string.at",
	"esnext.string.code-points",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed"
],
	"core-js/features/string/virtual/anchor": [
	"es.string.anchor"
],
	"core-js/features/string/virtual/at": [
	"es.string.at-alternative",
	"esnext.string.at"
],
	"core-js/features/string/virtual/big": [
	"es.string.big"
],
	"core-js/features/string/virtual/blink": [
	"es.string.blink"
],
	"core-js/features/string/virtual/bold": [
	"es.string.bold"
],
	"core-js/features/string/virtual/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/features/string/virtual/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/features/string/virtual/ends-with": [
	"es.string.ends-with"
],
	"core-js/features/string/virtual/fixed": [
	"es.string.fixed"
],
	"core-js/features/string/virtual/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/features/string/virtual/fontsize": [
	"es.string.fontsize"
],
	"core-js/features/string/virtual/includes": [
	"es.string.includes"
],
	"core-js/features/string/virtual/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/features/string/virtual/italics": [
	"es.string.italics"
],
	"core-js/features/string/virtual/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/features/string/virtual/link": [
	"es.string.link"
],
	"core-js/features/string/virtual/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/features/string/virtual/pad-end": [
	"es.string.pad-end"
],
	"core-js/features/string/virtual/pad-start": [
	"es.string.pad-start"
],
	"core-js/features/string/virtual/repeat": [
	"es.string.repeat"
],
	"core-js/features/string/virtual/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/features/string/virtual/small": [
	"es.string.small"
],
	"core-js/features/string/virtual/starts-with": [
	"es.string.starts-with"
],
	"core-js/features/string/virtual/strike": [
	"es.string.strike"
],
	"core-js/features/string/virtual/sub": [
	"es.string.sub"
],
	"core-js/features/string/virtual/substr": [
	"es.string.substr"
],
	"core-js/features/string/virtual/sup": [
	"es.string.sup"
],
	"core-js/features/string/virtual/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/features/string/virtual/trim": [
	"es.string.trim"
],
	"core-js/features/string/virtual/trim-end": [
	"es.string.trim-end"
],
	"core-js/features/string/virtual/trim-left": [
	"es.string.trim-start"
],
	"core-js/features/string/virtual/trim-right": [
	"es.string.trim-end"
],
	"core-js/features/string/virtual/trim-start": [
	"es.string.trim-start"
],
	"core-js/features/structured-clone": [
	"es.error.to-string",
	"es.array.iterator",
	"es.map",
	"es.object.keys",
	"es.object.to-string",
	"es.set",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.structured-clone"
],
	"core-js/features/suppressed-error": [
],
	"core-js/features/symbol": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag",
	"esnext.function.metadata",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"web.dom-collections.iterator"
],
	"core-js/features/symbol/async-dispose": [
	"esnext.symbol.async-dispose"
],
	"core-js/features/symbol/async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/features/symbol/custom-matcher": [
	"esnext.symbol.custom-matcher"
],
	"core-js/features/symbol/description": [
	"es.symbol.description"
],
	"core-js/features/symbol/dispose": [
	"esnext.symbol.dispose"
],
	"core-js/features/symbol/for": [
	"es.symbol"
],
	"core-js/features/symbol/has-instance": [
	"es.symbol.has-instance",
	"es.function.has-instance"
],
	"core-js/features/symbol/is-concat-spreadable": [
	"es.symbol.is-concat-spreadable",
	"es.array.concat"
],
	"core-js/features/symbol/is-registered": [
	"es.symbol",
	"esnext.symbol.is-registered"
],
	"core-js/features/symbol/is-registered-symbol": [
	"es.symbol",
	"esnext.symbol.is-registered-symbol"
],
	"core-js/features/symbol/is-well-known": [
	"es.symbol",
	"esnext.symbol.is-well-known"
],
	"core-js/features/symbol/is-well-known-symbol": [
	"es.symbol",
	"esnext.symbol.is-well-known-symbol"
],
	"core-js/features/symbol/iterator": [
	"es.symbol.iterator",
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/features/symbol/key-for": [
	"es.symbol"
],
	"core-js/features/symbol/match": [
	"es.symbol.match",
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/features/symbol/match-all": [
	"es.symbol.match-all",
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/features/symbol/matcher": [
	"esnext.symbol.matcher"
],
	"core-js/features/symbol/metadata": [
	"esnext.function.metadata",
	"esnext.symbol.metadata"
],
	"core-js/features/symbol/metadata-key": [
	"esnext.symbol.metadata-key"
],
	"core-js/features/symbol/observable": [
	"esnext.symbol.observable"
],
	"core-js/features/symbol/pattern-match": [
	"esnext.symbol.pattern-match"
],
	"core-js/features/symbol/replace": [
	"es.symbol.replace",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/features/symbol/replace-all": [
	"esnext.symbol.replace-all"
],
	"core-js/features/symbol/search": [
	"es.symbol.search",
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/features/symbol/species": [
	"es.symbol.species"
],
	"core-js/features/symbol/split": [
	"es.symbol.split",
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/features/symbol/to-primitive": [
	"es.symbol.to-primitive",
	"es.date.to-primitive"
],
	"core-js/features/symbol/to-string-tag": [
	"es.symbol.to-string-tag",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/features/symbol/unscopables": [
	"es.symbol.unscopables"
],
	"core-js/features/typed-array": [
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/at": [
	"es.typed-array.at",
	"esnext.typed-array.at"
],
	"core-js/features/typed-array/copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/features/typed-array/entries": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/features/typed-array/every": [
	"es.typed-array.every"
],
	"core-js/features/typed-array/fill": [
	"es.typed-array.fill"
],
	"core-js/features/typed-array/filter": [
	"es.typed-array.filter"
],
	"core-js/features/typed-array/filter-out": [
	"esnext.typed-array.filter-out"
],
	"core-js/features/typed-array/filter-reject": [
	"esnext.typed-array.filter-reject"
],
	"core-js/features/typed-array/find": [
	"es.typed-array.find"
],
	"core-js/features/typed-array/find-index": [
	"es.typed-array.find-index"
],
	"core-js/features/typed-array/find-last": [
	"es.typed-array.find-last",
	"esnext.typed-array.find-last"
],
	"core-js/features/typed-array/find-last-index": [
	"es.typed-array.find-last-index",
	"esnext.typed-array.find-last-index"
],
	"core-js/features/typed-array/float32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/float64-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float64-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/for-each": [
	"es.typed-array.for-each"
],
	"core-js/features/typed-array/from": [
	"es.typed-array.from"
],
	"core-js/features/typed-array/from-async": [
	"esnext.typed-array.from-async"
],
	"core-js/features/typed-array/from-base64": [
	"esnext.uint8-array.from-base64"
],
	"core-js/features/typed-array/from-hex": [
	"esnext.uint8-array.from-hex"
],
	"core-js/features/typed-array/group-by": [
	"esnext.typed-array.group-by"
],
	"core-js/features/typed-array/includes": [
	"es.typed-array.includes"
],
	"core-js/features/typed-array/index-of": [
	"es.typed-array.index-of"
],
	"core-js/features/typed-array/int16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/int32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/int8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/iterator": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/features/typed-array/join": [
	"es.typed-array.join"
],
	"core-js/features/typed-array/keys": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/features/typed-array/last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/features/typed-array/map": [
	"es.typed-array.map"
],
	"core-js/features/typed-array/methods": [
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/of": [
	"es.typed-array.of"
],
	"core-js/features/typed-array/reduce": [
	"es.typed-array.reduce"
],
	"core-js/features/typed-array/reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/features/typed-array/reverse": [
	"es.typed-array.reverse"
],
	"core-js/features/typed-array/set": [
	"es.typed-array.set"
],
	"core-js/features/typed-array/set-from-base64": [
	"esnext.uint8-array.set-from-base64"
],
	"core-js/features/typed-array/set-from-hex": [
	"esnext.uint8-array.set-from-hex"
],
	"core-js/features/typed-array/slice": [
	"es.typed-array.slice"
],
	"core-js/features/typed-array/some": [
	"es.typed-array.some"
],
	"core-js/features/typed-array/sort": [
	"es.typed-array.sort"
],
	"core-js/features/typed-array/subarray": [
	"es.typed-array.subarray"
],
	"core-js/features/typed-array/to-base64": [
	"esnext.uint8-array.to-base64"
],
	"core-js/features/typed-array/to-hex": [
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/features/typed-array/to-reversed": [
	"es.typed-array.to-reversed",
	"esnext.typed-array.to-reversed"
],
	"core-js/features/typed-array/to-sorted": [
	"es.typed-array.sort",
	"es.typed-array.to-sorted",
	"esnext.typed-array.to-sorted"
],
	"core-js/features/typed-array/to-spliced": [
	"esnext.typed-array.to-spliced"
],
	"core-js/features/typed-array/to-string": [
	"es.typed-array.to-string"
],
	"core-js/features/typed-array/uint16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/uint32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/uint8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/uint8-clamped-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/features/typed-array/unique-by": [
	"es.map",
	"esnext.typed-array.unique-by"
],
	"core-js/features/typed-array/values": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/features/typed-array/with": [
	"es.typed-array.with",
	"esnext.typed-array.with"
],
	"core-js/features/unescape": [
	"es.unescape"
],
	"core-js/features/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/features/url-search-params": [
	"web.dom-collections.iterator",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/features/url/can-parse": [
	"web.url",
	"web.url.can-parse"
],
	"core-js/features/url/parse": [
	"web.url",
	"web.url.parse"
],
	"core-js/features/url/to-json": [
	"web.url.to-json"
],
	"core-js/features/weak-map": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"web.dom-collections.iterator"
],
	"core-js/features/weak-map/delete-all": [
	"es.weak-map",
	"esnext.weak-map.delete-all"
],
	"core-js/features/weak-map/emplace": [
	"es.weak-map",
	"esnext.weak-map.emplace"
],
	"core-js/features/weak-map/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"web.dom-collections.iterator"
],
	"core-js/features/weak-map/get-or-insert": [
	"es.weak-map",
	"esnext.weak-map.get-or-insert"
],
	"core-js/features/weak-map/get-or-insert-computed": [
	"es.weak-map",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/features/weak-map/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/features/weak-map/upsert": [
	"es.weak-map",
	"esnext.weak-map.upsert"
],
	"core-js/features/weak-set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.dom-collections.iterator"
],
	"core-js/features/weak-set/add-all": [
	"es.weak-set",
	"esnext.weak-set.add-all"
],
	"core-js/features/weak-set/delete-all": [
	"es.weak-set",
	"esnext.weak-set.delete-all"
],
	"core-js/features/weak-set/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"web.dom-collections.iterator"
],
	"core-js/features/weak-set/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.of"
],
	"core-js/full": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/full/aggregate-error": [
],
	"core-js/full/array": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with"
],
	"core-js/full/array-buffer": [
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/full/array-buffer/constructor": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/full/array-buffer/detached": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"esnext.array-buffer.detached"
],
	"core-js/full/array-buffer/is-view": [
	"es.array-buffer.is-view"
],
	"core-js/full/array-buffer/slice": [
	"es.array-buffer.slice"
],
	"core-js/full/array-buffer/transfer": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer",
	"esnext.array-buffer.transfer"
],
	"core-js/full/array-buffer/transfer-to-fixed-length": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer-to-fixed-length",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/full/array/at": [
	"es.array.at",
	"esnext.array.at"
],
	"core-js/full/array/concat": [
	"es.array.concat"
],
	"core-js/full/array/copy-within": [
	"es.array.copy-within"
],
	"core-js/full/array/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/every": [
	"es.array.every"
],
	"core-js/full/array/fill": [
	"es.array.fill"
],
	"core-js/full/array/filter": [
	"es.array.filter"
],
	"core-js/full/array/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/full/array/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/full/array/find": [
	"es.array.find"
],
	"core-js/full/array/find-index": [
	"es.array.find-index"
],
	"core-js/full/array/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/full/array/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/full/array/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/full/array/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/full/array/for-each": [
	"es.array.for-each"
],
	"core-js/full/array/from": [
	"es.array.from",
	"es.string.iterator"
],
	"core-js/full/array/from-async": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.array.from-async"
],
	"core-js/full/array/group": [
	"esnext.array.group"
],
	"core-js/full/array/group-by": [
	"esnext.array.group-by"
],
	"core-js/full/array/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/full/array/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/full/array/includes": [
	"es.array.includes"
],
	"core-js/full/array/index-of": [
	"es.array.index-of"
],
	"core-js/full/array/is-array": [
	"es.array.is-array"
],
	"core-js/full/array/is-template-object": [
	"esnext.array.is-template-object"
],
	"core-js/full/array/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/join": [
	"es.array.join"
],
	"core-js/full/array/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/last-index": [
	"esnext.array.last-index"
],
	"core-js/full/array/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/full/array/last-item": [
	"esnext.array.last-item"
],
	"core-js/full/array/map": [
	"es.array.map"
],
	"core-js/full/array/of": [
	"es.array.of"
],
	"core-js/full/array/push": [
	"es.array.push"
],
	"core-js/full/array/reduce": [
	"es.array.reduce"
],
	"core-js/full/array/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/full/array/reverse": [
	"es.array.reverse"
],
	"core-js/full/array/slice": [
	"es.array.slice"
],
	"core-js/full/array/some": [
	"es.array.some"
],
	"core-js/full/array/sort": [
	"es.array.sort"
],
	"core-js/full/array/splice": [
	"es.array.splice"
],
	"core-js/full/array/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/full/array/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/full/array/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/full/array/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/full/array/unshift": [
	"es.array.unshift"
],
	"core-js/full/array/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/virtual": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.includes",
	"es.array.index-of",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.map",
	"es.object.to-string",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with"
],
	"core-js/full/array/virtual/at": [
	"es.array.at",
	"esnext.array.at"
],
	"core-js/full/array/virtual/concat": [
	"es.array.concat"
],
	"core-js/full/array/virtual/copy-within": [
	"es.array.copy-within"
],
	"core-js/full/array/virtual/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/virtual/every": [
	"es.array.every"
],
	"core-js/full/array/virtual/fill": [
	"es.array.fill"
],
	"core-js/full/array/virtual/filter": [
	"es.array.filter"
],
	"core-js/full/array/virtual/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/full/array/virtual/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/full/array/virtual/find": [
	"es.array.find"
],
	"core-js/full/array/virtual/find-index": [
	"es.array.find-index"
],
	"core-js/full/array/virtual/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/full/array/virtual/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/full/array/virtual/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/full/array/virtual/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/full/array/virtual/for-each": [
	"es.array.for-each"
],
	"core-js/full/array/virtual/group": [
	"esnext.array.group"
],
	"core-js/full/array/virtual/group-by": [
	"esnext.array.group-by"
],
	"core-js/full/array/virtual/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/full/array/virtual/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/full/array/virtual/includes": [
	"es.array.includes"
],
	"core-js/full/array/virtual/index-of": [
	"es.array.index-of"
],
	"core-js/full/array/virtual/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/virtual/join": [
	"es.array.join"
],
	"core-js/full/array/virtual/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/virtual/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/full/array/virtual/map": [
	"es.array.map"
],
	"core-js/full/array/virtual/push": [
	"es.array.push"
],
	"core-js/full/array/virtual/reduce": [
	"es.array.reduce"
],
	"core-js/full/array/virtual/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/full/array/virtual/reverse": [
	"es.array.reverse"
],
	"core-js/full/array/virtual/slice": [
	"es.array.slice"
],
	"core-js/full/array/virtual/some": [
	"es.array.some"
],
	"core-js/full/array/virtual/sort": [
	"es.array.sort"
],
	"core-js/full/array/virtual/splice": [
	"es.array.splice"
],
	"core-js/full/array/virtual/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/full/array/virtual/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/full/array/virtual/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/full/array/virtual/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/full/array/virtual/unshift": [
	"es.array.unshift"
],
	"core-js/full/array/virtual/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/full/array/virtual/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/full/array/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/full/async-disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/full/async-disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"es.promise",
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.iterator.dispose"
],
	"core-js/full/async-iterator": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/full/async-iterator/as-indexed-pairs": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs"
],
	"core-js/full/async-iterator/async-dispose": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.async-dispose"
],
	"core-js/full/async-iterator/drop": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop"
],
	"core-js/full/async-iterator/every": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.every"
],
	"core-js/full/async-iterator/filter": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.filter"
],
	"core-js/full/async-iterator/find": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.find"
],
	"core-js/full/async-iterator/flat-map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.flat-map"
],
	"core-js/full/async-iterator/for-each": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.for-each"
],
	"core-js/full/async-iterator/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"web.dom-collections.iterator"
],
	"core-js/full/async-iterator/indexed": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.indexed"
],
	"core-js/full/async-iterator/map": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.map"
],
	"core-js/full/async-iterator/reduce": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.reduce"
],
	"core-js/full/async-iterator/some": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.some"
],
	"core-js/full/async-iterator/take": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.take"
],
	"core-js/full/async-iterator/to-array": [
	"es.object.to-string",
	"es.promise",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.to-array"
],
	"core-js/full/atob": [
	"es.error.to-string",
	"es.object.to-string",
	"web.atob",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/full/bigint": [
	"es.object.to-string",
	"esnext.bigint.range"
],
	"core-js/full/bigint/range": [
	"es.object.to-string",
	"esnext.bigint.range"
],
	"core-js/full/btoa": [
	"es.error.to-string",
	"es.object.to-string",
	"web.btoa",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/full/clear-immediate": [
	"web.immediate"
],
	"core-js/full/composite-key": [
	"esnext.composite-key"
],
	"core-js/full/composite-symbol": [
	"es.symbol",
	"esnext.composite-symbol"
],
	"core-js/full/data-view": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.object.to-string",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/full/data-view/get-float16": [
	"es.data-view.get-float16",
	"esnext.data-view.get-float16"
],
	"core-js/full/data-view/get-uint8-clamped": [
	"esnext.data-view.get-uint8-clamped"
],
	"core-js/full/data-view/set-float16": [
	"es.data-view.set-float16",
	"esnext.data-view.set-float16"
],
	"core-js/full/data-view/set-uint8-clamped": [
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/full/date": [
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string"
],
	"core-js/full/date/get-year": [
	"es.date.get-year"
],
	"core-js/full/date/now": [
	"es.date.now"
],
	"core-js/full/date/set-year": [
	"es.date.set-year"
],
	"core-js/full/date/to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/full/date/to-iso-string": [
	"es.date.to-iso-string",
	"es.date.to-json"
],
	"core-js/full/date/to-json": [
	"es.date.to-json"
],
	"core-js/full/date/to-primitive": [
	"es.date.to-primitive"
],
	"core-js/full/date/to-string": [
	"es.date.to-string"
],
	"core-js/full/disposable-stack": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/full/disposable-stack/constructor": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.to-string",
	"esnext.suppressed-error.constructor",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose"
],
	"core-js/full/dom-collections": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator"
],
	"core-js/full/dom-collections/for-each": [
	"web.dom-collections.for-each"
],
	"core-js/full/dom-collections/iterator": [
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/full/dom-exception": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/full/dom-exception/constructor": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack"
],
	"core-js/full/dom-exception/to-string-tag": [
	"web.dom-exception.to-string-tag"
],
	"core-js/full/error": [
	"es.error.cause",
	"es.error.to-string",
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/full/error/constructor": [
	"es.error.cause"
],
	"core-js/full/error/is-error": [
	"es.object.create",
	"esnext.error.is-error"
],
	"core-js/full/error/to-string": [
	"es.error.to-string"
],
	"core-js/full/escape": [
	"es.escape"
],
	"core-js/full/function": [
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this"
],
	"core-js/full/function/bind": [
	"es.function.bind"
],
	"core-js/full/function/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/full/function/has-instance": [
	"es.function.has-instance"
],
	"core-js/full/function/is-callable": [
	"esnext.function.is-callable"
],
	"core-js/full/function/is-constructor": [
	"esnext.function.is-constructor"
],
	"core-js/full/function/metadata": [
	"esnext.function.metadata"
],
	"core-js/full/function/name": [
	"es.function.name"
],
	"core-js/full/function/un-this": [
	"esnext.function.un-this"
],
	"core-js/full/function/virtual": [
	"es.function.bind",
	"esnext.function.demethodize",
	"esnext.function.un-this"
],
	"core-js/full/function/virtual/bind": [
	"es.function.bind"
],
	"core-js/full/function/virtual/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/full/function/virtual/un-this": [
	"esnext.function.un-this"
],
	"core-js/full/get-iterator": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/full/get-iterator-method": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/full/global-this": [
	"es.global-this",
	"esnext.global-this"
],
	"core-js/full/instance/at": [
	"es.array.at",
	"es.string.at-alternative",
	"esnext.array.at",
	"esnext.string.at"
],
	"core-js/full/instance/bind": [
	"es.function.bind"
],
	"core-js/full/instance/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/full/instance/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/full/instance/concat": [
	"es.array.concat"
],
	"core-js/full/instance/copy-within": [
	"es.array.copy-within"
],
	"core-js/full/instance/demethodize": [
	"esnext.function.demethodize"
],
	"core-js/full/instance/ends-with": [
	"es.string.ends-with"
],
	"core-js/full/instance/entries": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/full/instance/every": [
	"es.array.every"
],
	"core-js/full/instance/fill": [
	"es.array.fill"
],
	"core-js/full/instance/filter": [
	"es.array.filter"
],
	"core-js/full/instance/filter-out": [
	"esnext.array.filter-out"
],
	"core-js/full/instance/filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/full/instance/find": [
	"es.array.find"
],
	"core-js/full/instance/find-index": [
	"es.array.find-index"
],
	"core-js/full/instance/find-last": [
	"es.array.find-last",
	"esnext.array.find-last"
],
	"core-js/full/instance/find-last-index": [
	"es.array.find-last-index",
	"esnext.array.find-last-index"
],
	"core-js/full/instance/flags": [
	"es.regexp.flags"
],
	"core-js/full/instance/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/full/instance/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/full/instance/for-each": [
	"es.array.for-each",
	"web.dom-collections.for-each"
],
	"core-js/full/instance/group": [
	"esnext.array.group"
],
	"core-js/full/instance/group-by": [
	"esnext.array.group-by"
],
	"core-js/full/instance/group-by-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-by-to-map"
],
	"core-js/full/instance/group-to-map": [
	"es.map",
	"es.object.to-string",
	"esnext.array.group-to-map"
],
	"core-js/full/instance/includes": [
	"es.array.includes",
	"es.string.includes"
],
	"core-js/full/instance/index-of": [
	"es.array.index-of"
],
	"core-js/full/instance/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/full/instance/keys": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/full/instance/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/full/instance/map": [
	"es.array.map"
],
	"core-js/full/instance/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/full/instance/pad-end": [
	"es.string.pad-end"
],
	"core-js/full/instance/pad-start": [
	"es.string.pad-start"
],
	"core-js/full/instance/push": [
	"es.array.push"
],
	"core-js/full/instance/reduce": [
	"es.array.reduce"
],
	"core-js/full/instance/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/full/instance/repeat": [
	"es.string.repeat"
],
	"core-js/full/instance/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/full/instance/reverse": [
	"es.array.reverse"
],
	"core-js/full/instance/slice": [
	"es.array.slice"
],
	"core-js/full/instance/some": [
	"es.array.some"
],
	"core-js/full/instance/sort": [
	"es.array.sort"
],
	"core-js/full/instance/splice": [
	"es.array.splice"
],
	"core-js/full/instance/starts-with": [
	"es.string.starts-with"
],
	"core-js/full/instance/to-reversed": [
	"es.array.to-reversed",
	"esnext.array.to-reversed"
],
	"core-js/full/instance/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted",
	"esnext.array.to-sorted"
],
	"core-js/full/instance/to-spliced": [
	"es.array.to-spliced",
	"esnext.array.to-spliced"
],
	"core-js/full/instance/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/full/instance/trim": [
	"es.string.trim"
],
	"core-js/full/instance/trim-end": [
	"es.string.trim-end"
],
	"core-js/full/instance/trim-left": [
	"es.string.trim-start"
],
	"core-js/full/instance/trim-right": [
	"es.string.trim-end"
],
	"core-js/full/instance/trim-start": [
	"es.string.trim-start"
],
	"core-js/full/instance/un-this": [
	"esnext.function.un-this"
],
	"core-js/full/instance/unique-by": [
	"es.map",
	"esnext.array.unique-by"
],
	"core-js/full/instance/unshift": [
	"es.array.unshift"
],
	"core-js/full/instance/values": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/full/instance/with": [
	"es.array.with",
	"esnext.array.with"
],
	"core-js/full/is-iterable": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/full/iterator": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/full/iterator/as-indexed-pairs": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs"
],
	"core-js/full/iterator/concat": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.iterator.concat"
],
	"core-js/full/iterator/dispose": [
	"esnext.iterator.dispose"
],
	"core-js/full/iterator/drop": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.drop"
],
	"core-js/full/iterator/every": [
	"es.iterator.constructor",
	"es.iterator.every",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.every"
],
	"core-js/full/iterator/filter": [
	"es.iterator.constructor",
	"es.iterator.filter",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.filter"
],
	"core-js/full/iterator/find": [
	"es.iterator.constructor",
	"es.iterator.find",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.find"
],
	"core-js/full/iterator/flat-map": [
	"es.iterator.constructor",
	"es.iterator.flat-map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.flat-map"
],
	"core-js/full/iterator/for-each": [
	"es.iterator.constructor",
	"es.iterator.for-each",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.for-each"
],
	"core-js/full/iterator/from": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"web.dom-collections.iterator"
],
	"core-js/full/iterator/indexed": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.indexed"
],
	"core-js/full/iterator/map": [
	"es.iterator.constructor",
	"es.iterator.map",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.map"
],
	"core-js/full/iterator/range": [
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.range"
],
	"core-js/full/iterator/reduce": [
	"es.iterator.constructor",
	"es.iterator.reduce",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.reduce"
],
	"core-js/full/iterator/some": [
	"es.iterator.constructor",
	"es.iterator.some",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.some"
],
	"core-js/full/iterator/take": [
	"es.iterator.constructor",
	"es.iterator.take",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.take"
],
	"core-js/full/iterator/to-array": [
	"es.iterator.constructor",
	"es.iterator.to-array",
	"es.object.to-string",
	"esnext.iterator.constructor",
	"esnext.iterator.to-array"
],
	"core-js/full/iterator/to-async": [
	"es.iterator.constructor",
	"es.object.to-string",
	"es.promise",
	"esnext.iterator.constructor",
	"esnext.iterator.to-async"
],
	"core-js/full/json": [
	"es.date.to-json",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.object.create",
	"es.object.freeze",
	"es.object.keys",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json"
],
	"core-js/full/json/is-raw-json": [
	"esnext.json.is-raw-json"
],
	"core-js/full/json/parse": [
	"es.object.keys",
	"esnext.json.parse"
],
	"core-js/full/json/raw-json": [
	"es.object.create",
	"es.object.freeze",
	"esnext.json.raw-json"
],
	"core-js/full/json/stringify": [
	"es.date.to-json",
	"es.json.stringify"
],
	"core-js/full/json/to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/full/map": [
	"es.array.iterator",
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"web.dom-collections.iterator"
],
	"core-js/full/map/delete-all": [
	"es.map",
	"esnext.map.delete-all"
],
	"core-js/full/map/emplace": [
	"es.map",
	"esnext.map.emplace"
],
	"core-js/full/map/every": [
	"es.map",
	"esnext.map.every"
],
	"core-js/full/map/filter": [
	"es.map",
	"esnext.map.filter"
],
	"core-js/full/map/find": [
	"es.map",
	"esnext.map.find"
],
	"core-js/full/map/find-key": [
	"es.map",
	"esnext.map.find-key"
],
	"core-js/full/map/from": [
	"es.array.iterator",
	"es.map",
	"es.object.to-string",
	"es.string.iterator",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"web.dom-collections.iterator"
],
	"core-js/full/map/get-or-insert": [
	"es.map",
	"esnext.map.get-or-insert"
],
	"core-js/full/map/get-or-insert-computed": [
	"es.map",
	"esnext.map.get-or-insert-computed"
],
	"core-js/full/map/group-by": [
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/full/map/includes": [
	"es.map",
	"esnext.map.includes"
],
	"core-js/full/map/key-by": [
	"es.map",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/full/map/key-of": [
	"es.map",
	"esnext.map.key-of"
],
	"core-js/full/map/map-keys": [
	"es.map",
	"esnext.map.map-keys"
],
	"core-js/full/map/map-values": [
	"es.map",
	"esnext.map.map-values"
],
	"core-js/full/map/merge": [
	"es.map",
	"esnext.map.merge"
],
	"core-js/full/map/of": [
	"es.array.iterator",
	"es.map",
	"es.object.to-string",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.includes",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update"
],
	"core-js/full/map/reduce": [
	"es.map",
	"esnext.map.reduce"
],
	"core-js/full/map/some": [
	"es.map",
	"esnext.map.some"
],
	"core-js/full/map/update": [
	"es.map",
	"esnext.map.update"
],
	"core-js/full/map/update-or-insert": [
	"es.map",
	"esnext.map.update-or-insert"
],
	"core-js/full/map/upsert": [
	"es.map",
	"esnext.map.upsert"
],
	"core-js/full/math": [
	"es.array.iterator",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh"
],
	"core-js/full/math/acosh": [
	"es.math.acosh"
],
	"core-js/full/math/asinh": [
	"es.math.asinh"
],
	"core-js/full/math/atanh": [
	"es.math.atanh"
],
	"core-js/full/math/cbrt": [
	"es.math.cbrt"
],
	"core-js/full/math/clamp": [
	"esnext.math.clamp"
],
	"core-js/full/math/clz32": [
	"es.math.clz32"
],
	"core-js/full/math/cosh": [
	"es.math.cosh"
],
	"core-js/full/math/deg-per-rad": [
	"esnext.math.deg-per-rad"
],
	"core-js/full/math/degrees": [
	"esnext.math.degrees"
],
	"core-js/full/math/expm1": [
	"es.math.expm1"
],
	"core-js/full/math/f16round": [
	"es.math.f16round",
	"esnext.math.f16round"
],
	"core-js/full/math/fround": [
	"es.math.fround"
],
	"core-js/full/math/fscale": [
	"esnext.math.fscale"
],
	"core-js/full/math/hypot": [
	"es.math.hypot"
],
	"core-js/full/math/iaddh": [
	"esnext.math.iaddh"
],
	"core-js/full/math/imul": [
	"es.math.imul"
],
	"core-js/full/math/imulh": [
	"esnext.math.imulh"
],
	"core-js/full/math/isubh": [
	"esnext.math.isubh"
],
	"core-js/full/math/log10": [
	"es.math.log10"
],
	"core-js/full/math/log1p": [
	"es.math.log1p"
],
	"core-js/full/math/log2": [
	"es.math.log2"
],
	"core-js/full/math/rad-per-deg": [
	"esnext.math.rad-per-deg"
],
	"core-js/full/math/radians": [
	"esnext.math.radians"
],
	"core-js/full/math/scale": [
	"esnext.math.scale"
],
	"core-js/full/math/seeded-prng": [
	"esnext.math.seeded-prng"
],
	"core-js/full/math/sign": [
	"es.math.sign"
],
	"core-js/full/math/signbit": [
	"esnext.math.signbit"
],
	"core-js/full/math/sinh": [
	"es.math.sinh"
],
	"core-js/full/math/sum-precise": [
	"es.array.iterator",
	"esnext.math.sum-precise"
],
	"core-js/full/math/tanh": [
	"es.math.tanh"
],
	"core-js/full/math/to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/full/math/trunc": [
	"es.math.trunc"
],
	"core-js/full/math/umulh": [
	"esnext.math.umulh"
],
	"core-js/full/number": [
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.to-string",
	"esnext.number.from-string",
	"esnext.number.range"
],
	"core-js/full/number/constructor": [
	"es.number.constructor"
],
	"core-js/full/number/epsilon": [
	"es.number.epsilon"
],
	"core-js/full/number/from-string": [
	"esnext.number.from-string"
],
	"core-js/full/number/is-finite": [
	"es.number.is-finite"
],
	"core-js/full/number/is-integer": [
	"es.number.is-integer"
],
	"core-js/full/number/is-nan": [
	"es.number.is-nan"
],
	"core-js/full/number/is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/full/number/max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/full/number/min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/full/number/parse-float": [
	"es.number.parse-float"
],
	"core-js/full/number/parse-int": [
	"es.number.parse-int"
],
	"core-js/full/number/range": [
	"es.object.to-string",
	"esnext.number.range"
],
	"core-js/full/number/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/full/number/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/full/number/to-precision": [
	"es.number.to-precision"
],
	"core-js/full/number/virtual": [
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/full/number/virtual/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/full/number/virtual/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/full/number/virtual/to-precision": [
	"es.number.to-precision"
],
	"core-js/full/object": [
	"es.symbol",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.reflect.to-string-tag",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"web.dom-collections.iterator"
],
	"core-js/full/object/assign": [
	"es.object.assign"
],
	"core-js/full/object/create": [
	"es.object.create"
],
	"core-js/full/object/define-getter": [
	"es.object.define-getter"
],
	"core-js/full/object/define-properties": [
	"es.object.define-properties"
],
	"core-js/full/object/define-property": [
	"es.object.define-property"
],
	"core-js/full/object/define-setter": [
	"es.object.define-setter"
],
	"core-js/full/object/entries": [
	"es.object.entries"
],
	"core-js/full/object/freeze": [
	"es.object.freeze"
],
	"core-js/full/object/from-entries": [
	"es.array.iterator",
	"es.object.from-entries",
	"web.dom-collections.iterator"
],
	"core-js/full/object/get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/full/object/get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/full/object/get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/full/object/get-own-property-symbols": [
	"es.symbol"
],
	"core-js/full/object/get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/full/object/group-by": [
	"es.object.create",
	"es.object.group-by",
	"esnext.object.group-by"
],
	"core-js/full/object/has-own": [
	"es.object.has-own",
	"esnext.object.has-own"
],
	"core-js/full/object/is": [
	"es.object.is"
],
	"core-js/full/object/is-extensible": [
	"es.object.is-extensible"
],
	"core-js/full/object/is-frozen": [
	"es.object.is-frozen"
],
	"core-js/full/object/is-sealed": [
	"es.object.is-sealed"
],
	"core-js/full/object/iterate-entries": [
	"esnext.object.iterate-entries"
],
	"core-js/full/object/iterate-keys": [
	"esnext.object.iterate-keys"
],
	"core-js/full/object/iterate-values": [
	"esnext.object.iterate-values"
],
	"core-js/full/object/keys": [
	"es.object.keys"
],
	"core-js/full/object/lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/full/object/lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/full/object/prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/full/object/proto": [
	"es.object.proto"
],
	"core-js/full/object/seal": [
	"es.object.seal"
],
	"core-js/full/object/set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/full/object/to-string": [
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/full/object/values": [
	"es.object.values"
],
	"core-js/full/observable": [
	"es.object.to-string",
	"es.string.iterator",
	"esnext.observable",
	"esnext.symbol.observable",
	"web.dom-collections.iterator"
],
	"core-js/full/parse-float": [
	"es.parse-float"
],
	"core-js/full/parse-int": [
	"es.parse-int"
],
	"core-js/full/promise": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.string.iterator",
	"esnext.aggregate-error",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"web.dom-collections.iterator"
],
	"core-js/full/promise/all-settled": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.string.iterator",
	"esnext.promise.all-settled",
	"web.dom-collections.iterator"
],
	"core-js/full/promise/any": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.any",
	"es.string.iterator",
	"esnext.aggregate-error",
	"esnext.promise.any",
	"web.dom-collections.iterator"
],
	"core-js/full/promise/finally": [
	"es.object.to-string",
	"es.promise",
	"es.promise.finally"
],
	"core-js/full/promise/try": [
	"es.object.to-string",
	"es.promise",
	"es.promise.try",
	"esnext.promise.try"
],
	"core-js/full/promise/with-resolvers": [
	"es.promise",
	"es.promise.with-resolvers",
	"esnext.promise.with-resolvers"
],
	"core-js/full/queue-microtask": [
	"web.queue-microtask"
],
	"core-js/full/reflect": [
	"es.object.to-string",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata"
],
	"core-js/full/reflect/apply": [
	"es.reflect.apply"
],
	"core-js/full/reflect/construct": [
	"es.reflect.construct"
],
	"core-js/full/reflect/define-metadata": [
	"esnext.reflect.define-metadata"
],
	"core-js/full/reflect/define-property": [
	"es.reflect.define-property"
],
	"core-js/full/reflect/delete-metadata": [
	"esnext.reflect.delete-metadata"
],
	"core-js/full/reflect/delete-property": [
	"es.reflect.delete-property"
],
	"core-js/full/reflect/get": [
	"es.reflect.get"
],
	"core-js/full/reflect/get-metadata": [
	"esnext.reflect.get-metadata"
],
	"core-js/full/reflect/get-metadata-keys": [
	"esnext.reflect.get-metadata-keys"
],
	"core-js/full/reflect/get-own-metadata": [
	"esnext.reflect.get-own-metadata"
],
	"core-js/full/reflect/get-own-metadata-keys": [
	"esnext.reflect.get-own-metadata-keys"
],
	"core-js/full/reflect/get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/full/reflect/get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/full/reflect/has": [
	"es.reflect.has"
],
	"core-js/full/reflect/has-metadata": [
	"esnext.reflect.has-metadata"
],
	"core-js/full/reflect/has-own-metadata": [
	"esnext.reflect.has-own-metadata"
],
	"core-js/full/reflect/is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/full/reflect/metadata": [
	"esnext.reflect.metadata"
],
	"core-js/full/reflect/own-keys": [
	"es.reflect.own-keys"
],
	"core-js/full/reflect/prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/full/reflect/set": [
	"es.reflect.set"
],
	"core-js/full/reflect/set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/full/reflect/to-string-tag": [
	"es.reflect.to-string-tag"
],
	"core-js/full/regexp": [
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.string.match",
	"es.string.replace",
	"es.string.search",
	"es.string.split",
	"esnext.regexp.escape"
],
	"core-js/full/regexp/constructor": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/full/regexp/dot-all": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec"
],
	"core-js/full/regexp/escape": [
	"es.regexp.escape",
	"esnext.regexp.escape"
],
	"core-js/full/regexp/flags": [
	"es.regexp.flags"
],
	"core-js/full/regexp/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/full/regexp/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/full/regexp/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/full/regexp/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/full/regexp/sticky": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/full/regexp/test": [
	"es.regexp.exec",
	"es.regexp.test"
],
	"core-js/full/regexp/to-string": [
	"es.regexp.to-string"
],
	"core-js/full/self": [
	"web.self"
],
	"core-js/full/set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.iterator",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"web.dom-collections.iterator"
],
	"core-js/full/set-immediate": [
	"web.immediate"
],
	"core-js/full/set-interval": [
	"web.timers"
],
	"core-js/full/set-timeout": [
	"web.timers"
],
	"core-js/full/set/add-all": [
	"es.set",
	"esnext.set.add-all"
],
	"core-js/full/set/delete-all": [
	"es.set",
	"esnext.set.delete-all"
],
	"core-js/full/set/difference": [
	"es.array.iterator",
	"es.set",
	"es.set.difference.v2",
	"es.string.iterator",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"web.dom-collections.iterator"
],
	"core-js/full/set/every": [
	"es.set",
	"esnext.set.every"
],
	"core-js/full/set/filter": [
	"es.set",
	"esnext.set.filter"
],
	"core-js/full/set/find": [
	"es.set",
	"esnext.set.find"
],
	"core-js/full/set/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.string.iterator",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"web.dom-collections.iterator"
],
	"core-js/full/set/intersection": [
	"es.array.iterator",
	"es.set",
	"es.set.intersection.v2",
	"es.string.iterator",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"web.dom-collections.iterator"
],
	"core-js/full/set/is-disjoint-from": [
	"es.array.iterator",
	"es.set",
	"es.set.is-disjoint-from.v2",
	"es.string.iterator",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"web.dom-collections.iterator"
],
	"core-js/full/set/is-subset-of": [
	"es.array.iterator",
	"es.set",
	"es.set.is-subset-of.v2",
	"es.string.iterator",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"web.dom-collections.iterator"
],
	"core-js/full/set/is-superset-of": [
	"es.array.iterator",
	"es.set",
	"es.set.is-superset-of.v2",
	"es.string.iterator",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"web.dom-collections.iterator"
],
	"core-js/full/set/join": [
	"es.set",
	"esnext.set.join"
],
	"core-js/full/set/map": [
	"es.set",
	"esnext.set.map"
],
	"core-js/full/set/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2"
],
	"core-js/full/set/reduce": [
	"es.set",
	"esnext.set.reduce"
],
	"core-js/full/set/some": [
	"es.set",
	"esnext.set.some"
],
	"core-js/full/set/symmetric-difference": [
	"es.array.iterator",
	"es.set",
	"es.set.symmetric-difference.v2",
	"es.string.iterator",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"web.dom-collections.iterator"
],
	"core-js/full/set/union": [
	"es.array.iterator",
	"es.set",
	"es.set.union.v2",
	"es.string.iterator",
	"esnext.set.union.v2",
	"esnext.set.union",
	"web.dom-collections.iterator"
],
	"core-js/full/string": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.weak-map",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed"
],
	"core-js/full/string/anchor": [
	"es.string.anchor"
],
	"core-js/full/string/at": [
	"es.string.at-alternative",
	"esnext.string.at"
],
	"core-js/full/string/big": [
	"es.string.big"
],
	"core-js/full/string/blink": [
	"es.string.blink"
],
	"core-js/full/string/bold": [
	"es.string.bold"
],
	"core-js/full/string/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/full/string/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/full/string/cooked": [
	"esnext.string.cooked"
],
	"core-js/full/string/dedent": [
	"es.string.from-code-point",
	"es.weak-map",
	"esnext.string.dedent"
],
	"core-js/full/string/ends-with": [
	"es.string.ends-with"
],
	"core-js/full/string/fixed": [
	"es.string.fixed"
],
	"core-js/full/string/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/full/string/fontsize": [
	"es.string.fontsize"
],
	"core-js/full/string/from-code-point": [
	"es.string.from-code-point"
],
	"core-js/full/string/includes": [
	"es.string.includes"
],
	"core-js/full/string/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/full/string/italics": [
	"es.string.italics"
],
	"core-js/full/string/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/full/string/link": [
	"es.string.link"
],
	"core-js/full/string/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/full/string/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/full/string/pad-end": [
	"es.string.pad-end"
],
	"core-js/full/string/pad-start": [
	"es.string.pad-start"
],
	"core-js/full/string/raw": [
	"es.string.raw"
],
	"core-js/full/string/repeat": [
	"es.string.repeat"
],
	"core-js/full/string/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/full/string/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/full/string/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/full/string/small": [
	"es.string.small"
],
	"core-js/full/string/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/full/string/starts-with": [
	"es.string.starts-with"
],
	"core-js/full/string/strike": [
	"es.string.strike"
],
	"core-js/full/string/sub": [
	"es.string.sub"
],
	"core-js/full/string/substr": [
	"es.string.substr"
],
	"core-js/full/string/sup": [
	"es.string.sup"
],
	"core-js/full/string/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/full/string/trim": [
	"es.string.trim"
],
	"core-js/full/string/trim-end": [
	"es.string.trim-end"
],
	"core-js/full/string/trim-left": [
	"es.string.trim-start"
],
	"core-js/full/string/trim-right": [
	"es.string.trim-end"
],
	"core-js/full/string/trim-start": [
	"es.string.trim-start"
],
	"core-js/full/string/virtual": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"esnext.string.at",
	"esnext.string.code-points",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed"
],
	"core-js/full/string/virtual/anchor": [
	"es.string.anchor"
],
	"core-js/full/string/virtual/at": [
	"es.string.at-alternative",
	"esnext.string.at"
],
	"core-js/full/string/virtual/big": [
	"es.string.big"
],
	"core-js/full/string/virtual/blink": [
	"es.string.blink"
],
	"core-js/full/string/virtual/bold": [
	"es.string.bold"
],
	"core-js/full/string/virtual/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/full/string/virtual/code-points": [
	"es.object.to-string",
	"esnext.string.code-points"
],
	"core-js/full/string/virtual/ends-with": [
	"es.string.ends-with"
],
	"core-js/full/string/virtual/fixed": [
	"es.string.fixed"
],
	"core-js/full/string/virtual/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/full/string/virtual/fontsize": [
	"es.string.fontsize"
],
	"core-js/full/string/virtual/includes": [
	"es.string.includes"
],
	"core-js/full/string/virtual/is-well-formed": [
	"es.string.is-well-formed",
	"esnext.string.is-well-formed"
],
	"core-js/full/string/virtual/italics": [
	"es.string.italics"
],
	"core-js/full/string/virtual/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/full/string/virtual/link": [
	"es.string.link"
],
	"core-js/full/string/virtual/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all",
	"esnext.string.match-all"
],
	"core-js/full/string/virtual/pad-end": [
	"es.string.pad-end"
],
	"core-js/full/string/virtual/pad-start": [
	"es.string.pad-start"
],
	"core-js/full/string/virtual/repeat": [
	"es.string.repeat"
],
	"core-js/full/string/virtual/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all",
	"esnext.string.replace-all"
],
	"core-js/full/string/virtual/small": [
	"es.string.small"
],
	"core-js/full/string/virtual/starts-with": [
	"es.string.starts-with"
],
	"core-js/full/string/virtual/strike": [
	"es.string.strike"
],
	"core-js/full/string/virtual/sub": [
	"es.string.sub"
],
	"core-js/full/string/virtual/substr": [
	"es.string.substr"
],
	"core-js/full/string/virtual/sup": [
	"es.string.sup"
],
	"core-js/full/string/virtual/to-well-formed": [
	"es.string.to-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/full/string/virtual/trim": [
	"es.string.trim"
],
	"core-js/full/string/virtual/trim-end": [
	"es.string.trim-end"
],
	"core-js/full/string/virtual/trim-left": [
	"es.string.trim-start"
],
	"core-js/full/string/virtual/trim-right": [
	"es.string.trim-end"
],
	"core-js/full/string/virtual/trim-start": [
	"es.string.trim-start"
],
	"core-js/full/structured-clone": [
	"es.error.to-string",
	"es.array.iterator",
	"es.map",
	"es.object.keys",
	"es.object.to-string",
	"es.set",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.structured-clone"
],
	"core-js/full/suppressed-error": [
],
	"core-js/full/symbol": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag",
	"esnext.function.metadata",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"web.dom-collections.iterator"
],
	"core-js/full/symbol/async-dispose": [
	"esnext.symbol.async-dispose"
],
	"core-js/full/symbol/async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/full/symbol/custom-matcher": [
	"esnext.symbol.custom-matcher"
],
	"core-js/full/symbol/description": [
	"es.symbol.description"
],
	"core-js/full/symbol/dispose": [
	"esnext.symbol.dispose"
],
	"core-js/full/symbol/for": [
	"es.symbol"
],
	"core-js/full/symbol/has-instance": [
	"es.symbol.has-instance",
	"es.function.has-instance"
],
	"core-js/full/symbol/is-concat-spreadable": [
	"es.symbol.is-concat-spreadable",
	"es.array.concat"
],
	"core-js/full/symbol/is-registered": [
	"es.symbol",
	"esnext.symbol.is-registered"
],
	"core-js/full/symbol/is-registered-symbol": [
	"es.symbol",
	"esnext.symbol.is-registered-symbol"
],
	"core-js/full/symbol/is-well-known": [
	"es.symbol",
	"esnext.symbol.is-well-known"
],
	"core-js/full/symbol/is-well-known-symbol": [
	"es.symbol",
	"esnext.symbol.is-well-known-symbol"
],
	"core-js/full/symbol/iterator": [
	"es.symbol.iterator",
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/full/symbol/key-for": [
	"es.symbol"
],
	"core-js/full/symbol/match": [
	"es.symbol.match",
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/full/symbol/match-all": [
	"es.symbol.match-all",
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/full/symbol/matcher": [
	"esnext.symbol.matcher"
],
	"core-js/full/symbol/metadata": [
	"esnext.function.metadata",
	"esnext.symbol.metadata"
],
	"core-js/full/symbol/metadata-key": [
	"esnext.symbol.metadata-key"
],
	"core-js/full/symbol/observable": [
	"esnext.symbol.observable"
],
	"core-js/full/symbol/pattern-match": [
	"esnext.symbol.pattern-match"
],
	"core-js/full/symbol/replace": [
	"es.symbol.replace",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/full/symbol/replace-all": [
	"esnext.symbol.replace-all"
],
	"core-js/full/symbol/search": [
	"es.symbol.search",
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/full/symbol/species": [
	"es.symbol.species"
],
	"core-js/full/symbol/split": [
	"es.symbol.split",
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/full/symbol/to-primitive": [
	"es.symbol.to-primitive",
	"es.date.to-primitive"
],
	"core-js/full/symbol/to-string-tag": [
	"es.symbol.to-string-tag",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/full/symbol/unscopables": [
	"es.symbol.unscopables"
],
	"core-js/full/typed-array": [
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/at": [
	"es.typed-array.at",
	"esnext.typed-array.at"
],
	"core-js/full/typed-array/copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/full/typed-array/entries": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/full/typed-array/every": [
	"es.typed-array.every"
],
	"core-js/full/typed-array/fill": [
	"es.typed-array.fill"
],
	"core-js/full/typed-array/filter": [
	"es.typed-array.filter"
],
	"core-js/full/typed-array/filter-out": [
	"esnext.typed-array.filter-out"
],
	"core-js/full/typed-array/filter-reject": [
	"esnext.typed-array.filter-reject"
],
	"core-js/full/typed-array/find": [
	"es.typed-array.find"
],
	"core-js/full/typed-array/find-index": [
	"es.typed-array.find-index"
],
	"core-js/full/typed-array/find-last": [
	"es.typed-array.find-last",
	"esnext.typed-array.find-last"
],
	"core-js/full/typed-array/find-last-index": [
	"es.typed-array.find-last-index",
	"esnext.typed-array.find-last-index"
],
	"core-js/full/typed-array/float32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/float64-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.float64-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/for-each": [
	"es.typed-array.for-each"
],
	"core-js/full/typed-array/from": [
	"es.typed-array.from"
],
	"core-js/full/typed-array/from-async": [
	"esnext.typed-array.from-async"
],
	"core-js/full/typed-array/from-base64": [
	"esnext.uint8-array.from-base64"
],
	"core-js/full/typed-array/from-hex": [
	"esnext.uint8-array.from-hex"
],
	"core-js/full/typed-array/group-by": [
	"esnext.typed-array.group-by"
],
	"core-js/full/typed-array/includes": [
	"es.typed-array.includes"
],
	"core-js/full/typed-array/index-of": [
	"es.typed-array.index-of"
],
	"core-js/full/typed-array/int16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/int32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/int8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.int8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/iterator": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/full/typed-array/join": [
	"es.typed-array.join"
],
	"core-js/full/typed-array/keys": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/full/typed-array/last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/full/typed-array/map": [
	"es.typed-array.map"
],
	"core-js/full/typed-array/methods": [
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/of": [
	"es.typed-array.of"
],
	"core-js/full/typed-array/reduce": [
	"es.typed-array.reduce"
],
	"core-js/full/typed-array/reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/full/typed-array/reverse": [
	"es.typed-array.reverse"
],
	"core-js/full/typed-array/set": [
	"es.typed-array.set"
],
	"core-js/full/typed-array/set-from-base64": [
	"esnext.uint8-array.set-from-base64"
],
	"core-js/full/typed-array/set-from-hex": [
	"esnext.uint8-array.set-from-hex"
],
	"core-js/full/typed-array/slice": [
	"es.typed-array.slice"
],
	"core-js/full/typed-array/some": [
	"es.typed-array.some"
],
	"core-js/full/typed-array/sort": [
	"es.typed-array.sort"
],
	"core-js/full/typed-array/subarray": [
	"es.typed-array.subarray"
],
	"core-js/full/typed-array/to-base64": [
	"esnext.uint8-array.to-base64"
],
	"core-js/full/typed-array/to-hex": [
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/full/typed-array/to-reversed": [
	"es.typed-array.to-reversed",
	"esnext.typed-array.to-reversed"
],
	"core-js/full/typed-array/to-sorted": [
	"es.typed-array.sort",
	"es.typed-array.to-sorted",
	"esnext.typed-array.to-sorted"
],
	"core-js/full/typed-array/to-spliced": [
	"esnext.typed-array.to-spliced"
],
	"core-js/full/typed-array/to-string": [
	"es.typed-array.to-string"
],
	"core-js/full/typed-array/uint16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/uint32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/uint8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/uint8-clamped-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.map",
	"es.object.to-string",
	"es.promise",
	"es.string.iterator",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/full/typed-array/unique-by": [
	"es.map",
	"esnext.typed-array.unique-by"
],
	"core-js/full/typed-array/values": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/full/typed-array/with": [
	"es.typed-array.with",
	"esnext.typed-array.with"
],
	"core-js/full/unescape": [
	"es.unescape"
],
	"core-js/full/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/full/url-search-params": [
	"web.dom-collections.iterator",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/full/url/can-parse": [
	"web.url",
	"web.url.can-parse"
],
	"core-js/full/url/parse": [
	"web.url",
	"web.url.parse"
],
	"core-js/full/url/to-json": [
	"web.url.to-json"
],
	"core-js/full/weak-map": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"web.dom-collections.iterator"
],
	"core-js/full/weak-map/delete-all": [
	"es.weak-map",
	"esnext.weak-map.delete-all"
],
	"core-js/full/weak-map/emplace": [
	"es.weak-map",
	"esnext.weak-map.emplace"
],
	"core-js/full/weak-map/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"web.dom-collections.iterator"
],
	"core-js/full/weak-map/get-or-insert": [
	"es.weak-map",
	"esnext.weak-map.get-or-insert"
],
	"core-js/full/weak-map/get-or-insert-computed": [
	"es.weak-map",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/full/weak-map/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-map",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/full/weak-map/upsert": [
	"es.weak-map",
	"esnext.weak-map.upsert"
],
	"core-js/full/weak-set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.dom-collections.iterator"
],
	"core-js/full/weak-set/add-all": [
	"es.weak-set",
	"esnext.weak-set.add-all"
],
	"core-js/full/weak-set/delete-all": [
	"es.weak-set",
	"esnext.weak-set.delete-all"
],
	"core-js/full/weak-set/from": [
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"web.dom-collections.iterator"
],
	"core-js/full/weak-set/of": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-set",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.of"
],
	"core-js/modules/es.aggregate-error": [
	"es.aggregate-error"
],
	"core-js/modules/es.aggregate-error.cause": [
	"es.aggregate-error.cause"
],
	"core-js/modules/es.aggregate-error.constructor": [
	"es.aggregate-error.constructor"
],
	"core-js/modules/es.array-buffer.constructor": [
	"es.array-buffer.constructor"
],
	"core-js/modules/es.array-buffer.detached": [
	"es.array-buffer.detached"
],
	"core-js/modules/es.array-buffer.is-view": [
	"es.array-buffer.is-view"
],
	"core-js/modules/es.array-buffer.slice": [
	"es.array-buffer.slice"
],
	"core-js/modules/es.array-buffer.transfer": [
	"es.array-buffer.transfer"
],
	"core-js/modules/es.array-buffer.transfer-to-fixed-length": [
	"es.array-buffer.transfer-to-fixed-length"
],
	"core-js/modules/es.array.at": [
	"es.array.at"
],
	"core-js/modules/es.array.concat": [
	"es.array.concat"
],
	"core-js/modules/es.array.copy-within": [
	"es.array.copy-within"
],
	"core-js/modules/es.array.every": [
	"es.array.every"
],
	"core-js/modules/es.array.fill": [
	"es.array.fill"
],
	"core-js/modules/es.array.filter": [
	"es.array.filter"
],
	"core-js/modules/es.array.find": [
	"es.array.find"
],
	"core-js/modules/es.array.find-index": [
	"es.array.find-index"
],
	"core-js/modules/es.array.find-last": [
	"es.array.find-last"
],
	"core-js/modules/es.array.find-last-index": [
	"es.array.find-last-index"
],
	"core-js/modules/es.array.flat": [
	"es.array.flat"
],
	"core-js/modules/es.array.flat-map": [
	"es.array.flat-map"
],
	"core-js/modules/es.array.for-each": [
	"es.array.for-each"
],
	"core-js/modules/es.array.from": [
	"es.array.from"
],
	"core-js/modules/es.array.includes": [
	"es.array.includes"
],
	"core-js/modules/es.array.index-of": [
	"es.array.index-of"
],
	"core-js/modules/es.array.is-array": [
	"es.array.is-array"
],
	"core-js/modules/es.array.iterator": [
	"es.array.iterator"
],
	"core-js/modules/es.array.join": [
	"es.array.join"
],
	"core-js/modules/es.array.last-index-of": [
	"es.array.last-index-of"
],
	"core-js/modules/es.array.map": [
	"es.array.map"
],
	"core-js/modules/es.array.of": [
	"es.array.of"
],
	"core-js/modules/es.array.push": [
	"es.array.push"
],
	"core-js/modules/es.array.reduce": [
	"es.array.reduce"
],
	"core-js/modules/es.array.reduce-right": [
	"es.array.reduce-right"
],
	"core-js/modules/es.array.reverse": [
	"es.array.reverse"
],
	"core-js/modules/es.array.slice": [
	"es.array.slice"
],
	"core-js/modules/es.array.some": [
	"es.array.some"
],
	"core-js/modules/es.array.sort": [
	"es.array.sort"
],
	"core-js/modules/es.array.species": [
	"es.array.species"
],
	"core-js/modules/es.array.splice": [
	"es.array.splice"
],
	"core-js/modules/es.array.to-reversed": [
	"es.array.to-reversed"
],
	"core-js/modules/es.array.to-sorted": [
	"es.array.to-sorted"
],
	"core-js/modules/es.array.to-spliced": [
	"es.array.to-spliced"
],
	"core-js/modules/es.array.unscopables.flat": [
	"es.array.unscopables.flat"
],
	"core-js/modules/es.array.unscopables.flat-map": [
	"es.array.unscopables.flat-map"
],
	"core-js/modules/es.array.unshift": [
	"es.array.unshift"
],
	"core-js/modules/es.array.with": [
	"es.array.with"
],
	"core-js/modules/es.data-view": [
	"es.data-view"
],
	"core-js/modules/es.data-view.constructor": [
	"es.data-view.constructor"
],
	"core-js/modules/es.data-view.get-float16": [
	"es.data-view.get-float16"
],
	"core-js/modules/es.data-view.set-float16": [
	"es.data-view.set-float16"
],
	"core-js/modules/es.date.get-year": [
	"es.date.get-year"
],
	"core-js/modules/es.date.now": [
	"es.date.now"
],
	"core-js/modules/es.date.set-year": [
	"es.date.set-year"
],
	"core-js/modules/es.date.to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/modules/es.date.to-iso-string": [
	"es.date.to-iso-string"
],
	"core-js/modules/es.date.to-json": [
	"es.date.to-json"
],
	"core-js/modules/es.date.to-primitive": [
	"es.date.to-primitive"
],
	"core-js/modules/es.date.to-string": [
	"es.date.to-string"
],
	"core-js/modules/es.error.cause": [
	"es.error.cause"
],
	"core-js/modules/es.error.to-string": [
	"es.error.to-string"
],
	"core-js/modules/es.escape": [
	"es.escape"
],
	"core-js/modules/es.function.bind": [
	"es.function.bind"
],
	"core-js/modules/es.function.has-instance": [
	"es.function.has-instance"
],
	"core-js/modules/es.function.name": [
	"es.function.name"
],
	"core-js/modules/es.global-this": [
	"es.global-this"
],
	"core-js/modules/es.iterator.constructor": [
	"es.iterator.constructor"
],
	"core-js/modules/es.iterator.drop": [
	"es.iterator.drop"
],
	"core-js/modules/es.iterator.every": [
	"es.iterator.every"
],
	"core-js/modules/es.iterator.filter": [
	"es.iterator.filter"
],
	"core-js/modules/es.iterator.find": [
	"es.iterator.find"
],
	"core-js/modules/es.iterator.flat-map": [
	"es.iterator.flat-map"
],
	"core-js/modules/es.iterator.for-each": [
	"es.iterator.for-each"
],
	"core-js/modules/es.iterator.from": [
	"es.iterator.from"
],
	"core-js/modules/es.iterator.map": [
	"es.iterator.map"
],
	"core-js/modules/es.iterator.reduce": [
	"es.iterator.reduce"
],
	"core-js/modules/es.iterator.some": [
	"es.iterator.some"
],
	"core-js/modules/es.iterator.take": [
	"es.iterator.take"
],
	"core-js/modules/es.iterator.to-array": [
	"es.iterator.to-array"
],
	"core-js/modules/es.json.stringify": [
	"es.json.stringify"
],
	"core-js/modules/es.json.to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/modules/es.map": [
	"es.map"
],
	"core-js/modules/es.map.constructor": [
	"es.map.constructor"
],
	"core-js/modules/es.map.group-by": [
	"es.map.group-by"
],
	"core-js/modules/es.math.acosh": [
	"es.math.acosh"
],
	"core-js/modules/es.math.asinh": [
	"es.math.asinh"
],
	"core-js/modules/es.math.atanh": [
	"es.math.atanh"
],
	"core-js/modules/es.math.cbrt": [
	"es.math.cbrt"
],
	"core-js/modules/es.math.clz32": [
	"es.math.clz32"
],
	"core-js/modules/es.math.cosh": [
	"es.math.cosh"
],
	"core-js/modules/es.math.expm1": [
	"es.math.expm1"
],
	"core-js/modules/es.math.f16round": [
	"es.math.f16round"
],
	"core-js/modules/es.math.fround": [
	"es.math.fround"
],
	"core-js/modules/es.math.hypot": [
	"es.math.hypot"
],
	"core-js/modules/es.math.imul": [
	"es.math.imul"
],
	"core-js/modules/es.math.log10": [
	"es.math.log10"
],
	"core-js/modules/es.math.log1p": [
	"es.math.log1p"
],
	"core-js/modules/es.math.log2": [
	"es.math.log2"
],
	"core-js/modules/es.math.sign": [
	"es.math.sign"
],
	"core-js/modules/es.math.sinh": [
	"es.math.sinh"
],
	"core-js/modules/es.math.tanh": [
	"es.math.tanh"
],
	"core-js/modules/es.math.to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/modules/es.math.trunc": [
	"es.math.trunc"
],
	"core-js/modules/es.number.constructor": [
	"es.number.constructor"
],
	"core-js/modules/es.number.epsilon": [
	"es.number.epsilon"
],
	"core-js/modules/es.number.is-finite": [
	"es.number.is-finite"
],
	"core-js/modules/es.number.is-integer": [
	"es.number.is-integer"
],
	"core-js/modules/es.number.is-nan": [
	"es.number.is-nan"
],
	"core-js/modules/es.number.is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/modules/es.number.max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/modules/es.number.min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/modules/es.number.parse-float": [
	"es.number.parse-float"
],
	"core-js/modules/es.number.parse-int": [
	"es.number.parse-int"
],
	"core-js/modules/es.number.to-exponential": [
	"es.number.to-exponential"
],
	"core-js/modules/es.number.to-fixed": [
	"es.number.to-fixed"
],
	"core-js/modules/es.number.to-precision": [
	"es.number.to-precision"
],
	"core-js/modules/es.object.assign": [
	"es.object.assign"
],
	"core-js/modules/es.object.create": [
	"es.object.create"
],
	"core-js/modules/es.object.define-getter": [
	"es.object.define-getter"
],
	"core-js/modules/es.object.define-properties": [
	"es.object.define-properties"
],
	"core-js/modules/es.object.define-property": [
	"es.object.define-property"
],
	"core-js/modules/es.object.define-setter": [
	"es.object.define-setter"
],
	"core-js/modules/es.object.entries": [
	"es.object.entries"
],
	"core-js/modules/es.object.freeze": [
	"es.object.freeze"
],
	"core-js/modules/es.object.from-entries": [
	"es.object.from-entries"
],
	"core-js/modules/es.object.get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/modules/es.object.get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/modules/es.object.get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/modules/es.object.get-own-property-symbols": [
	"es.object.get-own-property-symbols"
],
	"core-js/modules/es.object.get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/modules/es.object.group-by": [
	"es.object.group-by"
],
	"core-js/modules/es.object.has-own": [
	"es.object.has-own"
],
	"core-js/modules/es.object.is": [
	"es.object.is"
],
	"core-js/modules/es.object.is-extensible": [
	"es.object.is-extensible"
],
	"core-js/modules/es.object.is-frozen": [
	"es.object.is-frozen"
],
	"core-js/modules/es.object.is-sealed": [
	"es.object.is-sealed"
],
	"core-js/modules/es.object.keys": [
	"es.object.keys"
],
	"core-js/modules/es.object.lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/modules/es.object.lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/modules/es.object.prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/modules/es.object.proto": [
	"es.object.proto"
],
	"core-js/modules/es.object.seal": [
	"es.object.seal"
],
	"core-js/modules/es.object.set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/modules/es.object.to-string": [
	"es.object.to-string"
],
	"core-js/modules/es.object.values": [
	"es.object.values"
],
	"core-js/modules/es.parse-float": [
	"es.parse-float"
],
	"core-js/modules/es.parse-int": [
	"es.parse-int"
],
	"core-js/modules/es.promise": [
	"es.promise"
],
	"core-js/modules/es.promise.all": [
	"es.promise.all"
],
	"core-js/modules/es.promise.all-settled": [
	"es.promise.all-settled"
],
	"core-js/modules/es.promise.any": [
	"es.promise.any"
],
	"core-js/modules/es.promise.catch": [
	"es.promise.catch"
],
	"core-js/modules/es.promise.constructor": [
	"es.promise.constructor"
],
	"core-js/modules/es.promise.finally": [
	"es.promise.finally"
],
	"core-js/modules/es.promise.race": [
	"es.promise.race"
],
	"core-js/modules/es.promise.reject": [
	"es.promise.reject"
],
	"core-js/modules/es.promise.resolve": [
	"es.promise.resolve"
],
	"core-js/modules/es.promise.try": [
	"es.promise.try"
],
	"core-js/modules/es.promise.with-resolvers": [
	"es.promise.with-resolvers"
],
	"core-js/modules/es.reflect.apply": [
	"es.reflect.apply"
],
	"core-js/modules/es.reflect.construct": [
	"es.reflect.construct"
],
	"core-js/modules/es.reflect.define-property": [
	"es.reflect.define-property"
],
	"core-js/modules/es.reflect.delete-property": [
	"es.reflect.delete-property"
],
	"core-js/modules/es.reflect.get": [
	"es.reflect.get"
],
	"core-js/modules/es.reflect.get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/modules/es.reflect.get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/modules/es.reflect.has": [
	"es.reflect.has"
],
	"core-js/modules/es.reflect.is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/modules/es.reflect.own-keys": [
	"es.reflect.own-keys"
],
	"core-js/modules/es.reflect.prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/modules/es.reflect.set": [
	"es.reflect.set"
],
	"core-js/modules/es.reflect.set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/modules/es.reflect.to-string-tag": [
	"es.reflect.to-string-tag"
],
	"core-js/modules/es.regexp.constructor": [
	"es.regexp.constructor"
],
	"core-js/modules/es.regexp.dot-all": [
	"es.regexp.dot-all"
],
	"core-js/modules/es.regexp.escape": [
	"es.regexp.escape"
],
	"core-js/modules/es.regexp.exec": [
	"es.regexp.exec"
],
	"core-js/modules/es.regexp.flags": [
	"es.regexp.flags"
],
	"core-js/modules/es.regexp.sticky": [
	"es.regexp.sticky"
],
	"core-js/modules/es.regexp.test": [
	"es.regexp.test"
],
	"core-js/modules/es.regexp.to-string": [
	"es.regexp.to-string"
],
	"core-js/modules/es.set": [
	"es.set"
],
	"core-js/modules/es.set.constructor": [
	"es.set.constructor"
],
	"core-js/modules/es.set.difference.v2": [
	"es.set.difference.v2"
],
	"core-js/modules/es.set.intersection.v2": [
	"es.set.intersection.v2"
],
	"core-js/modules/es.set.is-disjoint-from.v2": [
	"es.set.is-disjoint-from.v2"
],
	"core-js/modules/es.set.is-subset-of.v2": [
	"es.set.is-subset-of.v2"
],
	"core-js/modules/es.set.is-superset-of.v2": [
	"es.set.is-superset-of.v2"
],
	"core-js/modules/es.set.symmetric-difference.v2": [
	"es.set.symmetric-difference.v2"
],
	"core-js/modules/es.set.union.v2": [
	"es.set.union.v2"
],
	"core-js/modules/es.string.anchor": [
	"es.string.anchor"
],
	"core-js/modules/es.string.at-alternative": [
	"es.string.at-alternative"
],
	"core-js/modules/es.string.big": [
	"es.string.big"
],
	"core-js/modules/es.string.blink": [
	"es.string.blink"
],
	"core-js/modules/es.string.bold": [
	"es.string.bold"
],
	"core-js/modules/es.string.code-point-at": [
	"es.string.code-point-at"
],
	"core-js/modules/es.string.ends-with": [
	"es.string.ends-with"
],
	"core-js/modules/es.string.fixed": [
	"es.string.fixed"
],
	"core-js/modules/es.string.fontcolor": [
	"es.string.fontcolor"
],
	"core-js/modules/es.string.fontsize": [
	"es.string.fontsize"
],
	"core-js/modules/es.string.from-code-point": [
	"es.string.from-code-point"
],
	"core-js/modules/es.string.includes": [
	"es.string.includes"
],
	"core-js/modules/es.string.is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/modules/es.string.italics": [
	"es.string.italics"
],
	"core-js/modules/es.string.iterator": [
	"es.string.iterator"
],
	"core-js/modules/es.string.link": [
	"es.string.link"
],
	"core-js/modules/es.string.match": [
	"es.string.match"
],
	"core-js/modules/es.string.match-all": [
	"es.string.match-all"
],
	"core-js/modules/es.string.pad-end": [
	"es.string.pad-end"
],
	"core-js/modules/es.string.pad-start": [
	"es.string.pad-start"
],
	"core-js/modules/es.string.raw": [
	"es.string.raw"
],
	"core-js/modules/es.string.repeat": [
	"es.string.repeat"
],
	"core-js/modules/es.string.replace": [
	"es.string.replace"
],
	"core-js/modules/es.string.replace-all": [
	"es.string.replace-all"
],
	"core-js/modules/es.string.search": [
	"es.string.search"
],
	"core-js/modules/es.string.small": [
	"es.string.small"
],
	"core-js/modules/es.string.split": [
	"es.string.split"
],
	"core-js/modules/es.string.starts-with": [
	"es.string.starts-with"
],
	"core-js/modules/es.string.strike": [
	"es.string.strike"
],
	"core-js/modules/es.string.sub": [
	"es.string.sub"
],
	"core-js/modules/es.string.substr": [
	"es.string.substr"
],
	"core-js/modules/es.string.sup": [
	"es.string.sup"
],
	"core-js/modules/es.string.to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/modules/es.string.trim": [
	"es.string.trim"
],
	"core-js/modules/es.string.trim-end": [
	"es.string.trim-end"
],
	"core-js/modules/es.string.trim-left": [
	"es.string.trim-left"
],
	"core-js/modules/es.string.trim-right": [
	"es.string.trim-right"
],
	"core-js/modules/es.string.trim-start": [
	"es.string.trim-start"
],
	"core-js/modules/es.symbol": [
	"es.symbol"
],
	"core-js/modules/es.symbol.async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/modules/es.symbol.constructor": [
	"es.symbol.constructor"
],
	"core-js/modules/es.symbol.description": [
	"es.symbol.description"
],
	"core-js/modules/es.symbol.for": [
	"es.symbol.for"
],
	"core-js/modules/es.symbol.has-instance": [
	"es.symbol.has-instance"
],
	"core-js/modules/es.symbol.is-concat-spreadable": [
	"es.symbol.is-concat-spreadable"
],
	"core-js/modules/es.symbol.iterator": [
	"es.symbol.iterator"
],
	"core-js/modules/es.symbol.key-for": [
	"es.symbol.key-for"
],
	"core-js/modules/es.symbol.match": [
	"es.symbol.match"
],
	"core-js/modules/es.symbol.match-all": [
	"es.symbol.match-all"
],
	"core-js/modules/es.symbol.replace": [
	"es.symbol.replace"
],
	"core-js/modules/es.symbol.search": [
	"es.symbol.search"
],
	"core-js/modules/es.symbol.species": [
	"es.symbol.species"
],
	"core-js/modules/es.symbol.split": [
	"es.symbol.split"
],
	"core-js/modules/es.symbol.to-primitive": [
	"es.symbol.to-primitive"
],
	"core-js/modules/es.symbol.to-string-tag": [
	"es.symbol.to-string-tag"
],
	"core-js/modules/es.symbol.unscopables": [
	"es.symbol.unscopables"
],
	"core-js/modules/es.typed-array.at": [
	"es.typed-array.at"
],
	"core-js/modules/es.typed-array.copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/modules/es.typed-array.every": [
	"es.typed-array.every"
],
	"core-js/modules/es.typed-array.fill": [
	"es.typed-array.fill"
],
	"core-js/modules/es.typed-array.filter": [
	"es.typed-array.filter"
],
	"core-js/modules/es.typed-array.find": [
	"es.typed-array.find"
],
	"core-js/modules/es.typed-array.find-index": [
	"es.typed-array.find-index"
],
	"core-js/modules/es.typed-array.find-last": [
	"es.typed-array.find-last"
],
	"core-js/modules/es.typed-array.find-last-index": [
	"es.typed-array.find-last-index"
],
	"core-js/modules/es.typed-array.float32-array": [
	"es.typed-array.float32-array"
],
	"core-js/modules/es.typed-array.float64-array": [
	"es.typed-array.float64-array"
],
	"core-js/modules/es.typed-array.for-each": [
	"es.typed-array.for-each"
],
	"core-js/modules/es.typed-array.from": [
	"es.typed-array.from"
],
	"core-js/modules/es.typed-array.includes": [
	"es.typed-array.includes"
],
	"core-js/modules/es.typed-array.index-of": [
	"es.typed-array.index-of"
],
	"core-js/modules/es.typed-array.int16-array": [
	"es.typed-array.int16-array"
],
	"core-js/modules/es.typed-array.int32-array": [
	"es.typed-array.int32-array"
],
	"core-js/modules/es.typed-array.int8-array": [
	"es.typed-array.int8-array"
],
	"core-js/modules/es.typed-array.iterator": [
	"es.typed-array.iterator"
],
	"core-js/modules/es.typed-array.join": [
	"es.typed-array.join"
],
	"core-js/modules/es.typed-array.last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/modules/es.typed-array.map": [
	"es.typed-array.map"
],
	"core-js/modules/es.typed-array.of": [
	"es.typed-array.of"
],
	"core-js/modules/es.typed-array.reduce": [
	"es.typed-array.reduce"
],
	"core-js/modules/es.typed-array.reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/modules/es.typed-array.reverse": [
	"es.typed-array.reverse"
],
	"core-js/modules/es.typed-array.set": [
	"es.typed-array.set"
],
	"core-js/modules/es.typed-array.slice": [
	"es.typed-array.slice"
],
	"core-js/modules/es.typed-array.some": [
	"es.typed-array.some"
],
	"core-js/modules/es.typed-array.sort": [
	"es.typed-array.sort"
],
	"core-js/modules/es.typed-array.subarray": [
	"es.typed-array.subarray"
],
	"core-js/modules/es.typed-array.to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/modules/es.typed-array.to-reversed": [
	"es.typed-array.to-reversed"
],
	"core-js/modules/es.typed-array.to-sorted": [
	"es.typed-array.to-sorted"
],
	"core-js/modules/es.typed-array.to-string": [
	"es.typed-array.to-string"
],
	"core-js/modules/es.typed-array.uint16-array": [
	"es.typed-array.uint16-array"
],
	"core-js/modules/es.typed-array.uint32-array": [
	"es.typed-array.uint32-array"
],
	"core-js/modules/es.typed-array.uint8-array": [
	"es.typed-array.uint8-array"
],
	"core-js/modules/es.typed-array.uint8-clamped-array": [
	"es.typed-array.uint8-clamped-array"
],
	"core-js/modules/es.typed-array.with": [
	"es.typed-array.with"
],
	"core-js/modules/es.unescape": [
	"es.unescape"
],
	"core-js/modules/es.weak-map": [
	"es.weak-map"
],
	"core-js/modules/es.weak-map.constructor": [
	"es.weak-map.constructor"
],
	"core-js/modules/es.weak-set": [
	"es.weak-set"
],
	"core-js/modules/es.weak-set.constructor": [
	"es.weak-set.constructor"
],
	"core-js/modules/esnext.aggregate-error": [
	"esnext.aggregate-error"
],
	"core-js/modules/esnext.array-buffer.detached": [
	"esnext.array-buffer.detached"
],
	"core-js/modules/esnext.array-buffer.transfer": [
	"esnext.array-buffer.transfer"
],
	"core-js/modules/esnext.array-buffer.transfer-to-fixed-length": [
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/modules/esnext.array.at": [
	"esnext.array.at"
],
	"core-js/modules/esnext.array.filter-out": [
	"esnext.array.filter-out"
],
	"core-js/modules/esnext.array.filter-reject": [
	"esnext.array.filter-reject"
],
	"core-js/modules/esnext.array.find-last": [
	"esnext.array.find-last"
],
	"core-js/modules/esnext.array.find-last-index": [
	"esnext.array.find-last-index"
],
	"core-js/modules/esnext.array.from-async": [
	"esnext.array.from-async"
],
	"core-js/modules/esnext.array.group": [
	"esnext.array.group"
],
	"core-js/modules/esnext.array.group-by": [
	"esnext.array.group-by"
],
	"core-js/modules/esnext.array.group-by-to-map": [
	"esnext.array.group-by-to-map"
],
	"core-js/modules/esnext.array.group-to-map": [
	"esnext.array.group-to-map"
],
	"core-js/modules/esnext.array.is-template-object": [
	"esnext.array.is-template-object"
],
	"core-js/modules/esnext.array.last-index": [
	"esnext.array.last-index"
],
	"core-js/modules/esnext.array.last-item": [
	"esnext.array.last-item"
],
	"core-js/modules/esnext.array.to-reversed": [
	"esnext.array.to-reversed"
],
	"core-js/modules/esnext.array.to-sorted": [
	"esnext.array.to-sorted"
],
	"core-js/modules/esnext.array.to-spliced": [
	"esnext.array.to-spliced"
],
	"core-js/modules/esnext.array.unique-by": [
	"esnext.array.unique-by"
],
	"core-js/modules/esnext.array.with": [
	"esnext.array.with"
],
	"core-js/modules/esnext.async-disposable-stack.constructor": [
	"esnext.async-disposable-stack.constructor"
],
	"core-js/modules/esnext.async-iterator.as-indexed-pairs": [
	"esnext.async-iterator.as-indexed-pairs"
],
	"core-js/modules/esnext.async-iterator.async-dispose": [
	"esnext.async-iterator.async-dispose"
],
	"core-js/modules/esnext.async-iterator.constructor": [
	"esnext.async-iterator.constructor"
],
	"core-js/modules/esnext.async-iterator.drop": [
	"esnext.async-iterator.drop"
],
	"core-js/modules/esnext.async-iterator.every": [
	"esnext.async-iterator.every"
],
	"core-js/modules/esnext.async-iterator.filter": [
	"esnext.async-iterator.filter"
],
	"core-js/modules/esnext.async-iterator.find": [
	"esnext.async-iterator.find"
],
	"core-js/modules/esnext.async-iterator.flat-map": [
	"esnext.async-iterator.flat-map"
],
	"core-js/modules/esnext.async-iterator.for-each": [
	"esnext.async-iterator.for-each"
],
	"core-js/modules/esnext.async-iterator.from": [
	"esnext.async-iterator.from"
],
	"core-js/modules/esnext.async-iterator.indexed": [
	"esnext.async-iterator.indexed"
],
	"core-js/modules/esnext.async-iterator.map": [
	"esnext.async-iterator.map"
],
	"core-js/modules/esnext.async-iterator.reduce": [
	"esnext.async-iterator.reduce"
],
	"core-js/modules/esnext.async-iterator.some": [
	"esnext.async-iterator.some"
],
	"core-js/modules/esnext.async-iterator.take": [
	"esnext.async-iterator.take"
],
	"core-js/modules/esnext.async-iterator.to-array": [
	"esnext.async-iterator.to-array"
],
	"core-js/modules/esnext.bigint.range": [
	"esnext.bigint.range"
],
	"core-js/modules/esnext.composite-key": [
	"esnext.composite-key"
],
	"core-js/modules/esnext.composite-symbol": [
	"esnext.composite-symbol"
],
	"core-js/modules/esnext.data-view.get-float16": [
	"esnext.data-view.get-float16"
],
	"core-js/modules/esnext.data-view.get-uint8-clamped": [
	"esnext.data-view.get-uint8-clamped"
],
	"core-js/modules/esnext.data-view.set-float16": [
	"esnext.data-view.set-float16"
],
	"core-js/modules/esnext.data-view.set-uint8-clamped": [
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/modules/esnext.disposable-stack.constructor": [
	"esnext.disposable-stack.constructor"
],
	"core-js/modules/esnext.error.is-error": [
	"esnext.error.is-error"
],
	"core-js/modules/esnext.function.demethodize": [
	"esnext.function.demethodize"
],
	"core-js/modules/esnext.function.is-callable": [
	"esnext.function.is-callable"
],
	"core-js/modules/esnext.function.is-constructor": [
	"esnext.function.is-constructor"
],
	"core-js/modules/esnext.function.metadata": [
	"esnext.function.metadata"
],
	"core-js/modules/esnext.function.un-this": [
	"esnext.function.un-this"
],
	"core-js/modules/esnext.global-this": [
	"esnext.global-this"
],
	"core-js/modules/esnext.iterator.as-indexed-pairs": [
	"esnext.iterator.as-indexed-pairs"
],
	"core-js/modules/esnext.iterator.concat": [
	"esnext.iterator.concat"
],
	"core-js/modules/esnext.iterator.constructor": [
	"esnext.iterator.constructor"
],
	"core-js/modules/esnext.iterator.dispose": [
	"esnext.iterator.dispose"
],
	"core-js/modules/esnext.iterator.drop": [
	"esnext.iterator.drop"
],
	"core-js/modules/esnext.iterator.every": [
	"esnext.iterator.every"
],
	"core-js/modules/esnext.iterator.filter": [
	"esnext.iterator.filter"
],
	"core-js/modules/esnext.iterator.find": [
	"esnext.iterator.find"
],
	"core-js/modules/esnext.iterator.flat-map": [
	"esnext.iterator.flat-map"
],
	"core-js/modules/esnext.iterator.for-each": [
	"esnext.iterator.for-each"
],
	"core-js/modules/esnext.iterator.from": [
	"esnext.iterator.from"
],
	"core-js/modules/esnext.iterator.indexed": [
	"esnext.iterator.indexed"
],
	"core-js/modules/esnext.iterator.map": [
	"esnext.iterator.map"
],
	"core-js/modules/esnext.iterator.range": [
	"esnext.iterator.range"
],
	"core-js/modules/esnext.iterator.reduce": [
	"esnext.iterator.reduce"
],
	"core-js/modules/esnext.iterator.some": [
	"esnext.iterator.some"
],
	"core-js/modules/esnext.iterator.take": [
	"esnext.iterator.take"
],
	"core-js/modules/esnext.iterator.to-array": [
	"esnext.iterator.to-array"
],
	"core-js/modules/esnext.iterator.to-async": [
	"esnext.iterator.to-async"
],
	"core-js/modules/esnext.json.is-raw-json": [
	"esnext.json.is-raw-json"
],
	"core-js/modules/esnext.json.parse": [
	"esnext.json.parse"
],
	"core-js/modules/esnext.json.raw-json": [
	"esnext.json.raw-json"
],
	"core-js/modules/esnext.map.delete-all": [
	"esnext.map.delete-all"
],
	"core-js/modules/esnext.map.emplace": [
	"esnext.map.emplace"
],
	"core-js/modules/esnext.map.every": [
	"esnext.map.every"
],
	"core-js/modules/esnext.map.filter": [
	"esnext.map.filter"
],
	"core-js/modules/esnext.map.find": [
	"esnext.map.find"
],
	"core-js/modules/esnext.map.find-key": [
	"esnext.map.find-key"
],
	"core-js/modules/esnext.map.from": [
	"esnext.map.from"
],
	"core-js/modules/esnext.map.get-or-insert": [
	"esnext.map.get-or-insert"
],
	"core-js/modules/esnext.map.get-or-insert-computed": [
	"esnext.map.get-or-insert-computed"
],
	"core-js/modules/esnext.map.group-by": [
	"esnext.map.group-by"
],
	"core-js/modules/esnext.map.includes": [
	"esnext.map.includes"
],
	"core-js/modules/esnext.map.key-by": [
	"esnext.map.key-by"
],
	"core-js/modules/esnext.map.key-of": [
	"esnext.map.key-of"
],
	"core-js/modules/esnext.map.map-keys": [
	"esnext.map.map-keys"
],
	"core-js/modules/esnext.map.map-values": [
	"esnext.map.map-values"
],
	"core-js/modules/esnext.map.merge": [
	"esnext.map.merge"
],
	"core-js/modules/esnext.map.of": [
	"esnext.map.of"
],
	"core-js/modules/esnext.map.reduce": [
	"esnext.map.reduce"
],
	"core-js/modules/esnext.map.some": [
	"esnext.map.some"
],
	"core-js/modules/esnext.map.update": [
	"esnext.map.update"
],
	"core-js/modules/esnext.map.update-or-insert": [
	"esnext.map.update-or-insert"
],
	"core-js/modules/esnext.map.upsert": [
	"esnext.map.upsert"
],
	"core-js/modules/esnext.math.clamp": [
	"esnext.math.clamp"
],
	"core-js/modules/esnext.math.deg-per-rad": [
	"esnext.math.deg-per-rad"
],
	"core-js/modules/esnext.math.degrees": [
	"esnext.math.degrees"
],
	"core-js/modules/esnext.math.f16round": [
	"esnext.math.f16round"
],
	"core-js/modules/esnext.math.fscale": [
	"esnext.math.fscale"
],
	"core-js/modules/esnext.math.iaddh": [
	"esnext.math.iaddh"
],
	"core-js/modules/esnext.math.imulh": [
	"esnext.math.imulh"
],
	"core-js/modules/esnext.math.isubh": [
	"esnext.math.isubh"
],
	"core-js/modules/esnext.math.rad-per-deg": [
	"esnext.math.rad-per-deg"
],
	"core-js/modules/esnext.math.radians": [
	"esnext.math.radians"
],
	"core-js/modules/esnext.math.scale": [
	"esnext.math.scale"
],
	"core-js/modules/esnext.math.seeded-prng": [
	"esnext.math.seeded-prng"
],
	"core-js/modules/esnext.math.signbit": [
	"esnext.math.signbit"
],
	"core-js/modules/esnext.math.sum-precise": [
	"esnext.math.sum-precise"
],
	"core-js/modules/esnext.math.umulh": [
	"esnext.math.umulh"
],
	"core-js/modules/esnext.number.from-string": [
	"esnext.number.from-string"
],
	"core-js/modules/esnext.number.range": [
	"esnext.number.range"
],
	"core-js/modules/esnext.object.group-by": [
	"esnext.object.group-by"
],
	"core-js/modules/esnext.object.has-own": [
	"esnext.object.has-own"
],
	"core-js/modules/esnext.object.iterate-entries": [
	"esnext.object.iterate-entries"
],
	"core-js/modules/esnext.object.iterate-keys": [
	"esnext.object.iterate-keys"
],
	"core-js/modules/esnext.object.iterate-values": [
	"esnext.object.iterate-values"
],
	"core-js/modules/esnext.observable": [
	"esnext.observable"
],
	"core-js/modules/esnext.observable.constructor": [
	"esnext.observable.constructor"
],
	"core-js/modules/esnext.observable.from": [
	"esnext.observable.from"
],
	"core-js/modules/esnext.observable.of": [
	"esnext.observable.of"
],
	"core-js/modules/esnext.promise.all-settled": [
	"esnext.promise.all-settled"
],
	"core-js/modules/esnext.promise.any": [
	"esnext.promise.any"
],
	"core-js/modules/esnext.promise.try": [
	"esnext.promise.try"
],
	"core-js/modules/esnext.promise.with-resolvers": [
	"esnext.promise.with-resolvers"
],
	"core-js/modules/esnext.reflect.define-metadata": [
	"esnext.reflect.define-metadata"
],
	"core-js/modules/esnext.reflect.delete-metadata": [
	"esnext.reflect.delete-metadata"
],
	"core-js/modules/esnext.reflect.get-metadata": [
	"esnext.reflect.get-metadata"
],
	"core-js/modules/esnext.reflect.get-metadata-keys": [
	"esnext.reflect.get-metadata-keys"
],
	"core-js/modules/esnext.reflect.get-own-metadata": [
	"esnext.reflect.get-own-metadata"
],
	"core-js/modules/esnext.reflect.get-own-metadata-keys": [
	"esnext.reflect.get-own-metadata-keys"
],
	"core-js/modules/esnext.reflect.has-metadata": [
	"esnext.reflect.has-metadata"
],
	"core-js/modules/esnext.reflect.has-own-metadata": [
	"esnext.reflect.has-own-metadata"
],
	"core-js/modules/esnext.reflect.metadata": [
	"esnext.reflect.metadata"
],
	"core-js/modules/esnext.regexp.escape": [
	"esnext.regexp.escape"
],
	"core-js/modules/esnext.set.add-all": [
	"esnext.set.add-all"
],
	"core-js/modules/esnext.set.delete-all": [
	"esnext.set.delete-all"
],
	"core-js/modules/esnext.set.difference": [
	"esnext.set.difference"
],
	"core-js/modules/esnext.set.difference.v2": [
	"esnext.set.difference.v2"
],
	"core-js/modules/esnext.set.every": [
	"esnext.set.every"
],
	"core-js/modules/esnext.set.filter": [
	"esnext.set.filter"
],
	"core-js/modules/esnext.set.find": [
	"esnext.set.find"
],
	"core-js/modules/esnext.set.from": [
	"esnext.set.from"
],
	"core-js/modules/esnext.set.intersection": [
	"esnext.set.intersection"
],
	"core-js/modules/esnext.set.intersection.v2": [
	"esnext.set.intersection.v2"
],
	"core-js/modules/esnext.set.is-disjoint-from": [
	"esnext.set.is-disjoint-from"
],
	"core-js/modules/esnext.set.is-disjoint-from.v2": [
	"esnext.set.is-disjoint-from.v2"
],
	"core-js/modules/esnext.set.is-subset-of": [
	"esnext.set.is-subset-of"
],
	"core-js/modules/esnext.set.is-subset-of.v2": [
	"esnext.set.is-subset-of.v2"
],
	"core-js/modules/esnext.set.is-superset-of": [
	"esnext.set.is-superset-of"
],
	"core-js/modules/esnext.set.is-superset-of.v2": [
	"esnext.set.is-superset-of.v2"
],
	"core-js/modules/esnext.set.join": [
	"esnext.set.join"
],
	"core-js/modules/esnext.set.map": [
	"esnext.set.map"
],
	"core-js/modules/esnext.set.of": [
	"esnext.set.of"
],
	"core-js/modules/esnext.set.reduce": [
	"esnext.set.reduce"
],
	"core-js/modules/esnext.set.some": [
	"esnext.set.some"
],
	"core-js/modules/esnext.set.symmetric-difference": [
	"esnext.set.symmetric-difference"
],
	"core-js/modules/esnext.set.symmetric-difference.v2": [
	"esnext.set.symmetric-difference.v2"
],
	"core-js/modules/esnext.set.union": [
	"esnext.set.union"
],
	"core-js/modules/esnext.set.union.v2": [
	"esnext.set.union.v2"
],
	"core-js/modules/esnext.string.at": [
	"esnext.string.at"
],
	"core-js/modules/esnext.string.at-alternative": [
	"esnext.string.at-alternative"
],
	"core-js/modules/esnext.string.code-points": [
	"esnext.string.code-points"
],
	"core-js/modules/esnext.string.cooked": [
	"esnext.string.cooked"
],
	"core-js/modules/esnext.string.dedent": [
	"esnext.string.dedent"
],
	"core-js/modules/esnext.string.is-well-formed": [
	"esnext.string.is-well-formed"
],
	"core-js/modules/esnext.string.match-all": [
	"esnext.string.match-all"
],
	"core-js/modules/esnext.string.replace-all": [
	"esnext.string.replace-all"
],
	"core-js/modules/esnext.string.to-well-formed": [
	"esnext.string.to-well-formed"
],
	"core-js/modules/esnext.suppressed-error.constructor": [
	"esnext.suppressed-error.constructor"
],
	"core-js/modules/esnext.symbol.async-dispose": [
	"esnext.symbol.async-dispose"
],
	"core-js/modules/esnext.symbol.custom-matcher": [
	"esnext.symbol.custom-matcher"
],
	"core-js/modules/esnext.symbol.dispose": [
	"esnext.symbol.dispose"
],
	"core-js/modules/esnext.symbol.is-registered": [
	"esnext.symbol.is-registered"
],
	"core-js/modules/esnext.symbol.is-registered-symbol": [
	"esnext.symbol.is-registered-symbol"
],
	"core-js/modules/esnext.symbol.is-well-known": [
	"esnext.symbol.is-well-known"
],
	"core-js/modules/esnext.symbol.is-well-known-symbol": [
	"esnext.symbol.is-well-known-symbol"
],
	"core-js/modules/esnext.symbol.matcher": [
	"esnext.symbol.matcher"
],
	"core-js/modules/esnext.symbol.metadata": [
	"esnext.symbol.metadata"
],
	"core-js/modules/esnext.symbol.metadata-key": [
	"esnext.symbol.metadata-key"
],
	"core-js/modules/esnext.symbol.observable": [
	"esnext.symbol.observable"
],
	"core-js/modules/esnext.symbol.pattern-match": [
	"esnext.symbol.pattern-match"
],
	"core-js/modules/esnext.symbol.replace-all": [
	"esnext.symbol.replace-all"
],
	"core-js/modules/esnext.typed-array.at": [
	"esnext.typed-array.at"
],
	"core-js/modules/esnext.typed-array.filter-out": [
	"esnext.typed-array.filter-out"
],
	"core-js/modules/esnext.typed-array.filter-reject": [
	"esnext.typed-array.filter-reject"
],
	"core-js/modules/esnext.typed-array.find-last": [
	"esnext.typed-array.find-last"
],
	"core-js/modules/esnext.typed-array.find-last-index": [
	"esnext.typed-array.find-last-index"
],
	"core-js/modules/esnext.typed-array.from-async": [
	"esnext.typed-array.from-async"
],
	"core-js/modules/esnext.typed-array.group-by": [
	"esnext.typed-array.group-by"
],
	"core-js/modules/esnext.typed-array.to-reversed": [
	"esnext.typed-array.to-reversed"
],
	"core-js/modules/esnext.typed-array.to-sorted": [
	"esnext.typed-array.to-sorted"
],
	"core-js/modules/esnext.typed-array.to-spliced": [
	"esnext.typed-array.to-spliced"
],
	"core-js/modules/esnext.typed-array.unique-by": [
	"esnext.typed-array.unique-by"
],
	"core-js/modules/esnext.typed-array.with": [
	"esnext.typed-array.with"
],
	"core-js/modules/esnext.uint8-array.from-base64": [
	"esnext.uint8-array.from-base64"
],
	"core-js/modules/esnext.uint8-array.from-hex": [
	"esnext.uint8-array.from-hex"
],
	"core-js/modules/esnext.uint8-array.set-from-base64": [
	"esnext.uint8-array.set-from-base64"
],
	"core-js/modules/esnext.uint8-array.set-from-hex": [
	"esnext.uint8-array.set-from-hex"
],
	"core-js/modules/esnext.uint8-array.to-base64": [
	"esnext.uint8-array.to-base64"
],
	"core-js/modules/esnext.uint8-array.to-hex": [
	"esnext.uint8-array.to-hex"
],
	"core-js/modules/esnext.weak-map.delete-all": [
	"esnext.weak-map.delete-all"
],
	"core-js/modules/esnext.weak-map.emplace": [
	"esnext.weak-map.emplace"
],
	"core-js/modules/esnext.weak-map.from": [
	"esnext.weak-map.from"
],
	"core-js/modules/esnext.weak-map.get-or-insert": [
	"esnext.weak-map.get-or-insert"
],
	"core-js/modules/esnext.weak-map.get-or-insert-computed": [
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/modules/esnext.weak-map.of": [
	"esnext.weak-map.of"
],
	"core-js/modules/esnext.weak-map.upsert": [
	"esnext.weak-map.upsert"
],
	"core-js/modules/esnext.weak-set.add-all": [
	"esnext.weak-set.add-all"
],
	"core-js/modules/esnext.weak-set.delete-all": [
	"esnext.weak-set.delete-all"
],
	"core-js/modules/esnext.weak-set.from": [
	"esnext.weak-set.from"
],
	"core-js/modules/esnext.weak-set.of": [
	"esnext.weak-set.of"
],
	"core-js/modules/web.atob": [
	"web.atob"
],
	"core-js/modules/web.btoa": [
	"web.btoa"
],
	"core-js/modules/web.clear-immediate": [
	"web.clear-immediate"
],
	"core-js/modules/web.dom-collections.for-each": [
	"web.dom-collections.for-each"
],
	"core-js/modules/web.dom-collections.iterator": [
	"web.dom-collections.iterator"
],
	"core-js/modules/web.dom-exception.constructor": [
	"web.dom-exception.constructor"
],
	"core-js/modules/web.dom-exception.stack": [
	"web.dom-exception.stack"
],
	"core-js/modules/web.dom-exception.to-string-tag": [
	"web.dom-exception.to-string-tag"
],
	"core-js/modules/web.immediate": [
	"web.immediate"
],
	"core-js/modules/web.queue-microtask": [
	"web.queue-microtask"
],
	"core-js/modules/web.self": [
	"web.self"
],
	"core-js/modules/web.set-immediate": [
	"web.set-immediate"
],
	"core-js/modules/web.set-interval": [
	"web.set-interval"
],
	"core-js/modules/web.set-timeout": [
	"web.set-timeout"
],
	"core-js/modules/web.structured-clone": [
	"web.structured-clone"
],
	"core-js/modules/web.timers": [
	"web.timers"
],
	"core-js/modules/web.url": [
	"web.url"
],
	"core-js/modules/web.url-search-params": [
	"web.url-search-params"
],
	"core-js/modules/web.url-search-params.constructor": [
	"web.url-search-params.constructor"
],
	"core-js/modules/web.url-search-params.delete": [
	"web.url-search-params.delete"
],
	"core-js/modules/web.url-search-params.has": [
	"web.url-search-params.has"
],
	"core-js/modules/web.url-search-params.size": [
	"web.url-search-params.size"
],
	"core-js/modules/web.url.can-parse": [
	"web.url.can-parse"
],
	"core-js/modules/web.url.constructor": [
	"web.url.constructor"
],
	"core-js/modules/web.url.parse": [
	"web.url.parse"
],
	"core-js/modules/web.url.to-json": [
	"web.url.to-json"
],
	"core-js/proposals": [
	"es.map",
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/proposals/accessible-object-hasownproperty": [
	"esnext.object.has-own"
],
	"core-js/proposals/array-buffer-base64": [
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/proposals/array-buffer-transfer": [
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length"
],
	"core-js/proposals/array-filtering": [
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject"
],
	"core-js/proposals/array-filtering-stage-1": [
	"esnext.array.filter-reject",
	"esnext.typed-array.filter-reject"
],
	"core-js/proposals/array-find-from-last": [
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index"
],
	"core-js/proposals/array-flat-map": [
	"es.array.flat",
	"es.array.flat-map",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map"
],
	"core-js/proposals/array-from-async": [
	"esnext.array.from-async",
	"esnext.typed-array.from-async"
],
	"core-js/proposals/array-from-async-stage-2": [
	"esnext.array.from-async"
],
	"core-js/proposals/array-grouping": [
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.typed-array.group-by"
],
	"core-js/proposals/array-grouping-stage-3": [
	"esnext.array.group-by",
	"esnext.array.group-by-to-map"
],
	"core-js/proposals/array-grouping-stage-3-2": [
	"esnext.array.group",
	"esnext.array.group-to-map"
],
	"core-js/proposals/array-grouping-v2": [
	"esnext.map.group-by",
	"esnext.object.group-by"
],
	"core-js/proposals/array-includes": [
	"es.array.includes",
	"es.typed-array.includes"
],
	"core-js/proposals/array-is-template-object": [
	"esnext.array.is-template-object"
],
	"core-js/proposals/array-last": [
	"esnext.array.last-index",
	"esnext.array.last-item"
],
	"core-js/proposals/array-unique": [
	"es.map",
	"esnext.array.unique-by",
	"esnext.typed-array.unique-by"
],
	"core-js/proposals/async-explicit-resource-management": [
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.symbol.async-dispose"
],
	"core-js/proposals/async-iteration": [
	"es.symbol.async-iterator"
],
	"core-js/proposals/async-iterator-helpers": [
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.iterator.to-async"
],
	"core-js/proposals/change-array-by-copy": [
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with"
],
	"core-js/proposals/change-array-by-copy-stage-4": [
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.with"
],
	"core-js/proposals/collection-methods": [
	"esnext.map.delete-all",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.weak-map.delete-all",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all"
],
	"core-js/proposals/collection-of-from": [
	"esnext.map.from",
	"esnext.map.of",
	"esnext.set.from",
	"esnext.set.of",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-set.from",
	"esnext.weak-set.of"
],
	"core-js/proposals/data-view-get-set-uint8-clamped": [
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-uint8-clamped"
],
	"core-js/proposals/decorator-metadata": [
	"esnext.symbol.metadata-key"
],
	"core-js/proposals/decorator-metadata-v2": [
	"esnext.function.metadata",
	"esnext.symbol.metadata"
],
	"core-js/proposals/decorators": [
	"esnext.symbol.metadata"
],
	"core-js/proposals/efficient-64-bit-arithmetic": [
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.umulh"
],
	"core-js/proposals/error-cause": [
	"es.error.cause",
	"es.aggregate-error.cause"
],
	"core-js/proposals/explicit-resource-management": [
	"esnext.suppressed-error.constructor",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.disposable-stack.constructor",
	"esnext.iterator.dispose",
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose"
],
	"core-js/proposals/extractors": [
	"esnext.symbol.custom-matcher"
],
	"core-js/proposals/float16": [
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.math.f16round"
],
	"core-js/proposals/function-demethodize": [
	"esnext.function.demethodize"
],
	"core-js/proposals/function-is-callable-is-constructor": [
	"esnext.function.is-callable",
	"esnext.function.is-constructor"
],
	"core-js/proposals/function-un-this": [
	"esnext.function.un-this"
],
	"core-js/proposals/global-this": [
	"esnext.global-this"
],
	"core-js/proposals/is-error": [
	"esnext.error.is-error"
],
	"core-js/proposals/iterator-helpers": [
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async"
],
	"core-js/proposals/iterator-helpers-stage-3": [
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.iterator.constructor",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async"
],
	"core-js/proposals/iterator-helpers-stage-3-2": [
	"esnext.iterator.constructor",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array"
],
	"core-js/proposals/iterator-range": [
	"esnext.iterator.constructor",
	"esnext.iterator.range"
],
	"core-js/proposals/iterator-sequencing": [
	"esnext.iterator.concat"
],
	"core-js/proposals/json-parse-with-source": [
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json"
],
	"core-js/proposals/keys-composition": [
	"esnext.composite-key",
	"esnext.composite-symbol"
],
	"core-js/proposals/map-update-or-insert": [
	"esnext.map.emplace",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.weak-map.emplace",
	"esnext.weak-map.upsert"
],
	"core-js/proposals/map-upsert": [
	"esnext.map.emplace",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.weak-map.emplace",
	"esnext.weak-map.upsert"
],
	"core-js/proposals/map-upsert-stage-2": [
	"esnext.map.emplace",
	"esnext.weak-map.emplace"
],
	"core-js/proposals/map-upsert-v4": [
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/proposals/math-clamp": [
	"esnext.math.clamp"
],
	"core-js/proposals/math-extensions": [
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale"
],
	"core-js/proposals/math-signbit": [
	"esnext.math.signbit"
],
	"core-js/proposals/math-sum": [
	"esnext.math.sum-precise"
],
	"core-js/proposals/number-from-string": [
	"esnext.number.from-string"
],
	"core-js/proposals/number-range": [
	"esnext.bigint.range",
	"esnext.number.range"
],
	"core-js/proposals/object-from-entries": [
	"es.object.from-entries"
],
	"core-js/proposals/object-getownpropertydescriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/proposals/object-iteration": [
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values"
],
	"core-js/proposals/object-values-entries": [
	"es.object.entries",
	"es.object.values"
],
	"core-js/proposals/observable": [
	"esnext.observable",
	"esnext.symbol.observable"
],
	"core-js/proposals/pattern-matching": [
	"esnext.symbol.matcher",
	"esnext.symbol.pattern-match"
],
	"core-js/proposals/pattern-matching-v2": [
	"esnext.symbol.custom-matcher"
],
	"core-js/proposals/promise-all-settled": [
	"esnext.promise.all-settled"
],
	"core-js/proposals/promise-any": [
	"esnext.aggregate-error",
	"esnext.promise.any"
],
	"core-js/proposals/promise-finally": [
	"es.promise.finally"
],
	"core-js/proposals/promise-try": [
	"esnext.promise.try"
],
	"core-js/proposals/promise-with-resolvers": [
	"esnext.promise.with-resolvers"
],
	"core-js/proposals/reflect-metadata": [
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata"
],
	"core-js/proposals/regexp-dotall-flag": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags"
],
	"core-js/proposals/regexp-escaping": [
	"esnext.regexp.escape"
],
	"core-js/proposals/regexp-named-groups": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/proposals/relative-indexing-method": [
	"es.string.at-alternative",
	"esnext.array.at",
	"esnext.typed-array.at"
],
	"core-js/proposals/seeded-random": [
	"esnext.math.seeded-prng"
],
	"core-js/proposals/set-methods": [
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union"
],
	"core-js/proposals/set-methods-v2": [
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2"
],
	"core-js/proposals/string-at": [
	"esnext.string.at"
],
	"core-js/proposals/string-code-points": [
	"esnext.string.code-points"
],
	"core-js/proposals/string-cooked": [
	"esnext.string.cooked"
],
	"core-js/proposals/string-dedent": [
	"esnext.string.dedent"
],
	"core-js/proposals/string-left-right-trim": [
	"es.string.trim-end",
	"es.string.trim-start"
],
	"core-js/proposals/string-match-all": [
	"esnext.string.match-all"
],
	"core-js/proposals/string-padding": [
	"es.string.pad-end",
	"es.string.pad-start"
],
	"core-js/proposals/string-replace-all": [
	"esnext.string.replace-all",
	"esnext.symbol.replace-all"
],
	"core-js/proposals/string-replace-all-stage-4": [
	"esnext.string.replace-all"
],
	"core-js/proposals/symbol-description": [
	"es.symbol.description"
],
	"core-js/proposals/symbol-predicates": [
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known"
],
	"core-js/proposals/symbol-predicates-v2": [
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-well-known-symbol"
],
	"core-js/proposals/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/proposals/using-statement": [
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose"
],
	"core-js/proposals/well-formed-stringify": [
	"es.json.stringify"
],
	"core-js/proposals/well-formed-unicode-strings": [
	"esnext.string.is-well-formed",
	"esnext.string.to-well-formed"
],
	"core-js/stable": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.error.cause",
	"es.error.to-string",
	"es.aggregate-error",
	"es.aggregate-error.cause",
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string",
	"es.escape",
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name",
	"es.global-this",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.json.stringify",
	"es.json.to-string-tag",
	"es.map",
	"es.map.group-by",
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc",
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.parse-float",
	"es.parse-int",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag",
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with",
	"es.unescape",
	"es.weak-map",
	"es.weak-set",
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/stable/aggregate-error": [
],
	"core-js/stable/array": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.from",
	"es.array.includes",
	"es.array.index-of",
	"es.array.is-array",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.of",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/stable/array-buffer": [
	"es.array-buffer.constructor",
	"es.array-buffer.is-view",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string"
],
	"core-js/stable/array-buffer/constructor": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached",
	"es.array-buffer.transfer",
	"es.array-buffer.transfer-to-fixed-length",
	"es.object.to-string"
],
	"core-js/stable/array-buffer/detached": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.array-buffer.detached"
],
	"core-js/stable/array-buffer/is-view": [
	"es.array-buffer.is-view"
],
	"core-js/stable/array-buffer/slice": [
	"es.array-buffer.slice"
],
	"core-js/stable/array-buffer/transfer": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer"
],
	"core-js/stable/array-buffer/transfer-to-fixed-length": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.array-buffer.transfer-to-fixed-length"
],
	"core-js/stable/array/at": [
	"es.array.at"
],
	"core-js/stable/array/concat": [
	"es.array.concat"
],
	"core-js/stable/array/copy-within": [
	"es.array.copy-within"
],
	"core-js/stable/array/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/every": [
	"es.array.every"
],
	"core-js/stable/array/fill": [
	"es.array.fill"
],
	"core-js/stable/array/filter": [
	"es.array.filter"
],
	"core-js/stable/array/find": [
	"es.array.find"
],
	"core-js/stable/array/find-index": [
	"es.array.find-index"
],
	"core-js/stable/array/find-last": [
	"es.array.find-last"
],
	"core-js/stable/array/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/stable/array/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/stable/array/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/stable/array/for-each": [
	"es.array.for-each"
],
	"core-js/stable/array/from": [
	"es.array.from",
	"es.string.iterator"
],
	"core-js/stable/array/includes": [
	"es.array.includes"
],
	"core-js/stable/array/index-of": [
	"es.array.index-of"
],
	"core-js/stable/array/is-array": [
	"es.array.is-array"
],
	"core-js/stable/array/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/join": [
	"es.array.join"
],
	"core-js/stable/array/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/stable/array/map": [
	"es.array.map"
],
	"core-js/stable/array/of": [
	"es.array.of"
],
	"core-js/stable/array/push": [
	"es.array.push"
],
	"core-js/stable/array/reduce": [
	"es.array.reduce"
],
	"core-js/stable/array/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/stable/array/reverse": [
	"es.array.reverse"
],
	"core-js/stable/array/slice": [
	"es.array.slice"
],
	"core-js/stable/array/some": [
	"es.array.some"
],
	"core-js/stable/array/sort": [
	"es.array.sort"
],
	"core-js/stable/array/splice": [
	"es.array.splice"
],
	"core-js/stable/array/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/stable/array/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/stable/array/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/stable/array/unshift": [
	"es.array.unshift"
],
	"core-js/stable/array/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/virtual": [
	"es.array.at",
	"es.array.concat",
	"es.array.copy-within",
	"es.array.every",
	"es.array.fill",
	"es.array.filter",
	"es.array.find",
	"es.array.find-index",
	"es.array.find-last",
	"es.array.find-last-index",
	"es.array.flat",
	"es.array.flat-map",
	"es.array.for-each",
	"es.array.includes",
	"es.array.index-of",
	"es.array.iterator",
	"es.array.join",
	"es.array.last-index-of",
	"es.array.map",
	"es.array.push",
	"es.array.reduce",
	"es.array.reduce-right",
	"es.array.reverse",
	"es.array.slice",
	"es.array.some",
	"es.array.sort",
	"es.array.species",
	"es.array.splice",
	"es.array.to-reversed",
	"es.array.to-sorted",
	"es.array.to-spliced",
	"es.array.unscopables.flat",
	"es.array.unscopables.flat-map",
	"es.array.unshift",
	"es.array.with",
	"es.object.to-string"
],
	"core-js/stable/array/virtual/at": [
	"es.array.at"
],
	"core-js/stable/array/virtual/concat": [
	"es.array.concat"
],
	"core-js/stable/array/virtual/copy-within": [
	"es.array.copy-within"
],
	"core-js/stable/array/virtual/entries": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/virtual/every": [
	"es.array.every"
],
	"core-js/stable/array/virtual/fill": [
	"es.array.fill"
],
	"core-js/stable/array/virtual/filter": [
	"es.array.filter"
],
	"core-js/stable/array/virtual/find": [
	"es.array.find"
],
	"core-js/stable/array/virtual/find-index": [
	"es.array.find-index"
],
	"core-js/stable/array/virtual/find-last": [
	"es.array.find-last"
],
	"core-js/stable/array/virtual/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/stable/array/virtual/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/stable/array/virtual/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/stable/array/virtual/for-each": [
	"es.array.for-each"
],
	"core-js/stable/array/virtual/includes": [
	"es.array.includes"
],
	"core-js/stable/array/virtual/index-of": [
	"es.array.index-of"
],
	"core-js/stable/array/virtual/iterator": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/virtual/join": [
	"es.array.join"
],
	"core-js/stable/array/virtual/keys": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/virtual/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/stable/array/virtual/map": [
	"es.array.map"
],
	"core-js/stable/array/virtual/push": [
	"es.array.push"
],
	"core-js/stable/array/virtual/reduce": [
	"es.array.reduce"
],
	"core-js/stable/array/virtual/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/stable/array/virtual/reverse": [
	"es.array.reverse"
],
	"core-js/stable/array/virtual/slice": [
	"es.array.slice"
],
	"core-js/stable/array/virtual/some": [
	"es.array.some"
],
	"core-js/stable/array/virtual/sort": [
	"es.array.sort"
],
	"core-js/stable/array/virtual/splice": [
	"es.array.splice"
],
	"core-js/stable/array/virtual/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/stable/array/virtual/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/stable/array/virtual/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/stable/array/virtual/unshift": [
	"es.array.unshift"
],
	"core-js/stable/array/virtual/values": [
	"es.array.iterator",
	"es.object.to-string"
],
	"core-js/stable/array/virtual/with": [
	"es.array.with"
],
	"core-js/stable/array/with": [
	"es.array.with"
],
	"core-js/stable/atob": [
	"es.error.to-string",
	"es.object.to-string",
	"web.atob",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/stable/btoa": [
	"es.error.to-string",
	"es.object.to-string",
	"web.btoa",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/stable/clear-immediate": [
	"web.immediate"
],
	"core-js/stable/data-view": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.data-view",
	"es.data-view.get-float16",
	"es.data-view.set-float16",
	"es.object.to-string"
],
	"core-js/stable/data-view/get-float16": [
	"es.data-view.get-float16"
],
	"core-js/stable/data-view/set-float16": [
	"es.data-view.set-float16"
],
	"core-js/stable/date": [
	"es.date.get-year",
	"es.date.now",
	"es.date.set-year",
	"es.date.to-gmt-string",
	"es.date.to-iso-string",
	"es.date.to-json",
	"es.date.to-primitive",
	"es.date.to-string"
],
	"core-js/stable/date/get-year": [
	"es.date.get-year"
],
	"core-js/stable/date/now": [
	"es.date.now"
],
	"core-js/stable/date/set-year": [
	"es.date.set-year"
],
	"core-js/stable/date/to-gmt-string": [
	"es.date.to-gmt-string"
],
	"core-js/stable/date/to-iso-string": [
	"es.date.to-iso-string",
	"es.date.to-json"
],
	"core-js/stable/date/to-json": [
	"es.date.to-json"
],
	"core-js/stable/date/to-primitive": [
	"es.date.to-primitive"
],
	"core-js/stable/date/to-string": [
	"es.date.to-string"
],
	"core-js/stable/dom-collections": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator"
],
	"core-js/stable/dom-collections/for-each": [
	"web.dom-collections.for-each"
],
	"core-js/stable/dom-collections/iterator": [
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/stable/dom-exception": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/stable/dom-exception/constructor": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack"
],
	"core-js/stable/dom-exception/to-string-tag": [
	"web.dom-exception.to-string-tag"
],
	"core-js/stable/error": [
	"es.error.cause",
	"es.error.to-string"
],
	"core-js/stable/error/constructor": [
	"es.error.cause"
],
	"core-js/stable/error/to-string": [
	"es.error.to-string"
],
	"core-js/stable/escape": [
	"es.escape"
],
	"core-js/stable/function": [
	"es.function.bind",
	"es.function.has-instance",
	"es.function.name"
],
	"core-js/stable/function/bind": [
	"es.function.bind"
],
	"core-js/stable/function/has-instance": [
	"es.function.has-instance"
],
	"core-js/stable/function/name": [
	"es.function.name"
],
	"core-js/stable/function/virtual": [
	"es.function.bind"
],
	"core-js/stable/function/virtual/bind": [
	"es.function.bind"
],
	"core-js/stable/get-iterator": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/get-iterator-method": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/global-this": [
	"es.global-this"
],
	"core-js/stable/instance/at": [
	"es.array.at",
	"es.string.at-alternative"
],
	"core-js/stable/instance/bind": [
	"es.function.bind"
],
	"core-js/stable/instance/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/stable/instance/concat": [
	"es.array.concat"
],
	"core-js/stable/instance/copy-within": [
	"es.array.copy-within"
],
	"core-js/stable/instance/ends-with": [
	"es.string.ends-with"
],
	"core-js/stable/instance/entries": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/stable/instance/every": [
	"es.array.every"
],
	"core-js/stable/instance/fill": [
	"es.array.fill"
],
	"core-js/stable/instance/filter": [
	"es.array.filter"
],
	"core-js/stable/instance/find": [
	"es.array.find"
],
	"core-js/stable/instance/find-index": [
	"es.array.find-index"
],
	"core-js/stable/instance/find-last": [
	"es.array.find-last"
],
	"core-js/stable/instance/find-last-index": [
	"es.array.find-last-index"
],
	"core-js/stable/instance/flags": [
	"es.regexp.flags"
],
	"core-js/stable/instance/flat": [
	"es.array.flat",
	"es.array.unscopables.flat"
],
	"core-js/stable/instance/flat-map": [
	"es.array.flat-map",
	"es.array.unscopables.flat-map"
],
	"core-js/stable/instance/for-each": [
	"es.array.for-each",
	"web.dom-collections.for-each"
],
	"core-js/stable/instance/includes": [
	"es.array.includes",
	"es.string.includes"
],
	"core-js/stable/instance/index-of": [
	"es.array.index-of"
],
	"core-js/stable/instance/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/stable/instance/keys": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/stable/instance/last-index-of": [
	"es.array.last-index-of"
],
	"core-js/stable/instance/map": [
	"es.array.map"
],
	"core-js/stable/instance/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/stable/instance/pad-end": [
	"es.string.pad-end"
],
	"core-js/stable/instance/pad-start": [
	"es.string.pad-start"
],
	"core-js/stable/instance/push": [
	"es.array.push"
],
	"core-js/stable/instance/reduce": [
	"es.array.reduce"
],
	"core-js/stable/instance/reduce-right": [
	"es.array.reduce-right"
],
	"core-js/stable/instance/repeat": [
	"es.string.repeat"
],
	"core-js/stable/instance/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/stable/instance/reverse": [
	"es.array.reverse"
],
	"core-js/stable/instance/slice": [
	"es.array.slice"
],
	"core-js/stable/instance/some": [
	"es.array.some"
],
	"core-js/stable/instance/sort": [
	"es.array.sort"
],
	"core-js/stable/instance/splice": [
	"es.array.splice"
],
	"core-js/stable/instance/starts-with": [
	"es.string.starts-with"
],
	"core-js/stable/instance/to-reversed": [
	"es.array.to-reversed"
],
	"core-js/stable/instance/to-sorted": [
	"es.array.sort",
	"es.array.to-sorted"
],
	"core-js/stable/instance/to-spliced": [
	"es.array.to-spliced"
],
	"core-js/stable/instance/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/stable/instance/trim": [
	"es.string.trim"
],
	"core-js/stable/instance/trim-end": [
	"es.string.trim-end"
],
	"core-js/stable/instance/trim-left": [
	"es.string.trim-start"
],
	"core-js/stable/instance/trim-right": [
	"es.string.trim-end"
],
	"core-js/stable/instance/trim-start": [
	"es.string.trim-start"
],
	"core-js/stable/instance/unshift": [
	"es.array.unshift"
],
	"core-js/stable/instance/values": [
	"es.array.iterator",
	"es.object.to-string",
	"web.dom-collections.iterator"
],
	"core-js/stable/instance/with": [
	"es.array.with"
],
	"core-js/stable/is-iterable": [
	"es.array.iterator",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/iterator": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/iterator/drop": [
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.object.to-string"
],
	"core-js/stable/iterator/every": [
	"es.iterator.constructor",
	"es.iterator.every",
	"es.object.to-string"
],
	"core-js/stable/iterator/filter": [
	"es.iterator.constructor",
	"es.iterator.filter",
	"es.object.to-string"
],
	"core-js/stable/iterator/find": [
	"es.iterator.constructor",
	"es.iterator.find",
	"es.object.to-string"
],
	"core-js/stable/iterator/flat-map": [
	"es.iterator.constructor",
	"es.iterator.flat-map",
	"es.object.to-string"
],
	"core-js/stable/iterator/for-each": [
	"es.iterator.constructor",
	"es.iterator.for-each",
	"es.object.to-string"
],
	"core-js/stable/iterator/from": [
	"es.array.iterator",
	"es.iterator.constructor",
	"es.iterator.drop",
	"es.iterator.every",
	"es.iterator.filter",
	"es.iterator.find",
	"es.iterator.flat-map",
	"es.iterator.for-each",
	"es.iterator.from",
	"es.iterator.map",
	"es.iterator.reduce",
	"es.iterator.some",
	"es.iterator.take",
	"es.iterator.to-array",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/iterator/map": [
	"es.iterator.constructor",
	"es.iterator.map",
	"es.object.to-string"
],
	"core-js/stable/iterator/reduce": [
	"es.iterator.constructor",
	"es.iterator.reduce",
	"es.object.to-string"
],
	"core-js/stable/iterator/some": [
	"es.iterator.constructor",
	"es.iterator.some",
	"es.object.to-string"
],
	"core-js/stable/iterator/take": [
	"es.iterator.constructor",
	"es.iterator.take",
	"es.object.to-string"
],
	"core-js/stable/iterator/to-array": [
	"es.iterator.constructor",
	"es.iterator.to-array",
	"es.object.to-string"
],
	"core-js/stable/json": [
	"es.date.to-json",
	"es.json.stringify",
	"es.json.to-string-tag"
],
	"core-js/stable/json/stringify": [
	"es.date.to-json",
	"es.json.stringify"
],
	"core-js/stable/json/to-string-tag": [
	"es.json.to-string-tag"
],
	"core-js/stable/map": [
	"es.array.iterator",
	"es.map",
	"es.map.group-by",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/map/group-by": [
	"es.map",
	"es.map.group-by",
	"es.object.to-string"
],
	"core-js/stable/math": [
	"es.math.acosh",
	"es.math.asinh",
	"es.math.atanh",
	"es.math.cbrt",
	"es.math.clz32",
	"es.math.cosh",
	"es.math.expm1",
	"es.math.fround",
	"es.math.f16round",
	"es.math.hypot",
	"es.math.imul",
	"es.math.log10",
	"es.math.log1p",
	"es.math.log2",
	"es.math.sign",
	"es.math.sinh",
	"es.math.tanh",
	"es.math.to-string-tag",
	"es.math.trunc"
],
	"core-js/stable/math/acosh": [
	"es.math.acosh"
],
	"core-js/stable/math/asinh": [
	"es.math.asinh"
],
	"core-js/stable/math/atanh": [
	"es.math.atanh"
],
	"core-js/stable/math/cbrt": [
	"es.math.cbrt"
],
	"core-js/stable/math/clz32": [
	"es.math.clz32"
],
	"core-js/stable/math/cosh": [
	"es.math.cosh"
],
	"core-js/stable/math/expm1": [
	"es.math.expm1"
],
	"core-js/stable/math/f16round": [
	"es.math.f16round"
],
	"core-js/stable/math/fround": [
	"es.math.fround"
],
	"core-js/stable/math/hypot": [
	"es.math.hypot"
],
	"core-js/stable/math/imul": [
	"es.math.imul"
],
	"core-js/stable/math/log10": [
	"es.math.log10"
],
	"core-js/stable/math/log1p": [
	"es.math.log1p"
],
	"core-js/stable/math/log2": [
	"es.math.log2"
],
	"core-js/stable/math/sign": [
	"es.math.sign"
],
	"core-js/stable/math/sinh": [
	"es.math.sinh"
],
	"core-js/stable/math/tanh": [
	"es.math.tanh"
],
	"core-js/stable/math/to-string-tag": [
	"es.math.to-string-tag"
],
	"core-js/stable/math/trunc": [
	"es.math.trunc"
],
	"core-js/stable/number": [
	"es.number.constructor",
	"es.number.epsilon",
	"es.number.is-finite",
	"es.number.is-integer",
	"es.number.is-nan",
	"es.number.is-safe-integer",
	"es.number.max-safe-integer",
	"es.number.min-safe-integer",
	"es.number.parse-float",
	"es.number.parse-int",
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/stable/number/constructor": [
	"es.number.constructor"
],
	"core-js/stable/number/epsilon": [
	"es.number.epsilon"
],
	"core-js/stable/number/is-finite": [
	"es.number.is-finite"
],
	"core-js/stable/number/is-integer": [
	"es.number.is-integer"
],
	"core-js/stable/number/is-nan": [
	"es.number.is-nan"
],
	"core-js/stable/number/is-safe-integer": [
	"es.number.is-safe-integer"
],
	"core-js/stable/number/max-safe-integer": [
	"es.number.max-safe-integer"
],
	"core-js/stable/number/min-safe-integer": [
	"es.number.min-safe-integer"
],
	"core-js/stable/number/parse-float": [
	"es.number.parse-float"
],
	"core-js/stable/number/parse-int": [
	"es.number.parse-int"
],
	"core-js/stable/number/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/stable/number/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/stable/number/to-precision": [
	"es.number.to-precision"
],
	"core-js/stable/number/virtual": [
	"es.number.to-exponential",
	"es.number.to-fixed",
	"es.number.to-precision"
],
	"core-js/stable/number/virtual/to-exponential": [
	"es.number.to-exponential"
],
	"core-js/stable/number/virtual/to-fixed": [
	"es.number.to-fixed"
],
	"core-js/stable/number/virtual/to-precision": [
	"es.number.to-precision"
],
	"core-js/stable/object": [
	"es.symbol",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.assign",
	"es.object.create",
	"es.object.define-getter",
	"es.object.define-properties",
	"es.object.define-property",
	"es.object.define-setter",
	"es.object.entries",
	"es.object.freeze",
	"es.object.from-entries",
	"es.object.get-own-property-descriptor",
	"es.object.get-own-property-descriptors",
	"es.object.get-own-property-names",
	"es.object.get-prototype-of",
	"es.object.group-by",
	"es.object.has-own",
	"es.object.is",
	"es.object.is-extensible",
	"es.object.is-frozen",
	"es.object.is-sealed",
	"es.object.keys",
	"es.object.lookup-getter",
	"es.object.lookup-setter",
	"es.object.prevent-extensions",
	"es.object.proto",
	"es.object.seal",
	"es.object.set-prototype-of",
	"es.object.to-string",
	"es.object.values",
	"es.reflect.to-string-tag",
	"web.dom-collections.iterator"
],
	"core-js/stable/object/assign": [
	"es.object.assign"
],
	"core-js/stable/object/create": [
	"es.object.create"
],
	"core-js/stable/object/define-getter": [
	"es.object.define-getter"
],
	"core-js/stable/object/define-properties": [
	"es.object.define-properties"
],
	"core-js/stable/object/define-property": [
	"es.object.define-property"
],
	"core-js/stable/object/define-setter": [
	"es.object.define-setter"
],
	"core-js/stable/object/entries": [
	"es.object.entries"
],
	"core-js/stable/object/freeze": [
	"es.object.freeze"
],
	"core-js/stable/object/from-entries": [
	"es.array.iterator",
	"es.object.from-entries",
	"web.dom-collections.iterator"
],
	"core-js/stable/object/get-own-property-descriptor": [
	"es.object.get-own-property-descriptor"
],
	"core-js/stable/object/get-own-property-descriptors": [
	"es.object.get-own-property-descriptors"
],
	"core-js/stable/object/get-own-property-names": [
	"es.object.get-own-property-names"
],
	"core-js/stable/object/get-own-property-symbols": [
	"es.symbol"
],
	"core-js/stable/object/get-prototype-of": [
	"es.object.get-prototype-of"
],
	"core-js/stable/object/group-by": [
	"es.object.create",
	"es.object.group-by"
],
	"core-js/stable/object/has-own": [
	"es.object.has-own"
],
	"core-js/stable/object/is": [
	"es.object.is"
],
	"core-js/stable/object/is-extensible": [
	"es.object.is-extensible"
],
	"core-js/stable/object/is-frozen": [
	"es.object.is-frozen"
],
	"core-js/stable/object/is-sealed": [
	"es.object.is-sealed"
],
	"core-js/stable/object/keys": [
	"es.object.keys"
],
	"core-js/stable/object/lookup-getter": [
	"es.object.lookup-getter"
],
	"core-js/stable/object/lookup-setter": [
	"es.object.lookup-setter"
],
	"core-js/stable/object/prevent-extensions": [
	"es.object.prevent-extensions"
],
	"core-js/stable/object/proto": [
	"es.object.proto"
],
	"core-js/stable/object/seal": [
	"es.object.seal"
],
	"core-js/stable/object/set-prototype-of": [
	"es.object.set-prototype-of"
],
	"core-js/stable/object/to-string": [
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/stable/object/values": [
	"es.object.values"
],
	"core-js/stable/parse-float": [
	"es.parse-float"
],
	"core-js/stable/parse-int": [
	"es.parse-int"
],
	"core-js/stable/promise": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.promise.any",
	"es.promise.finally",
	"es.promise.try",
	"es.promise.with-resolvers",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/promise/all-settled": [
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.all-settled",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/promise/any": [
	"es.aggregate-error",
	"es.array.iterator",
	"es.object.to-string",
	"es.promise",
	"es.promise.any",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/promise/finally": [
	"es.object.to-string",
	"es.promise",
	"es.promise.finally"
],
	"core-js/stable/promise/try": [
	"es.object.to-string",
	"es.promise",
	"es.promise.try"
],
	"core-js/stable/promise/with-resolvers": [
	"es.promise",
	"es.promise.with-resolvers"
],
	"core-js/stable/queue-microtask": [
	"web.queue-microtask"
],
	"core-js/stable/reflect": [
	"es.object.to-string",
	"es.reflect.apply",
	"es.reflect.construct",
	"es.reflect.define-property",
	"es.reflect.delete-property",
	"es.reflect.get",
	"es.reflect.get-own-property-descriptor",
	"es.reflect.get-prototype-of",
	"es.reflect.has",
	"es.reflect.is-extensible",
	"es.reflect.own-keys",
	"es.reflect.prevent-extensions",
	"es.reflect.set",
	"es.reflect.set-prototype-of",
	"es.reflect.to-string-tag"
],
	"core-js/stable/reflect/apply": [
	"es.reflect.apply"
],
	"core-js/stable/reflect/construct": [
	"es.reflect.construct"
],
	"core-js/stable/reflect/define-property": [
	"es.reflect.define-property"
],
	"core-js/stable/reflect/delete-property": [
	"es.reflect.delete-property"
],
	"core-js/stable/reflect/get": [
	"es.reflect.get"
],
	"core-js/stable/reflect/get-own-property-descriptor": [
	"es.reflect.get-own-property-descriptor"
],
	"core-js/stable/reflect/get-prototype-of": [
	"es.reflect.get-prototype-of"
],
	"core-js/stable/reflect/has": [
	"es.reflect.has"
],
	"core-js/stable/reflect/is-extensible": [
	"es.reflect.is-extensible"
],
	"core-js/stable/reflect/own-keys": [
	"es.reflect.own-keys"
],
	"core-js/stable/reflect/prevent-extensions": [
	"es.reflect.prevent-extensions"
],
	"core-js/stable/reflect/set": [
	"es.reflect.set"
],
	"core-js/stable/reflect/set-prototype-of": [
	"es.reflect.set-prototype-of"
],
	"core-js/stable/reflect/to-string-tag": [
	"es.reflect.to-string-tag"
],
	"core-js/stable/regexp": [
	"es.regexp.constructor",
	"es.regexp.escape",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.flags",
	"es.regexp.sticky",
	"es.regexp.test",
	"es.regexp.to-string",
	"es.string.match",
	"es.string.replace",
	"es.string.search",
	"es.string.split"
],
	"core-js/stable/regexp/constructor": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/stable/regexp/dot-all": [
	"es.regexp.constructor",
	"es.regexp.dot-all",
	"es.regexp.exec"
],
	"core-js/stable/regexp/escape": [
	"es.regexp.escape"
],
	"core-js/stable/regexp/flags": [
	"es.regexp.flags"
],
	"core-js/stable/regexp/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/stable/regexp/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/stable/regexp/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/stable/regexp/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/stable/regexp/sticky": [
	"es.regexp.constructor",
	"es.regexp.exec",
	"es.regexp.sticky"
],
	"core-js/stable/regexp/test": [
	"es.regexp.exec",
	"es.regexp.test"
],
	"core-js/stable/regexp/to-string": [
	"es.regexp.to-string"
],
	"core-js/stable/self": [
	"web.self"
],
	"core-js/stable/set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.set",
	"es.set.difference.v2",
	"es.set.intersection.v2",
	"es.set.is-disjoint-from.v2",
	"es.set.is-subset-of.v2",
	"es.set.is-superset-of.v2",
	"es.set.symmetric-difference.v2",
	"es.set.union.v2",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/set-immediate": [
	"web.immediate"
],
	"core-js/stable/set-interval": [
	"web.timers"
],
	"core-js/stable/set-timeout": [
	"web.timers"
],
	"core-js/stable/set/difference": [
	"es.set",
	"es.set.difference.v2"
],
	"core-js/stable/set/intersection": [
	"es.set",
	"es.set.intersection.v2"
],
	"core-js/stable/set/is-disjoint-from": [
	"es.set",
	"es.set.is-disjoint-from.v2"
],
	"core-js/stable/set/is-subset-of": [
	"es.set",
	"es.set.is-subset-of.v2"
],
	"core-js/stable/set/is-superset-of": [
	"es.set",
	"es.set.is-superset-of.v2"
],
	"core-js/stable/set/symmetric-difference": [
	"es.set",
	"es.set.symmetric-difference.v2"
],
	"core-js/stable/set/union": [
	"es.set",
	"es.set.union.v2"
],
	"core-js/stable/string": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.from-code-point",
	"es.string.includes",
	"es.string.is-well-formed",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.raw",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.to-well-formed",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup"
],
	"core-js/stable/string/anchor": [
	"es.string.anchor"
],
	"core-js/stable/string/at": [
	"es.string.at-alternative"
],
	"core-js/stable/string/big": [
	"es.string.big"
],
	"core-js/stable/string/blink": [
	"es.string.blink"
],
	"core-js/stable/string/bold": [
	"es.string.bold"
],
	"core-js/stable/string/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/stable/string/ends-with": [
	"es.string.ends-with"
],
	"core-js/stable/string/fixed": [
	"es.string.fixed"
],
	"core-js/stable/string/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/stable/string/fontsize": [
	"es.string.fontsize"
],
	"core-js/stable/string/from-code-point": [
	"es.string.from-code-point"
],
	"core-js/stable/string/includes": [
	"es.string.includes"
],
	"core-js/stable/string/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/stable/string/italics": [
	"es.string.italics"
],
	"core-js/stable/string/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/stable/string/link": [
	"es.string.link"
],
	"core-js/stable/string/match": [
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/stable/string/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/stable/string/pad-end": [
	"es.string.pad-end"
],
	"core-js/stable/string/pad-start": [
	"es.string.pad-start"
],
	"core-js/stable/string/raw": [
	"es.string.raw"
],
	"core-js/stable/string/repeat": [
	"es.string.repeat"
],
	"core-js/stable/string/replace": [
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/stable/string/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/stable/string/search": [
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/stable/string/small": [
	"es.string.small"
],
	"core-js/stable/string/split": [
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/stable/string/starts-with": [
	"es.string.starts-with"
],
	"core-js/stable/string/strike": [
	"es.string.strike"
],
	"core-js/stable/string/sub": [
	"es.string.sub"
],
	"core-js/stable/string/substr": [
	"es.string.substr"
],
	"core-js/stable/string/sup": [
	"es.string.sup"
],
	"core-js/stable/string/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/stable/string/trim": [
	"es.string.trim"
],
	"core-js/stable/string/trim-end": [
	"es.string.trim-end"
],
	"core-js/stable/string/trim-left": [
	"es.string.trim-start"
],
	"core-js/stable/string/trim-right": [
	"es.string.trim-end"
],
	"core-js/stable/string/trim-start": [
	"es.string.trim-start"
],
	"core-js/stable/string/virtual": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.at-alternative",
	"es.string.code-point-at",
	"es.string.ends-with",
	"es.string.includes",
	"es.string.iterator",
	"es.string.match",
	"es.string.match-all",
	"es.string.pad-end",
	"es.string.pad-start",
	"es.string.repeat",
	"es.string.replace",
	"es.string.replace-all",
	"es.string.search",
	"es.string.split",
	"es.string.starts-with",
	"es.string.substr",
	"es.string.trim",
	"es.string.trim-end",
	"es.string.trim-start",
	"es.string.anchor",
	"es.string.big",
	"es.string.blink",
	"es.string.bold",
	"es.string.fixed",
	"es.string.fontcolor",
	"es.string.fontsize",
	"es.string.italics",
	"es.string.link",
	"es.string.small",
	"es.string.strike",
	"es.string.sub",
	"es.string.sup"
],
	"core-js/stable/string/virtual/anchor": [
	"es.string.anchor"
],
	"core-js/stable/string/virtual/at": [
	"es.string.at-alternative"
],
	"core-js/stable/string/virtual/big": [
	"es.string.big"
],
	"core-js/stable/string/virtual/blink": [
	"es.string.blink"
],
	"core-js/stable/string/virtual/bold": [
	"es.string.bold"
],
	"core-js/stable/string/virtual/code-point-at": [
	"es.string.code-point-at"
],
	"core-js/stable/string/virtual/ends-with": [
	"es.string.ends-with"
],
	"core-js/stable/string/virtual/fixed": [
	"es.string.fixed"
],
	"core-js/stable/string/virtual/fontcolor": [
	"es.string.fontcolor"
],
	"core-js/stable/string/virtual/fontsize": [
	"es.string.fontsize"
],
	"core-js/stable/string/virtual/includes": [
	"es.string.includes"
],
	"core-js/stable/string/virtual/is-well-formed": [
	"es.string.is-well-formed"
],
	"core-js/stable/string/virtual/italics": [
	"es.string.italics"
],
	"core-js/stable/string/virtual/iterator": [
	"es.object.to-string",
	"es.string.iterator"
],
	"core-js/stable/string/virtual/link": [
	"es.string.link"
],
	"core-js/stable/string/virtual/match-all": [
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/stable/string/virtual/pad-end": [
	"es.string.pad-end"
],
	"core-js/stable/string/virtual/pad-start": [
	"es.string.pad-start"
],
	"core-js/stable/string/virtual/repeat": [
	"es.string.repeat"
],
	"core-js/stable/string/virtual/replace-all": [
	"es.regexp.exec",
	"es.string.replace",
	"es.string.replace-all"
],
	"core-js/stable/string/virtual/small": [
	"es.string.small"
],
	"core-js/stable/string/virtual/starts-with": [
	"es.string.starts-with"
],
	"core-js/stable/string/virtual/strike": [
	"es.string.strike"
],
	"core-js/stable/string/virtual/sub": [
	"es.string.sub"
],
	"core-js/stable/string/virtual/substr": [
	"es.string.substr"
],
	"core-js/stable/string/virtual/sup": [
	"es.string.sup"
],
	"core-js/stable/string/virtual/to-well-formed": [
	"es.string.to-well-formed"
],
	"core-js/stable/string/virtual/trim": [
	"es.string.trim"
],
	"core-js/stable/string/virtual/trim-end": [
	"es.string.trim-end"
],
	"core-js/stable/string/virtual/trim-left": [
	"es.string.trim-start"
],
	"core-js/stable/string/virtual/trim-right": [
	"es.string.trim-end"
],
	"core-js/stable/string/virtual/trim-start": [
	"es.string.trim-start"
],
	"core-js/stable/structured-clone": [
	"es.error.to-string",
	"es.array.iterator",
	"es.map",
	"es.object.keys",
	"es.object.to-string",
	"es.set",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.structured-clone"
],
	"core-js/stable/symbol": [
	"es.symbol",
	"es.symbol.description",
	"es.symbol.async-iterator",
	"es.symbol.has-instance",
	"es.symbol.is-concat-spreadable",
	"es.symbol.iterator",
	"es.symbol.match",
	"es.symbol.match-all",
	"es.symbol.replace",
	"es.symbol.search",
	"es.symbol.species",
	"es.symbol.split",
	"es.symbol.to-primitive",
	"es.symbol.to-string-tag",
	"es.symbol.unscopables",
	"es.array.concat",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag",
	"web.dom-collections.iterator"
],
	"core-js/stable/symbol/async-iterator": [
	"es.symbol.async-iterator"
],
	"core-js/stable/symbol/description": [
	"es.symbol.description"
],
	"core-js/stable/symbol/for": [
	"es.symbol"
],
	"core-js/stable/symbol/has-instance": [
	"es.symbol.has-instance",
	"es.function.has-instance"
],
	"core-js/stable/symbol/is-concat-spreadable": [
	"es.symbol.is-concat-spreadable",
	"es.array.concat"
],
	"core-js/stable/symbol/iterator": [
	"es.symbol.iterator",
	"es.array.iterator",
	"es.object.to-string",
	"es.string.iterator",
	"web.dom-collections.iterator"
],
	"core-js/stable/symbol/key-for": [
	"es.symbol"
],
	"core-js/stable/symbol/match": [
	"es.symbol.match",
	"es.regexp.exec",
	"es.string.match"
],
	"core-js/stable/symbol/match-all": [
	"es.symbol.match-all",
	"es.object.to-string",
	"es.regexp.exec",
	"es.string.match-all"
],
	"core-js/stable/symbol/replace": [
	"es.symbol.replace",
	"es.regexp.exec",
	"es.string.replace"
],
	"core-js/stable/symbol/search": [
	"es.symbol.search",
	"es.regexp.exec",
	"es.string.search"
],
	"core-js/stable/symbol/species": [
	"es.symbol.species"
],
	"core-js/stable/symbol/split": [
	"es.symbol.split",
	"es.regexp.exec",
	"es.string.split"
],
	"core-js/stable/symbol/to-primitive": [
	"es.symbol.to-primitive",
	"es.date.to-primitive"
],
	"core-js/stable/symbol/to-string-tag": [
	"es.symbol.to-string-tag",
	"es.json.to-string-tag",
	"es.math.to-string-tag",
	"es.object.to-string",
	"es.reflect.to-string-tag"
],
	"core-js/stable/symbol/unscopables": [
	"es.symbol.unscopables"
],
	"core-js/stable/typed-array": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.float64-array",
	"es.typed-array.int8-array",
	"es.typed-array.int16-array",
	"es.typed-array.int32-array",
	"es.typed-array.uint8-array",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.uint16-array",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/at": [
	"es.typed-array.at"
],
	"core-js/stable/typed-array/copy-within": [
	"es.typed-array.copy-within"
],
	"core-js/stable/typed-array/entries": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/stable/typed-array/every": [
	"es.typed-array.every"
],
	"core-js/stable/typed-array/fill": [
	"es.typed-array.fill"
],
	"core-js/stable/typed-array/filter": [
	"es.typed-array.filter"
],
	"core-js/stable/typed-array/find": [
	"es.typed-array.find"
],
	"core-js/stable/typed-array/find-index": [
	"es.typed-array.find-index"
],
	"core-js/stable/typed-array/find-last": [
	"es.typed-array.find-last"
],
	"core-js/stable/typed-array/find-last-index": [
	"es.typed-array.find-last-index"
],
	"core-js/stable/typed-array/float32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/float64-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.float64-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/for-each": [
	"es.typed-array.for-each"
],
	"core-js/stable/typed-array/from": [
	"es.typed-array.from"
],
	"core-js/stable/typed-array/includes": [
	"es.typed-array.includes"
],
	"core-js/stable/typed-array/index-of": [
	"es.typed-array.index-of"
],
	"core-js/stable/typed-array/int16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/int32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/int8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.int8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/iterator": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/stable/typed-array/join": [
	"es.typed-array.join"
],
	"core-js/stable/typed-array/keys": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/stable/typed-array/last-index-of": [
	"es.typed-array.last-index-of"
],
	"core-js/stable/typed-array/map": [
	"es.typed-array.map"
],
	"core-js/stable/typed-array/methods": [
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/of": [
	"es.typed-array.of"
],
	"core-js/stable/typed-array/reduce": [
	"es.typed-array.reduce"
],
	"core-js/stable/typed-array/reduce-right": [
	"es.typed-array.reduce-right"
],
	"core-js/stable/typed-array/reverse": [
	"es.typed-array.reverse"
],
	"core-js/stable/typed-array/set": [
	"es.typed-array.set"
],
	"core-js/stable/typed-array/slice": [
	"es.typed-array.slice"
],
	"core-js/stable/typed-array/some": [
	"es.typed-array.some"
],
	"core-js/stable/typed-array/sort": [
	"es.typed-array.sort"
],
	"core-js/stable/typed-array/subarray": [
	"es.typed-array.subarray"
],
	"core-js/stable/typed-array/to-locale-string": [
	"es.typed-array.to-locale-string"
],
	"core-js/stable/typed-array/to-reversed": [
	"es.typed-array.to-reversed"
],
	"core-js/stable/typed-array/to-sorted": [
	"es.typed-array.sort",
	"es.typed-array.to-sorted"
],
	"core-js/stable/typed-array/to-string": [
	"es.typed-array.to-string"
],
	"core-js/stable/typed-array/uint16-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint16-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/uint32-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint32-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/uint8-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/uint8-clamped-array": [
	"es.array-buffer.constructor",
	"es.array-buffer.slice",
	"es.object.to-string",
	"es.string.iterator",
	"es.typed-array.uint8-clamped-array",
	"es.typed-array.at",
	"es.typed-array.copy-within",
	"es.typed-array.every",
	"es.typed-array.fill",
	"es.typed-array.filter",
	"es.typed-array.find",
	"es.typed-array.find-index",
	"es.typed-array.find-last",
	"es.typed-array.find-last-index",
	"es.typed-array.for-each",
	"es.typed-array.from",
	"es.typed-array.includes",
	"es.typed-array.index-of",
	"es.typed-array.iterator",
	"es.typed-array.join",
	"es.typed-array.last-index-of",
	"es.typed-array.map",
	"es.typed-array.of",
	"es.typed-array.reduce",
	"es.typed-array.reduce-right",
	"es.typed-array.reverse",
	"es.typed-array.set",
	"es.typed-array.slice",
	"es.typed-array.some",
	"es.typed-array.sort",
	"es.typed-array.subarray",
	"es.typed-array.to-locale-string",
	"es.typed-array.to-reversed",
	"es.typed-array.to-sorted",
	"es.typed-array.to-string",
	"es.typed-array.with"
],
	"core-js/stable/typed-array/values": [
	"es.object.to-string",
	"es.typed-array.iterator"
],
	"core-js/stable/typed-array/with": [
	"es.typed-array.with"
],
	"core-js/stable/unescape": [
	"es.unescape"
],
	"core-js/stable/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/stable/url-search-params": [
	"web.dom-collections.iterator",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/stable/url/can-parse": [
	"web.url",
	"web.url.can-parse"
],
	"core-js/stable/url/parse": [
	"web.url",
	"web.url.parse"
],
	"core-js/stable/url/to-json": [
	"web.url.to-json"
],
	"core-js/stable/weak-map": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-map",
	"web.dom-collections.iterator"
],
	"core-js/stable/weak-set": [
	"es.array.iterator",
	"es.object.to-string",
	"es.weak-set",
	"web.dom-collections.iterator"
],
	"core-js/stage": [
	"es.map",
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/stage/0": [
	"es.map",
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/stage/1": [
	"es.map",
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.metadata",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of"
],
	"core-js/stage/2": [
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.metadata",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.emplace",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.math.f16round",
	"esnext.math.sum-precise",
	"esnext.object.has-own",
	"esnext.object.group-by",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.typed-array.at",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/stage/2.7": [
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.metadata",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.math.f16round",
	"esnext.math.sum-precise",
	"esnext.object.has-own",
	"esnext.object.group-by",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose",
	"esnext.symbol.metadata",
	"esnext.typed-array.at",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed"
],
	"core-js/stage/3": [
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.metadata",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.group-by",
	"esnext.math.f16round",
	"esnext.math.sum-precise",
	"esnext.object.has-own",
	"esnext.object.group-by",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.dispose",
	"esnext.symbol.metadata",
	"esnext.typed-array.at",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex"
],
	"core-js/stage/4": [
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.array.at",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.data-view.get-float16",
	"esnext.data-view.set-float16",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.map",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.map.group-by",
	"esnext.math.f16round",
	"esnext.object.has-own",
	"esnext.object.group-by",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.regexp.escape",
	"esnext.set.difference.v2",
	"esnext.set.intersection.v2",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-superset-of.v2",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.union.v2",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.typed-array.at",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.with"
],
	"core-js/stage/pre": [
	"es.map",
	"es.string.at-alternative",
	"esnext.aggregate-error",
	"esnext.suppressed-error.constructor",
	"esnext.array.from-async",
	"esnext.array.at",
	"esnext.array.filter-out",
	"esnext.array.filter-reject",
	"esnext.array.find-last",
	"esnext.array.find-last-index",
	"esnext.array.group",
	"esnext.array.group-by",
	"esnext.array.group-by-to-map",
	"esnext.array.group-to-map",
	"esnext.array.is-template-object",
	"esnext.array.last-index",
	"esnext.array.last-item",
	"esnext.array.to-reversed",
	"esnext.array.to-sorted",
	"esnext.array.to-spliced",
	"esnext.array.unique-by",
	"esnext.array.with",
	"esnext.array-buffer.detached",
	"esnext.array-buffer.transfer",
	"esnext.array-buffer.transfer-to-fixed-length",
	"esnext.async-disposable-stack.constructor",
	"esnext.async-iterator.constructor",
	"esnext.async-iterator.as-indexed-pairs",
	"esnext.async-iterator.async-dispose",
	"esnext.async-iterator.drop",
	"esnext.async-iterator.every",
	"esnext.async-iterator.filter",
	"esnext.async-iterator.find",
	"esnext.async-iterator.flat-map",
	"esnext.async-iterator.for-each",
	"esnext.async-iterator.from",
	"esnext.async-iterator.indexed",
	"esnext.async-iterator.map",
	"esnext.async-iterator.reduce",
	"esnext.async-iterator.some",
	"esnext.async-iterator.take",
	"esnext.async-iterator.to-array",
	"esnext.bigint.range",
	"esnext.composite-key",
	"esnext.composite-symbol",
	"esnext.data-view.get-float16",
	"esnext.data-view.get-uint8-clamped",
	"esnext.data-view.set-float16",
	"esnext.data-view.set-uint8-clamped",
	"esnext.disposable-stack.constructor",
	"esnext.error.is-error",
	"esnext.function.demethodize",
	"esnext.function.is-callable",
	"esnext.function.is-constructor",
	"esnext.function.metadata",
	"esnext.function.un-this",
	"esnext.global-this",
	"esnext.iterator.constructor",
	"esnext.iterator.as-indexed-pairs",
	"esnext.iterator.concat",
	"esnext.iterator.dispose",
	"esnext.iterator.drop",
	"esnext.iterator.every",
	"esnext.iterator.filter",
	"esnext.iterator.find",
	"esnext.iterator.flat-map",
	"esnext.iterator.for-each",
	"esnext.iterator.from",
	"esnext.iterator.indexed",
	"esnext.iterator.map",
	"esnext.iterator.range",
	"esnext.iterator.reduce",
	"esnext.iterator.some",
	"esnext.iterator.take",
	"esnext.iterator.to-array",
	"esnext.iterator.to-async",
	"esnext.json.is-raw-json",
	"esnext.json.parse",
	"esnext.json.raw-json",
	"esnext.map.delete-all",
	"esnext.map.emplace",
	"esnext.map.every",
	"esnext.map.filter",
	"esnext.map.find",
	"esnext.map.find-key",
	"esnext.map.from",
	"esnext.map.get-or-insert",
	"esnext.map.get-or-insert-computed",
	"esnext.map.group-by",
	"esnext.map.includes",
	"esnext.map.key-by",
	"esnext.map.key-of",
	"esnext.map.map-keys",
	"esnext.map.map-values",
	"esnext.map.merge",
	"esnext.map.of",
	"esnext.map.reduce",
	"esnext.map.some",
	"esnext.map.update",
	"esnext.map.update-or-insert",
	"esnext.map.upsert",
	"esnext.math.clamp",
	"esnext.math.deg-per-rad",
	"esnext.math.degrees",
	"esnext.math.fscale",
	"esnext.math.f16round",
	"esnext.math.iaddh",
	"esnext.math.imulh",
	"esnext.math.isubh",
	"esnext.math.rad-per-deg",
	"esnext.math.radians",
	"esnext.math.scale",
	"esnext.math.seeded-prng",
	"esnext.math.signbit",
	"esnext.math.sum-precise",
	"esnext.math.umulh",
	"esnext.number.from-string",
	"esnext.number.range",
	"esnext.object.has-own",
	"esnext.object.iterate-entries",
	"esnext.object.iterate-keys",
	"esnext.object.iterate-values",
	"esnext.object.group-by",
	"esnext.observable",
	"esnext.promise.all-settled",
	"esnext.promise.any",
	"esnext.promise.try",
	"esnext.promise.with-resolvers",
	"esnext.reflect.define-metadata",
	"esnext.reflect.delete-metadata",
	"esnext.reflect.get-metadata",
	"esnext.reflect.get-metadata-keys",
	"esnext.reflect.get-own-metadata",
	"esnext.reflect.get-own-metadata-keys",
	"esnext.reflect.has-metadata",
	"esnext.reflect.has-own-metadata",
	"esnext.reflect.metadata",
	"esnext.regexp.escape",
	"esnext.set.add-all",
	"esnext.set.delete-all",
	"esnext.set.difference.v2",
	"esnext.set.difference",
	"esnext.set.every",
	"esnext.set.filter",
	"esnext.set.find",
	"esnext.set.from",
	"esnext.set.intersection.v2",
	"esnext.set.intersection",
	"esnext.set.is-disjoint-from.v2",
	"esnext.set.is-disjoint-from",
	"esnext.set.is-subset-of.v2",
	"esnext.set.is-subset-of",
	"esnext.set.is-superset-of.v2",
	"esnext.set.is-superset-of",
	"esnext.set.join",
	"esnext.set.map",
	"esnext.set.of",
	"esnext.set.reduce",
	"esnext.set.some",
	"esnext.set.symmetric-difference.v2",
	"esnext.set.symmetric-difference",
	"esnext.set.union.v2",
	"esnext.set.union",
	"esnext.string.at",
	"esnext.string.cooked",
	"esnext.string.code-points",
	"esnext.string.dedent",
	"esnext.string.is-well-formed",
	"esnext.string.match-all",
	"esnext.string.replace-all",
	"esnext.string.to-well-formed",
	"esnext.symbol.async-dispose",
	"esnext.symbol.custom-matcher",
	"esnext.symbol.dispose",
	"esnext.symbol.is-registered-symbol",
	"esnext.symbol.is-registered",
	"esnext.symbol.is-well-known-symbol",
	"esnext.symbol.is-well-known",
	"esnext.symbol.matcher",
	"esnext.symbol.metadata",
	"esnext.symbol.metadata-key",
	"esnext.symbol.observable",
	"esnext.symbol.pattern-match",
	"esnext.symbol.replace-all",
	"esnext.typed-array.from-async",
	"esnext.typed-array.at",
	"esnext.typed-array.filter-out",
	"esnext.typed-array.filter-reject",
	"esnext.typed-array.find-last",
	"esnext.typed-array.find-last-index",
	"esnext.typed-array.group-by",
	"esnext.typed-array.to-reversed",
	"esnext.typed-array.to-sorted",
	"esnext.typed-array.to-spliced",
	"esnext.typed-array.unique-by",
	"esnext.typed-array.with",
	"esnext.uint8-array.from-base64",
	"esnext.uint8-array.from-hex",
	"esnext.uint8-array.set-from-base64",
	"esnext.uint8-array.set-from-hex",
	"esnext.uint8-array.to-base64",
	"esnext.uint8-array.to-hex",
	"esnext.weak-map.delete-all",
	"esnext.weak-map.from",
	"esnext.weak-map.of",
	"esnext.weak-map.emplace",
	"esnext.weak-map.get-or-insert",
	"esnext.weak-map.get-or-insert-computed",
	"esnext.weak-map.upsert",
	"esnext.weak-set.add-all",
	"esnext.weak-set.delete-all",
	"esnext.weak-set.from",
	"esnext.weak-set.of",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/web": [
	"web.atob",
	"web.btoa",
	"web.dom-collections.for-each",
	"web.dom-collections.iterator",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag",
	"web.immediate",
	"web.queue-microtask",
	"web.self",
	"web.structured-clone",
	"web.timers",
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/web/dom-collections": [
	"web.dom-collections.for-each",
	"web.dom-collections.iterator"
],
	"core-js/web/dom-exception": [
	"es.error.to-string",
	"web.dom-exception.constructor",
	"web.dom-exception.stack",
	"web.dom-exception.to-string-tag"
],
	"core-js/web/immediate": [
	"web.immediate"
],
	"core-js/web/queue-microtask": [
	"web.queue-microtask"
],
	"core-js/web/structured-clone": [
	"es.array.iterator",
	"es.map",
	"es.object.to-string",
	"es.set",
	"web.structured-clone"
],
	"core-js/web/timers": [
	"web.timers"
],
	"core-js/web/url": [
	"web.url",
	"web.url.can-parse",
	"web.url.parse",
	"web.url.to-json",
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
],
	"core-js/web/url-search-params": [
	"web.url-search-params",
	"web.url-search-params.delete",
	"web.url-search-params.has",
	"web.url-search-params.size"
]
};

var entries;
var hasRequiredEntries;

function requireEntries () {
	if (hasRequiredEntries) return entries;
	hasRequiredEntries = 1;
	entries = require$$0;
	return entries;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	utils.__esModule = true;
	utils.BABEL_RUNTIME = void 0;
	utils.callMethod = callMethod;
	utils.coreJSModule = coreJSModule;
	utils.coreJSPureHelper = coreJSPureHelper;
	utils.extractOptionalCheck = extractOptionalCheck;
	utils.isCoreJSSource = isCoreJSSource;
	utils.maybeMemoizeContext = maybeMemoizeContext;
	var _babel = _interopRequireWildcard(require$$0$b);
	var _entries = _interopRequireDefault(requireEntries());
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	const {
	  types: t
	} = _babel.default || _babel;
	const BABEL_RUNTIME = "@babel/runtime-corejs3";
	utils.BABEL_RUNTIME = BABEL_RUNTIME;
	function callMethod(path, id, optionalCall, wrapCallee) {
	  const [context1, context2] = maybeMemoizeContext(path.node, path.scope);
	  let callee = t.callExpression(id, [context1]);
	  if (wrapCallee) callee = wrapCallee(callee);
	  const call = t.identifier("call");
	  path.replaceWith(optionalCall ? t.optionalMemberExpression(callee, call, false, true) : t.memberExpression(callee, call));
	  path.parentPath.unshiftContainer("arguments", context2);
	}
	function maybeMemoizeContext(node, scope) {
	  const {
	    object
	  } = node;
	  let context1, context2;
	  if (t.isIdentifier(object)) {
	    context2 = object;
	    context1 = t.cloneNode(object);
	  } else {
	    context2 = scope.generateDeclaredUidIdentifier("context");
	    context1 = t.assignmentExpression("=", t.cloneNode(context2), object);
	  }
	  return [context1, context2];
	}
	function extractOptionalCheck(scope, node) {
	  let optionalNode = node;
	  while (!optionalNode.optional && t.isOptionalMemberExpression(optionalNode.object)) {
	    optionalNode = optionalNode.object;
	  }
	  optionalNode.optional = false;
	  const ctx = scope.generateDeclaredUidIdentifier("context");
	  const assign = t.assignmentExpression("=", ctx, optionalNode.object);
	  optionalNode.object = t.cloneNode(ctx);
	  return (ifNotNullish) => t.conditionalExpression(t.binaryExpression("==", assign, t.nullLiteral()), t.unaryExpression("void", t.numericLiteral(0)), ifNotNullish);
	}
	function isCoreJSSource(source) {
	  if (typeof source === "string") {
	    source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
	  }
	  return Object.prototype.hasOwnProperty.call(_entries.default, source) && _entries.default[source];
	}
	function coreJSModule(name) {
	  return `core-js/modules/${name}.js`;
	}
	function coreJSPureHelper(name, useBabelRuntime, ext) {
	  return useBabelRuntime ? `${BABEL_RUNTIME}/core-js/${name}${ext}` : `core-js-pure/features/${name}.js`;
	}
	return utils;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$1;
	hasRequiredLib$2 = 1;
	lib$1.__esModule = true;
	lib$1.default = void 0;
	var _data = _interopRequireDefault(requireData());
	var _shippedProposals = _interopRequireDefault(requireShippedProposals());
	var _getModulesListForTargetVersion = _interopRequireDefault(requireGetModulesListForTargetVersion());
	var _builtInDefinitions = requireBuiltInDefinitions();
	var BabelRuntimePaths = _interopRequireWildcard(requireBabelRuntimeCorejs3Paths());
	var _usageFilters = _interopRequireDefault(requireUsageFilters());
	var _babel = _interopRequireWildcard(require$$0$b);
	var _utils = requireUtils();
	var _helperDefinePolyfillProvider = _interopRequireDefault(requireLib$5());
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== "function") return null;
	  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
	  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
	  return (_getRequireWildcardCache = function(nodeInterop2) {
	    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
	    return { default: obj };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	const {
	  types: t,
	  template
	} = _babel.default || _babel;
	const presetEnvCompat = "#__secret_key__@babel/preset-env__compatibility";
	const runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
	const uniqueObjects = ["array", "string", "iterator", "async-iterator", "dom-collections"].map((v) => new RegExp(`[a-z]*\\.${v}\\..*`));
	const esnextFallback = (name, cb) => {
	  if (cb(name)) return true;
	  if (!name.startsWith("es.")) return false;
	  const fallback = `esnext.${name.slice(3)}`;
	  if (!_data.default[fallback]) return false;
	  return cb(fallback);
	};
	var _default = (0, _helperDefinePolyfillProvider.default)(function({
	  getUtils,
	  method,
	  shouldInjectPolyfill,
	  createMetaResolver,
	  debug,
	  babel
	}, {
	  version = 3,
	  proposals,
	  shippedProposals,
	  [presetEnvCompat]: {
	    noRuntimeName = false
	  } = {},
	  [runtimeCompat]: {
	    useBabelRuntime = false,
	    ext = ".js"
	  } = {}
	}) {
	  const isWebpack = babel.caller((caller) => (caller == null ? void 0 : caller.name) === "babel-loader");
	  const resolve = createMetaResolver({
	    global: _builtInDefinitions.BuiltIns,
	    static: _builtInDefinitions.StaticProperties,
	    instance: _builtInDefinitions.InstanceProperties
	  });
	  const available = new Set((0, _getModulesListForTargetVersion.default)(version));
	  function getCoreJSPureBase(useProposalBase) {
	    return useBabelRuntime ? useProposalBase ? `${_utils.BABEL_RUNTIME}/core-js` : `${_utils.BABEL_RUNTIME}/core-js-stable` : useProposalBase ? "core-js-pure/features" : "core-js-pure/stable";
	  }
	  function maybeInjectGlobalImpl(name, utils) {
	    if (shouldInjectPolyfill(name)) {
	      debug(name);
	      utils.injectGlobalImport((0, _utils.coreJSModule)(name), name);
	      return true;
	    }
	    return false;
	  }
	  function maybeInjectGlobal(names, utils, fallback = true) {
	    for (const name of names) {
	      if (fallback) {
	        esnextFallback(name, (name2) => maybeInjectGlobalImpl(name2, utils));
	      } else {
	        maybeInjectGlobalImpl(name, utils);
	      }
	    }
	  }
	  function maybeInjectPure(desc, hint, utils, object) {
	    if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback(desc.name, shouldInjectPolyfill)) {
	      const {
	        name
	      } = desc;
	      let useProposalBase = false;
	      if (proposals || shippedProposals && name.startsWith("esnext.")) {
	        useProposalBase = true;
	      } else if (name.startsWith("es.") && !available.has(name)) {
	        useProposalBase = true;
	      }
	      if (useBabelRuntime && !(useProposalBase ? BabelRuntimePaths.proposals : BabelRuntimePaths.stable).has(desc.pure)) {
	        return;
	      }
	      const coreJSPureBase = getCoreJSPureBase(useProposalBase);
	      return utils.injectDefaultImport(`${coreJSPureBase}/${desc.pure}${ext}`, hint);
	    }
	  }
	  function isFeatureStable(name) {
	    if (name.startsWith("esnext.")) {
	      const esName = `es.${name.slice(7)}`;
	      return esName in _data.default;
	    }
	    return true;
	  }
	  return {
	    name: "corejs3",
	    runtimeName: noRuntimeName ? null : _utils.BABEL_RUNTIME,
	    polyfills: _data.default,
	    filterPolyfills(name) {
	      if (!available.has(name)) return false;
	      if (proposals || method === "entry-global") return true;
	      if (shippedProposals && _shippedProposals.default.has(name)) {
	        return true;
	      }
	      return isFeatureStable(name);
	    },
	    entryGlobal(meta, utils, path) {
	      if (meta.kind !== "import") return;
	      const modules = (0, _utils.isCoreJSSource)(meta.source);
	      if (!modules) return;
	      if (modules.length === 1 && meta.source === (0, _utils.coreJSModule)(modules[0]) && shouldInjectPolyfill(modules[0])) {
	        debug(null);
	        return;
	      }
	      const modulesSet = new Set(modules);
	      const filteredModules = modules.filter((module) => {
	        if (!module.startsWith("esnext.")) return true;
	        const stable = module.replace("esnext.", "es.");
	        if (modulesSet.has(stable) && shouldInjectPolyfill(stable)) {
	          return false;
	        }
	        return true;
	      });
	      maybeInjectGlobal(filteredModules, utils, false);
	      path.remove();
	    },
	    usageGlobal(meta, utils, path) {
	      const resolved = resolve(meta);
	      if (!resolved) return;
	      if ((0, _usageFilters.default)(resolved.desc, path)) return;
	      let deps = resolved.desc.global;
	      if (resolved.kind !== "global" && "object" in meta && meta.object && meta.placement === "prototype") {
	        const low = meta.object.toLowerCase();
	        deps = deps.filter((m) => uniqueObjects.some((v) => v.test(m)) ? m.includes(low) : true);
	      }
	      maybeInjectGlobal(deps, utils);
	      return true;
	    },
	    usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t.callExpression(
	            utils.injectDefaultImport((0, _utils.coreJSPureHelper)("is-iterable", useBabelRuntime, ext), "isIterable"),
	            [path.node.right]
	            // meta.kind === "in" narrows this
	          ));
	        }
	        return;
	      }
	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;
	      if (meta.kind === "property") {
	        if (!path.isMemberExpression() && !path.isOptionalMemberExpression()) {
	          return;
	        }
	        if (!path.isReferenced()) return;
	        if (path.parentPath.isUpdateExpression()) return;
	        if (t.isSuper(path.node.object)) {
	          return;
	        }
	        if (meta.key === "Symbol.iterator") {
	          if (!shouldInjectPolyfill("es.symbol.iterator")) return;
	          const {
	            parent,
	            node
	          } = path;
	          if (t.isCallExpression(parent, {
	            callee: node
	          })) {
	            if (parent.arguments.length === 0) {
	              path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport((0, _utils.coreJSPureHelper)("get-iterator", useBabelRuntime, ext), "getIterator"), [node.object]));
	              path.skip();
	            } else {
	              (0, _utils.callMethod)(path, utils.injectDefaultImport((0, _utils.coreJSPureHelper)("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"));
	            }
	          } else {
	            path.replaceWith(t.callExpression(utils.injectDefaultImport((0, _utils.coreJSPureHelper)("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [path.node.object]));
	          }
	          return;
	        }
	      }
	      let resolved = resolve(meta);
	      if (!resolved) return;
	      if ((0, _usageFilters.default)(resolved.desc, path)) return;
	      if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index") {
	        resolved = _extends({}, resolved, {
	          desc: _extends({}, resolved.desc, {
	            pure: resolved.desc.pure.slice(0, -6)
	          })
	        });
	      }
	      if (resolved.kind === "global") {
	        const id = maybeInjectPure(resolved.desc, resolved.name, utils);
	        if (id) path.replaceWith(id);
	      } else if (resolved.kind === "static") {
	        const id = maybeInjectPure(
	          resolved.desc,
	          resolved.name,
	          utils,
	          // @ts-expect-error
	          meta.object
	        );
	        if (id) {
	          path.replaceWith(id);
	          let {
	            parentPath
	          } = path;
	          if (parentPath.isOptionalMemberExpression() || parentPath.isOptionalCallExpression()) {
	            do {
	              const parentAsNotOptional = parentPath;
	              parentAsNotOptional.type = parentAsNotOptional.node.type = parentPath.type === "OptionalMemberExpression" ? "MemberExpression" : "CallExpression";
	              delete parentAsNotOptional.node.optional;
	              ({
	                parentPath
	              } = parentPath);
	            } while ((parentPath.isOptionalMemberExpression() || parentPath.isOptionalCallExpression()) && !parentPath.node.optional);
	          }
	        }
	      } else if (resolved.kind === "instance") {
	        const id = maybeInjectPure(
	          resolved.desc,
	          `${resolved.name}InstanceProperty`,
	          utils,
	          // @ts-expect-error
	          meta.object
	        );
	        if (!id) return;
	        const {
	          node,
	          parent
	        } = path;
	        if (t.isOptionalCallExpression(parent) && parent.callee === node) {
	          const wasOptional = parent.optional;
	          parent.optional = !wasOptional;
	          if (!wasOptional) {
	            const check = (0, _utils.extractOptionalCheck)(path.scope, node);
	            const [thisArg, thisArg2] = (0, _utils.maybeMemoizeContext)(node, path.scope);
	            path.replaceWith(check(template.expression.ast`
                  Function.call.bind(${id}(${thisArg}), ${thisArg2})
                `));
	          } else if (t.isOptionalMemberExpression(node)) {
	            const check = (0, _utils.extractOptionalCheck)(path.scope, node);
	            (0, _utils.callMethod)(path, id, true, check);
	          } else {
	            (0, _utils.callMethod)(path, id, true);
	          }
	        } else if (t.isCallExpression(parent) && parent.callee === node) {
	          (0, _utils.callMethod)(path, id, false);
	        } else if (t.isOptionalMemberExpression(node)) {
	          const check = (0, _utils.extractOptionalCheck)(path.scope, node);
	          path.replaceWith(check(t.callExpression(id, [node.object])));
	          if (t.isOptionalMemberExpression(parent)) parent.optional = true;
	        } else {
	          path.replaceWith(t.callExpression(id, [node.object]));
	        }
	      }
	    },
	    visitor: method === "usage-global" && {
	      // import("foo")
	      CallExpression(path) {
	        if (path.get("callee").isImport()) {
	          const utils = getUtils(path);
	          if (isWebpack) {
	            maybeInjectGlobal(_builtInDefinitions.PromiseDependenciesWithIterators, utils);
	          } else {
	            maybeInjectGlobal(_builtInDefinitions.PromiseDependencies, utils);
	          }
	        }
	      },
	      // (async function () { }).finally(...)
	      Function(path) {
	        if (path.node.async) {
	          maybeInjectGlobal(_builtInDefinitions.PromiseDependencies, getUtils(path));
	        }
	      },
	      // for-of, [a, b] = c
	      "ForOfStatement|ArrayPattern"(path) {
	        maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
	      },
	      // [...spread]
	      SpreadElement(path) {
	        if (!path.parentPath.isObjectExpression()) {
	          maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
	        }
	      },
	      // yield*
	      YieldExpression(path) {
	        if (path.node.delegate) {
	          maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
	        }
	      },
	      // Decorators metadata
	      Class(path) {
	        var _path$node$decorators;
	        const hasDecorators = ((_path$node$decorators = path.node.decorators) == null ? void 0 : _path$node$decorators.length) || path.node.body.body.some((el) => {
	          var _decorators;
	          return (_decorators = el.decorators) == null ? void 0 : _decorators.length;
	        });
	        if (hasDecorators) {
	          maybeInjectGlobal(_builtInDefinitions.DecoratorMetadataDependencies, getUtils(path));
	        }
	      }
	    }
	  };
	});
	lib$1.default = _default;
	return lib$1;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1h;
	hasRequiredLib$1 = 1;
	Object.defineProperty(lib$1h, "__esModule", {
	  value: true
	});
	lib$1h.default = void 0;
	lib$1h.isPluginRequired = isPluginRequired;
	lib$1h.transformIncludesAndExcludes = void 0;
	var _semver = requireSemver();
	var _debug = requireDebug();
	var _filterItems = requireFilterItems();
	var _moduleTransformations = requireModuleTransformations();
	var _normalizeOptions = requireNormalizeOptions();
	var _shippedProposals = requireShippedProposals$1();
	var _pluginsCompatData = requirePluginsCompatData();
	var _babelPluginPolyfillCorejs = requireLib$2();
	var _babel7Plugins = requireBabel7Plugins();
	var _helperCompilationTargets = requireLib$1g();
	var _availablePlugins = requireAvailablePlugins();
	var _helperPluginUtils = requireLib$1f();
	const pluginCoreJS3 = _babelPluginPolyfillCorejs.default || _babelPluginPolyfillCorejs;
	function isPluginRequired(targets, support) {
	  return (0, _helperCompilationTargets.isRequired)("fake-name", targets, {
	    compatData: {
	      "fake-name": support
	    }
	  });
	}
	function filterStageFromList(list, stageList) {
	  return Object.keys(list).reduce((result, item) => {
	    if (!stageList.has(item)) {
	      result[item] = list[item];
	    }
	    return result;
	  }, {});
	}
	const pluginsListWithProposals = Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes);
	const pluginsListWithuotProposals = filterStageFromList(pluginsListWithProposals, _shippedProposals.proposalPlugins);
	{
	  var pluginsListNoBugfixesWithProposals = _pluginsCompatData.plugins;
	  var pluginsListNoBugfixesWithoutProposals = filterStageFromList(_pluginsCompatData.plugins, _shippedProposals.proposalPlugins);
	}
	const getPlugin = (pluginName) => {
	  const plugin = _availablePlugins.default[pluginName]();
	  if (!plugin) {
	    throw new Error(`Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`);
	  }
	  return plugin;
	};
	const transformIncludesAndExcludes = (opts) => {
	  return opts.reduce((result, opt) => {
	    const target = /^(?:es|es6|es7|esnext|web)\./.test(opt) ? "builtIns" : "plugins";
	    result[target].add(opt);
	    return result;
	  }, {
	    all: opts,
	    plugins: /* @__PURE__ */ new Set(),
	    builtIns: /* @__PURE__ */ new Set()
	  });
	};
	lib$1h.transformIncludesAndExcludes = transformIncludesAndExcludes;
	function getSpecialModulesPluginNames(modules, shouldTransformDynamicImport, babelVersion) {
	  const modulesPluginNames = [];
	  if (modules) {
	    modulesPluginNames.push(_moduleTransformations.default[modules]);
	  }
	  if (shouldTransformDynamicImport) {
	    if (modules && modules !== "umd") {
	      modulesPluginNames.push("transform-dynamic-import");
	    } else {
	      console.warn("Dynamic import can only be transformed when transforming ES modules to AMD, CommonJS or SystemJS.");
	    }
	  }
	  if (babelVersion[0] !== "8") {
	    if (!shouldTransformDynamicImport) {
	      modulesPluginNames.push("syntax-dynamic-import");
	    }
	    modulesPluginNames.push("syntax-top-level-await");
	    modulesPluginNames.push("syntax-import-meta");
	  }
	  return modulesPluginNames;
	}
	const getCoreJSOptions = ({
	  useBuiltIns,
	  corejs,
	  polyfillTargets,
	  include,
	  exclude,
	  proposals,
	  shippedProposals,
	  debug
	}) => ({
	  method: `${useBuiltIns}-global`,
	  version: corejs ? corejs.toString() : void 0,
	  targets: polyfillTargets,
	  include,
	  exclude,
	  proposals,
	  shippedProposals,
	  debug,
	  "#__secret_key__@babel/preset-env__compatibility": {
	    noRuntimeName: true
	  }
	});
	{
	  var getPolyfillPlugins = ({
	    useBuiltIns,
	    corejs,
	    polyfillTargets,
	    include,
	    exclude,
	    proposals,
	    shippedProposals,
	    regenerator,
	    debug
	  }) => {
	    const polyfillPlugins = [];
	    if (useBuiltIns === "usage" || useBuiltIns === "entry") {
	      const pluginOptions = getCoreJSOptions({
	        useBuiltIns,
	        corejs,
	        polyfillTargets,
	        include,
	        exclude,
	        proposals,
	        shippedProposals,
	        debug
	      });
	      if (corejs) {
	        {
	          if (useBuiltIns === "usage") {
	            if (corejs.major === 2) {
	              polyfillPlugins.push([_babel7Plugins.pluginCoreJS2, pluginOptions], [_babel7Plugins.legacyBabelPolyfillPlugin, {
	                usage: true
	              }]);
	            } else {
	              polyfillPlugins.push([pluginCoreJS3, pluginOptions], [_babel7Plugins.legacyBabelPolyfillPlugin, {
	                usage: true,
	                deprecated: true
	              }]);
	            }
	            if (regenerator) {
	              polyfillPlugins.push([_babel7Plugins.pluginRegenerator, {
	                method: "usage-global",
	                debug
	              }]);
	            }
	          } else {
	            if (corejs.major === 2) {
	              polyfillPlugins.push([_babel7Plugins.legacyBabelPolyfillPlugin, {
	                regenerator
	              }], [_babel7Plugins.pluginCoreJS2, pluginOptions]);
	            } else {
	              polyfillPlugins.push([pluginCoreJS3, pluginOptions], [_babel7Plugins.legacyBabelPolyfillPlugin, {
	                deprecated: true
	              }]);
	              if (!regenerator) {
	                polyfillPlugins.push([_babel7Plugins.removeRegeneratorEntryPlugin, pluginOptions]);
	              }
	            }
	          }
	        }
	      }
	    }
	    return polyfillPlugins;
	  };
	  {
	    lib$1h.getPolyfillPlugins = getPolyfillPlugins;
	  }
	}
	function getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv, api) {
	  if (optionsTargets != null && optionsTargets.esmodules && optionsTargets.browsers) {
	    console.warn(`
@babel/preset-env: esmodules and browsers targets have been specified together.
\`browsers\` target, \`${optionsTargets.browsers.toString()}\` will be ignored.
`);
	  }
	  return (0, _helperCompilationTargets.default)(optionsTargets, {
	    ignoreBrowserslistConfig,
	    configPath,
	    browserslistEnv,
	    onBrowserslistConfigFound(config) {
	      api.addExternalDependency(config);
	    }
	  });
	}
	function supportsStaticESM(caller) {
	  return !!(caller != null && caller.supportsStaticESM);
	}
	function supportsDynamicImport(caller) {
	  return !!(caller != null && caller.supportsDynamicImport);
	}
	function supportsExportNamespaceFrom(caller) {
	  return !!(caller != null && caller.supportsExportNamespaceFrom);
	}
	lib$1h.default = (0, _helperPluginUtils.declarePreset)((api, opts) => {
	  api.assertVersion(7);
	  const babelTargets = api.targets();
	  const {
	    configPath,
	    debug,
	    exclude: optionsExclude,
	    forceAllTransforms,
	    ignoreBrowserslistConfig,
	    include: optionsInclude,
	    modules: optionsModules,
	    shippedProposals,
	    targets: optionsTargets,
	    useBuiltIns,
	    corejs: {
	      version: corejs,
	      proposals
	    },
	    browserslistEnv
	  } = (0, _normalizeOptions.default)(opts);
	  {
	    var {
	      loose,
	      spec = false,
	      bugfixes = false
	    } = opts;
	  }
	  let targets = babelTargets;
	  if (_semver.lt(api.version, "7.13.0") || opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig) {
	    {
	      var hasUglifyTarget = false;
	      if (optionsTargets != null && optionsTargets.uglify) {
	        hasUglifyTarget = true;
	        delete optionsTargets.uglify;
	        console.warn(`
The uglify target has been deprecated. Set the top level
option \`forceAllTransforms: true\` instead.
`);
	      }
	    }
	    targets = getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv, api);
	  }
	  const transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
	  const include = transformIncludesAndExcludes(optionsInclude);
	  const exclude = transformIncludesAndExcludes(optionsExclude);
	  const compatData = bugfixes ? shippedProposals ? pluginsListWithProposals : pluginsListWithuotProposals : shippedProposals ? pluginsListNoBugfixesWithProposals : pluginsListNoBugfixesWithoutProposals;
	  const modules = optionsModules === "auto" ? api.caller(supportsStaticESM) ? false : "commonjs" : optionsModules;
	  const shouldTransformDynamicImport = optionsModules === "auto" ? !api.caller(supportsDynamicImport) : !!modules;
	  if (!exclude.plugins.has("transform-export-namespace-from") && (optionsModules === "auto" ? !api.caller(supportsExportNamespaceFrom) : !!modules)) {
	    include.plugins.add("transform-export-namespace-from");
	  }
	  const pluginNames = (0, _helperCompilationTargets.filterItems)(compatData, include.plugins, exclude.plugins, transformTargets, getSpecialModulesPluginNames(modules, shouldTransformDynamicImport, api.version), !loose ? void 0 : ["transform-typeof-symbol"], _shippedProposals.pluginSyntaxMap);
	  if (shippedProposals) {
	    (0, _filterItems.addProposalSyntaxPlugins)(pluginNames, _shippedProposals.proposalSyntaxPlugins);
	  }
	  (0, _filterItems.removeUnsupportedItems)(pluginNames, api.version);
	  (0, _filterItems.removeUnnecessaryItems)(pluginNames, _pluginsCompatData.overlappingPlugins);
	  const polyfillPlugins = getPolyfillPlugins({
	    useBuiltIns,
	    corejs,
	    polyfillTargets: targets,
	    include: include.builtIns,
	    exclude: exclude.builtIns,
	    proposals,
	    shippedProposals,
	    regenerator: pluginNames.has("transform-regenerator"),
	    debug
	  });
	  const pluginUseBuiltIns = useBuiltIns !== false;
	  const plugins = Array.from(pluginNames).map((pluginName) => {
	    if (pluginName === "transform-class-properties" || pluginName === "transform-private-methods" || pluginName === "transform-private-property-in-object") {
	      return [getPlugin(pluginName), {
	        loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
	      }];
	    }
	    if (pluginName === "syntax-import-attributes") {
	      return [getPlugin(pluginName), {
	        deprecatedAssertSyntax: true
	      }];
	    }
	    return [getPlugin(pluginName), {
	      spec,
	      loose,
	      useBuiltIns: pluginUseBuiltIns
	    }];
	  }).concat(polyfillPlugins);
	  if (debug) {
	    console.log("@babel/preset-env: `DEBUG` option");
	    console.log("\nUsing targets:");
	    console.log(JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2));
	    console.log(`
Using modules transform: ${optionsModules.toString()}`);
	    console.log("\nUsing plugins:");
	    pluginNames.forEach((pluginName) => {
	      (0, _debug.logPlugin)(pluginName, targets, compatData);
	    });
	    if (!useBuiltIns) {
	      console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
	    }
	  }
	  return {
	    plugins
	  };
	});
	{
	  lib$1h.getModulesPluginNames = ({
	    modules,
	    transformations,
	    shouldTransformESM,
	    shouldTransformDynamicImport,
	    shouldTransformExportNamespaceFrom
	  }) => {
	    const modulesPluginNames = [];
	    if (modules !== false && transformations[modules]) {
	      if (shouldTransformESM) {
	        modulesPluginNames.push(transformations[modules]);
	      }
	      if (shouldTransformDynamicImport) {
	        if (shouldTransformESM && modules !== "umd") {
	          modulesPluginNames.push("transform-dynamic-import");
	        } else {
	          console.warn("Dynamic import can only be transformed when transforming ES modules to AMD, CommonJS or SystemJS.");
	        }
	      }
	    }
	    if (shouldTransformExportNamespaceFrom) {
	      modulesPluginNames.push("transform-export-namespace-from");
	    }
	    if (!shouldTransformDynamicImport) {
	      modulesPluginNames.push("syntax-dynamic-import");
	    }
	    if (!shouldTransformExportNamespaceFrom) {
	      modulesPluginNames.push("syntax-export-namespace-from");
	    }
	    modulesPluginNames.push("syntax-top-level-await");
	    modulesPluginNames.push("syntax-import-meta");
	    return modulesPluginNames;
	  };
	}
	return lib$1h;
}

var libExports$1 = requireLib$1();
var babelPresetEnv = /*@__PURE__*/getDefaultExportFromCjs(libExports$1);

var lib = {};

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	Object.defineProperty(helpers, "__esModule", {
	  value: true
	});
	helpers.hasMinVersion = hasMinVersion;
	var _semver = requireSemver();
	function hasMinVersion(minVersion, runtimeVersion) {
	  if (!runtimeVersion) return true;
	  if (_semver.valid(runtimeVersion)) runtimeVersion = `^${runtimeVersion}`;
	  return !_semver.intersects(`<${minVersion}`, runtimeVersion) && !_semver.intersects(`>=8.0.0`, runtimeVersion);
	}
	return helpers;
}

var getRuntimePath = {};

var hasRequiredGetRuntimePath;

function requireGetRuntimePath () {
	if (hasRequiredGetRuntimePath) return getRuntimePath;
	hasRequiredGetRuntimePath = 1;
	Object.defineProperty(getRuntimePath, "__esModule", {
	  value: true
	});
	getRuntimePath.default = _default;
	getRuntimePath.resolveFSPath = resolveFSPath;
	var _path = require$$0$9;

	function _default(moduleName, dirname, absoluteRuntime) {
	  if (absoluteRuntime === false) return moduleName;
	  return resolveAbsoluteRuntime(moduleName, _path.resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
	}
	function resolveAbsoluteRuntime(moduleName, dirname) {
	  try {
	    return _path.dirname((((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? require.resolve : (r, {
	      paths: [b]
	    }, M = require("module")) => {
	      let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
	      if (f) return f;
	      f = new Error(`Cannot resolve module '${r}'`);
	      f.code = "MODULE_NOT_FOUND";
	      throw f;
	    })(`${moduleName}/package.json`, {
	      paths: [dirname]
	    })).replace(/\\/g, "/");
	  } catch (err) {
	    if (err.code !== "MODULE_NOT_FOUND") throw err;
	    throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
	      code: "BABEL_RUNTIME_NOT_FOUND",
	      runtime: moduleName,
	      dirname
	    });
	  }
	}
	function resolveFSPath(path) {
	  return require.resolve(path).replace(/\\/g, "/");
	}
	return getRuntimePath;
}

var babel7 = {};

var polyfills;
var hasRequiredPolyfills;

function requirePolyfills () {
	if (hasRequiredPolyfills) return polyfills;
	hasRequiredPolyfills = 1;
	const pluginCorejs2 = requireLib$4().default;
	const pluginCorejs3 = requireLib$2().default;
	const pluginRegenerator = requireLib$3().default;
	const pluginsCompat = "#__secret_key__@babel/runtime__compatibility";
	function createCorejs2Plugin(options) {
	  return (api, _, filename) => pluginCorejs2(api, options, filename);
	}
	function createCorejs3Plugin(options) {
	  return (api, _, filename) => pluginCorejs3(api, options, filename);
	}
	function createRegeneratorPlugin(options, useRuntimeRegenerator, corejsPlugin) {
	  if (!useRuntimeRegenerator) return corejsPlugin != null ? corejsPlugin : void 0;
	  return (api, _, filename) => {
	    return Object.assign({}, pluginRegenerator(api, options, filename), {
	      inherits: corejsPlugin != null ? corejsPlugin : void 0
	    });
	  };
	}
	polyfills = function createBasePolyfillsPlugin({
	  corejs,
	  regenerator = true,
	  moduleName
	}, runtimeVersion, absoluteImports) {
	  let proposals = false;
	  let rawVersion;
	  if (typeof corejs === "object" && corejs !== null) {
	    rawVersion = corejs.version;
	    proposals = Boolean(corejs.proposals);
	  } else {
	    rawVersion = corejs;
	  }
	  const corejsVersion = rawVersion ? Number(rawVersion) : false;
	  if (![false, 2, 3].includes(corejsVersion)) {
	    throw new Error(`The \`core-js\` version must be false, 2 or 3, but got ${JSON.stringify(rawVersion)}.`);
	  }
	  if (proposals && (!corejsVersion || corejsVersion < 3)) {
	    throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
	  }
	  if (typeof regenerator !== "boolean") {
	    throw new Error("The 'regenerator' option must be undefined, or a boolean.");
	  }
	  const polyfillOpts = {
	    method: "usage-pure",
	    absoluteImports,
	    proposals,
	    [pluginsCompat]: {
	      useBabelRuntime: true,
	      runtimeVersion,
	      ext: "",
	      moduleName
	    }
	  };
	  return createRegeneratorPlugin(polyfillOpts, regenerator, corejsVersion === 2 ? createCorejs2Plugin(polyfillOpts) : corejsVersion === 3 ? createCorejs3Plugin(polyfillOpts) : null);
	};
	return polyfills;
}

var hasRequiredBabel7;

function requireBabel7 () {
	if (hasRequiredBabel7) return babel7;
	hasRequiredBabel7 = 1;
	(function (exports) {
		Object.defineProperty(exports, "createPolyfillPlugins", {
		  get: () => requirePolyfills()
		}); 
	} (babel7));
	return babel7;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	Object.defineProperty(lib, "__esModule", {
	  value: true
	});
	lib.default = void 0;
	var _helperPluginUtils = requireLib$1f();
	var _helperModuleImports = requireLib$14();
	var _core = require$$0$b;
	var _helpers = requireHelpers();
	var _index = requireGetRuntimePath();
	var _index2 = requireBabel7();
	lib.default = (0, _helperPluginUtils.declare)((api, options, dirname) => {
	  api.assertVersion(7);
	  const {
	    version: runtimeVersion = "7.0.0-beta.0",
	    absoluteRuntime = false,
	    moduleName = null
	  } = options;
	  if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
	    throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
	  }
	  if (typeof runtimeVersion !== "string") {
	    throw new Error(`The 'version' option must be a version string.`);
	  }
	  if (moduleName !== null && typeof moduleName !== "string") {
	    throw new Error("The 'moduleName' option must be null or a string.");
	  }
	  {
	    const DUAL_MODE_RUNTIME = "7.13.0";
	    var supportsCJSDefault = (0, _helpers.hasMinVersion)(DUAL_MODE_RUNTIME, runtimeVersion);
	  }
	  if (hasOwnProperty.call(options, "useBuiltIns")) {
	    if (options.useBuiltIns) {
	      throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime module now uses builtins by default.");
	    } else {
	      throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'option to polyfill with `core-js` via @babel/runtime.");
	    }
	  }
	  if (hasOwnProperty.call(options, "polyfill")) {
	    if (options.polyfill === false) {
	      throw new Error("The 'polyfill' option has been removed. The @babel/runtime module now skips polyfilling by default.");
	    } else {
	      throw new Error("The 'polyfill' option has been removed. Use the 'corejs'option to polyfill with `core-js` via @babel/runtime.");
	    }
	  }
	  {
	    const {
	      useESModules = false
	    } = options;
	    if (typeof useESModules !== "boolean" && useESModules !== "auto") {
	      throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
	    }
	    var esModules = useESModules === "auto" ? api.caller((caller) => !!(caller != null && caller.supportsStaticESM)) : useESModules;
	  }
	  {
	    var {
	      helpers: useRuntimeHelpers = true
	    } = options;
	    if (typeof useRuntimeHelpers !== "boolean") {
	      throw new Error("The 'helpers' option must be undefined, or a boolean.");
	    }
	  }
	  const HEADER_HELPERS = /* @__PURE__ */ new Set(["interopRequireWildcard", "interopRequireDefault"]);
	  return {
	    name: "transform-runtime",
	    inherits: _index2.createPolyfillPlugins(options, runtimeVersion, absoluteRuntime),
	    pre(file) {
	      if (!useRuntimeHelpers) return;
	      let modulePath;
	      file.set("helperGenerator", (name) => {
	        var _ref;
	        modulePath != null ? modulePath : modulePath = (0, _index.default)((_ref = moduleName != null ? moduleName : file.get("runtimeHelpersModuleName")) != null ? _ref : "@babel/runtime", dirname, absoluteRuntime);
	        {
	          if (!(file.availableHelper != null && file.availableHelper(name, runtimeVersion))) {
	            if (name === "regeneratorRuntime") {
	              return _core.types.arrowFunctionExpression([], _core.types.identifier("regeneratorRuntime"));
	            }
	            if (name === "regenerator" || name === "regeneratorKeys" || name === "regeneratorAsync" || name === "regeneratorAsyncGen") {
	              return _core.types.identifier("__interal_marker_fallback_regenerator__");
	            }
	            return;
	          }
	        }
	        const blockHoist = HEADER_HELPERS.has(name) && !(0, _helperModuleImports.isModule)(file.path) ? 4 : void 0;
	        let helperPath = `${modulePath}/helpers/${esModules && file.path.node.sourceType === "module" ? "esm/" + name : name}`;
	        if (absoluteRuntime) helperPath = (0, _index.resolveFSPath)(helperPath);
	        return addDefaultImport(helperPath, name, blockHoist, true);
	      });
	      const cache = /* @__PURE__ */ new Map();
	      function addDefaultImport(source, nameHint, blockHoist, isHelper = false) {
	        const cacheKey = (0, _helperModuleImports.isModule)(file.path);
	        const key = `${source}:${nameHint}:${cacheKey || ""}`;
	        let cached = cache.get(key);
	        if (cached) {
	          cached = _core.types.cloneNode(cached);
	        } else {
	          cached = (0, _helperModuleImports.addDefault)(file.path, source, {
	            importedInterop: isHelper && supportsCJSDefault ? "compiled" : "uncompiled",
	            nameHint,
	            blockHoist
	          });
	          cache.set(key, cached);
	        }
	        return cached;
	      }
	    }
	  };
	});
	return lib;
}

var libExports = requireLib();
var babelPluginTransformRuntime = /*@__PURE__*/getDefaultExportFromCjs(libExports);

exports.babelPluginTransformRuntime = babelPluginTransformRuntime;
exports.babelPresetEnv = babelPresetEnv;
exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
exports.requireLib = requireLib$1f;
exports.requireLib$1 = requireLib$14;
exports.requireLib$10 = requireLib$w;
exports.requireLib$11 = requireLib$r;
exports.requireLib$12 = requireLib$x;
exports.requireLib$2 = requireLib$17;
exports.requireLib$3 = requireLib$1h;
exports.requireLib$4 = requireLib$X;
exports.requireLib$5 = requireLib$W;
exports.requireLib$6 = requireLib$C;
exports.requireLib$7 = requireLib$V;
exports.requireLib$8 = requireLib$q;
exports.requireLib$9 = requireLib$p;
